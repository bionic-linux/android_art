{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "abfaffef_a533ad85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-01-31T19:35:57Z",
      "side": 1,
      "message": "Currently this is failing in art/compiler/utils/assembler_thumb_test.cc:(66) Failure in test ArmVIXLAssemblerTest.VixlJniHelpers because some offsets changed. Can this happen due to 32-bit tls size changes?\n\nSpecifics:\n@@ -82,5 +82,5 @@\nf6: 18 bf         it ne\nf8: e3 46         movne r11, r12\n-      fa: d9 f8 8c c0   ldr.w r12, [r9, #140]\n+      fa: d9 f8 94 c0   ldr.w r12, [r9, #148]\nfe: bc f1 00 0f   cmp.w r12, #0\n102: 71 d1         bne 0x1e8     @ imm \u003d #226\n@@ -158,5 +158,5 @@\n21c: d9 f8 24 80   ldr.w r8, [r9, #36]\n220: 70 47         bx lr\n-     222: d9 f8 8c 00   ldr.w r0, [r9, #140]\n-     226: d9 f8 c0 e2   ldr.w lr, [r9, #704]\n+     222: d9 f8 94 00   ldr.w r0, [r9, #148]\n+     226: d9 f8 c8 e2   ldr.w lr, [r9, #712]\n22a: f0 47         blx lr\\n",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff60e9cc_93455a2d",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1071,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-02-01T12:08:27Z",
      "side": 1,
      "message": "Remove spaces.",
      "range": {
        "startLine": 1071,
        "startChar": 12,
        "endLine": 1071,
        "endChar": 16
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1ed6705f_aa76f716",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1071,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-02T02:40:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ff60e9cc_93455a2d",
      "range": {
        "startLine": 1071,
        "startChar": 12,
        "endLine": 1071,
        "endChar": 16
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "535fcf9a_3facc679",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-02-01T16:28:13Z",
      "side": 1,
      "message": "I am trying to prove myself that is correct.\n\nIt is obvious the if the reader\u0027s num_name_readers release runs first:\n[reader] copy ; release 0 -\u003e (happens after) -\u003e [writer] acquire 0; free\n\nI keep scratching my head what the \"proof\" (by contradiction?) is if the reader\u0027s num_name_readers release runs second.\n[writer] acquire 0; free OLD -\u003e ???? -\u003e [reader] acquire 0; copy OLD\nIt seems obvious that the reader must see the new pointer as opposed to the old. But I keep wondering what is the formal way to prove it.",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cad63438_d8c4d59d",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-02-01T23:51:31Z",
      "side": 1,
      "message": "It would be easy to see if it was compare_exchange(0, 0, order_acq_rel) here instead (I guess that is just like mutex lock/unlock in one operation, with nothing in the critical section). The added release here would mean the reader would have to see the updated name.",
      "parentUuid": "535fcf9a_3facc679",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f8869be3_2dd9ae62",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-02T00:51:49Z",
      "side": 1,
      "message": "Thanks! I think your doubts are well taken. We\u0027re counting on the ordering between the write in the xchg and the acquire load of num_name_readers, which currently doesn\u0027t hold.  The failing scenario is the one in which the load of the count effectively is executed in the middle of the xchg, and the increment and name access by the reader are executed between count load in the writer, and the xchg store.\n\nAt least the load in the writer needs to be seq_cst. At least the increment for this also needs to be for this to make sense.\n\nThen we have the following argument:\nAmong the three seq_cst operations, if the load is ordered after the xchg, it will see the new value, and there is no issue. If the load is ordered before the exchange, then the seq_cst order will also order the increment before the load, which means the load must see the increment.\n\nI think the release fro the decrement suffices. But this seems tricky enough to just use seq_cst for everything here.",
      "parentUuid": "535fcf9a_3facc679",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c554e1d2_0f933d5b",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-02T02:40:17Z",
      "side": 1,
      "message": "Actually, I don\u0027t think compare_exchange with acq_rel would help. You really need the store-\u003eload ordering between the xchg store and the load. The imprtant thing to remember is that RMW operations are not fully indivisible; they only guarantee that there is no intermediate store to the value being updated. And that\u0027s essential, since they\u0027re allowed to be implemented with a lock or acq/rel lx/sx.",
      "parentUuid": "f8869be3_2dd9ae62",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e0fef90_83e74d02",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-02-02T12:58:04Z",
      "side": 1,
      "message": "Firstly, I would like to clarify that I am mostly just satisfying my curiously here, so thank you for participating :-)\n\n\u003d\u003d\u003d\n\nI don\u0027t fully follow the \"RMW operations are not fully indivisible\".  Even if they are implemented as lock or sx/lx, there is still total order on the affected atomic variable, and there is still synchronizes-with relation between threads, so it fulfills the needs, no? (specifically, if we inline the lock implementation, the argument just transitively moves to using the lock\u0027s guard variable, and still holds;  and sx/lx just seems like hardware detail of how cas is dispatched to the cpu.)\n\nIf other thread loads the same atomic variable in the middle of RMW on our thread, isn\u0027t that same as if the load happened before the RMW? (i.e. the load is earlier in total order, and synchronizes-with does not apply if the load-acquire happens before store-release)\n\n\u003d\u003d\u003d\n\nBut, on second read, maybe you are saying that if we do RMW on two *distinct* atomics, then dividing RMW into smaller parts can help demonstrate the issue.  That makes more sense.  So I think you meant this...\n\nW: lx.acq name (\u003dold_name)\nW: ld.acq num_readers (\u003d0; reordered up*)\nR: inc.acq num_readers (0 -\u003e 1)\nR: ld.acq name (\u003dold_name)\nW: sx.rel name (\u003dnew_name)\nW: free old_name\nR: read old_name (use after free!!!)\n\n*note that the compare_exchange fix would disallow this reorder.\n\nMaking everything seq_cst works, of course, although I still think we don\u0027t need any at all.\n\n\u003d\u003d\u003d\n\nTo spell out the cases, I am assuming that even if we don\u0027t have seq_cst anywhere, there is still unambiguous total order on the \u0027num_readers\u0027 operations between all threads (including RMW), so we can state that there are only three possible cases:\n1) reader-before-writer, which seem easy to show that it works.\n2) reader-after-writer, which I am trying to fix with the compare_exchange.\n3) overlapping, which is intentionally broken - but in that case, the writer must read positive \u0027num_readers\u0027 value, and it will retry until it gets into state 1.\n\n\u003d\u003d\u003d\n\nTo spell out the compare_exchange fix:\n\n[writer] store name; acquire\u0026RELEASE num_readers -\u003e [reader] acquire num_readers; load name\n\nThere is release-acquire on num_readers, which establishes synchronizes-with, which then transitively implies \"store name\" happens before \"load name\".\n\n\u003d\u003d\u003d \n\nAnother simple mind experiment is: If this was run through thread sanitizes, would it pass? What do we need to do so that it works? My intuition is that it might fail as-is, but that the compare_exchange fix should be enough to make the sanitizers happy.\n\n\u003d\u003d\u003d\n\nI guess I should also elaborate on the \"it is like one-instruction mutex lock/unlock\", witch is different way to make the same argument.\n\nI have not tried to implement reader-writer mutex before but I think minimal native implementation is: (if we define \u0027num_readers\u0027 \u003d\u003d -1 to mean writer lock is taken)\n\nWriter thread:\n[acquire] cas num_readers from 0 to -1 (spin while num_readers !\u003d 0)\nallocate new_name\nexchange name (non-atomic)\nfree old_name\n[release] num_readers \u003d 0\n\nReader thread:\n[acquire] cas num_readers from N to N+1 (spin while num_readers \u003d\u003d -1)\ncopy name\n[release] cas num_readers from N to N-1\n\nThat works, right?  Now, we can optimize it a bit for our use case:\n\n1) We can eagerly pull \"allocate new_name\" before the critical section.\n2) We can lazily push \"free old_name\" after the critical section.\n3) We can make \"exchange name\" atomic, pull it before the critical section, and make \"copy name\" atomic as well. This changes semantic a bit since readers can now see new name a little sooner, but it does not break anything.\n4) With the above steps, the content of the writer\u0027s critical section is empty now (but we can not just remove it).  It consists of just the [acquire] cas to -1 and [release] store back to 0.  So my argument is that those two can be fused to compare_exchange(0, 0, order_acq_rel) with the same semantic.\n5) With the above step, the reader can never see value of -1, so we can just remove the spinning.\n6) This leaves us with your implementation plus the compare_exchange fix.\n\nSo I guess your implementation can also be thought of as minimal reader-writer mutex.",
      "parentUuid": "c554e1d2_0f933d5b",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9aaf7b8c_a6b3095c",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-03T01:31:26Z",
      "side": 1,
      "message": "Your \"on second read\" interpretation is exactly correct.\n\nI think I believe your argument about the acq-rel solution. \n\nBut this still seems subtle. My concern was that we have essentially, in the writer:\n(a) load-exclusive-acquire name\n(b) store-exclusive-release name\n(c) load-exclusive-acquire count\n[maybe:]\n(d) store-exclusive-release count\n\nReader:\n(x) load-exclusive-acquire count\n(y) store-exclusive count (incr)\n(z) load-exclusive-acquire name\n\nThe question is whether we can get\na-\u003ec-\u003ex-\u003ez-\u003eb-\u003ed-\u003ey\n\nwhich would result in the reader getting the old name, while the writer sees a zero. It\u0027s not completely clear from the standard that putting d (which doesn\u0027t change the value) between x and y is disallowed \"Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation.\" but implementations and formalizations probably would, by distinguishing which write is read, rather than checking the values. The standard should be clearer\n\nI\u0027ll go ahead and submit as is, since I\u0027m not convinced this is a real performance issue.",
      "parentUuid": "2e0fef90_83e74d02",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "48575444_f4d70eae",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-02-03T15:24:42Z",
      "side": 1,
      "message": "Oh, you made it SEQ_CST in the last PS.  That is strictly stronger then what I proposed, right? (despite keeping it as load rather then compare_exchange)\n\nSGTM\n\nRegarding putting d between x and y.  Intuitively, if d was increment as well, then we would miss one increment of the two, so that should be obviously disallowed.\n\nBut I think your point is that if we write back the same value, things might change by the strict reading of the standard.  Point taken.\n\nWhat if (d) sets the most significant bit? (and we promptly clear it again)  That is, it would be even more like reader-writer lock (where MSB signifies that writer lock is taken, but we still have the optimization that reader\u0027s don\u0027t spin even if writer lock is takn).\n\nPS: I am also thinking if this is safe if multiple threads try to set thread name at the same time, but I believe that it is.",
      "parentUuid": "9aaf7b8c_a6b3095c",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7d3713e1_d6f2cf0e",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1242,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-03T21:43:03Z",
      "side": 1,
      "message": "Yes. This is stronger and slower than needed. But I would be amazed if the latter mattered. And it seems much clearer to me than the almost-no-op compare-exchange.\n\nI agree that having it change the value would make it clearly correct, but it shouldn\u0027t really be needed.\n\nWG21 recently ran into a related issue with a fetch_max() proposal. There is a question of whether that always writes the maximum or conditionally replaces the maximum. It matters in cases like this. Whether or not you actually need the no-op store on a given platform seems a bit subtle. On ARM, with lx, sx, you probably would.\n\nI also believe the multiple writer case is fine. Each old value is retrieved by the next writer (in modification order for that location), which will eventually deallocate it.",
      "parentUuid": "48575444_f4d70eae",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3760f81_ed33dd45",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1247,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-02-01T16:28:13Z",
      "side": 1,
      "message": "SGTM. I guess \u00270\u0027 and \u0027i\u0027 would also be decent sleep times.",
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34425cdd_834e7256",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1388,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-02-01T12:08:27Z",
      "side": 1,
      "message": "We need to increment/decrement `num_name_readers` around this.",
      "range": {
        "startLine": 1383,
        "startChar": 2,
        "endLine": 1388,
        "endChar": 12
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e646e1e0_42091b57",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1388,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-02T02:40:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "34425cdd_834e7256",
      "range": {
        "startLine": 1383,
        "startChar": 2,
        "endLine": 1388,
        "endChar": 12
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1693c31d_7b868284",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1408,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-02-01T16:28:13Z",
      "side": 1,
      "message": "Does it need to be seq_cst?",
      "range": {
        "startLine": 1408,
        "startChar": 27,
        "endLine": 1408,
        "endChar": 31
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2ecd83c1_895b0f14",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1408,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-02T02:40:17Z",
      "side": 1,
      "message": "Yes, but that\u0027s the default. Since I\u0027m now convinced we need it, I\u0027ll make it explicit.",
      "parentUuid": "1693c31d_7b868284",
      "range": {
        "startLine": 1408,
        "startChar": 27,
        "endLine": 1408,
        "endChar": 31
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a709e42b_309100ef",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1968,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-02-01T12:08:27Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 1968,
        "startChar": 4,
        "endLine": 1968,
        "endChar": 52
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6fc8bf4_5e8c731c",
        "filename": "runtime/thread.cc",
        "patchSetId": 2
      },
      "lineNbr": 1968,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-02-02T02:40:17Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a709e42b_309100ef",
      "range": {
        "startLine": 1968,
        "startChar": 4,
        "endLine": 1968,
        "endChar": 52
      },
      "revId": "0b04fda5285ee47f7c36db4fef5c589fc4c66887",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}