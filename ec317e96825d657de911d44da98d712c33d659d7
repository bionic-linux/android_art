{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8ec4a618_0537a194",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-09T19:26:33Z",
      "side": 1,
      "message": "Adding Jared and Tim to check if I\u0027m doing the caching correctly.",
      "revId": "ec317e96825d657de911d44da98d712c33d659d7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2eaefe9_72c59fd3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1064003
      },
      "writtenOn": "2024-01-09T19:46:22Z",
      "side": 1,
      "message": "Thanks for taking a look at this Jiakai. What are your thoughts on the additional complexity of this approach versus something a bit more narrowly scoped and simple like aosp/2889793? I\u0027m somewhat indifferent, though I\u0027m always a bit hesitant of solutions that have timeout-based expirations.",
      "revId": "ec317e96825d657de911d44da98d712c33d659d7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ad192d23_249d7ba7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-09T23:53:11Z",
      "side": 1,
      "message": "Thanks for the thoughts. For b/317221732 (just avoiding repetitive waitForService calls), I think both solutions work, and I would prefer aosp/2889793 over this CL because it\u0027s simpler.\n\nHowever, when it comes to avoiding repetitive artd initialization, which is much more expensive than repetitive waitForService calls, the pinning approach in this CL is necessary. aosp/2889793 basically keeps the behavior unchanged, which relies on an assumption that the GC doesn\u0027t happen immediately after an artd handle is no longer referenced. I don\u0027t know how well this assumption holds in reality. Maybe under extreme memory pressure, artd is brought up and teared down repetitively because of the GC, though this is just theoretical. This has been my concern for a long time. I\u0027m actually more comfortable with explicit pinning instead of relying on the assumption.\n\nIn short, I think aosp/2889793 is simpler and it solves one problem, while this CL is more complicated but solves two at a time, though one of them is theoretical. But TBH, I\u0027m indifferent too. I\u0027ll leave this to Martin to provide some thoughts.\n\nThe timeout-based expiration is just a bonus. This main part of ArtdRefCache is about pinning. Because we already have a debouncer implementation, it\u0027s easy to add a few lines to use it to implement the timeout-based expiration. It can fight against the case where our APIs are called repetitively, in which case a local pinning won\u0027t work. I\u0027m interested in seeing how our APIs are used in real CUJs. You mentioned initial device setup in aosp/2889793. Could you provide some traces to show how our APIs are used in that CUJ? If it turns out that the timeout-based expiration is useless, I can remove it.",
      "parentUuid": "e2eaefe9_72c59fd3",
      "revId": "ec317e96825d657de911d44da98d712c33d659d7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba933361_d833f959",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-10T21:31:21Z",
      "side": 1,
      "message": "I think the unpredictable GC behaviour on high memory pressure is a good point. It\u0027s nice to avoid that uncertainty.\n\nThat said, the ref cache is rather more code than I\u0027d like for that sort of thing. I\u0027d expect/hope the JDK would have something to help with such scoped caching. That\u0027s not the case?\n\n\u003e it\u0027s easy to add a few lines to use it to implement the timeout-based expiration\n\nWell, it also introduces the finicky `DeathRecipient` stuff, doesn\u0027t it? That makes it not so trivial anymore.\n\nIf we do find CUJ\u0027s where there\u0027s a tangible benefit to cache the artd instance longer, then the proper approach is arguably to introduce a session class to give control of the lifetime to the caller (but admittedly at the cost of adding quite a bit of new API).\n\nAnother idea is to combine this and aosp/2889793 - i.e. do the refcounting but leave behind a best-effort weak ref when the refcount goes to zero. It\u0027s not clear to me if a weak ref would avoid the `DeathRecipient` stuff though - isn\u0027t it also prone to cache a potentially dead instance?",
      "parentUuid": "ad192d23_249d7ba7",
      "revId": "ec317e96825d657de911d44da98d712c33d659d7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ff39e07_eb424726",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-10T21:58:07Z",
      "side": 1,
      "message": "\u003e That said, the ref cache is rather more code than I\u0027d like for that sort of thing.\n\nThe file looks lengthy because it has various boilerplates like license, imports, injector pattern, etc. The core part is line 80-153 (only 74 lines).\n\n\u003e I\u0027d expect/hope the JDK would have something to help with such scoped caching. That\u0027s not the case?\n\nI\u0027d not expect JDK to have anything smart, frankly speaking :)\n\n\u003e it also introduces the finicky DeathRecipient stuff, doesn\u0027t it?\n\n`DeathRecipient` is not for the timeout-based expiration. It is needed whenever we keep a ref, so that if a previous call causes a crash, the next call won\u0027t be affected. For example, during bg dexopt, if artd crashes when dexopting a package, we still want the job to continue to dexopt other packages. Even if we decide to adopt aosp/2889793 (the `WeakReference` approach), we\u0027ll have to add `DeathRecipient` before submitting the CL.\n\nBTW, it\u0027s unfortunate that the `DeathRecipient` has to be a class because it has two callbacks, one of which is legacy. Otherwise, I could make it a lambda so that it looks shorter. But this is just an API detail. The lengthy class doesn\u0027t really add logically complexity, so don\u0027t be scared of it. At the end of the day, it\u0027s just a callback with 5 lines of code.",
      "parentUuid": "ba933361_d833f959",
      "revId": "ec317e96825d657de911d44da98d712c33d659d7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e6c8c1c_a1d2ff83",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1064003
      },
      "writtenOn": "2024-01-10T22:08:22Z",
      "side": 1,
      "message": "\u003e Even if we decide to adopt aosp/2889793 (the WeakReference approach), we\u0027ll have to add DeathRecipient before submitting the CL.\n\nDefinitely. @smoreland@google.com would you be the right person to talk in brainstorming how we could handle this more seamlessly for arbitrary clients? Maybe ART\u0027s needs are slightly unique here in how it\u0027s referencing the transient `artd` service, but I wonder if we can solve this more generally in the platform in a way that minimizes unnecessary calls into `servicemanager` for these handles (without needing each client to add this kind of additional caching/bookkeeping logic).",
      "parentUuid": "5ff39e07_eb424726",
      "revId": "ec317e96825d657de911d44da98d712c33d659d7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16e1e0ac_8031bad4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-10T22:37:49Z",
      "side": 1,
      "message": "\u003e Even if we decide to adopt aosp/2889793 (the WeakReference approach), we\u0027ll have to add DeathRecipient before submitting the CL.\n\nHow can we be sure about that, doesn\u0027t it depend on why artd died? If it got killed by the LMK then it sounds like a good idea to back off - dexopting isn\u0027t _that_ important. If it crashed because something is broken then isn\u0027t it rather likely that it\u0027ll just crash soon enough again? (dex2oat and profman are a different matter in that regard.)\n\n\u003e The lengthy class doesn\u0027t really add logically complexity\n\nI\u0027m discussing logical complexity, not lines. `CacheDeathRecipient` is indeed tedious and annoying, but it\u0027s line 91 that\u0027s the issue.",
      "parentUuid": "7e6c8c1c_a1d2ff83",
      "revId": "ec317e96825d657de911d44da98d712c33d659d7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}