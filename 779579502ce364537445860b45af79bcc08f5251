{
  "comments": [
    {
      "key": {
        "uuid": "ff13e649_1c7bd9af",
        "filename": "runtime/arch/arm/quick_entrypoints_arm.S",
        "patchSetId": 3
      },
      "lineNbr": 918,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-10-13T18:00:49Z",
      "side": 1,
      "message": "This will prevent reordering of memory accesses from the current CPU. But is this really enough? Or, could the CPU still use stale flags from its own L1 data cache after fetching a new status from the actual RAM?",
      "range": {
        "startLine": 909,
        "startChar": 0,
        "endLine": 918,
        "endChar": 21
      },
      "revId": "779579502ce364537445860b45af79bcc08f5251",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dfb462b2_4fd41e79",
        "filename": "runtime/arch/arm/quick_entrypoints_arm.S",
        "patchSetId": 3
      },
      "lineNbr": 918,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-10-13T19:53:03Z",
      "side": 1,
      "message": "This is fine.  The ARM v8 manual I have says:\n\nB2.7.2:\n\nIf an address dependency exists between two reads or between a read and a write, then those memory\naccesses are observed in program order by all observers within the shareability domain of the memory\naddress being accessed.\nThe ARMv8 architecture relaxes this rule for execution where the second read is generated by a Load\nNon-Temporal Pair instruction. See Load/Store Non-temporal Pair on page C2-132 and Load/Store\nSIMD and Floating-point Non-temporal pair on page C2-136.\n\n\nThis is followed by a section on \"Address dependencies and order\", which clearly includes this case.\n\nI believe this rule has been there since the beginning of time.  And it\u0027s required to make Java final fields work.",
      "parentUuid": "ff13e649_1c7bd9af",
      "range": {
        "startLine": 909,
        "startChar": 0,
        "endLine": 918,
        "endChar": 21
      },
      "revId": "779579502ce364537445860b45af79bcc08f5251",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7fa9b65d_8ed8dae0",
        "filename": "runtime/arch/arm/quick_entrypoints_arm.S",
        "patchSetId": 3
      },
      "lineNbr": 918,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2015-10-13T20:05:38Z",
      "side": 1,
      "message": "Another way to reason about this: The access flag had been set before the class status is set to initialized. The class status store is a store release (StoreSequentiallyConsistent) and there are multiple status stores as the status changes through loaded-\u003eresolved-\u003einitialized. If we see the status initialized in this status load here, we shouldn\u0027t see the stale access flags value in the second load that won\u0027t be reordered above the first load.",
      "parentUuid": "dfb462b2_4fd41e79",
      "range": {
        "startLine": 909,
        "startChar": 0,
        "endLine": 918,
        "endChar": 21
      },
      "revId": "779579502ce364537445860b45af79bcc08f5251",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ff8686d4_44564043",
        "filename": "runtime/arch/arm/quick_entrypoints_arm.S",
        "patchSetId": 3
      },
      "lineNbr": 918,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-10-14T10:31:55Z",
      "side": 1,
      "message": "I\u0027ll take the ARMv8 manual answer as satisfactory. (I\u0027m not taking the reasoning about StoreSequentiallyConsistent because we\u0027re not doing LoadSequentiallyConsistent.)",
      "parentUuid": "7fa9b65d_8ed8dae0",
      "range": {
        "startLine": 909,
        "startChar": 0,
        "endLine": 918,
        "endChar": 21
      },
      "revId": "779579502ce364537445860b45af79bcc08f5251",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aadf6a22_a14df859",
        "filename": "runtime/arch/arm/quick_entrypoints_arm.S",
        "patchSetId": 3
      },
      "lineNbr": 960,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-10-13T18:00:49Z",
      "side": 1,
      "message": "I think the assertion should be right here:\n\n    #if ROSALLOC_SLOT_NEXT_OFFSET !\u003d MIRROR_OBJECT_CLASS_OFFSET\n    #error \"Class pointer needs to overwrite next pointer.\"\n    #endif",
      "range": {
        "startLine": 960,
        "startChar": 65,
        "endLine": 960,
        "endChar": 73
      },
      "revId": "779579502ce364537445860b45af79bcc08f5251",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df39c202_ba86e1db",
        "filename": "runtime/arch/arm/quick_entrypoints_arm.S",
        "patchSetId": 3
      },
      "lineNbr": 960,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2015-10-13T20:05:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aadf6a22_a14df859",
      "range": {
        "startLine": 960,
        "startChar": 65,
        "endLine": 960,
        "endChar": 73
      },
      "revId": "779579502ce364537445860b45af79bcc08f5251",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}