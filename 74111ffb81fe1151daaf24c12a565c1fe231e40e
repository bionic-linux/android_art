{
  "comments": [
    {
      "key": {
        "uuid": "f5359ed2_e6a8869a",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-23T17:41:26Z",
      "side": 1,
      "message": "I\u0027m not sure I understand this sentence.",
      "range": {
        "startLine": 104,
        "startChar": 7,
        "endLine": 104,
        "endChar": 9
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b58de6f4_15b37ee1",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2014-10-23T23:05:27Z",
      "side": 1,
      "message": "Usually you would expect inactive intervals to be first moved from active set at some point, so the start of any inactive interval should be before the current interval being processed during linear scan, but it\u0027s inactive since it\u0027s in a hole at the current instruction position. Basically any interval starting after the current instruction is in unhandled set. I found it a little surprising during some debugging to see inactive intervals that start after the current instruction being processed. And I found those are fixed intervals, and they start in inactive set instead of unhandled. So I added some comment to make it clear. Or should it be stated with more clarity?\n\nI saw some algorithm that adds fixed intervals to unhandled set first, so you don\u0027t need to process them (like doing intersecting with the current interval) until they really start. I think the way we do it is fine but just want to make it clear with some comment.",
      "parentUuid": "f5359ed2_e6a8869a",
      "range": {
        "startLine": 104,
        "startChar": 7,
        "endLine": 104,
        "endChar": 9
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f5359ed2_c12c4c06",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-24T14:54:56Z",
      "side": 1,
      "message": "Oh I see. So should we move them to unhandled and then skip them in in the LinearScan loop?\n\nThat would make things consistent and unsurprising, WDYT?",
      "parentUuid": "b58de6f4_15b37ee1",
      "range": {
        "startLine": 104,
        "startChar": 7,
        "endLine": 104,
        "endChar": 9
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d5d6dada_2b4d1588",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2014-10-27T17:17:00Z",
      "side": 1,
      "message": "I thought a little more. Actually adding to inactive may generate better code since it tries to avoid assigning to a register that might be blocked later. Another way to think of fixed interval is it begins with a hole (even though its official start position is later). Then it makes sense it\u0027s in inactive first.\nThe statements in added comment are still accurate.",
      "parentUuid": "f5359ed2_c12c4c06",
      "range": {
        "startLine": 104,
        "startChar": 7,
        "endLine": 104,
        "endChar": 9
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "55abca56_089ce7cc",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 615,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-28T14:51:01Z",
      "side": 1,
      "message": "Add:\n\nOnly if it\u0027s not fixed, because fixed intervals don\u0027t come from SSA.\n\n(right?)",
      "range": {
        "startLine": 615,
        "startChar": 60,
        "endLine": 615,
        "endChar": 68
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f5359ed2_81c404d0",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 617,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-24T14:54:56Z",
      "side": 1,
      "message": "So you\u0027re doing this to ensure all inactive pass the DCHECK line 611?\n\nI think I\u0027d prefer a dedicated loop for that.",
      "range": {
        "startLine": 617,
        "startChar": 8,
        "endLine": 617,
        "endChar": 16
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35cf3649_12008c6f",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 617,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2014-10-27T17:17:00Z",
      "side": 1,
      "message": "It\u0027s the assert on line 623. debug version will try to verify that an SSA value starting in a hole of an inactive interal won\u0027t intersect. Non-debug version will just skip the intersection completely as an optimization due to the SSA property.",
      "parentUuid": "f5359ed2_81c404d0",
      "range": {
        "startLine": 617,
        "startChar": 8,
        "endLine": 617,
        "endChar": 16
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "55abca56_c8a56f14",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 617,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-28T14:51:01Z",
      "side": 1,
      "message": "OK so I suggest computing the intersection and doing the DCHECK here instead of line 623 (and you can just remove 622-624).",
      "parentUuid": "35cf3649_12008c6f",
      "range": {
        "startLine": 617,
        "startChar": 8,
        "endLine": 617,
        "endChar": 16
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f5359ed2_61c920e4",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 676,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-24T14:54:56Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 676,
        "startChar": 21,
        "endLine": 676,
        "endChar": 28
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "55abca56_e8a2ab09",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 676,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-28T14:51:01Z",
      "side": 1,
      "message": "DCHECK intersection is no lifetime?",
      "parentUuid": "f5359ed2_61c920e4",
      "range": {
        "startLine": 676,
        "startChar": 21,
        "endLine": 676,
        "endChar": 28
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7597ee02_217528f7",
        "filename": "compiler/optimizing/register_allocator_test.cc",
        "patchSetId": 3
      },
      "lineNbr": 418,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-23T17:41:26Z",
      "side": 1,
      "message": "I don\u0027t understand the change in this file.",
      "range": {
        "startLine": 418,
        "startChar": 28,
        "endLine": 418,
        "endChar": 29
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9592a210_a834bad4",
        "filename": "compiler/optimizing/register_allocator_test.cc",
        "patchSetId": 3
      },
      "lineNbr": 418,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2014-10-23T23:05:27Z",
      "side": 1,
      "message": "The old artificial intervals break this rule:\n// Thanks to SSA, a non-split interval starting in a hole of an\n// inactive interval should never intersect with that inactive interval.\n\nSo I tuned the intervals somewhat to make it work with that rule (add a split). I changed it to non-temp interval since I added an assertion somewhere that temp intervals don\u0027t have holes (well, that\u0027s my understanding from the code, they have a single range) so they won\u0027t be added to inactive set.\n\nSo basically I just try to work around some assertions.",
      "parentUuid": "7597ee02_217528f7",
      "range": {
        "startLine": 418,
        "startChar": 28,
        "endLine": 418,
        "endChar": 29
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "351e565a_8359c801",
        "filename": "compiler/optimizing/ssa_liveness_analysis.h",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-24T14:54:56Z",
      "side": 1,
      "message": "Maybe change the call sites that use the constructor and make them use this factory method? Then you can make the constructor private.",
      "range": {
        "startLine": 162,
        "startChar": 23,
        "endLine": 162,
        "endChar": 35
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d5d6dada_2bc2f561",
        "filename": "compiler/optimizing/ssa_liveness_analysis.h",
        "patchSetId": 3
      },
      "lineNbr": 162,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2014-10-27T17:17:00Z",
      "side": 1,
      "message": "Will do.",
      "parentUuid": "351e565a_8359c801",
      "range": {
        "startLine": 162,
        "startChar": 23,
        "endLine": 162,
        "endChar": 35
      },
      "revId": "74111ffb81fe1151daaf24c12a565c1fe231e40e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}