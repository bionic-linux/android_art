{
  "comments": [
    {
      "key": {
        "uuid": "788fe26d_4a783c5e",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2432,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-06-30T02:32:41Z",
      "side": 1,
      "message": "This is wrong, I think.\n\nYou cannot do this immediately. You can only do this if either of the following is true:\n* This is a DelegateLast classloader.\n* The *complete* chain is Path or Dex classloaders.\n\nThe recursive nature of FindClassInBaseDexClassLoader took care of that before...",
      "range": {
        "startLine": 2432,
        "startChar": 2,
        "endLine": 2432,
        "endChar": 72
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2459261b_8fd9e4aa",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2432,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2017-06-30T08:53:21Z",
      "side": 1,
      "message": "Hmm, I think you\u0027re right. Good catch! and it looks like we don\u0027t have a regression test to capture it. I\u0027ll add one.\n\nI\u0027ll just add a  full check of the chain before calling this. It will simplify the interface as well.",
      "parentUuid": "788fe26d_4a783c5e",
      "range": {
        "startLine": 2432,
        "startChar": 2,
        "endLine": 2432,
        "endChar": 72
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19e7c4d0_b910dca1",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2432,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-06-30T15:53:14Z",
      "side": 1,
      "message": "Please don\u0027t. Please keep it simple. Keep the original setup of this being the recursive function.\n\n bool Find(cl) {\n   if (IsBootClass(cl)) {\n     return LoadFromBoot()\n   } else if (IsPath(cl) || IsDex(cl)) {\n     if (Find(cl.getParent()) {\n       return true;\n     }\n     return LoadDexPathList(cl);\n   } else if (IsDelegateLast(cl)) {\n     if (LoadDexPathList(cl)) {\n       return true;\n     }\n     if (LoadFromBoot()) {\n       return true;\n     }\n     return Find(cl.getParent());\n   }\n }\n\nYes, that will hit the boot classloader twice for DelegateLast when the class is missing. But at least the loading code is *clean*-ish that way.",
      "parentUuid": "2459261b_8fd9e4aa",
      "range": {
        "startLine": 2432,
        "startChar": 2,
        "endLine": 2432,
        "endChar": 72
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7265c6ae_182fd2b8",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2432,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2017-06-30T19:41:59Z",
      "side": 1,
      "message": "You will hit the boot class path in the order of the number of DelegateLast loaders + 1.   That\u0027s a waste to me. \n\nIt will also makes things more complex because your snippet is not correct. For delegate last you need to first search the boot classpath. Which means that you still need to traverse to the top of the chain to verify that nothing is unsupported (as you noticed in your first reply). Implementing this recursively is doable but it adds much more complexity to make sure that after recursing for the boot classpath you return to the original DelegateLast.",
      "parentUuid": "19e7c4d0_b910dca1",
      "range": {
        "startLine": 2432,
        "startChar": 2,
        "endLine": 2432,
        "endChar": 72
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bf49c01_b425c6b9",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2432,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-06-30T20:22:02Z",
      "side": 1,
      "message": "Your reasoning is incorrect. The chain only needs to be verified for Path and Dex classloader. DelegateLast can fully ignore w/e the parent is if it finds the class with either boot or itself.\n\nYou can see the C++ code as a straightforward translation of the Java code and some partial evaluation. The bail case is that, in evaluation order, you reach an unsupported classloader. At that point you bail. If you never reach it (e.g., because it\u0027s the parent of a DelegateLast, but DelegateLast defines the class), then the Java code would not reach the parent, either. That\u0027s the underlying soundness argument of implementing the C++ fast-path...\n\n(And yeah, sorry, the two ifs for that branch should be reversed)\n\nIf you feel strongly, pass down an \"ignore boot at the end.\" However, I think you\u0027re over-optimizing for something we do not have any strong evidence for, and this all becomes really brittle.\n\n\nI\u0027ll repeat my point: if we were telling developers that they can shoot themselves, this discussion were moot. :-)",
      "parentUuid": "7265c6ae_182fd2b8",
      "range": {
        "startLine": 2432,
        "startChar": 2,
        "endLine": 2432,
        "endChar": 72
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e8bc218_5a868b8e",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2432,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2017-07-03T02:42:05Z",
      "side": 1,
      "message": "Oh right, for DelgateLast the chain doesn\u0027t need to be verified, so that can be simplified (your snippet is fine if the search order is reversed).\n\nSearching the boot class path multiple times is a waste. Of course we don\u0027t have data, because no one uses this at the moment. But we also know that in one of the major use cases we\u0027ll have a chain of 2 DelegateLast loaders in a row. Which means that we\u0027re gonna penalize it for no good reason. I don\u0027t think that the difference in readability is that big here that it justify leaving this optimization out.\n\n\n(and since we decided to support this case in libcore I also don\u0027t think we should go with the \"shoot\" option :-) )",
      "parentUuid": "1bf49c01_b425c6b9",
      "range": {
        "startLine": 2432,
        "startChar": 2,
        "endLine": 2432,
        "endChar": 72
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "050a004a_2fcd81bc",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2473,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-06-30T14:21:16Z",
      "side": 1,
      "message": "From an API standpoint, I do not like this method which walks the parent chain but arbitrarily stops at the boot classpath.",
      "range": {
        "startLine": 2465,
        "startChar": 0,
        "endLine": 2473,
        "endChar": 75
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "33abc7bd_d6536bab",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2473,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2017-06-30T19:41:59Z",
      "side": 1,
      "message": "What alternatives do you suggest?\n\n- Andreas suggestions for a pure recursive method (which hits the boot class multiple times and adds complexity imo)? \n- linearizing the chain in a natural search order?\n- others?",
      "parentUuid": "050a004a_2fcd81bc",
      "range": {
        "startLine": 2465,
        "startChar": 0,
        "endLine": 2473,
        "endChar": 75
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4a86c7e7_6094d872",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2473,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-06-30T20:23:43Z",
      "side": 1,
      "message": "Adds complexity? I *really* disagree with that assessment. It\u0027s the *way* simpler, better readable and to-reason-about code. *You* are partially evaluating/CSE-ing Java *way more* than the old code. At that point you introduce brittleness.",
      "parentUuid": "33abc7bd_d6536bab",
      "range": {
        "startLine": 2465,
        "startChar": 0,
        "endLine": 2473,
        "endChar": 75
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0cb0824f_63d6cdde",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2473,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2017-07-03T02:42:05Z",
      "side": 1,
      "message": "I get that you don\u0027t care if you search the boot multiple times, but I don\u0027t think your readability argument is strong enough to let pretty straightforward optimizations out.\n\nTo me it reads better to:\n\n- check that everything is supported\n- search boot\n- search the rest\n\ninstead of threading an extra arguments around. However I don\u0027t really mind either way. It\u0027s not a very big difference after all.",
      "parentUuid": "4a86c7e7_6094d872",
      "range": {
        "startLine": 2465,
        "startChar": 0,
        "endLine": 2473,
        "endChar": 75
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "015cdf4a_497a655c",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2473,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-07-05T11:54:56Z",
      "side": 1,
      "message": "I\u0027m still unclear why you can\u0027t do the same as Java land:\n- DelegateLastClassLoader::loadClass\n- ClassLoader::loadClass\n- ClassLoader::findClass.",
      "parentUuid": "0cb0824f_63d6cdde",
      "range": {
        "startLine": 2465,
        "startChar": 0,
        "endLine": 2473,
        "endChar": 75
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "286b06f4_7fdfa16a",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 2473,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2017-07-05T15:05:50Z",
      "side": 1,
      "message": "We chatted about this offline: the java code hits the boot classpath multiple times. As discussed, I\u0027ll revert to the full recursive solution with and extra flag to not check the boot classpath again.",
      "parentUuid": "015cdf4a_497a655c",
      "range": {
        "startLine": 2465,
        "startChar": 0,
        "endLine": 2473,
        "endChar": 75
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39365284_d8f15633",
        "filename": "runtime/class_linker.h",
        "patchSetId": 1
      },
      "lineNbr": 843,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-06-30T14:21:16Z",
      "side": 1,
      "message": "From just reading the header, these could sound like doing the same. The difference should be more explicit.",
      "range": {
        "startLine": 822,
        "startChar": 0,
        "endLine": 843,
        "endChar": 34
      },
      "revId": "6b6adddbbe58d9df3848cd1b3c2b1f4ca6d830c3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}