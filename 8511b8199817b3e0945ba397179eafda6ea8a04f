{
  "comments": [
    {
      "key": {
        "uuid": "4e7c5d8b_43fcb3f6",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2018-03-10T23:57:43Z",
      "side": 1,
      "message": "This will always move the unused argument into a register, thus inserting an unnecessary move. Is that intentional? If not, there are better values to use here.\n\n(same for all archs)",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "77aab66d_21057b3f",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-03-12T15:48:59Z",
      "side": 1,
      "message": "Yes, you can do:\nlocations-\u003eSetInAt(0, Location::NoLocation());        // Unused argument.",
      "parentUuid": "4e7c5d8b_43fcb3f6",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ac44dbd0_cd5b2252",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-13T01:52:13Z",
      "side": 1,
      "message": "I really want to say that it needs to be someplace from where I could load it into a register if I wanted, but I don\u0027t care whether it actually is in a register. It could be in a stack slot. It could be a constant if it were null, but that\u0027s an unlikely and uninteresting case.\n\nBased on what I could immediately find, NoLocation sounds like it might be too weak, in that it wouldn\u0027t force the value to be kept anywhere? It seems to be used for dead arguments? Is Location::Any() better?",
      "parentUuid": "77aab66d_21057b3f",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "de97b10e_4e5f6445",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-03-13T13:39:38Z",
      "side": 1,
      "message": "Correct, the liveness analysis will indeed use the location information. So you\u0027re right that Location::Any is best here.",
      "parentUuid": "ac44dbd0_cd5b2252",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ce4a20c4_377010f6",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-03-29T08:56:24Z",
      "side": 1,
      "message": "What\u0027s the reason for keeping the reference alive from the last environment use until this intrinsic? Is that extra liveness observable?",
      "parentUuid": "de97b10e_4e5f6445",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "01c6a2d4_00df3fa3",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-29T18:32:29Z",
      "side": 1,
      "message": "It is observable if the referent is e.g. finalizable, and the finalizer may otherwise run before the reachabilityFence(). The only effect of reachabilityFence is to prevent that.\n\nCurrently we generally implicitly prevent that in ART anyway by keeping references live. But that needs to change in the long run, since it can unexpectedly cause memory retention. (And ART\u0027s treatment is not completely consistent with dexers, so reachabilityFence() is already not quite a no-op.)",
      "parentUuid": "ce4a20c4_377010f6",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cc9dde57_65745a3b",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-04-03T09:42:48Z",
      "side": 1,
      "message": "Consider\n\n  HInvokeVirtual (environment use)\n  HAdd\n  HMul\n  ... (whatever else without an environment)\n  ... (even volatile reads/writes)\n  HInvokeStaticOrDirect/reachabilityFence\n\nHow is the extra liveness over HAdd/HMul/... observable? The lack of an opportunity to mark thread roots means a lack of opportunity for the reference to become dead.",
      "parentUuid": "01c6a2d4_00df3fa3",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e7d35c7a_ca2e6846",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-04-03T17:20:07Z",
      "side": 1,
      "message": "Thanks for the explanation. I\u0027m still learning about terminology and conventions here.\n\nIIUC, you are right that there is no need to keep the reference live after the last environment use. My goal here is to make sure that it appears in the last environment. This is currently unnecessary because we don\u0027t remove references. But we want to start doing that in the future.\n\nIs there a better way to only keep the register live until the preceding environment use? We would presumably also need to make sure that the environment use is not reordered with preceding memory accesses.\n\n(ReachabilityFence() is nonetheless useful, even now. We already sometimes need reachabilityFence() to prevent d8 (and, possibly less frequently, dx) from eliminating dead references. In that case the intrinsic reduces the cost from a non-trivial function call to keeping a register live for a bit longer than necessary. But if there\u0027s a way to do even better ...)",
      "parentUuid": "cc9dde57_65745a3b",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a1e107c0_fcb3e247",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2018-04-03T17:49:06Z",
      "side": 1,
      "message": "I think it should be enough to keep the HInvokeStaticOrDirect/reachabilityFence live until codegen. Even if we start removing references from environments, it\u0027s probably impossible to do while there is a subsequent use of that reference. (GC may need to mark that reference through the environment use. The exception is the throwing slow paths where we could try to remove the environment use despite the subsequent use in normal path; but you advocated putting the reachabilityFence in a finally block exactly because of concerns with ordering finalization and stack unwinding, otherwise the reference can be considered dead in the slow path.)\n\nOnce we get to codegen, specifying Location::None() instead of Location::Any() can occasionally avoid a spill or move without affecting the liveness for preceding environment uses.",
      "parentUuid": "e7d35c7a_ca2e6846",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "051d72f7_2a74cf2b",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2881,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-04-03T18:27:55Z",
      "side": 1,
      "message": "I agree that Location::None() can potentially generate faster code. But I\u0027m still a little surprised that it\u0027s sufficient. You\u0027re saying that the liveness analysis considers inputs to intrinsics to be live even if they specify Location::NoLocation()? That seems wrong for something like UnsafeGet, that really completely ignores its first argument (the receiver object).\n\nI think we currently use Location::NoLocation in intrinsics only for reference arguments, so there\u0027s not currently any difference between the two interpretations.",
      "parentUuid": "a1e107c0_fcb3e247",
      "range": {
        "startLine": 2881,
        "startChar": 24,
        "endLine": 2881,
        "endChar": 32
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "92a31526_fcb3ecee",
        "filename": "runtime/intrinsics_list.h",
        "patchSetId": 1
      },
      "lineNbr": 221,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-03-12T15:48:59Z",
      "side": 1,
      "message": "Should this be all side effects? (Read + write)",
      "range": {
        "startLine": 221,
        "startChar": 58,
        "endLine": 221,
        "endChar": 75
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "743e15f5_23f7725a",
        "filename": "runtime/intrinsics_list.h",
        "patchSetId": 1
      },
      "lineNbr": 221,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-13T01:52:13Z",
      "side": 1,
      "message": "I think this is correct. This should not be advanced past any read or write accesses to the heap. kWriteSideEffects should have that effect, right?",
      "parentUuid": "92a31526_fcb3ecee",
      "range": {
        "startLine": 221,
        "startChar": 58,
        "endLine": 221,
        "endChar": 75
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b450fda9_4410f646",
        "filename": "runtime/intrinsics_list.h",
        "patchSetId": 1
      },
      "lineNbr": 221,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-03-13T13:39:38Z",
      "side": 1,
      "message": "Yes. If you add read to it, that will make other (aliasing) writes not be scheduled before the intrinsic.\n\nI guess scheduling write instructions before the intrinsic is OK?",
      "parentUuid": "743e15f5_23f7725a",
      "range": {
        "startLine": 221,
        "startChar": 58,
        "endLine": 221,
        "endChar": 75
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "442b0e7d_c6602223",
        "filename": "runtime/intrinsics_list.h",
        "patchSetId": 1
      },
      "lineNbr": 221,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-20T00:43:43Z",
      "side": 1,
      "message": "I actually don\u0027t understand this. kWriteSideEffects presumably means that any heap location can conceivably be written? But if that\u0027s the case, then reordering it with another write, in either direction, should be unsafe, since a different write will \"win\". Similarly reordering with a read in either direction isn\u0027t safe, since the read will see a different value. That was certainly the assumption that went into the fullFence definition above.\n\nIs that not correct? Otherwise is there a difference between kWriteSideEffects and kAllSideEffects, aside from the fact that the latter can include suspend points, and thus we should be keeping derived pointers across a kAllSideEffects intrinsic?\n\nIn either case, I\u0027m currently leaning towards improving the comments defining these.",
      "parentUuid": "b450fda9_4410f646",
      "range": {
        "startLine": 221,
        "startChar": 58,
        "endLine": 221,
        "endChar": 75
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8245c674_dc1fb261",
        "filename": "runtime/intrinsics_list.h",
        "patchSetId": 1
      },
      "lineNbr": 221,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-03-20T14:08:19Z",
      "side": 1,
      "message": "The side effects aren\u0027t only used for reordering, they\u0027re also used for eg GVN and LSE (see uses of DoesAnyRead and DoesAnyWrite in the compiler code).\n\nSo I think you are right, this doesn\u0027t need to have a kRead, but needs an artificial side effect to prevent removal and reordering.",
      "parentUuid": "442b0e7d_c6602223",
      "range": {
        "startLine": 221,
        "startChar": 58,
        "endLine": 221,
        "endChar": 75
      },
      "revId": "8511b8199817b3e0945ba397179eafda6ea8a04f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}