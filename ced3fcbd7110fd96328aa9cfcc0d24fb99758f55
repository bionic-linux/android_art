{
  "comments": [
    {
      "key": {
        "uuid": "4d90030a_2243f012",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1870,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-11-29T20:45:30Z",
      "side": 1,
      "message": "Why this change?",
      "range": {
        "startLine": 1870,
        "startChar": 6,
        "endLine": 1870,
        "endChar": 24
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_422f2750",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1870,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-29T20:51:00Z",
      "side": 1,
      "message": "Just so we don\u0027t keep resetting the flag. It is a minor improvement (extra read to avoid duplicate writes)",
      "parentUuid": "4d90030a_2243f012",
      "range": {
        "startLine": 1870,
        "startChar": 6,
        "endLine": 1870,
        "endChar": 24
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_4248742a",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1900,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-11-29T20:45:30Z",
      "side": 1,
      "message": "Why not recursively calling NoEscapeForStringBufferReference?",
      "range": {
        "startLine": 1900,
        "startChar": 15,
        "endLine": 1900,
        "endChar": 31
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_a2495333",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1900,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-29T20:51:00Z",
      "side": 1,
      "message": "I thought about that, but decided against it to avoid weird looping cases and excessive times spent in this method. Note that I think that in the long run, perhaps we should make escape analysis a full blown analysis pass, not a on-demand service ....",
      "parentUuid": "4d90030a_4248742a",
      "range": {
        "startLine": 1900,
        "startChar": 15,
        "endLine": 1900,
        "endChar": 31
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_fd502024",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1900,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-11-29T21:49:54Z",
      "side": 1,
      "message": "HasUses() is too conservative since it includes env uses. Say there is another call after the user, it treats the reference as escaping. Env use only by Deopt should make it escaping. But I\u0027m really worried about correctness as I said previously due to Deopt being added after the allocation removal since there is simplifying happening before bce.\n\nMoving out escape analysis actually introduces the danger already (just realized today) which didn\u0027t exist before since previously it\u0027s used only by LSE which is done after all HDeoptimize instructions are in place. So in a sense IsNonEscapingSingleton() isn\u0027t accurate before the BCE pass. If we do any form of allocation removal before adding some HDeoptimize instructions, bugs may happen.\n\nOne solution is a conservative boolean for IsNonEscapingSingleton() that distinguishes whether all env uses or only Deopt env uses should make the singleton espcaping. We can be aggressive only after BCE which is the final pass that can introduce Deopt.",
      "parentUuid": "ade97f6b_a2495333",
      "range": {
        "startLine": 1900,
        "startChar": 15,
        "endLine": 1900,
        "endChar": 31
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_dd1afc30",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1900,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-29T22:23:43Z",
      "side": 1,
      "message": "Talked a bit offline with Mingyao about his concerns. The boolean addition to the API would solve his concerns but also render this optimization useless since it will always fail on some env use.\n\nSo the only solution is to make this simplification aware of where it runs (before or after bce). Mingyao said he needs similar tests also at one point.\n\nBoth of us also voiced concern that we should document such dependences someplace. Also, bisection search will become a bit fragile, since phases are now suddenly aware of where they run.....",
      "parentUuid": "ade97f6b_fd502024",
      "range": {
        "startLine": 1900,
        "startChar": 15,
        "endLine": 1900,
        "endChar": 31
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_f886eea4",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1900,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-29T23:13:12Z",
      "side": 1,
      "message": "Talked a bit more and this approach is actually safe, since I don\u0027t remove the new on the reference for which we apply escape analysis, but the new which uses the reference, but has no other uses either. I just used the escape analysis to prove that the synchronization is thread local.\n\nMingyou and I agreed that this is actually due to the naming (we have singleton, no return , and no escape to deopt), where the last two names are clumped together. A better naming scheme, and separation of the last two will make this more clear.\n\nComing up....",
      "parentUuid": "ade97f6b_dd1afc30",
      "range": {
        "startLine": 1900,
        "startChar": 15,
        "endLine": 1900,
        "endChar": 31
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_023a6c87",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1916,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-11-29T20:45:30Z",
      "side": 1,
      "message": "Maybe add the synchronized information in the intrinsics_list.h?",
      "range": {
        "startLine": 1916,
        "startChar": 3,
        "endLine": 1916,
        "endChar": 87
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_023a3f87",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 4
      },
      "lineNbr": 1916,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-29T20:51:00Z",
      "side": 1,
      "message": "you are reading my mind. I want to propose a more general attribute list in intrinsics_list.h. seems a bit too much to do that in this cl, but I can file a bug on this, where we can also brainstorm on what other attributes we want (and make sure it can be more easily extended than right now)",
      "parentUuid": "4d90030a_023a6c87",
      "range": {
        "startLine": 1916,
        "startChar": 3,
        "endLine": 1916,
        "endChar": 87
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_a23620a2",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 4
      },
      "lineNbr": 4197,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-11-29T20:45:30Z",
      "side": 1,
      "message": "Ditto about moving this to intrinsics_list.h?",
      "range": {
        "startLine": 4186,
        "startChar": 0,
        "endLine": 4197,
        "endChar": 3
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_e2363ba3",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 4
      },
      "lineNbr": 4197,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-29T20:51:00Z",
      "side": 1,
      "message": "see above",
      "parentUuid": "4d90030a_a23620a2",
      "range": {
        "startLine": 4186,
        "startChar": 0,
        "endLine": 4197,
        "endChar": 3
      },
      "revId": "ced3fcbd7110fd96328aa9cfcc0d24fb99758f55",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}