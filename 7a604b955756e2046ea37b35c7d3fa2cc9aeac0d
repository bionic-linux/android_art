{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "828ca520_09f32657",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2023-12-21T12:21:41Z",
      "side": 1,
      "message": "It\u0027s a pity the compiler doesn\u0027t figure out that the type [actually is](https://cs.android.com/android/platform/superproject/main/+/main:art/libartbase/base/enums.h;l\u003d25;drc\u003ded4898e280912b1014ded043138ef5d41613a5f8) a `size_t`.",
      "range": {
        "startLine": 9,
        "startChar": 99,
        "endLine": 9,
        "endChar": 138
      },
      "revId": "7a604b955756e2046ea37b35c7d3fa2cc9aeac0d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e5ffdd84_24887391",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2023-12-21T12:21:41Z",
      "side": 1,
      "message": "+scianciulli apropos compiler warnings.",
      "revId": "7a604b955756e2046ea37b35c7d3fa2cc9aeac0d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "210fb9fc_be0c7f97",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1972025
      },
      "writtenOn": "2023-12-21T12:42:20Z",
      "side": 1,
      "message": "\n/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"common_compiler_test.h\"\n#include \"arch/instruction_set_features.h\"\n#include \"art_field-inl.h\"\n#include \"art_method.h\"\n#include \"class_linker.h\"\n#include \"compiled_method.h\"\n#include \"dex/quick_compiler_callbacks.h\"\n#include \"dex/quick/dex_file_to_method_inliner_map.h\"\n#include \"dex/verification_results.h\"\n#include \"driver/compiler_driver.h\"\n#include \"driver/compiler_options.h\"\n#include \"interpreter/interpreter.h\"\n#include \"mirror/class_loader.h\"\n#include \"mirror/class-inl.h\"\n#include \"mirror/dex_cache.h\"\n#include \"mirror/object-inl.h\"\n#include \"oat_quick_method_header.h\"\n#include \"scoped_thread_state_change.h\"\n#include \"thread-inl.h\"\n#include \"utils.h\"\nnamespace art {\nCommonCompilerTest::CommonCompilerTest() {}\nCommonCompilerTest::~CommonCompilerTest() {}\nvoid CommonCompilerTest::MakeExecutable(ArtMethod* method) {\n  CHECK(method !\u003d nullptr);\n  const CompiledMethod* compiled_method \u003d nullptr;\n  if (!method-\u003eIsAbstract()) {\n    mirror::DexCache* dex_cache \u003d method-\u003eGetDeclaringClass()-\u003eGetDexCache();\n    const DexFile\u0026 dex_file \u003d *dex_cache-\u003eGetDexFile();\n    compiled_method \u003d\n        compiler_driver_-\u003eGetCompiledMethod(MethodReference(\u0026dex_file,\n                                                            method-\u003eGetDexMethodIndex()));\n  }\n  if (compiled_method !\u003d nullptr) {\n    ArrayRef\u003cconst uint8_t\u003e code \u003d compiled_method-\u003eGetQuickCode();\n    uint32_t code_size \u003d code.size();\n    CHECK_NE(0u, code_size);\n    ArrayRef\u003cconst uint8_t\u003e vmap_table \u003d compiled_method-\u003eGetVmapTable();\n    uint32_t vmap_table_offset \u003d vmap_table.empty() ? 0u\n        : sizeof(OatQuickMethodHeader) + vmap_table.size();\n    OatQuickMethodHeader method_header(vmap_table_offset,\n                                       compiled_method-\u003eGetFrameSizeInBytes(),\n                                       compiled_method-\u003eGetCoreSpillMask(),\n                                       compiled_method-\u003eGetFpSpillMask(),\n                                       code_size);\n    header_code_and_maps_chunks_.push_back(std::vector\u003cuint8_t\u003e());\n    std::vector\u003cuint8_t\u003e* chunk \u003d \u0026header_code_and_maps_chunks_.back();\n    const size_t max_padding \u003d GetInstructionSetAlignment(compiled_method-\u003eGetInstructionSet());\n    const size_t size \u003d vmap_table.size() + sizeof(method_header) + code_size;\n    chunk-\u003ereserve(size + max_padding);\n    chunk-\u003eresize(sizeof(method_header));\n    memcpy(\u0026(*chunk)[0], \u0026method_header, sizeof(method_header));\n    chunk-\u003einsert(chunk-\u003ebegin(), vmap_table.begin(), vmap_table.end());\n    chunk-\u003einsert(chunk-\u003eend(), code.begin(), code.end());\n    CHECK_EQ(chunk-\u003esize(), size);\n    const void* unaligned_code_ptr \u003d chunk-\u003edata() + (size - code_size);\n    size_t offset \u003d dchecked_integral_cast\u003csize_t\u003e(reinterpret_cast\u003cuintptr_t\u003e(unaligned_code_ptr));\n    size_t padding \u003d compiled_method-\u003eAlignCode(offset) - offset;\n    // Make sure no resizing takes place.\n    CHECK_GE(chunk-\u003ecapacity(), chunk-\u003esize() + padding);\n    chunk-\u003einsert(chunk-\u003ebegin(), padding, 0);\n    const void* code_ptr \u003d reinterpret_cast\u003cconst uint8_t*\u003e(unaligned_code_ptr) + padding;\n    CHECK_EQ(code_ptr, static_cast\u003cconst void*\u003e(chunk-\u003edata() + (chunk-\u003esize() - code_size)));\n    MakeExecutable(code_ptr, code.size());\n    const void* method_code \u003d CompiledMethod::CodePointer(code_ptr,\n                                                          compiled_method-\u003eGetInstructionSet());\n    LOG(INFO) \u003c\u003c \"MakeExecutable \" \u003c\u003c PrettyMethod(method) \u003c\u003c \" code\u003d\" \u003c\u003c method_code;\n    class_linker_-\u003eSetEntryPointsToCompiledCode(method, method_code);\n  } else {\n    // No code? You must mean to go into the interpreter.\n    // Or the generic JNI...\n    class_linker_-\u003eSetEntryPointsToInterpreter(method);\n  }\n}\nvoid CommonCompilerTest::MakeExecutable(const void* code_start, size_t code_length) {\n  CHECK(code_start !\u003d nullptr);\n  CHECK_NE(code_length, 0U);\n  uintptr_t data \u003d reinterpret_cast\u003cuintptr_t\u003e(code_start);\n  uintptr_t base \u003d RoundDown(data, kPageSize);\n  uintptr_t limit \u003d RoundUp(data + code_length, kPageSize);\n  uintptr_t len \u003d limit - base;\n  int result \u003d mprotect(reinterpret_cast\u003cvoid*\u003e(base), len, PROT_READ | PROT_WRITE | PROT_EXEC);\n  CHECK_EQ(result, 0);\n  FlushInstructionCache(reinterpret_cast\u003cchar*\u003e(base), reinterpret_cast\u003cchar*\u003e(base + len));\n}\nvoid CommonCompilerTest::MakeExecutable(mirror::ClassLoader* class_loader, const char* class_name) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  StackHandleScope\u003c1\u003e hs(self);\n  Handle\u003cmirror::ClassLoader\u003e loader(hs.NewHandle(class_loader));\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  size_t pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  for (auto\u0026 m : klass-\u003eGetMethods(pointer_size)) {\n    MakeExecutable(\u0026m);\n  }\n}\n// Get the set of image classes given to the compiler-driver in SetUp. Note: the compiler\n// driver assumes ownership of the set, so the test should properly release the set.\nstd::unordered_set\u003cstd::string\u003e* CommonCompilerTest::GetImageClasses() {\n  // Empty set: by default no classes are retained in the image.\n  return new std::unordered_set\u003cstd::string\u003e();\n}\n// Get the set of compiled classes given to the compiler-driver in SetUp. Note: the compiler\n// driver assumes ownership of the set, so the test should properly release the set.\nstd::unordered_set\u003cstd::string\u003e* CommonCompilerTest::GetCompiledClasses() {\n  // Null, no selection of compiled-classes.\n  return nullptr;\n}\n// Get the set of compiled methods given to the compiler-driver in SetUp. Note: the compiler\n// driver assumes ownership of the set, so the test should properly release the set.\nstd::unordered_set\u003cstd::string\u003e* CommonCompilerTest::GetCompiledMethods() {\n  // Null, no selection of compiled-methods.\n  return nullptr;\n}\n// Get ProfileCompilationInfo that should be passed to the driver.\nProfileCompilationInfo* CommonCompilerTest::GetProfileCompilationInfo() {\n  // Null, profile information will not be taken into account.\n  return nullptr;\n}\nvoid CommonCompilerTest::SetUp() {\n  CommonRuntimeTest::SetUp();\n  {\n    ScopedObjectAccess soa(Thread::Current());\n    const InstructionSet instruction_set \u003d kRuntimeISA;\n    // Take the default set of instruction features from the build.\n    instruction_set_features_.reset(InstructionSetFeatures::FromCppDefines());\n    runtime_-\u003eSetInstructionSet(instruction_set);\n    for (int i \u003d 0; i \u003c Runtime::kLastCalleeSaveType; i++) {\n      Runtime::CalleeSaveType type \u003d Runtime::CalleeSaveType(i);\n      if (!runtime_-\u003eHasCalleeSaveMethod(type)) {\n        runtime_-\u003eSetCalleeSaveMethod(runtime_-\u003eCreateCalleeSaveMethod(), type);\n      }\n    }\n    timer_.reset(new CumulativeLogger(\"Compilation times\"));\n    CreateCompilerDriver(compiler_kind_, instruction_set);\n  }\n}\nvoid CommonCompilerTest::CreateCompilerDriver(Compiler::Kind kind,\n                                              InstructionSet isa,\n                                              size_t number_of_threads) {\n  compiler_driver_.reset(new CompilerDriver(compiler_options_.get(),\n                                            verification_results_.get(),\n                                            method_inliner_map_.get(),\n                                            kind,\n                                            isa,\n                                            instruction_set_features_.get(),\n                                            /* boot_image */ true,\n                                            /* app_image */ false,\n                                            GetImageClasses(),\n                                            GetCompiledClasses(),\n                                            GetCompiledMethods(),\n                                            number_of_threads,\n                                            /* dump_stats */ true,\n                                            /* dump_passes */ true,\n                                            timer_.get(),\n                                            /* swap_fd */ -1,\n                                            GetProfileCompilationInfo()));\n  // We typically don\u0027t generate an image in unit tests, disable this optimization by default.\n  compiler_driver_-\u003eSetSupportBootImageFixup(false);\n}\nvoid CommonCompilerTest::SetUpRuntimeOptions(RuntimeOptions* options) {\n  CommonRuntimeTest::SetUpRuntimeOptions(options);\n  compiler_options_.reset(new CompilerOptions);\n  verification_results_.reset(new VerificationResults(compiler_options_.get()));\n  method_inliner_map_.reset(new DexFileToMethodInlinerMap);\n  callbacks_.reset(new QuickCompilerCallbacks(verification_results_.get(),\n                                              method_inliner_map_.get(),\n                                              CompilerCallbacks::CallbackMode::kCompileApp));\n}\nCompiler::Kind CommonCompilerTest::GetCompilerKind() const {\n  return compiler_kind_;\n}\nvoid CommonCompilerTest::SetCompilerKind(Compiler::Kind compiler_kind) {\n  compiler_kind_ \u003d compiler_kind;\n}\nInstructionSet CommonCompilerTest::GetInstructionSet() const {\n  DCHECK(compiler_driver_.get() !\u003d nullptr);\n  return compiler_driver_-\u003eGetInstructionSet();\n}\nvoid CommonCompilerTest::TearDown() {\n  timer_.reset();\n  compiler_driver_.reset();\n  callbacks_.reset();\n  method_inliner_map_.reset();\n  verification_results_.reset();\n  compiler_options_.reset();\n  CommonRuntimeTest::TearDown();\n}\nvoid CommonCompilerTest::CompileClass(mirror::ClassLoader* class_loader, const char* class_name) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  StackHandleScope\u003c1\u003e hs(self);\n  Handle\u003cmirror::ClassLoader\u003e loader(hs.NewHandle(class_loader));\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  auto pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  for (auto\u0026 m : klass-\u003eGetMethods(pointer_size)) {\n    CompileMethod(\u0026m);\n  }\n}\nvoid CommonCompilerTest::CompileMethod(ArtMethod* method) {\n  CHECK(method !\u003d nullptr);\n  TimingLogger timings(\"CommonTest::CompileMethod\", false, false);\n  TimingLogger::ScopedTiming t(__FUNCTION__, \u0026timings);\n  compiler_driver_-\u003eCompileOne(Thread::Current(), method, \u0026timings);\n  TimingLogger::ScopedTiming t2(\"MakeExecutable\", \u0026timings);\n  MakeExecutable(method);\n}\nvoid CommonCompilerTest::CompileDirectMethod(Handle\u003cmirror::ClassLoader\u003e class_loader,\n                                             const char* class_name, const char* method_name,\n                                             const char* signature) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), class_loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  auto pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  ArtMethod* method \u003d klass-\u003eFindDirectMethod(method_name, signature, pointer_size);\n  CHECK(method !\u003d nullptr) \u003c\u003c \"Direct method not found: \"\n      \u003c\u003c class_name \u003c\u003c \".\" \u003c\u003c method_name \u003c\u003c signature;\n  CompileMethod(method);\n}\nvoid CommonCompilerTest::CompileVirtualMethod(Handle\u003cmirror::ClassLoader\u003e class_loader,\n                                              const char* class_name, const char* method_name,\n                                              const char* signature) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), class_loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  auto pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  ArtMethod* method \u003d klass-\u003eFindVirtualMethod(method_name, signature, pointer_size);\n  CHECK(method !\u003d nullptr) \u003c\u003c \"Virtual method not found: \"\n      \u003c\u003c class_name \u003c\u003c \".\" \u003c\u003c method_name \u003c\u003c signature;\n  CompileMethod(method);\n}\nvoid CommonCompilerTest::ReserveImageSpace() {\n  // Reserve where the image will be loaded up front so that other parts of test set up don\u0027t\n  // accidentally end up colliding with the fixed memory address when we need to load the image.\n  std::string error_msg;\n  MemMap::Init();\n  image_reservation_.reset(MemMap::MapAnonymous(\"image reservation\",\n                                                reinterpret_cast\u003cuint8_t*\u003e(ART_BASE_ADDRESS),\n                                                (size_t)120 * 1024 * 1024,  // 120MB\n                                                PROT_NONE,\n                                                false /* no need for 4gb flag with fixed mmap*/,\n                                                false /* not reusing existing reservation */,\n                                                \u0026error_msg));\n  CHECK(image_reservation_.get() !\u003d nullptr) \u003c\u003c error_msg;\n}\nvoid CommonCompilerTest::UnreserveImageSpace() {\n  image_reservation_.reset();\n}\n}  // namespace art",
      "revId": "7a604b955756e2046ea37b35c7d3fa2cc9aeac0d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "faf54700_452eb9a6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1972025
      },
      "writtenOn": "2023-12-21T12:43:29Z",
      "side": 1,
      "message": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"common_compiler_test.h\"\n#include \"arch/instruction_set_features.h\"\n#include \"art_field-inl.h\"\n#include \"art_method.h\"\n#include \"class_linker.h\"\n#include \"compiled_method.h\"\n#include \"dex/quick_compiler_callbacks.h\"\n#include \"dex/quick/dex_file_to_method_inliner_map.h\"\n#include \"dex/verification_results.h\"\n#include \"driver/compiler_driver.h\"\n#include \"driver/compiler_options.h\"\n#include \"interpreter/interpreter.h\"\n#include \"mirror/class_loader.h\"\n#include \"mirror/class-inl.h\"\n#include \"mirror/dex_cache.h\"\n#include \"mirror/object-inl.h\"\n#include \"oat_quick_method_header.h\"\n#include \"scoped_thread_state_change.h\"\n#include \"thread-inl.h\"\n#include \"utils.h\"\nnamespace art {\nCommonCompilerTest::CommonCompilerTest() {}\nCommonCompilerTest::~CommonCompilerTest() {}\nvoid CommonCompilerTest::MakeExecutable(ArtMethod* method) {\n  CHECK(method !\u003d nullptr);\n  const CompiledMethod* compiled_method \u003d nullptr;\n  if (!method-\u003eIsAbstract()) {\n    mirror::DexCache* dex_cache \u003d method-\u003eGetDeclaringClass()-\u003eGetDexCache();\n    const DexFile\u0026 dex_file \u003d *dex_cache-\u003eGetDexFile();\n    compiled_method \u003d\n        compiler_driver_-\u003eGetCompiledMethod(MethodReference(\u0026dex_file,\n                                                            method-\u003eGetDexMethodIndex()));\n  }\n  if (compiled_method !\u003d nullptr) {\n    ArrayRef\u003cconst uint8_t\u003e code \u003d compiled_method-\u003eGetQuickCode();\n    uint32_t code_size \u003d code.size();\n    CHECK_NE(0u, code_size);\n    ArrayRef\u003cconst uint8_t\u003e vmap_table \u003d compiled_method-\u003eGetVmapTable();\n    uint32_t vmap_table_offset \u003d vmap_table.empty() ? 0u\n        : sizeof(OatQuickMethodHeader) + vmap_table.size();\n    OatQuickMethodHeader method_header(vmap_table_offset,\n                                       compiled_method-\u003eGetFrameSizeInBytes(),\n                                       compiled_method-\u003eGetCoreSpillMask(),\n                                       compiled_method-\u003eGetFpSpillMask(),\n                                       code_size);\n    header_code_and_maps_chunks_.push_back(std::vector\u003cuint8_t\u003e());\n    std::vector\u003cuint8_t\u003e* chunk \u003d \u0026header_code_and_maps_chunks_.back();\n    const size_t max_padding \u003d GetInstructionSetAlignment(compiled_method-\u003eGetInstructionSet());\n    const size_t size \u003d vmap_table.size() + sizeof(method_header) + code_size;\n    chunk-\u003ereserve(size + max_padding);\n    chunk-\u003eresize(sizeof(method_header));\n    memcpy(\u0026(*chunk)[0], \u0026method_header, sizeof(method_header));\n    chunk-\u003einsert(chunk-\u003ebegin(), vmap_table.begin(), vmap_table.end());\n    chunk-\u003einsert(chunk-\u003eend(), code.begin(), code.end());\n    CHECK_EQ(chunk-\u003esize(), size);\n    const void* unaligned_code_ptr \u003d chunk-\u003edata() + (size - code_size);\n    size_t offset \u003d dchecked_integral_cast\u003csize_t\u003e(reinterpret_cast\u003cuintptr_t\u003e(unaligned_code_ptr));\n    size_t padding \u003d compiled_method-\u003eAlignCode(offset) - offset;\n    // Make sure no resizing takes place.\n    CHECK_GE(chunk-\u003ecapacity(), chunk-\u003esize() + padding);\n    chunk-\u003einsert(chunk-\u003ebegin(), padding, 0);\n    const void* code_ptr \u003d reinterpret_cast\u003cconst uint8_t*\u003e(unaligned_code_ptr) + padding;\n    CHECK_EQ(code_ptr, static_cast\u003cconst void*\u003e(chunk-\u003edata() + (chunk-\u003esize() - code_size)));\n    MakeExecutable(code_ptr, code.size());\n    const void* method_code \u003d CompiledMethod::CodePointer(code_ptr,\n                                                          compiled_method-\u003eGetInstructionSet());\n    LOG(INFO) \u003c\u003c \"MakeExecutable \" \u003c\u003c PrettyMethod(method) \u003c\u003c \" code\u003d\" \u003c\u003c method_code;\n    class_linker_-\u003eSetEntryPointsToCompiledCode(method, method_code);\n  } else {\n    // No code? You must mean to go into the interpreter.\n    // Or the generic JNI...\n    class_linker_-\u003eSetEntryPointsToInterpreter(method);\n  }\n}\nvoid CommonCompilerTest::MakeExecutable(const void* code_start, size_t code_length) {\n  CHECK(code_start !\u003d nullptr);\n  CHECK_NE(code_length, 0U);\n  uintptr_t data \u003d reinterpret_cast\u003cuintptr_t\u003e(code_start);\n  uintptr_t base \u003d RoundDown(data, kPageSize);\n  uintptr_t limit \u003d RoundUp(data + code_length, kPageSize);\n  uintptr_t len \u003d limit - base;\n  int result \u003d mprotect(reinterpret_cast\u003cvoid*\u003e(base), len, PROT_READ | PROT_WRITE | PROT_EXEC);\n  CHECK_EQ(result, 0);\n  FlushInstructionCache(reinterpret_cast\u003cchar*\u003e(base), reinterpret_cast\u003cchar*\u003e(base + len));\n}\nvoid CommonCompilerTest::MakeExecutable(mirror::ClassLoader* class_loader, const char* class_name) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  StackHandleScope\u003c1\u003e hs(self);\n  Handle\u003cmirror::ClassLoader\u003e loader(hs.NewHandle(class_loader));\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  size_t pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  for (auto\u0026 m : klass-\u003eGetMethods(pointer_size)) {\n    MakeExecutable(\u0026m);\n  }\n}\n// Get the set of image classes given to the compiler-driver in SetUp. Note: the compiler\n// driver assumes ownership of the set, so the test should properly release the set.\nstd::unordered_set\u003cstd::string\u003e* CommonCompilerTest::GetImageClasses() {\n  // Empty set: by default no classes are retained in the image.\n  return new std::unordered_set\u003cstd::string\u003e();\n}\n// Get the set of compiled classes given to the compiler-driver in SetUp. Note: the compiler\n// driver assumes ownership of the set, so the test should properly release the set.\nstd::unordered_set\u003cstd::string\u003e* CommonCompilerTest::GetCompiledClasses() {\n  // Null, no selection of compiled-classes.\n  return nullptr;\n}\n// Get the set of compiled methods given to the compiler-driver in SetUp. Note: the compiler\n// driver assumes ownership of the set, so the test should properly release the set.\nstd::unordered_set\u003cstd::string\u003e* CommonCompilerTest::GetCompiledMethods() {\n  // Null, no selection of compiled-methods.\n  return nullptr;\n}\n// Get ProfileCompilationInfo that should be passed to the driver.\nProfileCompilationInfo* CommonCompilerTest::GetProfileCompilationInfo() {\n  // Null, profile information will not be taken into account.\n  return nullptr;\n}\nvoid CommonCompilerTest::SetUp() {\n  CommonRuntimeTest::SetUp();\n  {\n    ScopedObjectAccess soa(Thread::Current());\n    const InstructionSet instruction_set \u003d kRuntimeISA;\n    // Take the default set of instruction features from the build.\n    instruction_set_features_.reset(InstructionSetFeatures::FromCppDefines());\n    runtime_-\u003eSetInstructionSet(instruction_set);\n    for (int i \u003d 0; i \u003c Runtime::kLastCalleeSaveType; i++) {\n      Runtime::CalleeSaveType type \u003d Runtime::CalleeSaveType(i);\n      if (!runtime_-\u003eHasCalleeSaveMethod(type)) {\n        runtime_-\u003eSetCalleeSaveMethod(runtime_-\u003eCreateCalleeSaveMethod(), type);\n      }\n    }\n    timer_.reset(new CumulativeLogger(\"Compilation times\"));\n    CreateCompilerDriver(compiler_kind_, instruction_set);\n  }\n}\nvoid CommonCompilerTest::CreateCompilerDriver(Compiler::Kind kind,\n                                              InstructionSet isa,\n                                              size_t number_of_threads) {\n  compiler_driver_.reset(new CompilerDriver(compiler_options_.get(),\n                                            verification_results_.get(),\n                                            method_inliner_map_.get(),\n                                            kind,\n                                            isa,\n                                            instruction_set_features_.get(),\n                                            /* boot_image */ true,\n                                            /* app_image */ false,\n                                            GetImageClasses(),\n                                            GetCompiledClasses(),\n                                            GetCompiledMethods(),\n                                            number_of_threads,\n                                            /* dump_stats */ true,\n                                            /* dump_passes */ true,\n                                            timer_.get(),\n                                            /* swap_fd */ -1,\n                                            GetProfileCompilationInfo()));\n  // We typically don\u0027t generate an image in unit tests, disable this optimization by default.\n  compiler_driver_-\u003eSetSupportBootImageFixup(false);\n}\nvoid CommonCompilerTest::SetUpRuntimeOptions(RuntimeOptions* options) {\n  CommonRuntimeTest::SetUpRuntimeOptions(options);\n  compiler_options_.reset(new CompilerOptions);\n  verification_results_.reset(new VerificationResults(compiler_options_.get()));\n  method_inliner_map_.reset(new DexFileToMethodInlinerMap);\n  callbacks_.reset(new QuickCompilerCallbacks(verification_results_.get(),\n                                              method_inliner_map_.get(),\n                                              CompilerCallbacks::CallbackMode::kCompileApp));\n}\nCompiler::Kind CommonCompilerTest::GetCompilerKind() const {\n  return compiler_kind_;\n}\nvoid CommonCompilerTest::SetCompilerKind(Compiler::Kind compiler_kind) {\n  compiler_kind_ \u003d compiler_kind;\n}\nInstructionSet CommonCompilerTest::GetInstructionSet() const {\n  DCHECK(compiler_driver_.get() !\u003d nullptr);\n  return compiler_driver_-\u003eGetInstructionSet();\n}\nvoid CommonCompilerTest::TearDown() {\n  timer_.reset();\n  compiler_driver_.reset();\n  callbacks_.reset();\n  method_inliner_map_.reset();\n  verification_results_.reset();\n  compiler_options_.reset();\n  CommonRuntimeTest::TearDown();\n}\nvoid CommonCompilerTest::CompileClass(mirror::ClassLoader* class_loader, const char* class_name) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  StackHandleScope\u003c1\u003e hs(self);\n  Handle\u003cmirror::ClassLoader\u003e loader(hs.NewHandle(class_loader));\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  auto pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  for (auto\u0026 m : klass-\u003eGetMethods(pointer_size)) {\n    CompileMethod(\u0026m);\n  }\n}\nvoid CommonCompilerTest::CompileMethod(ArtMethod* method) {\n  CHECK(method !\u003d nullptr);\n  TimingLogger timings(\"CommonTest::CompileMethod\", false, false);\n  TimingLogger::ScopedTiming t(__FUNCTION__, \u0026timings);\n  compiler_driver_-\u003eCompileOne(Thread::Current(), method, \u0026timings);\n  TimingLogger::ScopedTiming t2(\"MakeExecutable\", \u0026timings);\n  MakeExecutable(method);\n}\nvoid CommonCompilerTest::CompileDirectMethod(Handle\u003cmirror::ClassLoader\u003e class_loader,\n                                             const char* class_name, const char* method_name,\n                                             const char* signature) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), class_loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  auto pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  ArtMethod* method \u003d klass-\u003eFindDirectMethod(method_name, signature, pointer_size);\n  CHECK(method !\u003d nullptr) \u003c\u003c \"Direct method not found: \"\n      \u003c\u003c class_name \u003c\u003c \".\" \u003c\u003c method_name \u003c\u003c signature;\n  CompileMethod(method);\n}\nvoid CommonCompilerTest::CompileVirtualMethod(Handle\u003cmirror::ClassLoader\u003e class_loader,\n                                              const char* class_name, const char* method_name,\n                                              const char* signature) {\n  std::string class_descriptor(DotToDescriptor(class_name));\n  Thread* self \u003d Thread::Current();\n  mirror::Class* klass \u003d class_linker_-\u003eFindClass(self, class_descriptor.c_str(), class_loader);\n  CHECK(klass !\u003d nullptr) \u003c\u003c \"Class not found \" \u003c\u003c class_name;\n  auto pointer_size \u003d class_linker_-\u003eGetImagePointerSize();\n  ArtMethod* method \u003d klass-\u003eFindVirtualMethod(method_name, signature, pointer_size);\n  CHECK(method !\u003d nullptr) \u003c\u003c \"Virtual method not found: \"\n      \u003c\u003c class_name \u003c\u003c \".\" \u003c\u003c method_name \u003c\u003c signature;\n  CompileMethod(method);\n}\nvoid CommonCompilerTest::ReserveImageSpace() {\n  // Reserve where the image will be loaded up front so that other parts of test set up don\u0027t\n  // accidentally end up colliding with the fixed memory address when we need to load the image.\n  std::string error_msg;\n  MemMap::Init();\n  image_reservation_.reset(MemMap::MapAnonymous(\"image reservation\",\n                                                reinterpret_cast\u003cuint8_t*\u003e(ART_BASE_ADDRESS),\n                                                (size_t)120 * 1024 * 1024,  // 120MB\n                                                PROT_NONE,\n                                                false /* no need for 4gb flag with fixed mmap*/,\n                                                false /* not reusing existing reservation */,\n                                                \u0026error_msg));\n  CHECK(image_reservation_.get() !\u003d nullptr) \u003c\u003c error_msg;\n}\nvoid CommonCompilerTest::UnreserveImageSpace() {\n  image_reservation_.reset();\n}\n}  // namespace art",
      "revId": "7a604b955756e2046ea37b35c7d3fa2cc9aeac0d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}