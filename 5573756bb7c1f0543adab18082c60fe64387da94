{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fee64e99_e6f930ae",
        "filename": "dex2oat/driver/compiler_driver.cc",
        "patchSetId": 17
      },
      "lineNbr": 490,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-01-11T09:27:02Z",
      "side": 1,
      "message": "Style: One argument per line.",
      "range": {
        "startLine": 490,
        "startChar": 49,
        "endLine": 490,
        "endChar": 95
      },
      "revId": "5573756bb7c1f0543adab18082c60fe64387da94",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a066d29_8692faec",
        "filename": "dex2oat/driver/compiler_driver.cc",
        "patchSetId": 17
      },
      "lineNbr": 492,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-01-11T09:27:02Z",
      "side": 1,
      "message": "It should be documented in `NeverCompile.java` that this does not apply to native methods (JNI stubs shall be compiled) or overriding methods (and it is therefore useless on abstract methods).",
      "range": {
        "startLine": 492,
        "startChar": 34,
        "endLine": 492,
        "endChar": 47
      },
      "revId": "5573756bb7c1f0543adab18082c60fe64387da94",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62dedc79_69dc8f73",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 17
      },
      "lineNbr": 3676,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-01-11T09:27:02Z",
      "side": 1,
      "message": "Should this be\n\n  } else if ((access_flags \u0026 kAccAbstract) \u003d\u003d 0u \u0026\u0026\n\nto align with the compiler driver?",
      "range": {
        "startLine": 3675,
        "startChar": 2,
        "endLine": 3676,
        "endChar": 4
      },
      "revId": "5573756bb7c1f0543adab18082c60fe64387da94",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9de5b031_46da79d4",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 17
      },
      "lineNbr": 3677,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-01-11T09:27:02Z",
      "side": 1,
      "message": "Is it deliberate that JIT does not respect this annotation?",
      "range": {
        "startLine": 3677,
        "startChar": 4,
        "endLine": 3677,
        "endChar": 42
      },
      "revId": "5573756bb7c1f0543adab18082c60fe64387da94",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "670ea944_8b35b36f",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 17
      },
      "lineNbr": 3677,
      "author": {
        "id": 1064003
      },
      "writtenOn": "2022-01-11T21:22:27Z",
      "side": 1,
      "message": "That\u0027s a good question, what are your thoughts? I think we get a lot of the initial benefit from suppressing AOT for methods that are unlikely to be bottlenecks/hot (particularly for system_server which is AOT\u0027ed on many devices). I could see an argument for suppressing JIT as well, but I wonder if it\u0027s better to let the JIT logic decide whether or not to compile? In either case, we should probably be clear about the semantics in the documentation.\n\n@ngeoffray any thoughts?",
      "parentUuid": "9de5b031_46da79d4",
      "range": {
        "startLine": 3677,
        "startChar": 4,
        "endLine": 3677,
        "endChar": 42
      },
      "revId": "5573756bb7c1f0543adab18082c60fe64387da94",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}