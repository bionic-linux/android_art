{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0ceb7e21_f6283160",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-20T16:50:24Z",
      "side": 1,
      "message": "Thanks Roland for forwarding this CL. Please include me as reviewer for future CLs that involve build changes like this.",
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79533b94_978d22e4",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 179,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-20T16:50:24Z",
      "side": 1,
      "message": "The customary extension is `.map.txt` for these files. Should it be different here?",
      "range": {
        "startLine": 179,
        "startChar": 36,
        "endLine": 179,
        "endChar": 40
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddb4bdef_d51ab355",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 232,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-20T16:50:24Z",
      "side": 1,
      "message": "The purpose of this being a `whole_static_libs` is that it exports all its symbols to libs that depend on libart-compiler. With the version script that becomes pointless unless those symbols are exported there.\n\nCan this dependency be removed here altogether? If not, isn\u0027t it better to export those symbols to avoid linking it repeatedly? It doesn\u0027t appear to be that many symbols in this library.",
      "range": {
        "startLine": 232,
        "startChar": 4,
        "endLine": 232,
        "endChar": 38
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03f6b6ab_08456da4",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-20T16:50:24Z",
      "side": 1,
      "message": "+rpl This means we won\u0027t test the code actually in the APEX module. If everything is working correctly the test comes from the same build as the module, so it doesn\u0027t matter. However in practice we\u0027ve seen problems in that area, and with tests that basically test themselves rather than the module that can make us blind to regressions.\n\nHow many extra symbols would be required to avoid this? (Not just in this gtest, but all of them.)\n\nIf we are to go this way with statically linked libraries, we need to ensure that the tests correspond to the module. One way to do that could be to add a test that compares the build id between the test and the module. It\u0027s not obvious how we\u0027d construct that build id to make it work correctly though (the ART module version is too coarse, and the platform build id won\u0027t work for unbundled modules).\n\nAnother problem is ODR violations: There\u0027s plenty of global state in this library, and the test could potentially end up with multiple copies of that if it has this static copy in addition to the .so file being loaded indirectly through other libraries. Apparently the tests don\u0027t break atm, but it\u0027s brittle, so this would need a safeguard of some sort.",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d64b67ee_166acdb3",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2022-09-20T17:24:28Z",
      "side": 1,
      "message": "Yeah, I was planning on following up with you / Dmitrii / Roland on this. On the statically linking we know the situation is brittle anyway as any symbol change can break the tests if we run MTS and ART versions that don\u0027t match. And the solution to that is to make sure that MTS and ART versions always match, which statically linking also achieves.",
      "parentUuid": "03f6b6ab_08456da4",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6546265b_abe9f64e",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2022-09-20T17:25:32Z",
      "side": 1,
      "message": "(we know the situation is brittle -\u003e we know the previous situation when we don\u0027t statically link is brittle)",
      "parentUuid": "d64b67ee_166acdb3",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "84237af5_d21c15bf",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-09-20T17:39:30Z",
      "side": 1,
      "message": "I keep wondering if we should just always statically link, and avoid the libart-compiler.so altogether.",
      "parentUuid": "6546265b_abe9f64e",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc2fc5c9_61712b43",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-20T20:40:12Z",
      "side": 1,
      "message": "\u003e And the solution to that is to make sure that MTS and ART versions always match, which statically linking also achieves.\n\nYes, but it makes us blind, which is much worse than being brittle.\n\n\u003e I keep wondering if we should just always statically link, and avoid the libart-compiler.so altogether.\n\nAgreed, we ought to link more statically to reduce the number of DSO\u0027s in the module. That\u0027s a separate issue though.",
      "parentUuid": "84237af5_d21c15bf",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf753892_72a7edd9",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2022-09-21T08:36:40Z",
      "side": 1,
      "message": "What does `blind` mean here?",
      "parentUuid": "fc2fc5c9_61712b43",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67308c6d_67fa2bfe",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-21T10:08:27Z",
      "side": 1,
      "message": "As I mentioned earlier, if module and tests are out of sync, then the module may be broken but the tests still pass. That\u0027s being blind.\n\nSo I think the way to go here is to add a test that checks that they aren\u0027t out of sync. Then we can link the tests statically all we want*. I think the way to do that is to checksum the .so\u0027s at build time and check those sums in a test.\n\n*) Assuming that there can\u0027t be toolchain differences that make one work and not the other. So there\u0027s still a small risk not testing what\u0027s in the module, but it\u0027s probably acceptable at that point.",
      "parentUuid": "bf753892_72a7edd9",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76b9c91d_f9fbfb75",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1963262
      },
      "writtenOn": "2022-09-21T13:53:49Z",
      "side": 1,
      "message": "\u003eHow many extra symbols would be required to avoid this? (Not just in this gtest, but all of them.)\n\nQuite a lot:\n```\n*art::DebugFrameOpCodeWriterForAssembler*;\n*art::arm::ArmVIXLAssembler*;             \n*art::arm::ArmVIXLJNIMacroAssembler*;     \n*art::x86::X86Assembler*;                 \n*art::x86_64::X86_64Assembler*;           \n*art::x86_64::X86_64JNIMacroAssembler*;   \n*art::InstructionSimplifier*;             \n*art::HExit*;                                    \n*art::GVNOptimization*;                   \n*art::HLessThan*;                         \n*art::HAdd*;                            \n*art::HInductionVarAnalysis*;             \n*art::BoundsCheckElimination*;           \n*art::HGreaterThan*;                   \n*art::HPhi*;                              \n*art::SideEffectsAnalysis*;               \n*art::HIntConstant*;                      \n*art::HRem*;                              \n*art::HArrayGet*;                         \n```\nThis is an incomplete list, there are even more. (leading `*` is required to also export vtable symbol)\n\nThere is also an option to build a separate libart-compiler.so without version_script for tests. But I guess it doesn\u0027t solve the case of \"not testing what is actually in use\"",
      "parentUuid": "67308c6d_67fa2bfe",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "372ee64e_94a1cda8",
        "filename": "compiler/Android.bp",
        "patchSetId": 12
      },
      "lineNbr": 522,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-22T14:37:53Z",
      "side": 1,
      "message": "\u003e Quite a lot:\n\nAs I suspected, thanks for checking.\n\n\u003e /.../ it doesn\u0027t solve the case of \"not testing what is actually in use\"\n\nCorrect.\n\nWe\u0027ll probably go with static linking and a sync check as mentioned earlier, but we need to run that past Mainline EngProd since they\u0027re heavy MTS users. It\u0027s on the agenda for a meeting next week.\n\nIn the meantime, Dmitrii, since this CL didn\u0027t get reverted in the end, can you please do a follow-up CL to address the other open comments here?",
      "parentUuid": "76b9c91d_f9fbfb75",
      "range": {
        "startLine": 522,
        "startChar": 7,
        "endLine": 522,
        "endChar": 26
      },
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f89e987b_ff793aa4",
        "filename": "compiler/libart-compiler.map",
        "patchSetId": 12
      },
      "lineNbr": 1,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-20T16:50:24Z",
      "side": 1,
      "message": "Please add copyright blurb.",
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59996fe0_d857b117",
        "filename": "compiler/libart-compiler.map",
        "patchSetId": 12
      },
      "lineNbr": 47,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2022-09-20T16:50:24Z",
      "side": 1,
      "message": "Nit: Extra empty line.",
      "revId": "d8d911d950825191986197c8dc9fedd76c351baa",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}