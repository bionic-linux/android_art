{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "767aa047_26f257aa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2022-11-03T09:36:56Z",
      "side": 1,
      "message": "That CL was for Linear. I think the other types are safe:\n* Polynomial checks for constant values (https://cs.android.com/android/platform/superproject/+/master:art/compiler/optimizing/induction_var_range.cc;l\u003d1181;drc\u003db45a2ea782074944f79fc388df20b06e01f265f7).\n* Geometric too (https://cs.android.com/android/platform/superproject/+/master:art/compiler/optimizing/induction_var_range.cc;l\u003d1223;drc\u003db45a2ea782074944f79fc388df20b06e01f265f7) and it has overflow checks (https://cs.android.com/android/platform/superproject/+/master:art/compiler/optimizing/induction_var_range.cc;l\u003d1236;drc\u003db45a2ea782074944f79fc388df20b06e01f265f7).\n* Wraparound also checks for constants (https://cs.android.com/android/platform/superproject/+/master:art/compiler/optimizing/induction_var_range.cc;l\u003d1287;drc\u003db45a2ea782074944f79fc388df20b06e01f265f7).",
      "range": {
        "startLine": 9,
        "startChar": 11,
        "endLine": 9,
        "endChar": 23
      },
      "revId": "6622977dff38d569727726ff8668db18d498271b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96b2e2ba_0d36d785",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2022-11-03T09:36:56Z",
      "side": 1,
      "message": "Vladimir PTAL",
      "revId": "6622977dff38d569727726ff8668db18d498271b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "611eee1c_4c69b57a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2022-11-18T10:51:58Z",
      "side": 1,
      "message": "Friendly ping",
      "revId": "6622977dff38d569727726ff8668db18d498271b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a20188e_bacb8dcd",
        "filename": "test/618-checker-induction/src/Main.java",
        "patchSetId": 2
      },
      "lineNbr": 519,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-24T15:09:34Z",
      "side": 1,
      "message": "If I understand this correctly, we\u0027re not fixing the optimization. We\u0027re just disabling it for pretty much all the relevant patterns. (The loop in this method is a very simple example.)\n\nLooking at the graph, I see no problem for this particular method. Omitting `Goto`s, we currently have `loop_optimization (after)`:\n\n    i0 ParameterValue\n    i3 IntConstant 0\n    i13 IntConstant 1\n    v1 SuspendCheck env:[[_,_,i0]]\n\n    i17 And [i0,i13]\n    z18 Equal [i17,i3]\n    i19 Select [i13,i3,z18]\n    z20 LessThan [i3,i0]\n    i21 Select [i3,i19,z20]\n\n    v11 Return [i21]\n\nThis looks correct to me, so I\u0027d like to keep the optimization for this method.",
      "revId": "6622977dff38d569727726ff8668db18d498271b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbc8967c_611ec931",
        "filename": "test/618-checker-induction/src/Main.java",
        "patchSetId": 2
      },
      "lineNbr": 519,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2022-11-24T15:42:04Z",
      "side": 1,
      "message": "We are disabling it if we cannot guarantee we won\u0027t overflow in the calculation. The easiest way to do it is to guarantee that we have constant values that we can check at compile time.\n\nIn the `periodicReturnedN` case, we could do it because we have a constant `0` as the start and because the step is `1`. The calculation\n  `(end - start) + (step - 1) / step`\nthen becomes\n  `end`.\n  \nHowever, if `start` was a negative number or if `step` was bigger than `1`, then we would have overflown. In order to support cases like this we would need to update loop optimization with cases like:\n* `constant start, variable end, constant step`\n* `variable start, constant end, constant step`\n* etc\n\nThe constants should be such that we can\u0027t overflow in signed 32 bit arithmetic no matter the variables. The cases also become impossible to figure out once you have two variables e.g. `variable start, variable end, constant step` could overflow no matter the step.\n\nWe would still perform the optimization for the cases in which we have constant values e.g. https://cs.android.com/android/platform/superproject/+/master:art/test/618-checker-induction/src/Main.java;l\u003d700;drc\u003ddb692461d217e59684baab57abcaf3055fa8ccf5.",
      "parentUuid": "5a20188e_bacb8dcd",
      "revId": "6622977dff38d569727726ff8668db18d498271b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "623df53b_8fba5610",
        "filename": "test/618-checker-induction/src/Main.java",
        "patchSetId": 2
      },
      "lineNbr": 519,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-24T16:11:14Z",
      "side": 1,
      "message": "We could use 64-bit or unsigned division for the calculation to avoid overflow for reasonable start values such as 0. (Unsigned: if `IsPowerOfTwo(step)`, just use `HUshr`, otherwise create an `HInvokeStaticOrDirect/intrinsic\u003dIntegerDivideUnsigned`.)",
      "parentUuid": "fbc8967c_611ec931",
      "revId": "6622977dff38d569727726ff8668db18d498271b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62a44baf_8ef72f33",
        "filename": "test/618-checker-induction/src/Main.java",
        "patchSetId": 2
      },
      "lineNbr": 519,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2022-11-24T16:19:39Z",
      "side": 1,
      "message": "The division itself is not an issue since the overflow happens before in:\n  `(end - start) + (step - 1)`.\n  \nIf we move to 64-bit calculations, we should move all calculations and not just the division. Even then, if we have:\n  * end \u003d Integer.MAX_VALUE\n  * start \u003d Integer.MIN_VALUE\n  * step \u003d Integer.MAX_VALUE\n  \nwe would still overflow in 64-bit calculations, right?",
      "parentUuid": "623df53b_8fba5610",
      "revId": "6622977dff38d569727726ff8668db18d498271b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}