{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b847fd5e_ec3ebcba",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2024-03-01T17:22:05Z",
      "side": 0,
      "message": "Why not change here directly? You can change the static_assert to be on `kPreferredAllocSpaceAgain`.",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2476c741_7292f5a7",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1958325
      },
      "writtenOn": "2024-03-01T18:12:36Z",
      "side": 0,
      "message": "Oh yeah I tried to do that at the beginning. However `IsAligned()` with a pointer rather than an integral isn\u0027t a valid `constexpr`. This is why I added `kPreferredAllocSpaceBeginAsUint` as an intermediate `constexpr` value.\n\nThat being said, maybe it would be better to turn `kPreferredAllocSpaceBegin` be an integral, and add `reinterpret_cast\u003cuint8_t*\u003e(..)` to the uses. Then we would move all this in heap.h:\n\n```c++\n#if defined(__LP64__) || !defined(ADDRESS_SANITIZER)\n  static constexpr int kMaxPMDSize \u003d (kMaxPageSize / sizeof(uint64_t)) * kMaxPageSize;\n  static constexpr size_t kPreferredAllocSpaceBegin \u003d 320 * MB - kDefaultNonMovingSpaceCapacity;\n  static_assert(IsAligned\u003ckMaxPMDSize\u003e(kPreferredAllocSpaceBegin),\n                \"kPreferredAllocSpaceBegin should be aligned to the maximum \"\n                \"supported PMD size.\");\n#else\n#ifdef __ANDROID__\n  // For 32-bit Android, use 0x20000000 because asan reserves 0x04000000 - 0x20000000.\n  static constexpr size_t kPreferredAllocSpaceBegin \u003d 0x20000000;\n#else\n  // For 32-bit host, use 0x40000000 because asan uses most of the space below this.\n  static constexpr size_t kPreferredAllocSpaceBegin \u003d 0x40000000;\n#endif\n#endif\n\n```\nDoes this seem better? I guess that would address your other comment too?\n\nUnless there\u0027s a way to check is a pointer is aligned with a `static_assert`/`constexpr`, that\u0027d be best I think",
      "parentUuid": "b847fd5e_ec3ebcba",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9dc07bd7_3cf516dd",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2024-03-01T18:42:15Z",
      "side": 0,
      "message": "\u003e However `IsAligned()` with a pointer rather than an integral isn\u0027t a valid constexpr\n\nI think the reason is that the definition of IsAligned() (in `libartbase/base/bit_utils.h`) for pointers is not constexpr whereas for integrals it is. Can you try making it constexpr? It should work as it just calls the integral IsAligned().",
      "parentUuid": "2476c741_7292f5a7",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65893c30_4137f76e",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1958325
      },
      "writtenOn": "2024-03-01T18:54:27Z",
      "side": 0,
      "message": "AFAICT, a `constexpr` cannot have a `reinterpret_cast` from a pointer to a `uintprt_t` so I\u0027m afraid that\u0027s not working. I\u0027m not so confident with the details of the standard, but I assume it\u0027s to do with pointer representation not being portable.\n\nFor reference, if I have this:\n\n```c++\ntemplate\u003cint n, typename T\u003e\nconstexpr inline bool IsAligned(T* x) {\n  return IsAligned\u003cn\u003e(reinterpret_cast\u003cconst uintptr_t\u003e(x));\n}\n```\n\nIt fails with:\n\n```c++\nart/runtime/gc/heap.cc:211:15: error: static assertion expression is not an integral constant expression\n  211 | static_assert(IsAligned\u003ckMaxPMDSize\u003e(Heap::kPreferredAllocSpaceBegin),\n      |               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nart/runtime/gc/heap.cc:211:38: note: read of non-constexpr variable \u0027kPreferredAllocSpaceBegin\u0027 is not allowed in a constant expression\n  211 | static_assert(IsAligned\u003ckMaxPMDSize\u003e(Heap::kPreferredAllocSpaceBegin),\n      |                                      ^\nart/runtime/gc/heap.cc:208:22: note: declared here\n  208 | uint8_t* const Heap::kPreferredAllocSpaceBegin \u003d\n```\n\nOf course the error message could do with adding more details ðŸ˜Š",
      "parentUuid": "9dc07bd7_3cf516dd",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}