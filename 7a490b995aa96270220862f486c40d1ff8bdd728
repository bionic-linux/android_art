{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b847fd5e_ec3ebcba",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2024-03-01T17:22:05Z",
      "side": 0,
      "message": "Why not change here directly? You can change the static_assert to be on `kPreferredAllocSpaceAgain`.",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2476c741_7292f5a7",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1958325
      },
      "writtenOn": "2024-03-01T18:12:36Z",
      "side": 0,
      "message": "Oh yeah I tried to do that at the beginning. However `IsAligned()` with a pointer rather than an integral isn\u0027t a valid `constexpr`. This is why I added `kPreferredAllocSpaceBeginAsUint` as an intermediate `constexpr` value.\n\nThat being said, maybe it would be better to turn `kPreferredAllocSpaceBegin` be an integral, and add `reinterpret_cast\u003cuint8_t*\u003e(..)` to the uses. Then we would move all this in heap.h:\n\n```c++\n#if defined(__LP64__) || !defined(ADDRESS_SANITIZER)\n  static constexpr int kMaxPMDSize \u003d (kMaxPageSize / sizeof(uint64_t)) * kMaxPageSize;\n  static constexpr size_t kPreferredAllocSpaceBegin \u003d 320 * MB - kDefaultNonMovingSpaceCapacity;\n  static_assert(IsAligned\u003ckMaxPMDSize\u003e(kPreferredAllocSpaceBegin),\n                \"kPreferredAllocSpaceBegin should be aligned to the maximum \"\n                \"supported PMD size.\");\n#else\n#ifdef __ANDROID__\n  // For 32-bit Android, use 0x20000000 because asan reserves 0x04000000 - 0x20000000.\n  static constexpr size_t kPreferredAllocSpaceBegin \u003d 0x20000000;\n#else\n  // For 32-bit host, use 0x40000000 because asan uses most of the space below this.\n  static constexpr size_t kPreferredAllocSpaceBegin \u003d 0x40000000;\n#endif\n#endif\n\n```\nDoes this seem better? I guess that would address your other comment too?\n\nUnless there\u0027s a way to check is a pointer is aligned with a `static_assert`/`constexpr`, that\u0027d be best I think",
      "parentUuid": "b847fd5e_ec3ebcba",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9dc07bd7_3cf516dd",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2024-03-01T18:42:15Z",
      "side": 0,
      "message": "\u003e However `IsAligned()` with a pointer rather than an integral isn\u0027t a valid constexpr\n\nI think the reason is that the definition of IsAligned() (in `libartbase/base/bit_utils.h`) for pointers is not constexpr whereas for integrals it is. Can you try making it constexpr? It should work as it just calls the integral IsAligned().",
      "parentUuid": "2476c741_7292f5a7",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65893c30_4137f76e",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1958325
      },
      "writtenOn": "2024-03-01T18:54:27Z",
      "side": 0,
      "message": "AFAICT, a `constexpr` cannot have a `reinterpret_cast` from a pointer to a `uintprt_t` so I\u0027m afraid that\u0027s not working. I\u0027m not so confident with the details of the standard, but I assume it\u0027s to do with pointer representation not being portable.\n\nFor reference, if I have this:\n\n```c++\ntemplate\u003cint n, typename T\u003e\nconstexpr inline bool IsAligned(T* x) {\n  return IsAligned\u003cn\u003e(reinterpret_cast\u003cconst uintptr_t\u003e(x));\n}\n```\n\nIt fails with:\n\n```c++\nart/runtime/gc/heap.cc:211:15: error: static assertion expression is not an integral constant expression\n  211 | static_assert(IsAligned\u003ckMaxPMDSize\u003e(Heap::kPreferredAllocSpaceBegin),\n      |               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nart/runtime/gc/heap.cc:211:38: note: read of non-constexpr variable \u0027kPreferredAllocSpaceBegin\u0027 is not allowed in a constant expression\n  211 | static_assert(IsAligned\u003ckMaxPMDSize\u003e(Heap::kPreferredAllocSpaceBegin),\n      |                                      ^\nart/runtime/gc/heap.cc:208:22: note: declared here\n  208 | uint8_t* const Heap::kPreferredAllocSpaceBegin \u003d\n```\n\nOf course the error message could do with adding more details ðŸ˜Š",
      "parentUuid": "9dc07bd7_3cf516dd",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d917de6b_d674583d",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2024-03-01T19:07:09Z",
      "side": 0,
      "message": "From the error it seems like the issue is that `kPreferredAllocSpaceBegin` is not constexpr. Can you try moving its definition to heap.h, make it constexpr (anyways the notation we follow in ART is that variables starting with `k` are constexpr), and then re-try.\n\nBasically I\u0027m saying to do what you suggested in your first comment but without changing kPreferredAllocSpaceBegin to integral.\n\nSorry for the trouble. I\u0027m just trying to avoid creating new variables or change the type of existing ones. But I also like the idea of adding a static_assert.",
      "parentUuid": "65893c30_4137f76e",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "179e9371_0babe688",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1958325
      },
      "writtenOn": "2024-03-01T19:47:36Z",
      "side": 0,
      "message": "\u003e Sorry for the trouble. I\u0027m just trying to avoid creating new variables or change the type of existing ones. But I also like the idea of adding a static_assert.\n\nNo problem! It\u0027s better to spend time getting something nice and clean. I\u0027ll give it a go on Monday, however I\u0027m not sure it\u0027s going to be possible to have both a pointer and a `constexpr`, as it seems the standard specifically disallows `reinterpret_cast` in `constexpr` in general.\n\nTo me it seems changing the type from a pointer to `uintptr_t` might be the simplest and cleanest option, but I\u0027ll check next week if I can find a better solution.",
      "parentUuid": "d917de6b_d674583d",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6df94cb_19eae56f",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1958325
      },
      "writtenOn": "2024-03-04T12:25:57Z",
      "side": 0,
      "message": "\u003e From the error it seems like the issue is that kPreferredAllocSpaceBegin is not constexpr. Can you try moving its definition to heap.h, make it constexpr (anyways the notation we follow in ART is that variables starting with k are constexpr), and then re-try.\n\nTrying this in heap.h for example:\n\n```\n  static constexpr uint8_t* kPreferredAllocSpaceBegin \u003d\n      reinterpret_cast\u003cuint8_t*\u003e(320 * MB - Heap::kDefaultNonMovingSpaceCapacity);\n```\n\nI\u0027m afraid it does not work because `reinterpret_cast` cannot produce a constexpr, and is specifically disallowed by the standard.\n\n```\nart/runtime/gc/heap.h:159:29: error: constexpr variable \u0027kPreferredAllocSpaceBegin\u0027 must be initialized by a constant expression\n  160 |   static constexpr uint8_t* kPreferredAllocSpaceBegin \u003d\n      |                             ^\n  161 |       reinterpret_cast\u003cuint8_t*\u003e(320 * MB - Heap::kDefaultNonMovingSpaceCapacity);\n      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nart/runtime/gc/heap.h:160:7: note: reinterpret_cast is not allowed in a constant expression\n  160 |       reinterpret_cast\u003cuint8_t*\u003e(320 * MB - Heap::kDefaultNonMovingSpaceCapacity);\n      |       ^\n1 error generated.\n```\n\nHowever! Over the weekend I remembered seeing a clever pattern, in the V8 JS engine, where you can use a `constexpr` lambda to wrap a constant expression. This way, we can move the `reinterpret_cast` out of the initializer, and allow us to write the static assert in the lambda, keeping the intermediary integral constant local to that scope.\n\n```\n// 320 MB (0x14000000) - (default non-moving space capacity).\n// The value is picked to ensure it is aligned to the largest supported PMD\n// size, which is 32mb with a 16k page size on AArch64.\nuint8_t* const Heap::kPreferredAllocSpaceBegin \u003d reinterpret_cast\u003cuint8_t*\u003e(([]() constexpr {\n  constexpr size_t kBegin \u003d 320 * MB - Heap::kDefaultNonMovingSpaceCapacity;\n  constexpr int kMaxPMDSize \u003d (kMaxPageSize / sizeof(uint64_t)) * kMaxPageSize;\n  static_assert(IsAligned\u003ckMaxPMDSize\u003e(kBegin),\n                \"kPreferredAllocSpaceBegin should be aligned to the maximum \"\n                \"supported PMD size.\");\n  return kBegin;\n})());\n```\n\nAlthough it might look a bit weird, and I don\u0027t see this pattern in ART, it seems like a nice solution, that does not introduce any new constant, and does not change the type, WDYT?",
      "parentUuid": "179e9371_0babe688",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e0e8dad_c9adeba6",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2024-03-04T16:55:35Z",
      "side": 0,
      "message": "Thanks so much for looking into this. This looks like a good idea to me as it also nicely encapsulates other additional constexpr variables which are only required for this static_assert.\n\nBut let\u0027s see if Nicolas is also ok with it.",
      "parentUuid": "c6df94cb_19eae56f",
      "range": {
        "startLine": 207,
        "startChar": 31,
        "endLine": 207,
        "endChar": 34
      },
      "revId": "7a490b995aa96270220862f486c40d1ff8bdd728",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}