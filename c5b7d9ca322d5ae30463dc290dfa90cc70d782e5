{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "da038c65_14cc5bab",
        "filename": "dex2oat/linker/image_writer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1468,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T14:54:36Z",
      "side": 1,
      "message": "What do you mean by this part of the sentence?",
      "range": {
        "startLine": 1468,
        "startChar": 7,
        "endLine": 1468,
        "endChar": 76
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24803486_b3ca2328",
        "filename": "dex2oat/linker/image_writer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1468,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-19T15:15:57Z",
      "side": 1,
      "message": "I noticed some native methods in boot image extensions are not compiled into AOTed codes, and I want to explain why we only restrict the JNI stubs in boot images can be reused for others. Anyway, I could delete this if it\u0027s confusing.",
      "parentUuid": "da038c65_14cc5bab",
      "range": {
        "startLine": 1468,
        "startChar": 7,
        "endLine": 1468,
        "endChar": 76
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56f5462a_3d56c8be",
        "filename": "dex2oat/linker/image_writer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1468,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T16:05:41Z",
      "side": 1,
      "message": "I do find it confusing and would prefer this to be removed.\n\nAFAIK, the only reason to not compile JNI stubs in a boot image extension is being added in this change - an appropriate JNI stub is already present in the primary boot image. Or is there another case where we do not compile a JNI stub?",
      "parentUuid": "24803486_b3ca2328",
      "range": {
        "startLine": 1468,
        "startChar": 7,
        "endLine": 1468,
        "endChar": 76
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3507b9f0_19a2ef9c",
        "filename": "dex2oat/linker/image_writer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1468,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-20T06:17:10Z",
      "side": 1,
      "message": "I\u0027m not sure which mechanism cause this, but I do found many com.android.org.conscrypt.xxx native methods are not compiled into AOTed code. For example (seems these methods are resides in boot-framework-adservices.art):\n\n```\nvoid com.android.org.conscrypt.NativeCrypto.EVP_DigestUpdate(com.android.org.conscrypt.NativeRef$EVP_MD_CTX, byte[], int, int)\nvoid com.android.org.conscrypt.NativeCrypto.HMAC_Update(com.android.org.conscrypt.NativeRef$HMAC_CTX, byte[], int, int)\nvoid com.android.org.conscrypt.NativeCrypto.HMAC_Init_ex(com.android.org.conscrypt.NativeRef$HMAC_CTX, byte[], long)\n```",
      "parentUuid": "56f5462a_3d56c8be",
      "range": {
        "startLine": 1468,
        "startChar": 7,
        "endLine": 1468,
        "endChar": 76
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e763b99a_04976c5c",
        "filename": "dex2oat/linker/image_writer.cc",
        "patchSetId": 2
      },
      "lineNbr": 1468,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-21T06:32:57Z",
      "side": 1,
      "message": "Removed the confusing comments.",
      "parentUuid": "3507b9f0_19a2ef9c",
      "range": {
        "startLine": 1468,
        "startChar": 7,
        "endLine": 1468,
        "endChar": 76
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "382aff65_826f417c",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1452,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T14:54:36Z",
      "side": 1,
      "message": "\"check for deoptimization on exit\"",
      "range": {
        "startLine": 1451,
        "startChar": 69,
        "endLine": 1452,
        "endChar": 10
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d8c6f32_fc3beb34",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1452,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-19T15:15:57Z",
      "side": 1,
      "message": "I\u0027m planing to edit this to \"since we never use AOT code for debuggable.\"",
      "parentUuid": "382aff65_826f417c",
      "range": {
        "startLine": 1451,
        "startChar": 69,
        "endLine": 1452,
        "endChar": 10
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67037420_1660813a",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1452,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T16:05:41Z",
      "side": 1,
      "message": "OK. Alternatively, you could also drop the first part of the sentence:\n\n    // We never use AOT code for debuggable.",
      "parentUuid": "5d8c6f32_fc3beb34",
      "range": {
        "startLine": 1451,
        "startChar": 69,
        "endLine": 1452,
        "endChar": 10
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8e9784b_f99dd850",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1452,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-20T06:17:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "67037420_1660813a",
      "range": {
        "startLine": 1451,
        "startChar": 69,
        "endLine": 1452,
        "endChar": 10
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "721a157f_d82ff28e",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1453,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T14:54:36Z",
      "side": 1,
      "message": "We should instead do this check in `FixupStaticTrampolines()` and `LinkCode()`. The `debuggable` state can change, so we can end up with a non-empty `boot_image_jni_stubs_` in a `debugable` process anyway. The state change to `debuggable` replaces already initialized entrypoints but we\u0027ll need to avoid the boot JNI stubs for methods initialized afterwards.",
      "range": {
        "startLine": 1453,
        "startChar": 2,
        "endLine": 1453,
        "endChar": 37
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dec1cf1d_f5b3b0f9",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1453,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-19T15:15:57Z",
      "side": 1,
      "message": "\u003e We should instead do this check in `FixupStaticTrampolines()` and `LinkCode()`. The `debuggable` state can change, so we can end up with a non-empty `boot_image_jni_stubs_` in a `debugable` process anyway. The state change to `debuggable` replaces already initialized entrypoints but we\u0027ll need to avoid the boot JNI stubs for methods initialized afterwards.\n\nHaha, I was just thinking about that. For `LinkCode`, seems `InitializeMethodsCode` will guarantee that AOT code won\u0027t be used since it use `CanUseAotCode` to check that. But for `FixupStaticTrampoline`, it won\u0027t as it use `UpdateMethodsCode` directly. But I\u0027m thinking if we should export `CanUseAotCode` and use it in `FixupStaticTrampoline` for better consistency?",
      "parentUuid": "721a157f_d82ff28e",
      "range": {
        "startLine": 1453,
        "startChar": 2,
        "endLine": 1453,
        "endChar": 37
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88f6cbe7_6016b25c",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1453,
      "author": {
        "id": 1894735
      },
      "writtenOn": "2024-03-19T15:24:57Z",
      "side": 1,
      "message": "I am not sure I understand this fully, but I think even if we initialize boot_Image_jni_stubs_ here we shouldn\u0027t use them in debuggable runtimes. When we update the code we either use ``Instrumentation::UpdateMethodsCode`` or ``Instrumentation::InitializeMethodsCode`` which should eventually check if the code supports entry exit hooks and discard the code if it doesn\u0027t support. \n\nShouldn\u0027t this check: ``CodeInfo::IsDebuggable()`` check in ``CodeSupportsEntryExitHooks``[1] fail here? I don\u0027t fully understand if the boot image jni stub will be mapped to out Jit memory or not. If they are not mapped then we should return false too.\n\nOne problem could be if we generated these stubs in debuggable runtime with AOT compiler, then the check would pass but AOT compiler doesn\u0027t add entry / exit hooks. Though I believe we should return false for ``jit-\u003eGetCodeCache()-\u003eContainsPc(entry_point)``\n\n[1]https://cs.android.com/android/platform/superproject/main/+/main:art/runtime/instrumentation.cc;l\u003d239",
      "parentUuid": "721a157f_d82ff28e",
      "range": {
        "startLine": 1453,
        "startChar": 2,
        "endLine": 1453,
        "endChar": 37
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eecbf446_9f05bcb2",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1453,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T16:05:41Z",
      "side": 1,
      "message": "The difference between the `LinkCode()` and `FixupStaticTrampolines()` is unfortunate. I\u0027m wondering if we should change `FixupStaticTrampolines()` to fetch the `OatClass` and do the same call as `LinkCode()`. Then we could just let the `InitializeMethodsCode()` do the check instead of having any explicit check in the `ClassLinker`.\n\nThe `CodeInfo::IsDebuggable()` check in `CodeSupportsEntryExitHooks()` is applied only to code in JIT code cache. The boot JNI stubs are in the boot image, not in the JIT code cache.",
      "parentUuid": "88f6cbe7_6016b25c",
      "range": {
        "startLine": 1453,
        "startChar": 2,
        "endLine": 1453,
        "endChar": 37
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c34593c3_ad2a9001",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1453,
      "author": {
        "id": 1894735
      },
      "writtenOn": "2024-03-19T16:26:56Z",
      "side": 1,
      "message": "Thanks! I was wondering why we installed them because we should correctly return ``false`` from ``CodeSupportsEntryExitHooks()``. \n\nEarlier I didn\u0027t look at ``FixupStaticTrampolines`` carefully enough. We only do ``UpdateMethodsCode`` if the method needs a clinit check. So now I see why may use the JNI stubs from the boot image. \n\nI don\u0027t understand ``FixupStaticTrampolines`` or ``LinkCode`` but it seems safer to either use ``InitializeMethodsCode`` or ``UpdateMethodsCode`` so we always do the checks correctly.",
      "parentUuid": "eecbf446_9f05bcb2",
      "range": {
        "startLine": 1453,
        "startChar": 2,
        "endLine": 1453,
        "endChar": 37
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50aa3dc2_b27b729f",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1453,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-20T06:17:10Z",
      "side": 1,
      "message": "FixupStaticTrampoline use below way to set entrypoint. Though `UpdateMethodsCode` doesn\u0027t check if we can use AOT code here, `GetCodeForInvoke` will do the check (in `GetOptimizedCodeFor`). So it\u0027s safe for originally codes. But once this change get merged, things get complicated. I don\u0027t want to check in the `ClassLinker` explicitly, either. But I haven\u0027t came up with an elegant way yet.\n\n```\ninstrumentation-\u003eUpdateMethodsCode(method, instrumentation-\u003eGetCodeForInvoke(method));\n```",
      "parentUuid": "c34593c3_ad2a9001",
      "range": {
        "startLine": 1453,
        "startChar": 2,
        "endLine": 1453,
        "endChar": 37
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "67fde826_aa2cf02e",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 2
      },
      "lineNbr": 1453,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-21T06:32:57Z",
      "side": 1,
      "message": "Add runtime IsJavaDebuggable check here.",
      "parentUuid": "50aa3dc2_b27b729f",
      "range": {
        "startLine": 1453,
        "startChar": 2,
        "endLine": 1453,
        "endChar": 37
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4614aa6f_b5d9e202",
        "filename": "runtime/stack.cc",
        "patchSetId": 2
      },
      "lineNbr": 877,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T14:54:36Z",
      "side": 1,
      "message": "Pull the shared code out of the then-block and else-block. (Just like it was originally in the PS1. Feel free to keep the `CHECK()` in the then-block.)",
      "range": {
        "startLine": 877,
        "startChar": 16,
        "endLine": 877,
        "endChar": 91
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "552a8eac_9f12c7e5",
        "filename": "runtime/stack.cc",
        "patchSetId": 2
      },
      "lineNbr": 877,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-19T15:15:57Z",
      "side": 1,
      "message": "These 2 methods are not the same, one is `FromEntryPoint`, another is `FromCodePointer`. Because the code got from JIT cache is code pointer but it is entrypoint(especially for thumb2) when got from boot jni stubs.",
      "parentUuid": "4614aa6f_b5d9e202",
      "range": {
        "startLine": 877,
        "startChar": 16,
        "endLine": 877,
        "endChar": 91
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33e76510_ca611aba",
        "filename": "runtime/stack.cc",
        "patchSetId": 2
      },
      "lineNbr": 877,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-03-19T16:05:41Z",
      "side": 1,
      "message": "I see. So there was an ARM bug in the previously merged CL?\n\nWe could still have a shared `FromCodePointer()` call outside the if-block and then-block. We would just need to add `EntryPointToCodePointer()` to line 872.",
      "parentUuid": "552a8eac_9f12c7e5",
      "range": {
        "startLine": 877,
        "startChar": 16,
        "endLine": 877,
        "endChar": 91
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3dcb5828_fd04063d",
        "filename": "runtime/stack.cc",
        "patchSetId": 2
      },
      "lineNbr": 877,
      "author": {
        "id": 1868486
      },
      "writtenOn": "2024-03-20T06:17:10Z",
      "side": 1,
      "message": "Yes, it changes because the LUCI bots detected a stack unwind issue for ARM.",
      "parentUuid": "33e76510_ca611aba",
      "range": {
        "startLine": 877,
        "startChar": 16,
        "endLine": 877,
        "endChar": 91
      },
      "revId": "c5b7d9ca322d5ae30463dc290dfa90cc70d782e5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}