{
  "comments": [
    {
      "key": {
        "uuid": "1096c0c9_a12d7a88",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1022,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-20T16:37:36Z",
      "side": 1,
      "message": "One line?",
      "range": {
        "startLine": 1022,
        "startChar": 51,
        "endLine": 1022,
        "endChar": 66
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_a20c9adf",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1022,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:12:55Z",
      "side": 1,
      "message": "The line would be longer than 80 columns.  By the way, what is the rule here?  The Google C++ Style Guide guide says 80 columns, but I think I\u0027ve read something about 100 columns in an Android-related source.",
      "parentUuid": "1096c0c9_a12d7a88",
      "range": {
        "startLine": 1022,
        "startChar": 51,
        "endLine": 1022,
        "endChar": 66
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_226faa6c",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1022,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-10-20T17:23:19Z",
      "side": 1,
      "message": "yea, 100 columns is the norm (at least in framework), but as far as I could tell the runtime uses up to 120.\n\nI\u0027d keep it under 100 though.",
      "parentUuid": "309904fa_a20c9adf",
      "range": {
        "startLine": 1022,
        "startChar": 51,
        "endLine": 1022,
        "endChar": 66
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1096c0c9_41d036d7",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1022,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:43:08Z",
      "side": 1,
      "message": "Duly noted, thanks. :)",
      "parentUuid": "309904fa_226faa6c",
      "range": {
        "startLine": 1022,
        "startChar": 51,
        "endLine": 1022,
        "endChar": 66
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_6246121a",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 963,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-20T16:37:36Z",
      "side": 1,
      "message": "One line?",
      "range": {
        "startLine": 963,
        "startChar": 51,
        "endLine": 963,
        "endChar": 66
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_22fa4a56",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 987,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-10-20T16:51:10Z",
      "side": 1,
      "message": "in is Any but you DCHECK that\u0027s not constant. Add a note why is that. Probably because x86 doesn\u0027t have a neg with constants? If so, does it worth doing \u0027-a \u003d 0 - a\u0027? or some other pattern?",
      "range": {
        "startLine": 987,
        "startChar": 6,
        "endLine": 987,
        "endChar": 30
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_20b96e51",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 987,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:12:55Z",
      "side": 1,
      "message": "Yes, the negl instruction only takes a register or memory location as operand.  Constant operands would be likely addressed by the constant folding pass (see https://android-review.googlesource.com/#/c/111393/).",
      "parentUuid": "309904fa_22fa4a56",
      "range": {
        "startLine": 987,
        "startChar": 6,
        "endLine": 987,
        "endChar": 30
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "30474440_75d09a05",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 987,
      "author": {
        "id": 1013855
      },
      "writtenOn": "2014-10-20T17:16:06Z",
      "side": 1,
      "message": "I guess it is probably because unary operations with constant operand can be evaluated at compile time. But might be worth adding a comment here.",
      "parentUuid": "309904fa_22fa4a56",
      "range": {
        "startLine": 987,
        "startChar": 6,
        "endLine": 987,
        "endChar": 30
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_c097d2a9",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 987,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:18:58Z",
      "side": 1,
      "message": "Good point, will do.",
      "parentUuid": "30474440_75d09a05",
      "range": {
        "startLine": 987,
        "startChar": 6,
        "endLine": 987,
        "endChar": 30
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1096c0c9_a1573acb",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 987,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-10-20T17:23:19Z",
      "side": 1,
      "message": "yea, please add a comment for that.",
      "parentUuid": "30474440_75d09a05",
      "range": {
        "startLine": 987,
        "startChar": 6,
        "endLine": 987,
        "endChar": 30
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_409ae201",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 988,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-20T16:37:36Z",
      "side": 1,
      "message": "Shouldn\u0027t you handle stack location as well?",
      "range": {
        "startLine": 988,
        "startChar": 21,
        "endLine": 988,
        "endChar": 29
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_021c6e0c",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 988,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:12:55Z",
      "side": 1,
      "message": "I limited inputs and outputs to registers because art::x86::X86Assembler::negl only accepts a Register as argument.  Can I (should I) extend this method to accept memory locations as well?",
      "parentUuid": "f064ccc9_409ae201",
      "range": {
        "startLine": 988,
        "startChar": 21,
        "endLine": 988,
        "endChar": 29
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_a241fad7",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 988,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-10-20T17:23:19Z",
      "side": 1,
      "message": "if it only accepts registers you need to do some moving/poping as well. That should be done in the allocator so I think it\u0027s ok to just request a register for it.",
      "parentUuid": "309904fa_021c6e0c",
      "range": {
        "startLine": 988,
        "startChar": 21,
        "endLine": 988,
        "endChar": 29
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_0079caf1",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 988,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:43:08Z",
      "side": 1,
      "message": "Yes, this is what I inferred.",
      "parentUuid": "309904fa_a241fad7",
      "range": {
        "startLine": 988,
        "startChar": 21,
        "endLine": 988,
        "endChar": 29
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_82431e07",
        "filename": "compiler/optimizing/code_generator_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 939,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-20T16:37:36Z",
      "side": 1,
      "message": "One line?",
      "range": {
        "startLine": 939,
        "startChar": 51,
        "endLine": 939,
        "endChar": 66
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1096c0c9_41ed96c8",
        "filename": "compiler/optimizing/code_generator_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 963,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-10-20T16:51:10Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 963,
        "startChar": 6,
        "endLine": 963,
        "endChar": 12
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_60a7e648",
        "filename": "compiler/optimizing/code_generator_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 964,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-20T16:37:36Z",
      "side": 1,
      "message": "Stack location?",
      "range": {
        "startLine": 964,
        "startChar": 18,
        "endLine": 964,
        "endChar": 20
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1096c0c9_c10b6615",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 1
      },
      "lineNbr": 487,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-10-20T16:37:36Z",
      "side": 1,
      "message": "Make this one a UnaryInstruction?",
      "range": {
        "startLine": 487,
        "startChar": 4,
        "endLine": 487,
        "endChar": 7
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_a0ebbe3a",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 1
      },
      "lineNbr": 487,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:12:55Z",
      "side": 1,
      "message": "I did at first, but a naive implementation did not work as intended, as this class does not seem to fit in the same pattern as HNeg.  HNot is tied to a Boolean input in the current implementation and seems to be meant to work on logical expressions only (and not bit-level one\u0027s complement negations).",
      "parentUuid": "1096c0c9_c10b6615",
      "range": {
        "startLine": 487,
        "startChar": 4,
        "endLine": 487,
        "endChar": 7
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_80123ac4",
        "filename": "test/411-optimizing-arith/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-10-20T16:51:10Z",
      "side": 1,
      "message": "is this part of the standard spec?",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 68,
        "endChar": 64
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_02338e9a",
        "filename": "test/411-optimizing-arith/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:12:55Z",
      "side": 1,
      "message": "I did not check the Java Language Specification, but on a more general level I believe this behavior follows the definition of two\u0027s complement.  I\u0027ll check the specification to be sure.",
      "parentUuid": "f064ccc9_80123ac4",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 68,
        "endChar": 64
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_40dd8296",
        "filename": "test/411-optimizing-arith/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:18:23Z",
      "side": 1,
      "message": "The Java Language Specification (for version 7) aligns with this definition: http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.15.4\n\n\n  For integer values, negation is the same as subtraction\n  from zero.  The Java programming language uses two\u0027s-\n  complement representation for integers, and the range of\n  two\u0027s-complement values is not symmetric, so negation of\n  the maximum negative int or long results in that same\n  maximum negative number. Overflow occurs in this case,\n  but no exception is thrown. For all integer values x,\n  -x equals (~x)+1.",
      "parentUuid": "309904fa_02338e9a",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 68,
        "endChar": 64
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f064ccc9_e09cd6d0",
        "filename": "test/411-optimizing-arith/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-10-20T17:23:19Z",
      "side": 1,
      "message": "nice, I\u0027d add a note that that\u0027s the expected behaviour according to the spec.\n\nMore generally if we ever test something that\u0027s implementation specific we should add a note for it explaining why.",
      "parentUuid": "f064ccc9_40dd8296",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 68,
        "endChar": 64
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "309904fa_c29446d1",
        "filename": "test/411-optimizing-arith/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2014-10-20T17:43:08Z",
      "side": 1,
      "message": "Alright, will do.  But this does not look like an implementation-specific case to me: I believe all two\u0027s complement implementations exhibit this behavior. :)",
      "parentUuid": "f064ccc9_e09cd6d0",
      "range": {
        "startLine": 67,
        "startChar": 4,
        "endLine": 68,
        "endChar": 64
      },
      "revId": "ca66869b978926286855875e79b1077950a46c37",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}