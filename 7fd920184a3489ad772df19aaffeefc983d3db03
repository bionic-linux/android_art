{
  "comments": [
    {
      "key": {
        "uuid": "62eda937_6501e2e7",
        "filename": "runtime/interpreter/mterp/mterp.cc",
        "patchSetId": 2
      },
      "lineNbr": 655,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2016-03-03T04:53:39Z",
      "side": 1,
      "message": "May be decide whether to profile all branches or only backward branches basing on events. As I understand other interpreters do in this way, correct?",
      "range": {
        "startLine": 655,
        "startChar": 2,
        "endLine": 655,
        "endChar": 19
      },
      "revId": "7fd920184a3489ad772df19aaffeefc983d3db03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e211990a_524295e8",
        "filename": "runtime/interpreter/mterp/mterp.cc",
        "patchSetId": 2
      },
      "lineNbr": 655,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2016-03-03T13:47:11Z",
      "side": 1,
      "message": "Serguei, what you\u0027re seeing here is just a snapshot of a work in progress.  Here\u0027s where I\u0027m going with this:\n\nThe JIT currently requires two profiling-related things from the interpreters: hotness updates and OSR switch checks.  The hotness updates use the existing instrumentation framework - which is flexible, but quite heavyweight.  For most things, the instrumentation framework overhead is acceptable, but because we do a hotness update on every backwards branch the overhead is unacceptable.  Right now, branch profiling dominates interpreter cost.\n\nThe most efficient hotness update mechanism would simply bypass the instrumentation framework.  However, from a code health point of view, this would be somewhat unclean.  I\u0027d like to avoid parallel instrumentation mechanisms.  What I\u0027m doing here is introducing a new instrumentation \"event\" - a batch update of hotness count.  This will enable us to locally update hotness, but only periodically call out to the instrumentation framework to amortize the cost.  This isn\u0027t yet apparent in the CL - but it should be more clear in an upcoming patch set.\n\nRight now, the JIT doesn\u0027t need true branch profiling.  But, we expect it will in the future.  However, taken/not-taken profiling is only useful once you\u0027ve decided a method is hot enough to optimize.  That\u0027s another reason why I\u0027ve introduced a new \"event\", and kept the old one.  During the initial stages, we\u0027d interpret using the hotness event only.  Once a method is hot, we could then disable hotness and enable full branch profiling for a short duration to gather additional info to feed into the optimizer.  Once we\u0027ve collected enough, full branch profiling would be disabled and hotness resumed (in order to detect OSR candidates).\n\nI would expect that full branch profiling would not need to be implemented in mterp.  It\u0027s heavyweight enough that it would largely eliminate mterp gains anyway.  And, we\u0027d presumably only be doing it for a short time.\n\nThe other thing you will see coming up is a type change in the method\u0027s hotness counter.  I\u0027ll be moving it to an int rather than uint and will encode state information.  We don\u0027t need to do an OSR check until after we\u0027ve requested an OSR compilation (or better, once the OSR compilation is complete).  A magic negative value in the hotness counter will determine whether we should bother to take the time to detect a viable OSR loop entry.",
      "parentUuid": "62eda937_6501e2e7",
      "range": {
        "startLine": 655,
        "startChar": 2,
        "endLine": 655,
        "endChar": 19
      },
      "revId": "7fd920184a3489ad772df19aaffeefc983d3db03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}