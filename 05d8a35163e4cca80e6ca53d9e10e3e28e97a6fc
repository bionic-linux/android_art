{
  "comments": [
    {
      "key": {
        "uuid": "12552618_8cbcc4dc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-06-22T08:31:24Z",
      "side": 1,
      "message": "I think we should be robust here in the presence of exceptions. Can we instead make generic JNI handle that case?",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10449aac_aa6bbf72",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-06-22T13:28:51Z",
      "side": 1,
      "message": "Yeah, if that\u0027s possible, it would probably be better.\n\nNote: Vladimir mentioned in b/34659969 that there\u0027s an issue with non-generic JNI too.",
      "parentUuid": "12552618_8cbcc4dc",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d05d5cd_5a52f283",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-06-22T13:30:15Z",
      "side": 1,
      "message": "Do you still want to push for this change, or should we look at whether making it robust is possible?",
      "parentUuid": "10449aac_aa6bbf72",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ef0a2f5c_76d9b111",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-22T14:28:07Z",
      "side": 1,
      "message": "Why wouldn\u0027t regular JNI be hit by this as well? I am not sure I see how it\u0027s generic JNI specific?\n\nRegular JNI could also hit it from the DCHECK no?",
      "parentUuid": "7d05d5cd_5a52f283",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8269d7c8_bfc5e523",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-06-22T14:31:03Z",
      "side": 1,
      "message": "Is regular JNI checking the annotation? I thought we don\u0027t, as regular JNI know for what kind of JNI ABI it\u0027s been compiled for.",
      "parentUuid": "ef0a2f5c_76d9b111",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "863be574_9126fa47",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-22T14:58:47Z",
      "side": 1,
      "message": "It checks it via DCHECKs, which will happen increasingly more with our fast-debug builds being used by non-art team members.",
      "parentUuid": "8269d7c8_bfc5e523",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6afb25a7_0b8aa651",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-06-22T15:16:29Z",
      "side": 1,
      "message": "You need to fix up a callee-save frame at the top of the stack.\n\n *sp \u003d Runtime::Current()-\u003eGetCalleeSaveMethod(CalleeSaveType::kSaveRefAndArgs);\n self-\u003eSetTopOfStack(sp);\n\nat the start of artQuickGenericJniTrampoline. That should show the callee-save frame during the resolution stages, instead of an incomplete method frame.\n\nNote: the generic-jni code is really not written with expectations of exceptions in that early code.",
      "parentUuid": "863be574_9126fa47",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6357fd55_144542e9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-06-22T15:17:54Z",
      "side": 1,
      "message": "(Alternatively, change the signature of artQuickGenericJniTrampoline to also pass the ArtMethod, and emit the callee-save like normal, i.e., write and install the runtime method)",
      "parentUuid": "6afb25a7_0b8aa651",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "836e09c4_13f9ba68",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-22T15:35:53Z",
      "side": 1,
      "message": "That sounds much more complicated than just doing it the way it\u0027s done now.",
      "parentUuid": "6357fd55_144542e9",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5c7d8eb0_024da091",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-06-22T17:16:01Z",
      "side": 1,
      "message": "The way it\u0027s done in this CL doesn\u0027t scale - I don\u0027t trust all the code we\u0027re running during that annotation lookup is interruption free, or exception free. And given the code it\u0027s going into, I could easily see someone change the behavior to again potentially throw an exception.\n\nAndreas: are you saying the generic JNI *could not* handle exceptions? Or that we haven\u0027t tested it?",
      "parentUuid": "836e09c4_13f9ba68",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a6b734eb_db602b01",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-22T17:28:28Z",
      "side": 1,
      "message": "That\u0027s an excellent point, Nicolas.\n\nI think I would tend to agree the complexity seems like it would be worth it in this case.\n\nIt would probably need to be implemented for both regular JNI as well as generic JNI, and we need to have a test to exercise this \"ignore exception\" functionality is working correctly.",
      "parentUuid": "5c7d8eb0_024da091",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b62a811e_839ad585",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-06-22T17:37:26Z",
      "side": 1,
      "message": "Re Nicolas: Generic JNI was written under the assumption that there are no throws will creating the final JNI frame - which was true until the annotation code was added. So it was OK to leave a \"wrong\" stack frame on the stack (and not even complete the ManagedStack fragment). There were no suspend points, so nobody could ask to walk the stack. I should have asserted that in the code (as-is, it will not work), but again, it wasn\u0027t necessary because it was obvious. :-)\n\nRe Igor: This doesn\u0027t need a fix in regular JNI. Again, if I understand correctly, the issue here is that we throw an exception (which wants to walk the stack) when the stack is invalid. I *believe* that the stack frame is correct for compiled JNI at the point we go into the runtime for DCHECKs. The compiler *knows* the frame layout, so it can emit the final layout on entry. Generic JNI does *not* know the layout until it can inspect the method. So the assembly stub plops don\u0027t a callee-save frame for the registers and expands with a scratch area.\n\nI could have been more careful before, and correctly install that callee-save frame. That requires to not write the actual method being called into it, but the runtime method, and to finish the ManagedStack fragment. Both will be fixed up when creating the real JNI frame layout, so I skipped it as superfluous.",
      "parentUuid": "a6b734eb_db602b01",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5dfe7b06_581ad454",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-22T17:42:18Z",
      "side": 1,
      "message": "\u003e Re Igor: This doesn\u0027t need a fix in regular JNI. Again, if I understand correctly, the issue here is that we throw an exception (which wants to walk the stack) when the stack is invalid. I *believe* that the stack frame is correct for compiled JNI at the point we go into the runtime for DCHECKs. The compiler *knows* the frame layout, so it can emit the final layout on entry. Generic JNI does *not* know the layout until it can inspect the method. So the assembly stub plops don\u0027t a callee-save frame for the registers and expands with a scratch area.\n\nWhat if JniMethodEnd throws an exception? Then the transition will see that there\u0027s an exception and throw it, when in reality there was no exception generated from the user code.",
      "parentUuid": "b62a811e_839ad585",
      "range": {
        "startLine": 12,
        "startChar": 31,
        "endLine": 13,
        "endChar": 52
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4895c4e7_f4a980b6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-06-22T13:28:51Z",
      "side": 1,
      "message": "This CL is lacking a non-regression test; I\u0027ll carve one out from the scenario seen in b/38454151.",
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "53ba188c_3e668ba4",
        "filename": "runtime/art_method.h",
        "patchSetId": 1
      },
      "lineNbr": 732,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T17:17:19Z",
      "side": 1,
      "message": "nit: It\u0027s not a hint. @CriticalNative changes the calling convention.\n\nSo please consider e.g. \"IsAnnotatedWithOptimization\" ?",
      "range": {
        "startLine": 732,
        "startChar": 7,
        "endLine": 732,
        "endChar": 38
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c153565_51b32b25",
        "filename": "runtime/art_method.h",
        "patchSetId": 1
      },
      "lineNbr": 732,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-06-22T13:28:51Z",
      "side": 1,
      "message": "Sure; done in PS2.",
      "parentUuid": "53ba188c_3e668ba4",
      "range": {
        "startLine": 732,
        "startChar": 7,
        "endLine": 732,
        "endChar": 38
      },
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "532fa080_fdb43386",
        "filename": "runtime/dex_file_annotations.cc",
        "patchSetId": 1
      },
      "lineNbr": 787,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T17:23:53Z",
      "side": 1,
      "message": "Why isn\u0027t this using the klass\u0027s classloader? It\u0027ll still be null for criticalnative/fastnative won\u0027t it?\n\nAnd if something else uses this function later it might be surprising that allow_class_resolution\u003dfalse also restricts it to only the bootclasspath classloader.",
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c70af2b8_8e915192",
        "filename": "runtime/dex_file_annotations.cc",
        "patchSetId": 1
      },
      "lineNbr": 787,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-06-22T13:28:51Z",
      "side": 1,
      "message": "IIUC, in that context, `klass` is the declaring class of the method holding the annotations, so the associated class loader might not be the bootstrap class loader.\n\nI agree the name `allow_class_resolution` is probably not the best; maybe we should switch to something like `lookup_in_resolved_boot_classes`?",
      "parentUuid": "532fa080_fdb43386",
      "revId": "05d8a35163e4cca80e6ca53d9e10e3e28e97a6fc",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}