#!/usr/bin/python3.4
#
# Copyright (C) 2017 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Regenerate the following files:
#   src/Generated.java
#   src/Test.java
#   expected.profile.txt
#   expected.no-profile.txt
#   profile
#
# Usage:
#   $> cd into this directory
#   $> ./gen.py [--dev]
#
# (blank output means success, use `git diff` to validate)
#
from string import ascii_lowercase, ascii_uppercase, Template
from collections import namedtuple

import argparse
import sys

MethodHotness = namedtuple('MethodHotness', ['name', 'abbr', 'value'])

#####################
# GENERATION CONFIG #
#####################

# See ProfileCompilationInfo::MethodHotness in profile_compilation_info.h for names and digits.
# See profman.cc (kMethodFlagString*) for the one letter abbreviations.
METHOD_HOTNESS = [ MethodHotness('Hot', 'H', 0x1),
                   MethodHotness('Startup', 'S', 0x2),
                   MethodHotness('Poststartup', 'P', 0x4) ]

# Generate # classes A,B,C,...
NUM_BASE_CLASSES = 3
# Generate # methods m_a, m_b, m_c... X # of hotness combinations.
NUM_BASE_METHODS = 3

# How much to indent (see also below templates).
NUM_INDENT = 2

HEADER_STRING = """
// Copyright (C) 2017 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// DO NOT MODIFY: AUTOGENERATED BY gen.py
""".strip()

REFLECTION_METHOD_TEMPLATE = Template(
"""$HEADER
import java.lang.reflect.Method;

public class Test {
  public static Method[] getTestMethods() throws NoSuchMethodException, SecurityException {
    Method[] all_methods = new Method[$ARRAY_LENGTH];
$GET_DECLARED_METHODS_BODY
    return all_methods;
  }
}
""")

#####################
#     END CONFIG    #
#####################
class JavaMethod:
  def __init__(self, kls_name, name, hotness_list):
    self.kls_name = kls_name
    self.name = name
    self.hotness_list = hotness_list

  def format_method_definition(self):
    return "void %s() { System.out.println(\"Don't dedupe me! %s\"); }" %(self.format_name_only(), self.format_method_reference())

  # This must match the regular layout order of oat files.
  # Sort by class_def_idx first, then sort by the method_idx.
  def sort_key_name(self):
    # Note: Methods are lexicographically sorted within a class.
    # A class name is ordered by the class_def_idx within dx, even though it's not required in
    # the dex format specification.
    return "%s#%s" %(self.kls_name, self.format_name_only())

  # This must match the profile-guided layout order of OAT files.
  # Sort by the method hotness first, then sort by the regular order above.
  def sort_key_hotness(self):
    # sort by hotness first.
    # then sort by the regular class name / method name.
    return "%s#%s" %(chr(self.hotness_mask()), self.sort_key_name())

  def format_name_only(self):
    combo = [i and i.name or "" for i in self.hotness_list]
    combo_str = ["$" + i for i in combo]
    combo_str = "".join(combo_str)
    return "%s%s" %(self.name, combo_str)

  # e.g. "SPLjava/lang/Comparable;->compareTo(Ljava/lang/Object;)I"
  def format_profile(self):
    hotness_string = "".join([i and i.abbr or "" for i in self.hotness_list])
    return "%sL%s;->%s()V" %(hotness_string, self.kls_name, self.format_name_only())

  # e.g. ClassName::MethodName
  def format_method_reference(self):
    return "%s::%s" %(self.kls_name, self.format_name_only())

  def hotness_mask(self):
    mask = 0
    for hotness in self.hotness_list:
      if not hotness:
        continue
      mask = mask | hotness.value

    return mask

class JavaClass:
  def __init__(self, kls_name, method_list):
    self.kls_name = kls_name
    self.method_list = method_list

  def _methods_string(self, indent_sz):
    return "\n".join([indent(i.format_method_definition(), indent_sz) for i in self.method_list])

  def format_class_definition(self, indent_sz=0):
    return ("class %s {\n"
            "%s"
            "\n}") %(self.kls_name, self._methods_string(indent_sz + NUM_INDENT))

def generate_powerset(lst):
  if not lst:
    return

  if len(lst) == 1:
    yield [None]
    yield lst[0:1]
    return

  remaining = lst[1::]

  for c in generate_powerset(remaining):
    yield [None] + c
    yield lst[0:1] + c

def generate_methods(kls_name):
  hotness_list = [k[0] for k in METHOD_HOTNESS]

  idx = 0
  for c in ascii_lowercase:
    if idx >= NUM_BASE_CLASSES:
      break
    idx = idx + 1

    method_base_name = 'm_%s' %(c)
    for combo in generate_powerset(METHOD_HOTNESS):
      yield JavaMethod(kls_name, method_base_name, combo)


def indent(what, size=2):
  return " " * size + what;

def generate_classes(indent_sz=0):
  idx = 0
  for c in ascii_uppercase:
    if idx >= NUM_BASE_CLASSES:
      break
    idx = idx + 1

    kls_name = c
    methods_list = [i for i in generate_methods(kls_name)]
    yield JavaClass(kls_name, methods_list)

def sort_by_class_name_and_method_name(method_list):
  return sorted(method_list, key=lambda x: x.sort_key_name())

def sort_by_hotness(method_list):
  return sorted(method_list, key=lambda x: x.sort_key_hotness())

def format_test_class_string(method_list, indent_sz=2):
  body = []

  idx = 0
  for m in method_list:
    code_str = 'all_methods[%d] = %s.class.getDeclaredMethod("%s");' %(idx, m.kls_name, m.format_name_only())
    idx = idx + 1
    body.append(indent(code_str, indent_sz + NUM_INDENT))

  return REFLECTION_METHOD_TEMPLATE.substitute(HEADER=HEADER_STRING,
          ARRAY_LENGTH=len(method_list),
          GET_DECLARED_METHODS_BODY="\n".join(body))

def main(argv):
  parser = argparse.ArgumentParser(description="Re-generate the expecteds, profile, and source java files.")
  parser.add_argument("--dev", "-d", help="dev mode, print everything to stdout", action="store_true")
  args = parser.parse_args()

  if args.dev:
    output_file_src_generated = sys.stdout
    output_file_src_test = sys.stdout
    output_file_expected_default = sys.stdout
    output_file_expected_profile = sys.stdout
    output_file_profile = sys.stdout

    debug_file = sys.stderr
  else:
    output_file_src_generated = open("src/Generated.java", "w")
    output_file_src_test = open("src/Test.java", "w")
    output_file_expected_default = open("expected.no-profile.txt", "w")
    output_file_expected_profile = open("expected.profile.txt", "w")
    output_file_profile = open("profile", "w")

    debug_file = open("/dev/null", "w")

  hotness_list = [k for k in METHOD_HOTNESS]

  for hotness_combo in generate_powerset(hotness_list):
    print("Hotness combo: ", end="", file=debug_file);
    print(hotness_combo, file=debug_file)

  print("===== JAVA DEFINITIONS ==========", file=debug_file)

  print(HEADER_STRING, file=output_file_src_generated)
  for kls in generate_classes():
    print(kls.format_class_definition(), file=output_file_src_generated)

  print("=======ALL METHODS    ===========", file=debug_file)

  all_methods = []
  for kls in generate_classes():
    for method in kls.method_list:
      all_methods.append(method)

  print(format_test_class_string(all_methods), file=output_file_src_test)

  print("======= PROFILE ===========", file=debug_file)
  for i in all_methods:
    # profiles must NOT include methods with 0 hotness.
    # i.e. "HMethodName()" is equivalent to "MethodName", both of which are considered "Hot".
    skip = i.hotness_mask() == 0
    maybe_output_file_profile = skip and debug_file or output_file_profile
    prefix = skip and "[SKIPPED]" or ""
    print("%s%s" %(prefix, i.format_profile()), file=maybe_output_file_profile)

  print("======= SORTED (class_idx, method_idx)  ===========", file=debug_file)
  # dx appears to sort classes alphabetically when figuring out class_def_idx
  # and method_idx is guaranteed to be sorted by dex specification
  sorted_class_and_method_list = sort_by_class_name_and_method_name(all_methods)
  for i in sorted_class_and_method_list:
    print(i.format_method_reference(), file=output_file_expected_default)

  print("======= SORTED HOTNESS ===========", file=debug_file)
  sorted_hotness_list = sort_by_hotness(all_methods)
  for i in sorted_hotness_list:
    # interleave stdout/stderr by flushing the output with every print.
    print(i.format_method_reference(), end="", file=output_file_expected_profile, flush=True)
    # this goes to debug but we see it on the same line as normal output, for readability.
    print(" // hotness=%d" %(i.hotness_mask()), end="", file=debug_file, flush=True)
    print("", file=output_file_expected_profile, flush=True)

  return 0

sys.exit(main(sys.argv))
