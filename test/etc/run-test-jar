#!/usr/bin/env python3
#
# Copyright (C) 2022 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys, os, shutil, shlex, re, subprocess, glob
from apex_bootclasspath_utils import get_apex_bootclasspath, get_apex_bootclasspath_locations
from os import path
from os.path import isfile, isdir
from typing import List
from subprocess import DEVNULL, PIPE, STDOUT

def export(env: str, value: str) -> None:
  os.environ[env] = value
  if env in globals():
    globals()[env] = value

# Script debugging: Record executed commands into the given directory.
# This is useful to ensure that changes to the script don't change behaviour.
# (the commands are appended so the directory needs to be cleared before run)
ART_TEST_CMD_DIR = os.environ.get("ART_TEST_CMD_DIR")

# Script debugging: Record executed commands, but don't actually run the main test.
# This makes it possible the extract the test commands without waiting for days.
# This will make tests fail since there is no stdout.  Use with large -j value.
ART_TEST_DRY_RUN = os.environ.get("ART_TEST_DRY_RUN")

def run(cmdline: str, capture_output=True, check=True, save_cmd=True) -> subprocess.CompletedProcess:
  if ART_TEST_CMD_DIR and save_cmd and cmdline != "true":
    tmp = os.environ["DEX_LOCATION"]
    with open(os.path.join(ART_TEST_CMD_DIR, os.environ["FULL_TEST_NAME"]), "a") as f:
      env_ignore = ["SHLVL", "_", "ART_TOOLS_BUILD_VAR_CACHE", "PWD", "OLDPWD", "TMUX", "TMUX_PANE"]
      env = {k: v for k, v in sorted(os.environ.items()) if k not in env_ignore}
      # Replace DEX_LOCATION (which is randomly generated temporary directory),
      # with a deterministic placeholder so that we can do a diff from run to run.
      f.write("\n".join(k + ":" + v.replace(tmp, "<tmp>") for k, v in env.items()) + "\n\n")
      f.write(re.sub(" +", "\n", cmdline).replace(tmp, "<tmp>") + "\n\n")
    if ART_TEST_DRY_RUN and ("dalvikvm" in cmdline or "adb shell chroot" in cmdline):
      cmdline = "true"  # We still need to run some command, so run the no-op "true" binary instead.
  proc = subprocess.run([cmdline],
                        shell=True,
                        encoding="utf8",
                        capture_output=capture_output)
  if check and proc.returncode != 0:
    print(proc.stdout or "", file=sys.stdout, flush=True)
    print("$ " + cmdline + "\n", file=sys.stderr)
    print(proc.stderr or "", file=sys.stderr, flush=True)
    raise Exception("Command returned exit code {}".format(proc.returncode))
  return proc

class Adb():
  def root(self) -> None:
    run("adb root")
  def wait_for_device(self) -> None:
    run("adb wait-for-device")
  def shell(self, cmdline: str, **kwargs) -> subprocess.CompletedProcess:
    return run("adb shell " + cmdline, **kwargs)
  def push(self, src: str, dst: str, **kwargs) -> None:
    run(f"adb push {src} {dst}", **kwargs)

adb = Adb()

local_path=os.path.dirname(__file__)

# Check that stdout is connected to a terminal and that we have at least 1 color.
# This ensures that if the stdout is not connected to a terminal and instead
# the stdout will be used for a log, it will not append the color characters.
bold_red=""
if sys.stdout.isatty():
  if int(run("tput colors", save_cmd=False).stdout) >= 1:
    bold_red=run("tput bold", save_cmd=False).stdout.strip()
    bold_red+=run("tput setaf 1", save_cmd=False).stdout.strip()

def error_msg(msg: str):
  print(f"{bold_red}ERROR: {msg}")

ANDROID_BUILD_TOP = os.environ.get("ANDROID_BUILD_TOP")
ANDROID_DATA = os.environ.get("ANDROID_DATA")
ANDROID_HOST_OUT = os.environ["ANDROID_HOST_OUT"]
ANDROID_LOG_TAGS = os.environ.get("ANDROID_LOG_TAGS", "")
ART_TIME_OUT_MULTIPLIER = int(os.environ.get("ART_TIME_OUT_MULTIPLIER", 1))
DEX2OAT = os.environ.get("DEX2OAT", "")
DEX_LOCATION = os.environ["DEX_LOCATION"]
JAVA = os.environ.get("JAVA")
OUT_DIR = os.environ.get("OUT_DIR")
PATH = os.environ.get("PATH", "")
SANITIZE_HOST = os.environ.get("SANITIZE_HOST", "")
TEST_NAME = os.environ["TEST_NAME"]
USE_EXRACTED_ZIPAPEX = os.environ.get("USE_EXRACTED_ZIPAPEX", "")

if not ANDROID_BUILD_TOP:
  error_msg('ANDROID_BUILD_TOP environment variable is empty; did you forget to run `lunch`?')
  sys.exit(1)

def msg(msg: str):
    if not QUIET:
        print(msg)

ANDROID_ROOT="/system"
ANDROID_ART_ROOT="/apex/com.android.art"
ANDROID_I18N_ROOT="/apex/com.android.i18n"
ANDROID_TZDATA_ROOT="/apex/com.android.tzdata"
ARCHITECTURES_32="(arm|x86|none)"
ARCHITECTURES_64="(arm64|x86_64|none)"
ARCHITECTURES_PATTERN=ARCHITECTURES_32
GET_DEVICE_ISA_BITNESS_FLAG="--32"
BOOT_IMAGE=""
CHROOT=""
COMPILE_FLAGS=""
DALVIKVM="dalvikvm32"
DEBUGGER="n"
WITH_AGENT=[]
DEBUGGER_AGENT=""
WRAP_DEBUGGER_AGENT=False
DEV_MODE=False
DEX2OAT_NDEBUG_BINARY="dex2oat32"
DEX2OAT_DEBUG_BINARY="dex2oatd32"
EXPERIMENTAL=[]
FALSE_BIN="false"
FLAGS=""
ANDROID_FLAGS=""
GDB=""
GDB_ARGS=""
GDB_DEX2OAT=""
GDB_DEX2OAT_ARGS=""
GDBSERVER_DEVICE="gdbserver"
GDBSERVER_HOST="gdbserver"
HAVE_IMAGE=True
HOST=False
BIONIC=False
CREATE_ANDROID_ROOT=False
USE_ZIPAPEX=False
ZIPAPEX_LOC=""
USE_EXTRACTED_ZIPAPEX=False
EXTRACTED_ZIPAPEX_LOC=""
INTERPRETER=False
JIT=False
INVOKE_WITH=""
IS_JVMTI_TEST=False
ADD_LIBDIR_ARGUMENTS=False
SUFFIX64=""
ISA="x86"
LIBRARY_DIRECTORY="lib"
TEST_DIRECTORY="nativetest"
MAIN=""
OPTIMIZE=True
PREBUILD=True
QUIET=False
RELOCATE=False
SECONDARY_DEX=""
TIME_OUT="n"  # "n" (disabled), "timeout" (use timeout), "gdb" (use gdb)
TIMEOUT_DUMPER="signal_dumper"
# Values in seconds.
TIME_OUT_EXTRA=0
TIME_OUT_VALUE=0
USE_GDB=False
USE_GDBSERVER=False
GDBSERVER_PORT=":5039"
USE_GDB_DEX2OAT=False
USE_JVM=False
USE_JVMTI=False
VERIFY="y" # y=yes,n=no,s=softfail
ZYGOTE=""
DEX_VERIFY=""
INSTRUCTION_SET_FEATURES=""
ARGS=""
VDEX_ARGS=""
EXTERNAL_LOG_TAGS=False # if True respect externally set ANDROID_LOG_TAGS.
DRY_RUN=False # if True prepare to run the test but don't run it.
TEST_VDEX=False
TEST_DEX2OAT_DM=False
TEST_RUNTIME_DM=False
TEST_IS_NDEBUG=False
APP_IMAGE=True
SECONDARY_APP_IMAGE=True
SECONDARY_CLASS_LOADER_CONTEXT=""
SECONDARY_COMPILATION=True
JVMTI_STRESS=False
JVMTI_STEP_STRESS=False
JVMTI_FIELD_STRESS=False
JVMTI_TRACE_STRESS=False
JVMTI_REDEFINE_STRESS=False
PROFILE=False
RANDOM_PROFILE=False
# The normal dex2oat timeout.
DEX2OAT_TIMEOUT=300 # 5 mins
# The *hard* timeout where we really start trying to kill the dex2oat.
DEX2OAT_RT_TIMEOUT=360 # 6 mins
CREATE_RUNNER=False
INT_OPTS=""
SIMPLEPERF=False
DEBUGGER_OPTS=""
JVM_VERIFY_ARG=""

# if True, run 'sync' before dalvikvm to make sure all files from
# build step (e.g. dex2oat) were finished writing.
SYNC_BEFORE_RUN=False

# When running a debug build, we want to run with all checks.
ANDROID_FLAGS+=" -XX:SlowDebug=true"
# The same for dex2oatd, both prebuild and runtime-driven.
ANDROID_FLAGS+=" -Xcompiler-option --runtime-arg -Xcompiler-option -XX:SlowDebug=true"
COMPILER_FLAGS="  --runtime-arg -XX:SlowDebug=true"

# Let the compiler and runtime know that we are running tests.
COMPILE_FLAGS+=" --compile-art-test"
ANDROID_FLAGS+=" -Xcompiler-option --compile-art-test"

RUNTIME_OPTIONS=""
COMPACT_DEX_LEVEL=""

args = list(sys.argv)
arg = ""
def shift():
  global arg
  args.pop(0)
  arg = args[0] if args else None
shift()
while arg:
    if arg == "--quiet":
        QUIET=True
        shift()
    elif arg == "--dex2oat-rt-timeout":
        shift()
        if arg == "":
            error_msg("missing argument to --dex2oat-rt-timeout")
            sys.exit(1)
        DEX2OAT_RT_TIMEOUT=int(arg)
        shift()
    elif arg == "--dex2oat-timeout":
        shift()
        if arg == "":
            error_msg("missing argument to --dex2oat-timeout")
            sys.exit(1)
        DEX2OAT_TIMEOUT=int(arg)
        shift()
    elif arg == "--jvmti":
        USE_JVMTI=True
        IS_JVMTI_TEST=True
        # Secondary images block some tested behavior.
        SECONDARY_APP_IMAGE=False
        shift()
    elif arg == "--add-libdir-argument":
        ADD_LIBDIR_ARGUMENTS=True
        shift()
    elif arg == "-O":
        TEST_IS_NDEBUG=True
        shift()
    elif arg == "--lib":
        shift()
        if arg == "":
            error_msg("missing argument to --lib")
            sys.exit(1)
        LIB=arg
        shift()
    elif arg == "--gc-stress":
        # Give an extra 20 mins if we are gc-stress.
        TIME_OUT_EXTRA+=1200
        shift()
    elif arg == "--testlib":
        shift()
        if arg == "":
            error_msg("missing argument to --testlib")
            sys.exit(1)
        ARGS+=f" {arg}"
        shift()
    elif arg == "--args":
        shift()
        if arg == "":
            error_msg("missing argument to --args")
            sys.exit(1)
        ARGS+=f" {arg}"
        shift()
    elif arg == "--compiler-only-option":
        shift()
        option=arg
        COMPILE_FLAGS+=f" {option}"
        shift()
    elif arg == "-Xcompiler-option":
        shift()
        option=arg
        FLAGS+=f" -Xcompiler-option {option}"
        COMPILE_FLAGS+=f" {option}"
        shift()
    elif arg == "--create-runner":
        CREATE_RUNNER=True
        shift()
    elif arg == "--android-runtime-option":
        shift()
        option=arg
        ANDROID_FLAGS+=f" {option}"
        shift()
    elif arg == "--runtime-option":
        shift()
        option=arg
        RUNTIME_OPTIONS+=f" {option}"
        if option == "-Xmethod-trace":
            # Method tracing can slow some tests down a lot.
            TIME_OUT_EXTRA+=1200
        shift()
    elif arg == "--boot":
        shift()
        BOOT_IMAGE=arg
        shift()
    elif arg == "--relocate":
        RELOCATE=True
        shift()
    elif arg == "--no-relocate":
        RELOCATE=False
        shift()
    elif arg == "--prebuild":
        PREBUILD=True
        shift()
    elif arg == "--compact-dex-level":
        shift()
        COMPACT_DEX_LEVEL+=f" --compact-dex-level={arg}"
        shift()
    elif arg == "--jvmti-redefine-stress":
        # APP_IMAGE doesn't really work with jvmti redefine stress
        USE_JVMTI=True
        APP_IMAGE=False
        SECONDARY_APP_IMAGE=False
        JVMTI_STRESS=True
        JVMTI_REDEFINE_STRESS=True
        shift()
    elif arg == "--jvmti-step-stress":
        USE_JVMTI=True
        JVMTI_STRESS=True
        JVMTI_STEP_STRESS=True
        shift()
    elif arg == "--jvmti-field-stress":
        USE_JVMTI=True
        JVMTI_STRESS=True
        JVMTI_FIELD_STRESS=True
        shift()
    elif arg == "--jvmti-trace-stress":
        USE_JVMTI=True
        JVMTI_STRESS=True
        JVMTI_TRACE_STRESS=True
        shift()
    elif arg == "--no-app-image":
        APP_IMAGE=False
        shift()
    elif arg == "--no-secondary-app-image":
        SECONDARY_APP_IMAGE=False
        shift()
    elif arg == "--secondary-class-loader-context":
        shift()
        SECONDARY_CLASS_LOADER_CONTEXT=arg
        shift()
    elif arg == "--no-secondary-compilation":
        SECONDARY_COMPILATION=False
        shift()
    elif arg == "--host":
        HOST=True
        ANDROID_ROOT=ANDROID_HOST_OUT
        ANDROID_ART_ROOT=f"{ANDROID_HOST_OUT}/com.android.art"
        ANDROID_I18N_ROOT=f"{ANDROID_HOST_OUT}/com.android.i18n"
        ANDROID_TZDATA_ROOT=f"{ANDROID_HOST_OUT}/com.android.tzdata"
        # On host, we default to using the symlink, as the PREFER_32BIT
        # configuration is the only configuration building a 32bit version of
        # dex2oat.
        DEX2OAT_DEBUG_BINARY="dex2oatd"
        DEX2OAT_NDEBUG_BINARY="dex2oat"
        shift()
    elif arg == "--bionic":
        BIONIC=True
        # We need to create an ANDROID_ROOT because currently we cannot create
        # the frameworks/libcore with linux_bionic so we need to use the normal
        # host ones which are in a different location.
        CREATE_ANDROID_ROOT=True
        shift()
    elif arg == "--runtime-extracted-zipapex":
        shift()
        USE_EXTRACTED_ZIPAPEX=True
        EXTRACTED_ZIPAPEX_LOC=arg
        shift()
    elif arg == "--runtime-zipapex":
        shift()
        USE_ZIPAPEX=True
        ZIPAPEX_LOC=arg
        # TODO (b/119942078): Currently apex does not support
        # symlink_preferred_arch so we will not have a dex2oatd to execute and
        # need to manually provide
        # dex2oatd64.
        DEX2OAT_DEBUG_BINARY="dex2oatd64"
        shift()
    elif arg == "--no-prebuild":
        PREBUILD=False
        shift()
    elif arg == "--no-image":
        HAVE_IMAGE=False
        shift()
    elif arg == "--secondary":
        SECONDARY_DEX=f":{DEX_LOCATION}/{TEST_NAME}-ex.jar"
        # Enable cfg-append to make sure we get the dump for both dex files.
        # (otherwise the runtime compilation of the secondary dex will overwrite
        # the dump of the first one).
        FLAGS+=" -Xcompiler-option --dump-cfg-append"
        COMPILE_FLAGS+=" --dump-cfg-append"
        shift()
    elif arg == "--with-agent":
        shift()
        USE_JVMTI=True
        WITH_AGENT.append(arg)
        shift()
    elif arg == "--debug-wrap-agent":
        WRAP_DEBUGGER_AGENT=True
        shift()
    elif arg == "--debug-agent":
        shift()
        DEBUGGER="agent"
        USE_JVMTI=True
        DEBUGGER_AGENT=arg
        TIME_OUT="n"
        shift()
    elif arg == "--debug":
        USE_JVMTI=True
        DEBUGGER="y"
        TIME_OUT="n"
        shift()
    elif arg == "--gdbserver-port":
        shift()
        GDBSERVER_PORT=arg
        shift()
    elif arg == "--gdbserver-bin":
        shift()
        GDBSERVER_HOST=arg
        GDBSERVER_DEVICE=arg
        shift()
    elif arg == "--gdbserver":
        USE_GDBSERVER=True
        DEV_MODE=True
        TIME_OUT="n"
        shift()
    elif arg == "--gdb":
        USE_GDB=True
        DEV_MODE=True
        TIME_OUT="n"
        shift()
    elif arg == "--gdb-arg":
        shift()
        gdb_arg=arg
        GDB_ARGS+=f" {gdb_arg}"
        shift()
    elif arg == "--gdb-dex2oat":
        USE_GDB_DEX2OAT=True
        DEV_MODE=True
        TIME_OUT="n"
        shift()
    elif arg == "--gdb-dex2oat-args":
        shift()
        for arg in arg.split(";"):
          GDB_DEX2OAT_ARGS+=f"{arg} "
        shift()
    elif arg == "--zygote":
        ZYGOTE="-Xzygote"
        msg("Spawning from zygote")
        shift()
    elif arg == "--dev":
        DEV_MODE=True
        shift()
    elif arg == "--interpreter":
        INTERPRETER=True
        shift()
    elif arg == "--jit":
        JIT=True
        shift()
    elif arg == "--baseline":
        FLAGS+=" -Xcompiler-option --baseline"
        COMPILE_FLAGS+=" --baseline"
        shift()
    elif arg == "--jvm":
        USE_JVM=True
        shift()
    elif arg == "--invoke-with":
        shift()
        if arg == "":
            error_msg("missing argument to --invoke-with")
            sys.exit(1)
        if INVOKE_WITH == "":
            INVOKE_WITH=arg
        else:
            INVOKE_WITH+=f" {arg}"
        shift()
    elif arg == "--no-verify":
        VERIFY="n"
        shift()
    elif arg == "--verify-soft-fail":
        VERIFY="s"
        shift()
    elif arg == "--no-optimize":
        OPTIMIZE=False
        shift()
    elif arg == "--chroot":
        shift()
        CHROOT=arg
        shift()
    elif arg == "--simpleperf":
        SIMPLEPERF=True
        shift()
    elif arg == "--android-root":
        shift()
        ANDROID_ROOT=arg
        shift()
    elif arg == "--android-i18n-root":
        shift()
        ANDROID_I18N_ROOT=arg
        shift()
    elif arg == "--android-art-root":
        shift()
        ANDROID_ART_ROOT=arg
        shift()
    elif arg == "--android-tzdata-root":
        shift()
        ANDROID_TZDATA_ROOT=arg
        shift()
    elif arg == "--instruction-set-features":
        shift()
        INSTRUCTION_SET_FEATURES=arg
        shift()
    elif arg == "--timeout":
        shift()
        TIME_OUT_VALUE=int(arg)
        shift()
    elif arg == "--":
        shift()
        break
    elif arg == "--64":
        SUFFIX64="64"
        ISA="x86_64"
        GDBSERVER_DEVICE="gdbserver64"
        DALVIKVM="dalvikvm64"
        LIBRARY_DIRECTORY="lib64"
        TEST_DIRECTORY="nativetest64"
        ARCHITECTURES_PATTERN=ARCHITECTURES_64
        GET_DEVICE_ISA_BITNESS_FLAG="--64"
        DEX2OAT_NDEBUG_BINARY="dex2oat64"
        DEX2OAT_DEBUG_BINARY="dex2oatd64"
        shift()
    elif arg == "--experimental":
        if len(args) < 2:
            error_msg("missing --experimental option")
            sys.exit(1)
        shift()
        EXPERIMENTAL.append(arg)
        shift()
    elif arg == "--external-log-tags":
        EXTERNAL_LOG_TAGS=True
        shift()
    elif arg == "--dry-run":
        DRY_RUN=True
        shift()
    elif arg == "--vdex":
        TEST_VDEX=True
        shift()
    elif arg == "--dex2oat-dm":
        TEST_DEX2OAT_DM=True
        shift()
    elif arg == "--runtime-dm":
        TEST_RUNTIME_DM=True
        shift()
    elif arg == "--vdex-filter":
        shift()
        option=arg
        VDEX_ARGS+=f" --compiler-filter={option}"
        shift()
    elif arg == "--vdex-arg":
        shift()
        VDEX_ARGS+=f" {arg}"
        shift()
    elif arg == "--sync":
        SYNC_BEFORE_RUN=True
        shift()
    elif arg == "--profile":
        PROFILE=True
        shift()
    elif arg == "--random-profile":
        RANDOM_PROFILE=True
        shift()
    elif arg.startswith("--"):
        error_msg(f"unknown option: {arg}")
        sys.exit(1)
    else:
        break

FLAGS+=RUNTIME_OPTIONS
COMPILE_FLAGS+=COMPACT_DEX_LEVEL

# HACK: Force the use of `signal_dumper` on host.
if HOST:
  TIME_OUT="timeout"

# If you change this, update the timeout in testrunner.py as well.
if not TIME_OUT_VALUE:
  # 10 minutes is the default.
  TIME_OUT_VALUE=600

  # For sanitized builds use a larger base.
  # TODO: Consider sanitized target builds?
  if SANITIZE_HOST != "":
    TIME_OUT_VALUE=1500  # 25 minutes.

  TIME_OUT_VALUE+=TIME_OUT_EXTRA

# Escape hatch for slow hosts or devices. Accept an environment variable as a timeout factor.
if ART_TIME_OUT_MULTIPLIER:
  TIME_OUT_VALUE*=ART_TIME_OUT_MULTIPLIER

# The DEX_LOCATION with the chroot prefix, if any.
CHROOT_DEX_LOCATION=f"{CHROOT}{DEX_LOCATION}"

# If running on device, determine the ISA of the device.
if not HOST and not USE_JVM:
  ISA=run(f"{ANDROID_BUILD_TOP}/art/test/utils/get-device-isa {GET_DEVICE_ISA_BITNESS_FLAG}",
          save_cmd=False).stdout.strip()

if not USE_JVM:
    FLAGS+=f" {ANDROID_FLAGS}"
    # we don't want to be trying to get adbconnections since the plugin might
    # not have been built.
    FLAGS+=" -XjdwpProvider:none"
    for feature in EXPERIMENTAL:
        FLAGS+=f" -Xexperimental:{feature} -Xcompiler-option --runtime-arg -Xcompiler-option -Xexperimental:{feature}"
        COMPILE_FLAGS=f"{COMPILE_FLAGS} --runtime-arg -Xexperimental:{feature}"

if CREATE_ANDROID_ROOT:
    ANDROID_ROOT=f"{DEX_LOCATION}/android-root"

if not arg:
  MAIN="Main"
else:
  MAIN=arg
  shift()

test_args = (" " + " ".join(args)) if args else ""

if ZYGOTE == "":
    if OPTIMIZE:
        if VERIFY == "y":
            DEX_OPTIMIZE="-Xdexopt:verified"
        else:
            DEX_OPTIMIZE="-Xdexopt:all"
        msg("Performing optimizations")
    else:
        DEX_OPTIMIZE="-Xdexopt:none"
        msg("Skipping optimizations")

    if VERIFY == "y":
        JVM_VERIFY_ARG="-Xverify:all"
        msg("Performing verification")
    elif VERIFY == "s":
        JVM_VERIFY_ARG="Xverify:all"
        DEX_VERIFY="-Xverify:softfail"
        msg("Forcing verification to be soft fail")
    else: # VERIFY == "n"
        DEX_VERIFY="-Xverify:none"
        JVM_VERIFY_ARG="-Xverify:none"
        msg("Skipping verification")

msg("------------------------------")

if DEBUGGER == "y":
  # Use this instead for ddms and connect by running 'ddms':
  # DEBUGGER_OPTS="-XjdwpOptions=server=y,suspend=y -XjdwpProvider:adbconnection"
  # TODO: add a separate --ddms option?

  PORT=12345
  msg("Waiting for jdb to connect:")
  if not HOST:
    msg(f"    adb forward tcp:{PORT} tcp:{PORT}")
  msg(f"    jdb -attach localhost:{PORT}")
  if not USE_JVM:
    # Use the default libjdwp agent. Use --debug-agent to use a custom one.
    DEBUGGER_OPTS=f"-agentpath:libjdwp.so=transport=dt_socket,address={PORT},server=y,suspend=y -XjdwpProvider:internal"
  else:
    DEBUGGER_OPTS=f"-agentlib:jdwp=transport=dt_socket,address={PORT},server=y,suspend=y"
elif DEBUGGER == "agent":
  PORT=12345
  # TODO Support ddms connection and support target.
  if not HOST:
    error_msg("--debug-agent not supported yet for target!")
    sys.exit(1)
  AGENTPATH=DEBUGGER_AGENT
  if WRAP_DEBUGGER_AGENT:
    WRAPPROPS=f"{ANDROID_ROOT}/{LIBRARY_DIRECTORY}/libwrapagentpropertiesd.so"
    if TEST_IS_NDEBUG:
      WRAPPROPS=f"{ANDROID_ROOT}/{LIBRARY_DIRECTORY}/libwrapagentproperties.so"
    AGENTPATH=f"{WRAPPROPS}={ANDROID_BUILD_TOP}/art/tools/libjdwp-compat.props,{AGENTPATH}"
  msg(f"Connect to localhost:{PORT}")
  DEBUGGER_OPTS=f"-agentpath:{AGENTPATH}=transport=dt_socket,address={PORT},server=y,suspend=y"

for agent in WITH_AGENT:
  FLAGS+=f" -agentpath:{agent}"

if USE_JVMTI:
  if not USE_JVM:
    plugin="libopenjdkjvmtid.so"
    if TEST_IS_NDEBUG:
      plugin="libopenjdkjvmti.so"
    # We used to add flags here that made the runtime debuggable but that is not
    # needed anymore since the plugin can do it for us now.
    FLAGS+=f" -Xplugin:{plugin}"

    # For jvmti tests, set the threshold of compilation to 1, so we jit early to
    # provide better test coverage for jvmti + jit. This means we won't run
    # the default --jit configuration but it is not too important test scenario for
    # jvmti tests. This is art specific flag, so don't use it with jvm.
    FLAGS+=" -Xjitthreshold:1"

# Add the libdir to the argv passed to the main function.
if ADD_LIBDIR_ARGUMENTS:
  if HOST:
    ARGS+=f" {ANDROID_HOST_OUT}/{TEST_DIRECTORY}/"
  else:
    ARGS+=f" /data/{TEST_DIRECTORY}/art/{ISA}/"
if IS_JVMTI_TEST:
  agent="libtiagentd.so"
  lib="tiagentd"
  if TEST_IS_NDEBUG:
    agent="libtiagent.so"
    lib="tiagent"

  ARGS+=f" {lib}"
  if USE_JVM:
    FLAGS+=f" -agentpath:{ANDROID_HOST_OUT}/nativetest64/{agent}={TEST_NAME},jvm"
  else:
    FLAGS+=f" -agentpath:{agent}={TEST_NAME},art"

if JVMTI_STRESS:
  agent="libtistressd.so"
  if TEST_IS_NDEBUG:
    agent="libtistress.so"

  # Just give it a default start so we can always add ',' to it.
  agent_args="jvmti-stress"
  if JVMTI_REDEFINE_STRESS:
    # We really cannot do this on RI so don't both passing it in that case.
    if not USE_JVM:
      agent_args=f"{agent_args},redefine"
  if JVMTI_FIELD_STRESS:
    agent_args=f"{agent_args},field"
  if JVMTI_STEP_STRESS:
    agent_args=f"{agent_args},step"
  if JVMTI_TRACE_STRESS:
    agent_args=f"{agent_args},trace"
  # In the future add onto this;
  if USE_JVM:
    FLAGS+=f" -agentpath:{ANDROID_HOST_OUT}/nativetest64/{agent}={agent_args}"
  else:
    FLAGS+=f" -agentpath:{agent}={agent_args}"

if USE_JVM:
  export(f"LD_LIBRARY_PATH", f"{ANDROID_HOST_OUT}/lib64")
  # Some jvmti tests are flaky without -Xint on the RI.
  if IS_JVMTI_TEST:
    FLAGS+=" -Xint"
  # Xmx is necessary since we don't pass down the ART flags to JVM.
  # We pass the classes2 path whether it's used (src-multidex) or not.
  cmdline=f"{JAVA} {DEBUGGER_OPTS} {JVM_VERIFY_ARG} -Xmx256m -classpath classes:classes2 {FLAGS} {MAIN} {test_args} {ARGS}"
  if DEV_MODE:
    print(cmdline)
  if CREATE_RUNNER:
    with open("runit.sh", "w") as f:
      f.write("#!/bin/bash")
      print(f"export LD_LIBRARY_PATH=\"{LD_LIBRARY_PATH}\"")
      f.write(cmdline)
    os.chmod("runit.sh", 0o777)
    pwd = os.getcwd()
    print(f"Runnable test script written to {pwd}/runit.sh")
    sys.exit(0)
  else:
    exit_value=run(cmdline, check=False, capture_output=False).returncode
    sys.exit(exit_value)

b_path=get_apex_bootclasspath(HOST)
b_path_locations=get_apex_bootclasspath_locations(HOST)

BCPEX=""
if isfile(f"{TEST_NAME}-bcpex.jar"):
  BCPEX=f":{DEX_LOCATION}/{TEST_NAME}-bcpex.jar"

# Pass down the bootclasspath
FLAGS+=f" -Xbootclasspath:{b_path}{BCPEX}"
FLAGS+=f" -Xbootclasspath-locations:{b_path_locations}{BCPEX}"
COMPILE_FLAGS+=f" --runtime-arg -Xbootclasspath:{b_path}"
COMPILE_FLAGS+=f" --runtime-arg -Xbootclasspath-locations:{b_path_locations}"

if not HAVE_IMAGE:
    # Disable image dex2oat - this will forbid the runtime to patch or compile an image.
    FLAGS+=" -Xnoimage-dex2oat"

    # We'll abuse a second flag here to test different behavior. If --relocate, use the
    # existing image - relocation will fail as patching is disallowed. If --no-relocate,
    # pass a non-existent image - compilation will fail as dex2oat is disallowed.
    if not RELOCATE:
      BOOT_IMAGE="/system/non-existent/boot.art"
    # App images cannot be generated without a boot image.
    APP_IMAGE=False
DALVIKVM_BOOT_OPT=f"-Ximage:{BOOT_IMAGE}"

if USE_GDB_DEX2OAT:
  if not HOST:
    print("The --gdb-dex2oat option is not yet implemented for target.", file=sys.stderr)
    sys.exit(1)

if USE_GDB:
  if USE_GDBSERVER:
    error_msg("Cannot pass both --gdb and --gdbserver at the same time!")
    sys.exit(1)
  elif not HOST:
    # We might not have any hostname resolution if we are using a chroot.
    GDB=f"{GDBSERVER_DEVICE} --no-startup-with-shell 127.0.0.1{GDBSERVER_PORT}"
  else:
    if run("uname").stdout.strip() == "Darwin":
        GDB="lldb"
        GDB_ARGS+=f" -- {DALVIKVM}"
        DALVIKVM=""
    else:
        GDB="gdb"
        GDB_ARGS+=f" --args {DALVIKVM}"
        # Enable for Emacs "M-x gdb" support. TODO: allow extra gdb arguments on command line.
        # gdbargs=f"--annotate=3 {gdbargs}"
elif USE_GDBSERVER:
  if not HOST:
    # We might not have any hostname resolution if we are using a chroot.
    GDB=f"{GDBSERVER_DEVICE} --no-startup-with-shell 127.0.0.1{GDBSERVER_PORT}"
  else:
    GDB=f"{GDBSERVER_HOST} {GDBSERVER_PORT}"

if INTERPRETER:
    INT_OPTS+=" -Xint"

if JIT:
    INT_OPTS+=" -Xusejit:true"
else:
    INT_OPTS+=" -Xusejit:false"

if INTERPRETER or JIT:
  if VERIFY == "y":
    INT_OPTS+=" -Xcompiler-option --compiler-filter=verify"
    COMPILE_FLAGS+=" --compiler-filter=verify"
  elif VERIFY == "s":
    INT_OPTS+=" -Xcompiler-option --compiler-filter=extract"
    COMPILE_FLAGS+=" --compiler-filter=extract"
    DEX_VERIFY=f"{DEX_VERIFY} -Xverify:softfail"
  else: # VERIFY == "n"
    INT_OPTS+=" -Xcompiler-option --compiler-filter=assume-verified"
    COMPILE_FLAGS+=" --compiler-filter=assume-verified"
    DEX_VERIFY=f"{DEX_VERIFY} -Xverify:none"

JNI_OPTS="-Xjnigreflimit:512 -Xcheck:jni"

COMPILE_FLAGS+=" --runtime-arg -Xnorelocate"
if RELOCATE:
    FLAGS+=" -Xrelocate"
else:
    FLAGS+=" -Xnorelocate"

if BIONIC:
  # This is the location that soong drops linux_bionic builds. Despite being
  # called linux_bionic-x86 the build is actually amd64 (x86_64) only.
  if not path.exists(f"{OUT_DIR}/soong/host/linux_bionic-x86"):
    error_msg("linux_bionic-x86 target doesn't seem to have been built!")
    sys.exit(1)
  # Set TIMEOUT_DUMPER manually so it works even with apex's
  TIMEOUT_DUMPER=f"{OUT_DIR}/soong/host/linux_bionic-x86/bin/signal_dumper"

# Prevent test from silently falling back to interpreter in no-prebuild mode. This happens
# when DEX_LOCATION path is too long, because vdex/odex filename is constructed by taking
# full path to dex, stripping leading '/', appending '@classes.vdex' and changing every
# remaining '/' into '@'.
if HOST:
  max_filename_size=int(run(f"getconf NAME_MAX {DEX_LOCATION}", save_cmd=False).stdout)
else:
  # There is no getconf on device, fallback to standard value.
  # See NAME_MAX in kernel <linux/limits.h>
  max_filename_size=255
# Compute VDEX_NAME.
DEX_LOCATION_STRIPPED=DEX_LOCATION.lstrip("/")
VDEX_NAME=f"{DEX_LOCATION_STRIPPED}@{TEST_NAME}.jar@classes.vdex".replace("/", "@")
if len(VDEX_NAME) > max_filename_size:
    print("Dex location path too long:")
    error_msg(f"{VDEX_NAME} is {len(VDEX_NAME)} character long, and the limit is {max_filename_size}.")
    sys.exit(1)

if HOST:
  # On host, run binaries (`dex2oat(d)`, `dalvikvm`, `profman`) from the `bin`
  # directory under the "Android Root" (usually `out/host/linux-x86`).
  #
  # TODO(b/130295968): Adjust this if/when ART host artifacts are installed
  # under the ART root (usually `out/host/linux-x86/com.android.art`).
  ANDROID_ART_BIN_DIR=f"{ANDROID_ROOT}/bin"
else:
  # On target, run binaries (`dex2oat(d)`, `dalvikvm`, `profman`) from the ART
  # APEX's `bin` directory. This means the linker will observe the ART APEX
  # linker configuration file (`/apex/com.android.art/etc/ld.config.txt`) for
  # these binaries.
  ANDROID_ART_BIN_DIR=f"{ANDROID_ART_ROOT}/bin"

profman_cmdline="true"
dex2oat_cmdline="true"
vdex_cmdline="true"
dm_cmdline="true"
mkdir_locations=f"{DEX_LOCATION}/dalvik-cache/{ISA}"
strip_cmdline="true"
sync_cmdline="true"
linkroot_cmdline="true"
linkroot_overlay_cmdline="true"
setupapex_cmdline="true"
installapex_cmdline="true"
installapex_test_cmdline="true"

def linkdirs(host_out: str, root: str):
  dirs = list(filter(os.path.isdir, glob.glob(os.path.join(host_out, "*"))))
  # Also create a link for the boot image.
  dirs.append(f"{ANDROID_HOST_OUT}/apex/art_boot_images")
  return " && ".join(f"ln -sf {dir} {root}" for dir in dirs)

if CREATE_ANDROID_ROOT:
  mkdir_locations+=f" {ANDROID_ROOT}"
  linkroot_cmdline=linkdirs(ANDROID_HOST_OUT, ANDROID_ROOT)
  if BIONIC:
    # TODO Make this overlay more generic.
    linkroot_overlay_cmdline=linkdirs(f"{OUT_DIR}/soong/host/linux_bionic-x86", ANDROID_ROOT)
  # Replace the boot image to a location expected by the runtime.
  DALVIKVM_BOOT_OPT=f"-Ximage:{ANDROID_ROOT}/art_boot_images/javalib/boot.art"

if USE_ZIPAPEX:
  # TODO Currently this only works for linux_bionic zipapexes because those are
  # stripped and so small enough that the ulimit doesn't kill us.
  mkdir_locations+=f" {DEX_LOCATION}/zipapex"
  zip_options="-qq"
  if DEV_MODE:
    zip_options=""
  setupapex_cmdline=f"unzip -o -u {zip_options} {ZIPAPEX_LOC} apex_payload.zip -d {DEX_LOCATION}"
  installapex_cmdline=f"unzip -o -u {zip_options} {DEX_LOCATION}/apex_payload.zip -d {DEX_LOCATION}/zipapex"
  ANDROID_ART_BIN_DIR=f"{DEX_LOCATION}/zipapex/bin"
elif USE_EXTRACTED_ZIPAPEX:
  # Just symlink the zipapex binaries
  ANDROID_ART_BIN_DIR=f"{DEX_LOCATION}/zipapex/bin"
  # Force since some tests manually run this file twice.
  ln_options=""
  if DEV_MODE:
    ln_options="--verbose"
  # If the {RUN} is executed multiple times we don't need to recreate the link
  installapex_test_cmdline=f"test -L {DEX_LOCATION}/zipapex"
  installapex_cmdline=f"ln -s -f {ln_options} {EXTRACTED_ZIPAPEX_LOC} {DEX_LOCATION}/zipapex"

# PROFILE takes precedence over RANDOM_PROFILE, since PROFILE tests require a
# specific profile to run properly.
if PROFILE or RANDOM_PROFILE:
  profman_cmdline=f"{ANDROID_ART_BIN_DIR}/profman  \
    --apk={DEX_LOCATION}/{TEST_NAME}.jar \
    --dex-location={DEX_LOCATION}/{TEST_NAME}.jar"
  if isfile(f"{TEST_NAME}-ex.jar") and SECONDARY_COMPILATION:
    profman_cmdline=f"{profman_cmdline} \
      --apk={DEX_LOCATION}/{TEST_NAME}-ex.jar \
      --dex-location={DEX_LOCATION}/{TEST_NAME}-ex.jar"
  COMPILE_FLAGS=f"{COMPILE_FLAGS} --profile-file={DEX_LOCATION}/{TEST_NAME}.prof"
  FLAGS=f"{FLAGS} -Xcompiler-option --profile-file={DEX_LOCATION}/{TEST_NAME}.prof"
  if PROFILE:
    profman_cmdline=f"{profman_cmdline} --create-profile-from={DEX_LOCATION}/profile \
        --reference-profile-file={DEX_LOCATION}/{TEST_NAME}.prof"
  else:
    profman_cmdline=f"{profman_cmdline} --generate-test-profile={DEX_LOCATION}/{TEST_NAME}.prof \
        --generate-test-profile-seed=0"

def get_prebuilt_lldb_path():
  CLANG_BASE="prebuilts/clang/host"
  CLANG_VERSION=run(f"{ANDROID_BUILD_TOP}/build/soong/scripts/get_clang_version.py").stdout.strip()
  uname = run("uname -s").stdout.strip()
  if uname == "Darwin":
      PREBUILT_NAME="darwin-x86"
  elif uname == "Linux":
      PREBUILT_NAME="linux-x86"
  else:
      print("Unknown host $(uname -s). Unsupported for debugging dex2oat with LLDB.", file=sys.stderr)
      return
  CLANG_PREBUILT_HOST_PATH=f"{ANDROID_BUILD_TOP}/{CLANG_BASE}/{PREBUILT_NAME}/{CLANG_VERSION}"
  # If the clang prebuilt directory exists and the reported clang version
  # string does not, then it is likely that the clang version reported by the
  # get_clang_version.py script does not match the expected directory name.
  if (isdir(f"{ANDROID_BUILD_TOP}/{CLANG_BASE}/{PREBUILT_NAME}") and
      not isdir(CLANG_PREBUILT_HOST_PATH)):
    error_msg("The prebuilt clang directory exists, but the specific clang"\
    "\nversion reported by get_clang_version.py does not exist in that path."\
    "\nPlease make sure that the reported clang version resides in the"\
    "\nprebuilt clang directory!")
    sys.exit(1)

  # The lldb-server binary is a dependency of lldb.
  export("LLDB_DEBUGSERVER_PATH", f"{CLANG_PREBUILT_HOST_PATH}/runtimes_ndk_cxx/x86_64/lldb-server")

  # Set the current terminfo directory to TERMINFO so that LLDB can read the
  # termcap database.
  terminfo = re.search('/.*/terminfo/', run("infocmp", save_cmd=False).stdout)
  if terminfo:
    export("TERMINFO", terminfo[0])

  return f"{CLANG_PREBUILT_HOST_PATH}/bin/lldb.sh"

def write_dex2oat_cmdlines(name: str):
  global dex2oat_cmdline, dm_cmdline, vdex_cmdline

  class_loader_context=""
  enable_app_image=False
  if APP_IMAGE:
    enable_app_image=True

  # If the name ends in -ex then this is a secondary dex file
  if name.endswith("-ex"):
    # Lazily realize the default value in case DEX_LOCATION/TEST_NAME change
    global SECONDARY_CLASS_LOADER_CONTEXT
    if SECONDARY_CLASS_LOADER_CONTEXT == "":
      if SECONDARY_DEX == "":
        # Tests without `--secondary` load the "-ex" jar in a separate PathClassLoader
        # that is a child of the main PathClassLoader. If the class loader is constructed
        # in any other way, the test needs to specify the secondary CLC explicitly.
        SECONDARY_CLASS_LOADER_CONTEXT=f"PCL[];PCL[{DEX_LOCATION}/{TEST_NAME}.jar]"
      else:
        # Tests with `--secondary` load the `-ex` jar a part of the main PathClassLoader.
        SECONDARY_CLASS_LOADER_CONTEXT=f"PCL[{DEX_LOCATION}/{TEST_NAME}.jar]"
    class_loader_context=f"'--class-loader-context={SECONDARY_CLASS_LOADER_CONTEXT}'"
    enable_app_image = enable_app_image and SECONDARY_APP_IMAGE

  app_image=""
  if enable_app_image:
    app_image=f"--app-image-file={DEX_LOCATION}/oat/{ISA}/{name}.art --resolve-startup-const-strings=true"

  global GDB_DEX2OAT, GDB_DEX2OAT_ARGS
  if USE_GDB_DEX2OAT:
    prebuilt_lldb_path=get_prebuilt_lldb_path()
    GDB_DEX2OAT=f"{prebuilt_lldb_path} -f"
    GDB_DEX2OAT_ARGS+=" -- "

  dex2oat_binary=DEX2OAT_DEBUG_BINARY
  if TEST_IS_NDEBUG:
    dex2oat_binary=DEX2OAT_NDEBUG_BINARY
  dex2oat_cmdline=f"{INVOKE_WITH} {GDB_DEX2OAT} \
                      {ANDROID_ART_BIN_DIR}/{dex2oat_binary} \
                      {GDB_DEX2OAT_ARGS} \
                      {COMPILE_FLAGS} \
                      --boot-image={BOOT_IMAGE} \
                      --dex-file={DEX_LOCATION}/{name}.jar \
                      --oat-file={DEX_LOCATION}/oat/{ISA}/{name}.odex \
                      {app_image} \
                      --generate-mini-debug-info \
                      --instruction-set={ISA} \
                      {class_loader_context}"
  if INSTRUCTION_SET_FEATURES != "":
    dex2oat_cmdline+=f" --instruction-set-features={INSTRUCTION_SET_FEATURES}"

  # Add in a timeout. This is important for testing the compilation/verification time of
  # pathological cases. We do not append a timeout when debugging dex2oat because we
  # do not want it to exit while debugging.
  # Note: as we don't know how decent targets are (e.g., emulator), only do this on the host for
  #       now. We should try to improve this.
  #       The current value is rather arbitrary. run-tests should compile quickly.
  # Watchdog timeout is in milliseconds so add 3 '0's to the dex2oat timeout.
  if HOST and not USE_GDB_DEX2OAT:
    # Use SIGRTMIN+2 to try to dump threads.
    # Use -k 1m to SIGKILL it a minute later if it hasn't ended.
    dex2oat_cmdline=f"timeout -k {DEX2OAT_TIMEOUT}s -s SIGRTMIN+2 {DEX2OAT_RT_TIMEOUT}s {dex2oat_cmdline} --watchdog-timeout={DEX2OAT_TIMEOUT}000"
  if PROFILE or RANDOM_PROFILE:
    vdex_cmdline=f"{dex2oat_cmdline} {VDEX_ARGS} --input-vdex={DEX_LOCATION}/oat/{ISA}/{name}.vdex --output-vdex={DEX_LOCATION}/oat/{ISA}/{name}.vdex"
  elif TEST_VDEX:
    if VDEX_ARGS == "":
      # If no arguments need to be passed, just delete the odex file so that the runtime only picks up the vdex file.
      vdex_cmdline=f"rm {DEX_LOCATION}/oat/{ISA}/{name}.odex"
    else:
      vdex_cmdline=f"{dex2oat_cmdline} {VDEX_ARGS} --input-vdex={DEX_LOCATION}/oat/{ISA}/{name}.vdex"
  elif TEST_DEX2OAT_DM:
    vdex_cmdline=f"{dex2oat_cmdline} {VDEX_ARGS} --dump-timings --dm-file={DEX_LOCATION}/oat/{ISA}/{name}.dm"
    dex2oat_cmdline=f"{dex2oat_cmdline} --copy-dex-files=false --output-vdex={DEX_LOCATION}/oat/{ISA}/primary.vdex"
    dm_cmdline=f"zip -qj {DEX_LOCATION}/oat/{ISA}/{name}.dm {DEX_LOCATION}/oat/{ISA}/primary.vdex"
  elif TEST_RUNTIME_DM:
    dex2oat_cmdline=f"{dex2oat_cmdline} --copy-dex-files=false --output-vdex={DEX_LOCATION}/oat/{ISA}/primary.vdex"
    dm_cmdline=f"zip -qj {DEX_LOCATION}/{name}.dm {DEX_LOCATION}/oat/{ISA}/primary.vdex"

# Enable mini-debug-info for JIT (if JIT is used).
FLAGS+=" -Xcompiler-option --generate-mini-debug-info"

if PREBUILD:
  mkdir_locations+=f" {DEX_LOCATION}/oat/{ISA}"

  # "Primary".
  write_dex2oat_cmdlines(TEST_NAME)
  dex2oat_cmdline=re.sub(" +", " ", dex2oat_cmdline)
  dm_cmdline=re.sub(" +", " ", dm_cmdline)
  vdex_cmdline=re.sub(" +", " ", vdex_cmdline)

  # Enable mini-debug-info for JIT (if JIT is used).
  FLAGS+=" -Xcompiler-option --generate-mini-debug-info"

  if isfile(f"{TEST_NAME}-ex.jar") and SECONDARY_COMPILATION:
    # "Secondary" for test coverage.

    # Store primary values.
    base_dex2oat_cmdline=dex2oat_cmdline
    base_dm_cmdline=dm_cmdline
    base_vdex_cmdline=vdex_cmdline

    write_dex2oat_cmdlines(f"{TEST_NAME}-ex")
    dex2oat_cmdline=re.sub(" +", " ", dex2oat_cmdline)
    dm_cmdline=re.sub(" +", " ", dm_cmdline)
    vdex_cmdline=re.sub(" +", " ", vdex_cmdline)

    # Concatenate.
    dex2oat_cmdline=f"{base_dex2oat_cmdline} && {dex2oat_cmdline}"
    dm_cmdline=base_dm_cmdline # Only use primary dm.
    vdex_cmdline=f"{base_vdex_cmdline} && {vdex_cmdline}"

if SYNC_BEFORE_RUN:
  sync_cmdline="sync"

DALVIKVM_ISA_FEATURES_ARGS=""
if INSTRUCTION_SET_FEATURES != "":
  DALVIKVM_ISA_FEATURES_ARGS=f"-Xcompiler-option --instruction-set-features={INSTRUCTION_SET_FEATURES}"

# java.io.tmpdir can only be set at launch time.
TMP_DIR_OPTION=""
if not HOST:
  TMP_DIR_OPTION="-Djava.io.tmpdir=/data/local/tmp"

# The build servers have an ancient version of bash so we cannot use @Q.
QUOTED_DALVIKVM_BOOT_OPT=shlex.quote(DALVIKVM_BOOT_OPT)

DALVIKVM_CLASSPATH=f"{DEX_LOCATION}/{TEST_NAME}.jar"
if isfile(f"{TEST_NAME}-aotex.jar"):
  DALVIKVM_CLASSPATH=f"{DALVIKVM_CLASSPATH}:{DEX_LOCATION}/{TEST_NAME}-aotex.jar"
DALVIKVM_CLASSPATH=f"{DALVIKVM_CLASSPATH}{SECONDARY_DEX}"

# We set DumpNativeStackOnSigQuit to false to avoid stressing libunwind.
# b/27185632
# b/24664297

dalvikvm_cmdline=f"{INVOKE_WITH} {GDB} {ANDROID_ART_BIN_DIR}/{DALVIKVM} \
                  {GDB_ARGS} \
                  {FLAGS} \
                  {DEX_VERIFY} \
                  -XXlib:{LIB} \
                  {DEX2OAT} \
                  {DALVIKVM_ISA_FEATURES_ARGS} \
                  {ZYGOTE} \
                  {JNI_OPTS} \
                  {INT_OPTS} \
                  {DEBUGGER_OPTS} \
                  {QUOTED_DALVIKVM_BOOT_OPT} \
                  {TMP_DIR_OPTION} \
                  -XX:DumpNativeStackOnSigQuit:false \
                  -cp {DALVIKVM_CLASSPATH} {MAIN} {ARGS}"

if SIMPLEPERF:
  dalvikvm_cmdline=f"simpleperf record {dalvikvm_cmdline} && simpleperf report"

def sanitize_dex2oat_cmdline(cmdline: str) -> str:
  args = []
  for arg in cmdline.split(" "):
    if arg == "--class-loader-context=&":
      arg="--class-loader-context=\&"
    args.append(arg)
  return " ".join(args)

# Remove whitespace.
dex2oat_cmdline=sanitize_dex2oat_cmdline(dex2oat_cmdline)
dalvikvm_cmdline=re.sub(" +", " ", dalvikvm_cmdline)
dm_cmdline=re.sub(" +", " ", dm_cmdline)
vdex_cmdline=sanitize_dex2oat_cmdline(vdex_cmdline)
profman_cmdline=re.sub(" +", " ", profman_cmdline)

# Use an empty ASAN_OPTIONS to enable defaults.
# Note: this is required as envsetup right now exports detect_leaks=0.
RUN_TEST_ASAN_OPTIONS=""

# Multiple shutdown leaks. b/38341789
if RUN_TEST_ASAN_OPTIONS != "":
  RUN_TEST_ASAN_OPTIONS=f"{RUN_TEST_ASAN_OPTIONS}:"
RUN_TEST_ASAN_OPTIONS=f"{RUN_TEST_ASAN_OPTIONS}detect_leaks=0"

# For running, we must turn off logging when dex2oat is missing. Otherwise we use
# the same defaults as for prebuilt: everything when --dev, otherwise errors and above only.
if not EXTERNAL_LOG_TAGS:
  if DEV_MODE:
      export("ANDROID_LOG_TAGS", '*:d')
  elif not HAVE_IMAGE:
      # All tests would log the error of missing image. Be silent here and only log fatal
      # events.
      export("ANDROID_LOG_TAGS", '*:s')
  else:
      # We are interested in LOG(ERROR) output.
      export("ANDROID_LOG_TAGS", '*:e')

if not HOST:
    adb.root()
    adb.wait_for_device()
    if not QUIET:
      adb.shell(f"rm -rf {CHROOT_DEX_LOCATION}", capture_output=False)
      adb.shell(f"mkdir -p {CHROOT_DEX_LOCATION}", capture_output=False)
      adb.push(f"{TEST_NAME}.jar", CHROOT_DEX_LOCATION, capture_output=False)
      adb.push(f"{TEST_NAME}-ex.jar", CHROOT_DEX_LOCATION, check=False, capture_output=False)
      adb.push(f"{TEST_NAME}-aotex.jar", CHROOT_DEX_LOCATION, check=False, capture_output=False)
      adb.push(f"{TEST_NAME}-bcpex.jar", CHROOT_DEX_LOCATION, check=False, capture_output=False)
      if PROFILE or RANDOM_PROFILE:
        adb.push("profile", CHROOT_DEX_LOCATION, check=False, capture_output=False)
      # Copy resource folder
      if isdir("res"):
        adb.push("res", CHROOT_DEX_LOCATION, capture_output=False)
    else:
      adb.shell(f"rm -rf {CHROOT_DEX_LOCATION}")
      adb.shell(f"mkdir -p {CHROOT_DEX_LOCATION}")
      adb.push(f"{TEST_NAME}.jar", CHROOT_DEX_LOCATION)
      adb.push(f"{TEST_NAME}-ex.jar", CHROOT_DEX_LOCATION, check=False)
      adb.push(f"{TEST_NAME}-aotex.jar", CHROOT_DEX_LOCATION, check=False)
      adb.push(f"{TEST_NAME}-bcpex.jar", CHROOT_DEX_LOCATION, check=False)
      if PROFILE or RANDOM_PROFILE:
        adb.push("profile", CHROOT_DEX_LOCATION, check=False)
      # Copy resource folder
      if isdir("res"):
        adb.push("res", CHROOT_DEX_LOCATION)

    # Populate LD_LIBRARY_PATH.
    LD_LIBRARY_PATH=""
    if ANDROID_ROOT != "/system":
      # Current default installation is dalvikvm 64bits and dex2oat 32bits,
      # so we can only use LD_LIBRARY_PATH when testing on a local
      # installation.
      LD_LIBRARY_PATH=f"{ANDROID_ROOT}/{LIBRARY_DIRECTORY}"

    # This adds libarttest(d).so to the default linker namespace when dalvikvm
    # is run from /apex/com.android.art/bin. Since that namespace is essentially
    # an alias for the com_android_art namespace, that gives libarttest(d).so
    # full access to the internal ART libraries.
    LD_LIBRARY_PATH=f"/data/{TEST_DIRECTORY}/com.android.art/lib{SUFFIX64}:{LD_LIBRARY_PATH}"
    dlib=("" if TEST_IS_NDEBUG else "d")
    art_test_internal_libraries=[
      f"libartagent{dlib}.so",
      f"libarttest{dlib}.so",
      f"libtiagent{dlib}.so",
      f"libtistress{dlib}.so",
    ]
    NATIVELOADER_DEFAULT_NAMESPACE_LIBS=":".join(art_test_internal_libraries)
    dlib=""
    art_test_internal_libraries=[]

    # Needed to access the test's Odex files.
    LD_LIBRARY_PATH=f"{DEX_LOCATION}/oat/{ISA}:{LD_LIBRARY_PATH}"
    # Needed to access the test's native libraries (see e.g. 674-hiddenapi,
    # which generates `libhiddenapitest_*.so` libraries in `{DEX_LOCATION}`).
    LD_LIBRARY_PATH=f"{DEX_LOCATION}:{LD_LIBRARY_PATH}"

    # Prepend directories to the path on device.
    PREPEND_TARGET_PATH=ANDROID_ART_BIN_DIR
    if ANDROID_ROOT != "/system":
      PREPEND_TARGET_PATH=f"{PREPEND_TARGET_PATH}:{ANDROID_ROOT}/bin"

    timeout_dumper_cmd=""

    # Check whether signal_dumper is available.
    if TIMEOUT_DUMPER == "signal_dumper":
      # Chroot? Use as prefix for tests.
      TIMEOUT_DUMPER_PATH_PREFIX=""
      if CHROOT:
        TIMEOUT_DUMPER_PATH_PREFIX=f"{CHROOT}/"

      # Testing APEX?
      if adb.shell(f"test -x {TIMEOUT_DUMPER_PATH_PREFIX}/apex/com.android.art/bin/signal_dumper",
                   check=False, save_cmd=False).returncode:
        TIMEOUT_DUMPER="/apex/com.android.art/bin/signal_dumper"
      # Is it in /system/bin?
      elif adb.shell(f"test -x {TIMEOUT_DUMPER_PATH_PREFIX}/system/bin/signal_dumper",
                     check=False, save_cmd=False).returncode:
        TIMEOUT_DUMPER="/system/bin/signal_dumper"
      else:
        TIMEOUT_DUMPER=""
    else:
      TIMEOUT_DUMPER=""

    if TIMEOUT_DUMPER:
      # Use "-l" to dump to logcat. That is convenience for the build bot crash symbolization.
      # Use exit code 124 for toybox timeout (b/141007616).
      timeout_dumper_cmd=f"{TIMEOUT_DUMPER} -l -s 15 -e 124"

    timeout_prefix=""
    if TIME_OUT == "timeout":
      # Add timeout command if time out is desired.
      #
      # Note: We first send SIGTERM (the timeout default, signal 15) to the signal dumper, which
      #       will induce a full thread dump before killing the process. To ensure any issues in
      #       dumping do not lead to a deadlock, we also use the "-k" option to definitely kill the
      #       child.
      # Note: Using "--foreground" to not propagate the signal to children, i.e., the runtime.
      timeout_prefix=f"timeout --foreground -k 120s {TIME_OUT_VALUE}s {timeout_dumper_cmd} {cmdline}"

    # Create a script with the command. The command can get longer than the longest
    # allowed adb command and there is no way to get the exit status from a adb shell
    # command. Dalvik cache is cleaned before running to make subsequent executions
    # of the script follow the same runtime path.
    cmdline=f"cd {DEX_LOCATION} && \
             export ASAN_OPTIONS={RUN_TEST_ASAN_OPTIONS} && \
             export ANDROID_DATA={DEX_LOCATION} && \
             export DEX_LOCATION={DEX_LOCATION} && \
             export ANDROID_ROOT={ANDROID_ROOT} && \
             export ANDROID_I18N_ROOT={ANDROID_I18N_ROOT} && \
             export ANDROID_ART_ROOT={ANDROID_ART_ROOT} && \
             export ANDROID_TZDATA_ROOT={ANDROID_TZDATA_ROOT} && \
             export ANDROID_LOG_TAGS={ANDROID_LOG_TAGS} && \
             rm -rf {DEX_LOCATION}/dalvik-cache/ && \
             mkdir -p {mkdir_locations} && \
             export LD_LIBRARY_PATH={LD_LIBRARY_PATH} && \
             export NATIVELOADER_DEFAULT_NAMESPACE_LIBS={NATIVELOADER_DEFAULT_NAMESPACE_LIBS} && \
             export PATH={PREPEND_TARGET_PATH}:$PATH && \
             {profman_cmdline} && \
             {dex2oat_cmdline} && \
             {dm_cmdline} && \
             {vdex_cmdline} && \
             {strip_cmdline} && \
             {sync_cmdline} && \
             {timeout_prefix} {dalvikvm_cmdline}"

    cmdfile=run(f'mktemp cmd-XXXX --suffix "-{TEST_NAME}"', save_cmd=False).stdout.strip()
    with open(cmdfile, "w") as f:
      f.write(cmdline)

    run('echo cmdline.sh "' + cmdline.replace('"', '\\"') + '"')

    if DEV_MODE:
      print(cmdline)
      if USE_GDB or USE_GDBSERVER:
        print(f"Forward {GDBSERVER_PORT} to local port and connect GDB")

    if not QUIET:
      adb.push(cmdfile, f"{CHROOT_DEX_LOCATION}/cmdline.sh", save_cmd=False, capture_output=False)
    else:
      adb.push(cmdfile, f"{CHROOT_DEX_LOCATION}/cmdline.sh", save_cmd=False)

    exit_status=0
    if not DRY_RUN:
      if CHROOT:
        exit_status=adb.shell(f"chroot {CHROOT} sh {DEX_LOCATION}/cmdline.sh",
                              check=False, capture_output=False).returncode
      else:
        exit_status=adb.shell(f"sh {DEX_LOCATION}/cmdline.sh",
                              check=False ,capture_output=False).returncode

    run(f'rm -f {cmdfile}', save_cmd=False)
    sys.exit(exit_status)
else:
    # Host run.
    export("ANDROID_PRINTF_LOG", "brief")

    export("ANDROID_DATA", DEX_LOCATION)
    export("ANDROID_ROOT", ANDROID_ROOT)
    export("ANDROID_I18N_ROOT", ANDROID_I18N_ROOT)
    export("ANDROID_ART_ROOT", ANDROID_ART_ROOT)
    export("ANDROID_TZDATA_ROOT", ANDROID_TZDATA_ROOT)
    if USE_ZIPAPEX or USE_EXRACTED_ZIPAPEX:
      # Put the zipapex files in front of the ld-library-path
      export("LD_LIBRARY_PATH", f"{ANDROID_DATA}/zipapex/{LIBRARY_DIRECTORY}:{ANDROID_ROOT}/{TEST_DIRECTORY}")
      export("DYLD_LIBRARY_PATH", f"{ANDROID_DATA}/zipapex/{LIBRARY_DIRECTORY}:{ANDROID_ROOT}/{TEST_DIRECTORY}")
    else:
      export("LD_LIBRARY_PATH", f"{ANDROID_ROOT}/{LIBRARY_DIRECTORY}:{ANDROID_ROOT}/{TEST_DIRECTORY}")
      export("DYLD_LIBRARY_PATH", f"{ANDROID_ROOT}/{LIBRARY_DIRECTORY}:{ANDROID_ROOT}/{TEST_DIRECTORY}")
    export("PATH", f"{PATH}:{ANDROID_ART_BIN_DIR}")

    # Temporarily disable address space layout randomization (ASLR).
    # This is needed on the host so that the linker loads core.oat at the necessary address.
    export("LD_USE_LOAD_BIAS", "1")

    cmdline=dalvikvm_cmdline

    if TIME_OUT == "gdb":
      if run("uname").stdout.strip() == "Darwin":
        # Fall back to timeout on Mac.
        TIME_OUT="timeout"
      elif ISA == "x86":
        # prctl call may fail in 32-bit on an older (3.2) 64-bit Linux kernel. Fall back to timeout.
        TIME_OUT="timeout"
      else:
        # Check if gdb is available.
        proc = run('gdb --eval-command="quit"', check=False, save_cmd=False, capture_output=True)
        if proc.returncode != 0:
          # gdb isn't available. Fall back to timeout.
          TIME_OUT="timeout"

    if TIME_OUT == "timeout":
      # Add timeout command if time out is desired.
      #
      # Note: We first send SIGTERM (the timeout default, signal 15) to the signal dumper, which
      #       will induce a full thread dump before killing the process. To ensure any issues in
      #       dumping do not lead to a deadlock, we also use the "-k" option to definitely kill the
      #       child.
      # Note: Using "--foreground" to not propagate the signal to children, i.e., the runtime.
      cmdline=f"timeout --foreground -k 120s {TIME_OUT_VALUE}s {TIMEOUT_DUMPER} -s 15 {cmdline}"

    if DEV_MODE:
      for var in "ANDROID_PRINTF_LOG ANDROID_DATA ANDROID_ROOT ANDROID_I18N_ROOT ANDROID_TZDATA_ROOT ANDROID_ART_ROOT LD_LIBRARY_PATH DYLD_LIBRARY_PATH PATH LD_USE_LOAD_BIAS".split(" "):
        value = os.environ.get(var, "")
        print(f"echo EXPORT {var}={value}")
      print("$(declare -f linkdirs)")
      print(f"mkdir -p {mkdir_locations} && {setupapex_cmdline} && ( {installapex_test_cmdline} || {installapex_cmdline} ) && {linkroot_cmdline} && {linkroot_overlay_cmdline} && {profman_cmdline} && {dex2oat_cmdline} && {dm_cmdline} && {vdex_cmdline} && {strip_cmdline} && {sync_cmdline} && {cmdline}")

    os.chdir(ANDROID_BUILD_TOP)

    # Make sure we delete any existing compiler artifacts.
    # This enables tests to call the RUN script multiple times in a row
    # without worrying about interference.
    shutil.rmtree(f"{DEX_LOCATION}/oat", ignore_errors=True)
    shutil.rmtree(f"{DEX_LOCATION}/dalvik-cache/", ignore_errors=True)

    export("ASAN_OPTIONS", RUN_TEST_ASAN_OPTIONS)

    run(f"mkdir -p {mkdir_locations}", save_cmd=False)
    run(setupapex_cmdline, capture_output=False)
    if run(installapex_test_cmdline, check=False, capture_output=False).returncode != 0:
      run(installapex_cmdline, capture_output=False)
    run(linkroot_cmdline, capture_output=False)
    run(linkroot_overlay_cmdline, capture_output=False)
    run(profman_cmdline, capture_output=False)
    run(dex2oat_cmdline, capture_output=False)
    run(dm_cmdline, capture_output=False)
    run(vdex_cmdline, capture_output=False)
    run(strip_cmdline, capture_output=False)
    run(sync_cmdline, capture_output=False)

    if CREATE_RUNNER:
      with open(f"{DEX_LOCATION}/runit.sh", "w") as f:
        f.write("#!/bin/bash")
        for var in "ANDROID_PRINTF_LOG ANDROID_DATA ANDROID_ROOT ANDROID_I18N_ROOT ANDROID_TZDATA_ROOT ANDROID_ART_ROOT LD_LIBRARY_PATH DYLD_LIBRARY_PATH PATH LD_USE_LOAD_BIAS".split(" "):
          value = os.environ.get(var, "")
          f.write(f'export {var}="{value}"')
        if DEV_MODE:
          f.write(cmdline)
        else:
          f.writelines([
            'STDERR=$(mktemp)',
            'STDOUT=$(mktemp)',
            cmdline + ' >${STDOUT} 2>${STDERR}',
            'if diff ${STDOUT} {ANDROID_DATA}/expected-stdout.txt; then',
            '  rm -f ${STDOUT} ${STDERR}',
            '  exit 0',
            'elif diff ${STDERR} {ANDROID_DATA}/expected-stderr.txt; then',
            '  rm -f ${STDOUT} ${STDERR}',
            '  exit 0',
            'else',
            '  echo  STDOUT:',
            '  cat ${STDOUT}',
            '  echo  STDERR:',
            '  cat ${STDERR}',
            '  rm -f ${STDOUT} ${STDERR}',
            '  exit 1',
            'fi',
          ])
      os.chmod("{DEX_LOCATION}/runit.sh", 0o777)
      print(f"Runnable test script written to {DEX_LOCATION}/runit.sh")
    if DRY_RUN:
      sys.exit(0)

    if USE_GDB:
      # When running under gdb, we cannot do piping and grepping...
      subprocess.run(cmdline + test_args, shell=True)
    elif USE_GDBSERVER:
      print("Connect to {GDBSERVER_PORT}")
      # When running under gdb, we cannot do piping and grepping...
      subprocess.run(cmdline + test_args, shell=True)
    else:
      if TIME_OUT != "gdb":
        proc = run(cmdline + test_args, check=False, capture_output=False)
        exit_value=proc.returncode
        # Add extra detail if time out is enabled.
        if exit_value == 124 and TIME_OUT == "timeout":
          print("\e[91mTEST TIMED OUT!\e[0m", file=sys.stderr)
        sys.exit(exit_value)
      else:
        # With a thread dump that uses gdb if a timeout.
        proc = run(cmdline + test_args, check=False)
        # TODO: Spawn a watcher process.
        raise Exception("Not implemented")
        # ( sleep {TIME_OUT_VALUE} && \
        #   echo "##### Thread dump using gdb on test timeout" && \
        #   ( gdb -q -p {pid} --eval-command="info thread" --eval-command="thread apply all bt" \
        #                    --eval-command="call exit(124)" --eval-command=quit || \
        #     kill {pid} )) 2> /dev/null & watcher=$!
        test_exit_status=proc.returncode
        # pkill -P {watcher} 2> /dev/null # kill the sleep which will in turn end the watcher as well
        if test_exit_status == 0:
          # The test finished normally.
          sys.exit(0)
        else:
          # The test failed or timed out.
          if test_exit_status == 124:
            # The test timed out.
            print("\e[91mTEST TIMED OUT!\e[0m", file=sys.stderr)
          sys.exit(test_exit_status)
