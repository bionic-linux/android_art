{
  "comments": [
    {
      "key": {
        "uuid": "d82d604f_cc10ea0e",
        "filename": "runtime/gc/collector/concurrent_copying.cc",
        "patchSetId": 14
      },
      "lineNbr": 628,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2018-01-21T21:58:20Z",
      "side": 1,
      "message": "Note: we seem to never clear the card table (i.e. marking dirty/aged cards clean) for non-immune spaces, which sounds strange, as it means that the set of dirty cards would only grow over time, seemingly diminishing the value of the verification done here (\"Objects on clean cards should never have references to newly allocated regions.\"). Did I miss something?\n\nFor the region space, there is a statement line 2722 that does it for the whole region space, but it\u0027s disabled when the above verification is performed (`kVerifyNoMissingCardMarks` flag) – and this CL disables it unconditionally anyway (see line 2719).\n\nFor the non-moving space, there seems to be no statement at all clearing dirty/aged cards in the original CC code nor in the Sticky-Bit CC code. To me, this means that the set of dirty cards for this space will grow over time and that we will spend more and more time in the code visiting dirty cards lines 867-874 (note that the call to `CardTable::Scan` line 856 scans the card table without clearing the cards, as the parameter `kClearCard` is set to `false`).\n\nI\u0027m asking, because I have seen the VerifyNoMissingCardMarks check fail when booting a device with AOSP + the current stack of Sticky-Bit CC patches with libartd. I thought I had addressed all these issues, as I could not reproduce them with ART tests, but they must not cover these cases.",
      "range": {
        "startLine": 628,
        "startChar": 8,
        "endLine": 628,
        "endChar": 84
      },
      "revId": "f482c9ef80cb0ea33f7c9731c0f47dd78b707269",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "16f436c0_113b7ed8",
        "filename": "runtime/gc/collector/concurrent_copying.cc",
        "patchSetId": 14
      },
      "lineNbr": 2093,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2018-01-17T15:16:09Z",
      "side": 1,
      "message": "This should hopefully be addressed by https://android-review.googlesource.com/#/c/platform/art/+/590993/.",
      "range": {
        "startLine": 2091,
        "startChar": 0,
        "endLine": 2093,
        "endChar": 77
      },
      "revId": "f482c9ef80cb0ea33f7c9731c0f47dd78b707269",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f54441ca_774b3911",
        "filename": "runtime/gc/collector/concurrent_copying.cc",
        "patchSetId": 14
      },
      "lineNbr": 2560,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2018-01-21T21:58:20Z",
      "side": 1,
      "message": "This seems odd to consider a reference to a non-region-space always marked… Wouldn\u0027t this mess up the reference processing, which relies on ConcurrentCopying::IsMarked / ConcurrentCopying::IsNullOrMarkedHeapReference ?",
      "range": {
        "startLine": 2557,
        "startChar": 0,
        "endLine": 2560,
        "endChar": 5
      },
      "revId": "f482c9ef80cb0ea33f7c9731c0f47dd78b707269",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}