{
  "comments": [
    {
      "key": {
        "uuid": "65c57378_393d0fb3",
        "filename": "runtime/interpreter/interpreter_goto_table_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 2390,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-04-25T09:40:35Z",
      "side": 1,
      "message": "Could you just check that a is kReturn?",
      "range": {
        "startLine": 2390,
        "startChar": 29,
        "endLine": 2390,
        "endChar": 40
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aa26584d_b6c82658",
        "filename": "runtime/interpreter/interpreter_goto_table_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 2390,
      "author": {
        "id": 1029223
      },
      "writtenOn": "2014-05-14T14:36:03Z",
      "side": 1,
      "message": "I wrote it this way so the \"if\" is actually simplified by the compiler (after preprocessing). It does not seem to be the case if I use instruction flags: (Instruction::FlagsOf(Instruction::code) \u0026 kReturn) !\u003d 0\" does not seem to be simplified to a constant expression so the \"if\" remains.",
      "parentUuid": "65c57378_393d0fb3",
      "range": {
        "startLine": 2390,
        "startChar": 29,
        "endLine": 2390,
        "endChar": 40
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a3da49e_ee803f3a",
        "filename": "runtime/interpreter/interpreter_goto_table_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 2390,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-05-15T08:05:04Z",
      "side": 1,
      "message": "I see. Maybe add that as a comment, so this information does not get lost in a future refactoring/rewrite.",
      "parentUuid": "aa26584d_b6c82658",
      "range": {
        "startLine": 2390,
        "startChar": 29,
        "endLine": 2390,
        "endChar": 40
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a58a819_0f5bc50d",
        "filename": "runtime/interpreter/interpreter_goto_table_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 2390,
      "author": {
        "id": 1029223
      },
      "writtenOn": "2014-05-15T09:12:31Z",
      "side": 1,
      "message": "I\u0027ll address it in https://android-review.googlesource.com/94701",
      "parentUuid": "0a3da49e_ee803f3a",
      "range": {
        "startLine": 2390,
        "startChar": 29,
        "endLine": 2390,
        "endChar": 40
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4a531cfd_d0279ca3",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-05-15T08:11:27Z",
      "side": 1,
      "message": "What happens if a method just has a return?",
      "range": {
        "startLine": 53,
        "startChar": 12,
        "endLine": 53,
        "endChar": 16
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4a531cfd_90b994de",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1029223
      },
      "writtenOn": "2014-05-15T09:12:31Z",
      "side": 1,
      "message": "We just do not get here. However, we CL https://android-review.googlesource.com/94334, we need to report DexPcChange events in RETURN if there is no listener for MethodExit events. I\u0027m addressing this in https://android-review.googlesource.com/94701.",
      "parentUuid": "4a531cfd_d0279ca3",
      "range": {
        "startLine": 53,
        "startChar": 12,
        "endLine": 53,
        "endChar": 16
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a58a819_4f55cdd5",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-05-15T09:24:52Z",
      "side": 1,
      "message": "Sorry the question wasn\u0027t clear. If a method only has a return, do we have code that will notify the method it entered. Answering my question, I can see the code line 73 handles it for all bytecode, so nevermind this question :)\n\nMaybe add as a comment what the code below is for.",
      "parentUuid": "4a531cfd_90b994de",
      "range": {
        "startLine": 53,
        "startChar": 12,
        "endLine": 53,
        "endChar": 16
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65c57378_99441b2c",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-04-25T09:40:35Z",
      "side": 1,
      "message": "Could you get rid of that check with some refactoring? Move the switch to its own method, only do the check for the first instruction, and loop over the remaining instructions?",
      "range": {
        "startLine": 54,
        "startChar": 17,
        "endLine": 54,
        "endChar": 44
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a292485_4e8f73aa",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2014-05-01T00:06:10Z",
      "side": 1,
      "message": "I agree. the original purpose was to play code layout games to see if we could trick GCC into actually doing -fthread-jumps. Wrt refactoring, should all of the instrumentation live in a different template specialization? For the threaded interpreter that\u0027s easier as it can be achieved by dorking the dispatch table.",
      "parentUuid": "65c57378_99441b2c",
      "range": {
        "startLine": 54,
        "startChar": 17,
        "endLine": 54,
        "endChar": 44
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a1cc41d_f9f593a7",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1029223
      },
      "writtenOn": "2014-05-14T14:36:03Z",
      "side": 1,
      "message": "I\u0027m not sure moving the switch to its own method would be a good solution. It would make the code more complex, especially because of control flow (RETURN and exception). Note I\u0027m not happy with this flag either. Maybe we could deal with it in a differrent way. I\u0027m thinking about using function pointer but did not try that yet.\n\nWrt to template specialization, we could do this. However, a debugger can attach in the middle of the execution of a method so we\u0027d need to transition from a non-debug specialization to a debug specialization when that happens (and the contrary too). Indeed, we do that in the threaded interpreter by switching dispatch table when that happens.",
      "parentUuid": "0a292485_4e8f73aa",
      "range": {
        "startLine": 54,
        "startChar": 17,
        "endLine": 54,
        "endChar": 44
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a58a819_afc47976",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-05-15T08:11:27Z",
      "side": 1,
      "message": "Maybe the switch can stay here, but the loop be in a caller method?",
      "parentUuid": "0a1cc41d_f9f593a7",
      "range": {
        "startLine": 54,
        "startChar": 17,
        "endLine": 54,
        "endChar": 44
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a58a819_cf40dd1b",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1029223
      },
      "writtenOn": "2014-05-15T09:12:31Z",
      "side": 1,
      "message": "I\u0027m worried about splitting interpreter in two methods. Even with inlining, this could cause performance penalties. Maybe you have a more precise idea and I may not see your point.",
      "parentUuid": "2a58a819_afc47976",
      "range": {
        "startLine": 54,
        "startChar": 17,
        "endLine": 54,
        "endChar": 44
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a58a819_2fdde926",
        "filename": "runtime/interpreter/interpreter_switch_impl.cc",
        "patchSetId": 2
      },
      "lineNbr": 54,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2014-05-15T09:24:52Z",
      "side": 1,
      "message": "I was thinking of:\n\nvoid MainInterpreterEntry() {\n  // Do something for first instruction\n  // BigSwitch(firstInst);\n  // Move to second instruction\n  while (true) {\n    // DexPcMovedEvent\n    BigSwitch(inst);\n  }\n}\n\nvoid BigSwitch(inst) {\n  switch(inst-\u003eOpcode(inst_data)) {\n    /// NO CALL TO PREAMBLE\n  }\n}\n\nIt does indeed add a call for each instruction. Ideally, we would inline the second BigSwitch and not the first, but I doubt that\u0027s easily controllable. Nevermind :)",
      "parentUuid": "2a58a819_cf40dd1b",
      "range": {
        "startLine": 54,
        "startChar": 17,
        "endLine": 54,
        "endChar": 44
      },
      "revId": "d011c5c1d371f19070b6253239a39e7e87be1e70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}