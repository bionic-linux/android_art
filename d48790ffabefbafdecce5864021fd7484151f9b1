{
  "comments": [
    {
      "key": {
        "uuid": "54884712_1ca56bf9",
        "filename": "runtime/Android.bp",
        "patchSetId": 3
      },
      "lineNbr": 344,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-02-28T09:46:55Z",
      "side": 1,
      "message": "Have you checked how portable this is? If there\u0027s no backwards compatibile guarantees for that library, we cannot include it in ART.",
      "range": {
        "startLine": 344,
        "startChar": 10,
        "endLine": 344,
        "endChar": 20
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5f369a0_d410fa9e",
        "filename": "runtime/Android.bp",
        "patchSetId": 3
      },
      "lineNbr": 344,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T16:56:19Z",
      "side": 1,
      "message": "Your concern is specific to this library or reading from /proc/self/smaps? Because if it\u0027s just the library, I can go back to my original plan of reading smaps directly and extracting the needed info.",
      "parentUuid": "54884712_1ca56bf9",
      "range": {
        "startLine": 344,
        "startChar": 10,
        "endLine": 344,
        "endChar": 20
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da368897_e3fbaf9c",
        "filename": "runtime/Android.bp",
        "patchSetId": 3
      },
      "lineNbr": 344,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-02-28T17:03:08Z",
      "side": 1,
      "message": "It\u0027s the library - adding it here means it\u0027s going to duplicate it in the APEX. Maybe that\u0027s OK and all the things that library does are trivial and portable. But we need to understand tradeoffs of including a new library or doing what it does ourselves.",
      "parentUuid": "d5f369a0_d410fa9e",
      "range": {
        "startLine": 344,
        "startChar": 10,
        "endLine": 344,
        "endChar": 20
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4994f3c2_cbbd98fd",
        "filename": "runtime/Android.bp",
        "patchSetId": 3
      },
      "lineNbr": 344,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T17:46:58Z",
      "side": 1,
      "message": "OK. Who can help me with that assessment?\n\nAlso, what if the library is statically linked? Would that help?",
      "parentUuid": "da368897_e3fbaf9c",
      "range": {
        "startLine": 344,
        "startChar": 10,
        "endLine": 344,
        "endChar": 20
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dbaf7fca_b7fdb1ab",
        "filename": "runtime/Android.bp",
        "patchSetId": 3
      },
      "lineNbr": 344,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-02-28T17:53:40Z",
      "side": 1,
      "message": "It\u0027s essentially going to be statically linked - The .so will be in the APEX and ART will use that one instead of the one in /system.\n\nThe assessment would need to be (and that\u0027s on individuals that want to start rely on a new library):\n- What dependencies does that library have on a particular platform version?\n- What\u0027s the footprint? Is the size increase worth the functionality we want to use?\n- Should we have this library expose an API through libpalette or stubs?\n- Should we just implement the functionality we need ourselves?",
      "parentUuid": "4994f3c2_cbbd98fd",
      "range": {
        "startLine": 344,
        "startChar": 10,
        "endLine": 344,
        "endChar": 20
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "82e1eaf8_52e22108",
        "filename": "runtime/Android.bp",
        "patchSetId": 3
      },
      "lineNbr": 344,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T21:31:20Z",
      "side": 1,
      "message": "The code in the library that I\u0027m interested in is fairly independent. It only depends on kernel (for smaps file) and c++ library. I have moved libmeminfo to static_libs.\n\nIf it is still a concern, then I can implement the needed functionality in runtime by directly reading smaps.",
      "parentUuid": "dbaf7fca_b7fdb1ab",
      "range": {
        "startLine": 344,
        "startChar": 10,
        "endLine": 344,
        "endChar": 20
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c01bacf6_0fc36aef",
        "filename": "runtime/Android.bp",
        "patchSetId": 3
      },
      "lineNbr": 344,
      "author": {
        "id": 1108565
      },
      "writtenOn": "2019-02-28T23:53:53Z",
      "side": 1,
      "message": "To answer Nicolas\u0027s questions:\n1. Library has no dependency on the platform version whatsoever\n2. I haven\u0027t checked the size it will pull in, I imagine though that you will end up adding similar code size. The functionality you are using is trivial and is simply parsing a file.\n   However, I just spent this release unifying all of the /proc/\u003cpid\u003e/ memory accounting into that library, so will be sad to start forking again :(. So, I think Art should write their own by \n   all means if the code / apex size is significantly bigger than expected for sure.\n3. I am not sure what that means. However, I do have a question. What are the API / ABI guarantees ART will need from the library? Am I free to change the API / ABI if I wish after (apex\u0027d) ART \n   starts depending on it? if yes, then should be no problem.\n4. See #2 .. :(.\n\nAnother note, the ReadMapFileContent() call in libmeminfo/procmeminfo.cpp is currently implemented in system/core/libprocinfo. I have a pending bug to move that into meminfo, but its not urgent. So, you are also indirectly depending on libprocinfo - FYI.",
      "parentUuid": "82e1eaf8_52e22108",
      "range": {
        "startLine": 344,
        "startChar": 10,
        "endLine": 344,
        "endChar": 20
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9ae6fbd_5717325e",
        "filename": "runtime/gc/collector/concurrent_copying.cc",
        "patchSetId": 3
      },
      "lineNbr": 2532,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-02-28T18:19:51Z",
      "side": 1,
      "message": "This doesn\u0027t seem like a very informative type. It\u0027s also not the right size on 32 bit. Void * seems more natural. Maybe uintptr_t. But meminfo.h does it this way, so I can go either way if we\u0027re keeping it. Maybe at least define range_t constructors from two T* and a T* plus byte size to avoid the casts all over the place?",
      "range": {
        "startLine": 2532,
        "startChar": 28,
        "endLine": 2532,
        "endChar": 46
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3169107_851b9ad0",
        "filename": "runtime/gc/collector/concurrent_copying.cc",
        "patchSetId": 3
      },
      "lineNbr": 2532,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T21:31:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f9ae6fbd_5717325e",
      "range": {
        "startLine": 2532,
        "startChar": 28,
        "endLine": 2532,
        "endChar": 46
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17a07d95_1a01ab7a",
        "filename": "runtime/gc/collector/concurrent_copying.cc",
        "patchSetId": 3
      },
      "lineNbr": 2600,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-02-28T18:19:51Z",
      "side": 1,
      "message": "Nit: delete?",
      "range": {
        "startLine": 2600,
        "startChar": 18,
        "endLine": 2600,
        "endChar": 54
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e157002_98983072",
        "filename": "runtime/gc/collector/concurrent_copying.cc",
        "patchSetId": 3
      },
      "lineNbr": 2600,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T21:31:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "17a07d95_1a01ab7a",
      "range": {
        "startLine": 2600,
        "startChar": 18,
        "endLine": 2600,
        "endChar": 54
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "85e452b0_7d791ee1",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 3
      },
      "lineNbr": 100,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-02-28T18:19:51Z",
      "side": 1,
      "message": "std::less if you switch to void *.",
      "range": {
        "startLine": 100,
        "startChar": 21,
        "endLine": 100,
        "endChar": 22
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d370108f_c59f780f",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 3
      },
      "lineNbr": 100,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T21:31:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "85e452b0_7d791ee1",
      "range": {
        "startLine": 100,
        "startChar": 21,
        "endLine": 100,
        "endChar": 22
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a489b3a_aa10cd5d",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 3
      },
      "lineNbr": 103,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-02-28T18:19:51Z",
      "side": 1,
      "message": "their properties",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 35
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f636b33_7f444e07",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 3
      },
      "lineNbr": 103,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T21:31:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2a489b3a_aa10cd5d",
      "range": {
        "startLine": 103,
        "startChar": 18,
        "endLine": 103,
        "endChar": 35
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "26a42795_478cbdc5",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-02-28T18:19:51Z",
      "side": 1,
      "message": "Is there a good argument that smaps_ranges can\u0027t be merged with non-gc ranges?",
      "range": {
        "startLine": 134,
        "startChar": 6,
        "endLine": 134,
        "endChar": 61
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ac8a3c4_a59a4a4d",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-02-28T21:31:20Z",
      "side": 1,
      "message": "All properties of adjoining memory mappings need to match for merging. That includes the name as well. All the gc_ranges are anonymous and named. So they cannot merge with non-gc ranges.",
      "parentUuid": "26a42795_478cbdc5",
      "range": {
        "startLine": 134,
        "startChar": 6,
        "endLine": 134,
        "endChar": 61
      },
      "revId": "d48790ffabefbafdecce5864021fd7484151f9b1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}