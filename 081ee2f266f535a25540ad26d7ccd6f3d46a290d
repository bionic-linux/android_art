{
  "comments": [
    {
      "key": {
        "uuid": "c4ae4a93_780d613f",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 490,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2015-09-07T14:01:14Z",
      "side": 1,
      "message": "Please use a more revealing name and add documentation. *New* will not be so *new* anymore after a few weeks.",
      "range": {
        "startLine": 490,
        "startChar": 61,
        "endLine": 490,
        "endChar": 83
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6492fe15_ee687d02",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 490,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:01:55Z",
      "side": 1,
      "message": "? :-)\n\nNew is not because I wrote this code yesterday, but it denotes I am creating a new node, possibly simplified.\n\nSee L103-113 in the header, NewInvariantOp, NewInvariantFetch, NewInduction.",
      "parentUuid": "c4ae4a93_780d613f",
      "range": {
        "startLine": 490,
        "startChar": 61,
        "endLine": 490,
        "endChar": 83
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4d42ed5_1a5bc120",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 490,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2015-09-07T17:07:25Z",
      "side": 1,
      "message": "arh, ok, my bad :)\n\nThe rest of the code uses CreateSomething though...",
      "parentUuid": "6492fe15_ee687d02",
      "range": {
        "startLine": 490,
        "startChar": 61,
        "endLine": 490,
        "endChar": 83
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "64159e82_679961b5",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 490,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:25:13Z",
      "side": 1,
      "message": "Ah, I see, I can rename them in Create if that is the common nomenclature. I also like it when teams use one style consistently, so we all read code easier.",
      "parentUuid": "e4d42ed5_1a5bc120",
      "range": {
        "startLine": 490,
        "startChar": 61,
        "endLine": 490,
        "endChar": 83
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4deb6f4_f5413029",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 493,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-07T09:14:50Z",
      "side": 1,
      "message": "Perform some light-weight....",
      "range": {
        "startLine": 493,
        "startChar": 5,
        "endLine": 493,
        "endChar": 52
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44141a88_a4ccf74a",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 493,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:01:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a4deb6f4_f5413029",
      "range": {
        "startLine": 493,
        "startChar": 5,
        "endLine": 493,
        "endChar": 52
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4deb6f4_b54ba847",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-07T09:14:50Z",
      "side": 1,
      "message": "Do you actually see this in practice? I\u0027d assume other optimization phases would take care of it already.",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "240f267a_2c375219",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:01:55Z",
      "side": 1,
      "message": "Yes, the 1, 0, and probably -1 are very common in induction. Note that these nodes are not in the HIR yet. If they would be, indeed instruction simplification would kick in, which is why I only do some light weight here, I will rely on HIR simplification later. But avoiding some of the very obvious cases saves a ton of new nodes in memory during analysis (viz. x + 0 and 1 * x occur a lot, see the tests alone already).",
      "parentUuid": "a4deb6f4_b54ba847",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "24bd66ca_535b241f",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-07T17:05:46Z",
      "side": 1,
      "message": "My point is that you can rely on HIR simplification, as we are already doing it. The fewer code the better :)",
      "parentUuid": "240f267a_2c375219",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6492fe15_ce37c116",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:25:13Z",
      "side": 1,
      "message": "I fully agree with that, which is why I did not have this earlier. But while working with it a bit, it seems a bit of a waste to have all those nodes in memory for nothing (also it makes debugging output easier to read, but that would not be my sole reason).",
      "parentUuid": "24bd66ca_535b241f",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a455d63a_9a44c912",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-07T17:27:13Z",
      "side": 1,
      "message": "But won\u0027t that memory only be there under your test? \n\nRealistically, in production, after we run the simplifier pass, you won\u0027t have those nodes, right?",
      "parentUuid": "6492fe15_ce37c116",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "644d9e85_795b0120",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:31:01Z",
      "side": 1,
      "message": "No, this is the internal representation of normalized induction expressions. E.g. range analysis, but also loop optimization use these nodes to determine how the induction is formed.\n\nI have a CL ready that does range analysis, and uses this in BCE. I can put that out as a WIP to give you a better idea on how this works. But in essence, the induction_ mapping is what is needed by later phases.",
      "parentUuid": "a455d63a_9a44c912",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a455d63a_fa418500",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-07T17:33:32Z",
      "side": 1,
      "message": "Yes, I understand :-) What I\u0027m saying is that those a + 0, a * 1 nodes, you\u0027ll never see them in production because the instruction simplifier will have removed them.",
      "parentUuid": "644d9e85_795b0120",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0484e2ca_974ea534",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:40:19Z",
      "side": 1,
      "message": "Put in the meanwhile, it adds to the memory footprint during analysis. Since we will pass induction_ mapping to next phases, having hundred  \"100 * i + x\" will take a lot less bytes than the same hundred \"(100 * 1) * i + (x + 0)\". So if you only care about the eventually generated code, then yes, but I guess we also care about how much memory the optimizing compiler itself uses, right?",
      "parentUuid": "a455d63a_fa418500",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2461e61f_39b5c7b8",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-07T17:45:08Z",
      "side": 1,
      "message": "Let\u0027s chat offline, this conversation is ending up like a dialogue of the deaf :-)\n\nI\u0027m not talking about the generated code. I\u0027m taking about whether this induction pass will ever see, eg (1 * a) in the HIR.",
      "parentUuid": "0484e2ca_974ea534",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6492fe15_4e43b179",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T17:53:01Z",
      "side": 1,
      "message": "Even if the incoming HIR is fully optimized (and it usually is), just by the nature of analysis, those + 0 and * 1 nodes are generated (otherwise I would have to simplify during analysis, making it even less desirable code).\n\nLook at the tests, not a +0 or *1 in the incoming input. Yet, the analysis by its mechanical nature, generates a lot of those in the internal representation.",
      "parentUuid": "2461e61f_39b5c7b8",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4deb6f4_f5aa90b9",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-07T19:53:20Z",
      "side": 1,
      "message": "I see. Do you have a Java equivalent that would lead to such internal representation?",
      "parentUuid": "6492fe15_4e43b179",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04cce27b_7db5504e",
        "filename": "compiler/optimizing/induction_var_analysis.cc",
        "patchSetId": 1
      },
      "lineNbr": 529,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2015-09-07T20:12:28Z",
      "side": 1,
      "message": "Any  \n\nfor (int i \u003d 0; i \u003c 100; i++) {\n  \n}\n\nin Java will already represent the phi node a 1 * i + 0\n(since 0 is the first value, and the stride is 1)\nand the add node\ni_2 \u003d i_1 + 1\n\nas 1 * i + (0 + 1)\n(since it transfers the first representation over the + 1, so we add the 0 value).\n\nIf we need to special cases the transfer operations, we would get horrible convoluted code. But by adding just a few basic rules to the CreateXX() method we avoid the most common cases.\n\nNote that I am generally fully in agreement with you, we should not have two simplifiers if one suffices (for all the good software engineering reasons).\n\nIt is just that a few lines of code at a very well-defined place will save a substantial amount of runtime internal representation, so I thought this would be worthwhile.",
      "parentUuid": "a4deb6f4_f5aa90b9",
      "range": {
        "startLine": 496,
        "startChar": 0,
        "endLine": 529,
        "endChar": 3
      },
      "revId": "081ee2f266f535a25540ad26d7ccd6f3d46a290d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}