{
  "comments": [
    {
      "key": {
        "uuid": "bf4bfc72_cdc9215d",
        "filename": "runtime/atomic.h",
        "patchSetId": 2
      },
      "lineNbr": 21,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-05-21T18:47:44Z",
      "side": 1,
      "message": "A side question: do we currently build with clang for host and with gcc for target (that is, we use std::atomic for host only) by default?",
      "range": {
        "startLine": 21,
        "startChar": 8,
        "endLine": 21,
        "endChar": 26
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f3504d1_324da582",
        "filename": "runtime/atomic.h",
        "patchSetId": 2
      },
      "lineNbr": 138,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "Should be \"accesses\".  We also need to guarantee that prior loads by the other thread do NOT see subsequent stores by this thread.",
      "range": {
        "startLine": 138,
        "startChar": 93,
        "endLine": 138,
        "endChar": 99
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f5ee42c_be09714c",
        "filename": "runtime/atomic.h",
        "patchSetId": 2
      },
      "lineNbr": 146,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "\"accesses\"",
      "range": {
        "startLine": 146,
        "startChar": 93,
        "endLine": 146,
        "endChar": 99
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f5ee42c_de81c53b",
        "filename": "runtime/atomic.h",
        "patchSetId": 2
      },
      "lineNbr": 187,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "I think this needs to be volatile for now.  Otherwise compilers can misoptimize relaxed loads and stores.  Sorry I missed that the first time.\n\nIf that turns into a performance issue, we can add a separate primitive for non-racing accesses.  C++17 may end up with something like that as well.",
      "range": {
        "startLine": 187,
        "startChar": 2,
        "endLine": 187,
        "endChar": 11
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f3f0cb7_9789e3aa",
        "filename": "runtime/base/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 353,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "Presumably this should also be converted to AtomicInteger?",
      "range": {
        "startLine": 353,
        "startChar": 2,
        "endLine": 353,
        "endChar": 40
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f5ee42c_5e1b9546",
        "filename": "runtime/gc/accounting/atomic_stack.h",
        "patchSetId": 2
      },
      "lineNbr": 132,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "In what sense is this stack concurrent?  If someone can simultaneously add something to the stack, then those additions need to use release operations on the index, and this should be an acquire operation.  In any case, this change is improving matters, but I\u0027m not sure whether it\u0027s actually fixing it.\n\nSimilar issues arise elsewhere in this file where data is added to, or removed from, the stack.",
      "range": {
        "startLine": 132,
        "startChar": 33,
        "endLine": 132,
        "endChar": 46
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f5ee42c_be03b1d9",
        "filename": "runtime/gc/accounting/atomic_stack.h",
        "patchSetId": 2
      },
      "lineNbr": 153,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "This API looks dubious to me for a concurrent data structure.  Traversals using the resulting pointer are allowed only if everything else is stopped?  Again this CL is certainly not making things worse.",
      "range": {
        "startLine": 153,
        "startChar": 5,
        "endLine": 153,
        "endChar": 12
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f3504d1_526ca98a",
        "filename": "runtime/gc/collector/mark_sweep.cc",
        "patchSetId": 2
      },
      "lineNbr": 1218,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "I\u0027m still not sure why you would use SequentiallyConsistent inside CHECK.  Since the rest of the code doesn\u0027t really see the outcome of the loads, it can\u0027t tell whether order is enforced.",
      "range": {
        "startLine": 1218,
        "startChar": 32,
        "endLine": 1218,
        "endChar": 59
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f3504d1_72fc4d52",
        "filename": "runtime/gc/space/bump_pointer_space-inl.h",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2014-05-21T22:47:24Z",
      "side": 1,
      "message": "Complete aside:  This looks very slow to me, if we do this on a regular basis.  Three separate (atomic) accesses to contended locations.  The accounting could presumably use relaxed operations, but that might be minor compared to cache contention.\n\nIgnore this comment if this is an unusual path.",
      "range": {
        "startLine": 79,
        "startChar": 24,
        "endLine": 79,
        "endChar": 56
      },
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f8840e2_e1e2e6eb",
        "filename": "runtime/gc/space/bump_pointer_space-inl.h",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-05-21T22:50:06Z",
      "side": 1,
      "message": "Normally we use the TLAB allocator instead of the bump pointer allocator, so it should be an unusual path.",
      "parentUuid": "7f3504d1_72fc4d52",
      "revId": "3e5cf305db800b2989ad57b7cde8fb3cc9fa1b9e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}