{
  "comments": [
    {
      "key": {
        "uuid": "104ec00c_69014c26",
        "filename": "compiler/dex/reference_map_calculator.h",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2014-10-13T19:26:24Z",
      "side": 1,
      "message": "Could you expand the context of this. Its using the verifier\u0027s GC maps and then pruning/expanding the data. Why not have a pass that computes the reference maps from LIR? This would be useful for the comment.",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 28,
        "endChar": 78
      },
      "revId": "19fa3ef1aa5af01bb7b61806a50e781f38f68acf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10f960d6_5818c967",
        "filename": "compiler/dex/reference_map_calculator.h",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1013855
      },
      "writtenOn": "2014-10-13T21:07:51Z",
      "side": 1,
      "message": "I will expand the comment on this but to answer you here, the calculator will not reuse the verifier GC maps. This is because it may need to generate GC maps for: offsets which did not exist, offsets that are not in original program order, instructions using compiler temps. Therefore what ends up happening is that the results of type inference are used by the reference map calculator. It will generate maps for each instruction (that has safepoint) based on what references reach that point. The backend changes very little in that it is only updated to call the new interface instead of verifier and the runtime does not change at all.\n\nYou are right that I could\u0027ve done the reference maps from LIRs, but conceptually it did not match what I wanted. Namely, the reference registers are a bytecode level semantic. Additionally, in absence of LIRGraph with reference type information, the MIRGraph was a better alternative. The only ugliness that arose from this approach is that the ME must provide information on whether something has safepoint when safepoints are generated by BE. However, this to me is fundamentally needed anyway since ME level optimizations must have knowledge of safepoints in order to prevent/reduce code motion around them.",
      "parentUuid": "104ec00c_69014c26",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 28,
        "endChar": 78
      },
      "revId": "19fa3ef1aa5af01bb7b61806a50e781f38f68acf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d0218832_68e06b52",
        "filename": "runtime/dex_file.cc",
        "patchSetId": 1
      },
      "lineNbr": 715,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2014-10-13T19:26:24Z",
      "side": 1,
      "message": "Is this a TODO or an optimization? Some more information would be useful.",
      "range": {
        "startLine": 715,
        "startChar": 0,
        "endLine": 715,
        "endChar": 72
      },
      "revId": "19fa3ef1aa5af01bb7b61806a50e781f38f68acf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d038a85e_39d4fa4d",
        "filename": "runtime/dex_file.cc",
        "patchSetId": 1
      },
      "lineNbr": 715,
      "author": {
        "id": 1013855
      },
      "writtenOn": "2014-10-13T21:07:51Z",
      "side": 1,
      "message": "This is more of a TODO actually. The runtime must be augmented with extra information in cases where offsets did not exist in original method but can escape to runtime with information for this offset. This can happen due to inlining method with loops for example. Another place it can happen is if you do some loop unrolling and you duplicate offsets. The reference map calculator will end up assigning a non-disambiguating offset if the reference maps are different at those points. This new offset will not have debug information unless we explicitly record it in the oat method (something we can definitely do but I wanted to keep it out of this solution).",
      "parentUuid": "d0218832_68e06b52",
      "range": {
        "startLine": 715,
        "startChar": 0,
        "endLine": 715,
        "endChar": 72
      },
      "revId": "19fa3ef1aa5af01bb7b61806a50e781f38f68acf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}