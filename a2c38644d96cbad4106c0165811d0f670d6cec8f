{
  "comments": [
    {
      "key": {
        "uuid": "c9ef43fe_50bf8ce3",
        "filename": "runtime/base/mutex.cc",
        "patchSetId": 2
      },
      "lineNbr": 998,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-18T07:26:00Z",
      "side": 1,
      "message": "Line too long",
      "range": {
        "startLine": 998,
        "startChar": 0,
        "endLine": 998,
        "endChar": 123
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c9ef43fe_90d5f423",
        "filename": "runtime/interpreter/interpreter_common.cc",
        "patchSetId": 2
      },
      "lineNbr": 707,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-09-18T09:18:37Z",
      "side": 1,
      "message": "This should be done with the mutex held, otherwise you\u0027re relying on subtle properties of the container. I would prefer\n\n    SafeMap\u003cuint32_t, std::set\u003cuint32_t\u003e\u003e* string_init_map_ptr \u003d nullptr;\n    {\n      MutexLock mu(self, *Locks::interpreter_string_init_map_lock_);\n      it \u003d method_to_string_init_map.find(method_ref);\n      if (it !\u003d method_to_string_init_map.end()) {\n        string_init_map_ptr \u003d \u0026it-\u003esecond;\n      }\n    }\n    if (string_init_map_ptr \u003d\u003d nullptr) {\n      SafeMap\u003cuint32_t, std::set\u003cuint32_t\u003e\u003e string_init_map \u003d\n          verifier::MethodVerifier::FindStringInitMap(method);\n      MutexLock mu(self, *Locks::interpreter_string_init_map_lock_);\n      // For efficiency you should add an overload of Overwrite() that takes\n      // the value as an rvalue reference and have both overloads return\n      // the iterator to the inserted/replaced entry.\n      auto it \u003d method_to_string_init_map.Overwrite(\n          method_ref, std::move(string_init_map));\n      string_init_map_ptr \u003d \u0026it-\u003esecond;\n    }",
      "range": {
        "startLine": 707,
        "startChar": 4,
        "endLine": 707,
        "endChar": 46
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "099a3b78_c673e26e",
        "filename": "runtime/interpreter/interpreter_common.cc",
        "patchSetId": 2
      },
      "lineNbr": 707,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2015-09-18T20:05:20Z",
      "side": 1,
      "message": "How can thee existing code in PS2 be thread-safe? It\u0027s reading from iterator without a lock, but it looks like that same value can be overwritten on line 711 from another thread.\n\nI don\u0027t know about SafeMap guarantees, but std::map the iterator will be invalid if the key is erased.",
      "parentUuid": "c9ef43fe_90d5f423",
      "range": {
        "startLine": 707,
        "startChar": 4,
        "endLine": 707,
        "endChar": 46
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c91663dc_3b27237a",
        "filename": "runtime/interpreter/interpreter_common.cc",
        "patchSetId": 2
      },
      "lineNbr": 707,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-09-18T20:10:33Z",
      "side": 1,
      "message": "The map is strictly growing. So this uses, as vmarko says, some conclusions from internals, namely that on insert iterators aren\u0027t invalidated, so end() must always be the same. (It\u0027s still not explicitly race-free, as there are no guarantees given for that, but if there were, it would be somewhat insane...)",
      "parentUuid": "099a3b78_c673e26e",
      "range": {
        "startLine": 707,
        "startChar": 4,
        "endLine": 707,
        "endChar": 46
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "49c27358_c8a4df88",
        "filename": "runtime/interpreter/interpreter_common.cc",
        "patchSetId": 2
      },
      "lineNbr": 707,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2015-09-18T20:32:23Z",
      "side": 1,
      "message": "Seems like a brittle microoptimization that will break the moment we decide to mutate the map in some other part of the code.\n\nI would humbly prefer we consider vmarko\u0027s alternative code here.",
      "parentUuid": "c91663dc_3b27237a",
      "range": {
        "startLine": 707,
        "startChar": 4,
        "endLine": 707,
        "endChar": 46
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "89762b11_e63ffe77",
        "filename": "runtime/interpreter/interpreter_common.cc",
        "patchSetId": 2
      },
      "lineNbr": 707,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-09-21T09:36:11Z",
      "side": 1,
      "message": "Igor is right, the Overwrite() makes this unsafe no matter what\u0027s the iterator validity. We should not Overwrite() at all, we should instead try to find() once again and if that fails we should Put() the new element. (With a micro-optimization of using lower_bound()+PutBefore().)",
      "parentUuid": "49c27358_c8a4df88",
      "range": {
        "startLine": 707,
        "startChar": 4,
        "endLine": 707,
        "endChar": 46
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8902ab8b_86d5ca23",
        "filename": "runtime/interpreter/interpreter_common.cc",
        "patchSetId": 2
      },
      "lineNbr": 708,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-09-18T09:18:37Z",
      "side": 1,
      "message": "Unnecessary std::move().",
      "range": {
        "startLine": 708,
        "startChar": 24,
        "endLine": 708,
        "endChar": 33
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "89762b11_86180ab1",
        "filename": "runtime/interpreter/interpreter_common.cc",
        "patchSetId": 2
      },
      "lineNbr": 713,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-09-18T09:18:37Z",
      "side": 1,
      "message": "This may be correct as it is but it looks odd, you\u0027re using a copy that\u0027s outside the method_to_string_init_map.",
      "range": {
        "startLine": 713,
        "startChar": 6,
        "endLine": 713,
        "endChar": 45
      },
      "revId": "a2c38644d96cbad4106c0165811d0f670d6cec8f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}