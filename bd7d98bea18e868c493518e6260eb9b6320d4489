{
  "comments": [
    {
      "key": {
        "uuid": "4d90030a_02a90c58",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-11-29T10:01:20Z",
      "side": 1,
      "message": "Mention the doc and the section describing the new implementation.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 65
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_e4e75863",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3882,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T19:33:35Z",
      "side": 1,
      "message": "I think we\u0027re OK with Relaxed here. This is performance critical, and IIUC, we only use the result as a hint; there is no correctness issue no matter what value we see here. Since we\u0027re not deducing anything important from the value, I don\u0027t think memory ordering is required.\n\nIn either case, we can presumably end up with two concurrent calls to RequestConcurrentGC or CollectGarbageInternal. Is that OK?",
      "range": {
        "startLine": 3882,
        "startChar": 56,
        "endLine": 3882,
        "endChar": 89
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_42cdd4c1",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3882,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-29T16:46:40Z",
      "side": 1,
      "message": "Having skimmed the documentation for relaxed versus sequentially consistent, I agree that relaxed seems appropriate here.\n\nAre there guarantees that relaxed updates from one thread will eventually be visible to other threads? Is it possible each thread sees its own increments of native_bytes_allocated_ but not any increments done by other threads?",
      "parentUuid": "2d266fad_e4e75863",
      "range": {
        "startLine": 3882,
        "startChar": 56,
        "endLine": 3882,
        "endChar": 89
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_072c9606",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3888,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T20:31:29Z",
      "side": 1,
      "message": "I might change all of these to relaxed for consistency, though it doesn\u0027t matter here.",
      "range": {
        "startLine": 3888,
        "startChar": 33,
        "endLine": 3888,
        "endChar": 55
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_dfba1b08",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3899,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-28T15:42:00Z",
      "side": 1,
      "message": "Probably this should be specified as a constant or parameter somewhere. I\u0027m open to suggestions.",
      "range": {
        "startLine": 3899,
        "startChar": 35,
        "endLine": 3899,
        "endChar": 48
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_c468dcd3",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3903,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T19:33:35Z",
      "side": 1,
      "message": "If we get two of these concurrently, do we correctly suppress one? That seems like a fairly important and not particularly unlikely scenario.",
      "range": {
        "startLine": 3903,
        "startChar": 4,
        "endLine": 3903,
        "endChar": 67
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_e2d18861",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3903,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-29T16:46:40Z",
      "side": 1,
      "message": "Briefly skimming the code suggests to me that we would end up running two GCs in a row in this case. I\u0027ll try writing a test case that calls RegisterNativeAllocation on multiple threads to see what happens.",
      "parentUuid": "2d266fad_c468dcd3",
      "range": {
        "startLine": 3903,
        "startChar": 4,
        "endLine": 3903,
        "endChar": 67
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_a7028224",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3912,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T20:31:29Z",
      "side": 1,
      "message": "The down side of this design is that a client that normally manages its own native memory, and only uses Cleaners as a fallback, still regularly triggers Java GCs. I\u0027m not sure how important that is. My a priori inclination would have been to still negate the effect of RegisterNativeAllocation here. That seems to make sense even if we otherwise keep the current design.\n\nMy intuition is that we would want to do this only for explicit deallocations, not for those invoked by a Cleaner.\n\nFor now, would it make sense to have RegisterNativeFree just do the decrement (probably limited to keep the value non-negative), and remove the RegisterNativeFree call from NativeAllocationRegistry? That removes an empty JNI call, and gives us a clearer path forward if this starts to matter. We\u0027d add a NativeAllocationRegistry version that handles the \"expect to deallocate natively\" case.",
      "range": {
        "startLine": 3911,
        "startChar": 2,
        "endLine": 3912,
        "endChar": 37
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_e2e8a8f7",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3912,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-29T16:46:40Z",
      "side": 1,
      "message": "I think I understand this comment and agree in principle.\n\nFor example, we could imagine a user calling RegisterNativeAllocation followed immediately by a matching RegisterNativeFree in a loop. In that case there is no reason to run GC.\n\nIf the user never relies on the GC to call RegisterNativeFree, then they don\u0027t need to use RegisterNativeAllocation or RegisterNativeFree at all. I\u0027ll take a look and see if there are any users who mostly call RegisterNativeFree explicitly, but sometimes rely on the GC to do the cleaning.\n\nI do wonder if its worth worrying about this in practice, given the limited number of users of RegisterNativeAllocation and the subtlety involved in knowing when it is appropriate to call RegisterNativeFree and when not to.",
      "parentUuid": "2d266fad_a7028224",
      "range": {
        "startLine": 3911,
        "startChar": 2,
        "endLine": 3912,
        "endChar": 37
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}