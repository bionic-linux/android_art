{
  "comments": [
    {
      "key": {
        "uuid": "4d90030a_02a90c58",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-11-29T10:01:20Z",
      "side": 1,
      "message": "Mention the doc and the section describing the new implementation.",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 65
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_9b37f30c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-21T14:36:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4d90030a_02a90c58",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 11,
        "endChar": 65
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_4248472a",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3881,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-11-29T21:46:10Z",
      "side": 1,
      "message": "Can you describe the new design in a comment?",
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_5b1b9b99",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3881,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-21T14:36:10Z",
      "side": 1,
      "message": "I can try. Is this okay? Would it be better to put a link to the doc I wrote?",
      "parentUuid": "ade97f6b_4248472a",
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f7a50a83_bd185e8e",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3881,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-12-21T18:27:37Z",
      "side": 1,
      "message": "Yes. The go link from the commit message would be good.",
      "parentUuid": "17237e9f_5b1b9b99",
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_beb73db5",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3881,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-22T09:56:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f7a50a83_bd185e8e",
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_e4e75863",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3882,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T19:33:35Z",
      "side": 1,
      "message": "I think we\u0027re OK with Relaxed here. This is performance critical, and IIUC, we only use the result as a hint; there is no correctness issue no matter what value we see here. Since we\u0027re not deducing anything important from the value, I don\u0027t think memory ordering is required.\n\nIn either case, we can presumably end up with two concurrent calls to RequestConcurrentGC or CollectGarbageInternal. Is that OK?",
      "range": {
        "startLine": 3882,
        "startChar": 56,
        "endLine": 3882,
        "endChar": 89
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_42cdd4c1",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3882,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-29T16:46:40Z",
      "side": 1,
      "message": "Having skimmed the documentation for relaxed versus sequentially consistent, I agree that relaxed seems appropriate here.\n\nAre there guarantees that relaxed updates from one thread will eventually be visible to other threads? Is it possible each thread sees its own increments of native_bytes_allocated_ but not any increments done by other threads?",
      "parentUuid": "2d266fad_e4e75863",
      "range": {
        "startLine": 3882,
        "startChar": 56,
        "endLine": 3882,
        "endChar": 89
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_9fb8ecac",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3882,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-29T18:36:31Z",
      "side": 1,
      "message": "The short answer is that you shouldn\u0027t expect sequentially consistent to make things visible much sooner. It\u0027s mostly about ordering guarantees with respect to other updates.\n\nThe detailed answers here get messy. See e.g.\nhttp://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0062r1.html, which didn\u0027t go anywhere. Part of the issue here is that hardware vendors aren\u0027t willing to provide much in the way of guarantees, and compiler writers also hate providing guarantees.\n\nBut there is a guarantee that you will see updates that \"happen before\" you.  And there is enough random synchronization in Java programs that that helps. It is also guaranteed that all accesses to a single location like native_bytes_allocated appear to occur in a single global order, consistent with happens-before, but not necessarily consistent with such global orders for other locations.\n\nI attempted to present some general guidelines for weakly ordered atomics in my recent CppCon talk (slides at http://schd.ws/hosted_files/cppcon2016/74/HansWeakAtomics.pdf, talk on YouTube)",
      "parentUuid": "4d90030a_42cdd4c1",
      "range": {
        "startLine": 3882,
        "startChar": 56,
        "endLine": 3882,
        "endChar": 89
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_622a2b42",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3885,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-11-29T21:46:10Z",
      "side": 1,
      "message": "Why is this compared to max_free_?",
      "range": {
        "startLine": 3885,
        "startChar": 35,
        "endLine": 3885,
        "endChar": 44
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_986c9922",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3885,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-21T14:36:10Z",
      "side": 1,
      "message": "The previous implementation incremented the native gc watermark by at most max_free_. This is intended to match that increment, using the assumption that the increase in the native gc watermark would exceed max_free_ based solely on the target utilization and the typical amount of memory used by an Android application. Using max_free_ instead of the target utilization means we don\u0027t have to keep track of the current number of registered native allocations.",
      "parentUuid": "ade97f6b_622a2b42",
      "range": {
        "startLine": 3885,
        "startChar": 35,
        "endLine": 3885,
        "endChar": 44
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f7a50a83_7d7426ad",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3885,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-12-21T18:27:37Z",
      "side": 1,
      "message": "OK. How about also mentioning in the above comment the rationale and that using max_free_ or 4*max_free_ (particularly the 4* part) is a heuristic that we currently use to sort of mirror what happens for the managed heap?",
      "parentUuid": "17237e9f_986c9922",
      "range": {
        "startLine": 3885,
        "startChar": 35,
        "endLine": 3885,
        "endChar": 44
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_1ec99148",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3885,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-22T09:56:21Z",
      "side": 1,
      "message": "We don\u0027t have to use the same max_free_ for both the Java and Native heaps. What do you think about having constants kNativeAllocationGcWatermark and kNativeAllocationBlockingGcWatermark instead? If we do use separate parameters for the native and java heaps, is it important to add command line options to control them, or is it okay to hardcode values for them?",
      "parentUuid": "f7a50a83_7d7426ad",
      "range": {
        "startLine": 3885,
        "startChar": 35,
        "endLine": 3885,
        "endChar": 44
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f7a50a83_6f61beba",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3885,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-12-22T18:52:17Z",
      "side": 1,
      "message": "I don\u0027t have an objection to using max_free_ as in PS2. We just need to explain that in a comment. And if we need to in the future, we could try tuning it.\n\nCode-searching by \"heapmaxfree\" indicates that there are some device types that override the HeapMaxFree values. So, if we add options for native max free, we may want to allow the \"native max free\" to be overridden there as well.\n\nIt seems to make sense to me to either, use max_free_ for native allocations and add a comment that it happens to use the same max free for managed and native, or add separate options for the \"native max free\" and add overrides for the devices. The former may be easier, but up to you.",
      "parentUuid": "17237e9f_1ec99148",
      "range": {
        "startLine": 3885,
        "startChar": 35,
        "endLine": 3885,
        "endChar": 44
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_072c9606",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3888,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T20:31:29Z",
      "side": 1,
      "message": "I might change all of these to relaxed for consistency, though it doesn\u0027t matter here.",
      "range": {
        "startLine": 3888,
        "startChar": 33,
        "endLine": 3888,
        "endChar": 55
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_d8545140",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3888,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-21T14:36:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2d266fad_072c9606",
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_dfba1b08",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3899,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-28T15:42:00Z",
      "side": 1,
      "message": "Probably this should be specified as a constant or parameter somewhere. I\u0027m open to suggestions.",
      "range": {
        "startLine": 3899,
        "startChar": 35,
        "endLine": 3899,
        "endChar": 48
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_c468dcd3",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3903,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T19:33:35Z",
      "side": 1,
      "message": "If we get two of these concurrently, do we correctly suppress one? That seems like a fairly important and not particularly unlikely scenario.",
      "range": {
        "startLine": 3903,
        "startChar": 4,
        "endLine": 3903,
        "endChar": 67
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_e2d18861",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3903,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-29T16:46:40Z",
      "side": 1,
      "message": "Briefly skimming the code suggests to me that we would end up running two GCs in a row in this case. I\u0027ll try writing a test case that calls RegisterNativeAllocation on multiple threads to see what happens.",
      "parentUuid": "2d266fad_c468dcd3",
      "range": {
        "startLine": 3903,
        "startChar": 4,
        "endLine": 3903,
        "endChar": 67
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_bfcbb032",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3903,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-29T18:36:31Z",
      "side": 1,
      "message": "If so, we should probably avoid that. E.g. use compare_exchange to reset native_bytes_allocated_, and trigger a GC only if you are the thread that succeeds at it.",
      "parentUuid": "4d90030a_e2d18861",
      "range": {
        "startLine": 3903,
        "startChar": 4,
        "endLine": 3903,
        "endChar": 67
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_b861951c",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3903,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-21T14:36:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ade97f6b_bfcbb032",
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d266fad_a7028224",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3912,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-11-28T20:31:29Z",
      "side": 1,
      "message": "The down side of this design is that a client that normally manages its own native memory, and only uses Cleaners as a fallback, still regularly triggers Java GCs. I\u0027m not sure how important that is. My a priori inclination would have been to still negate the effect of RegisterNativeAllocation here. That seems to make sense even if we otherwise keep the current design.\n\nMy intuition is that we would want to do this only for explicit deallocations, not for those invoked by a Cleaner.\n\nFor now, would it make sense to have RegisterNativeFree just do the decrement (probably limited to keep the value non-negative), and remove the RegisterNativeFree call from NativeAllocationRegistry? That removes an empty JNI call, and gives us a clearer path forward if this starts to matter. We\u0027d add a NativeAllocationRegistry version that handles the \"expect to deallocate natively\" case.",
      "range": {
        "startLine": 3911,
        "startChar": 2,
        "endLine": 3912,
        "endChar": 37
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d90030a_e2e8a8f7",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3912,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-11-29T16:46:40Z",
      "side": 1,
      "message": "I think I understand this comment and agree in principle.\n\nFor example, we could imagine a user calling RegisterNativeAllocation followed immediately by a matching RegisterNativeFree in a loop. In that case there is no reason to run GC.\n\nIf the user never relies on the GC to call RegisterNativeFree, then they don\u0027t need to use RegisterNativeAllocation or RegisterNativeFree at all. I\u0027ll take a look and see if there are any users who mostly call RegisterNativeFree explicitly, but sometimes rely on the GC to do the cleaning.\n\nI do wonder if its worth worrying about this in practice, given the limited number of users of RegisterNativeAllocation and the subtlety involved in knowing when it is appropriate to call RegisterNativeFree and when not to.",
      "parentUuid": "2d266fad_a7028224",
      "range": {
        "startLine": 3911,
        "startChar": 2,
        "endLine": 3912,
        "endChar": 37
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ade97f6b_c26c57b1",
        "filename": "runtime/gc/heap.h",
        "patchSetId": 1
      },
      "lineNbr": 1185,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-11-29T21:46:10Z",
      "side": 1,
      "message": "Would native_bytes_allocated_since_last_gc_ be a better name?",
      "range": {
        "startLine": 1185,
        "startChar": 17,
        "endLine": 1185,
        "endChar": 40
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "17237e9f_7872dd04",
        "filename": "runtime/gc/heap.h",
        "patchSetId": 1
      },
      "lineNbr": 1185,
      "author": {
        "id": 1057373
      },
      "writtenOn": "2016-12-21T14:36:10Z",
      "side": 1,
      "message": "\"since_last_gc\" is slightly misleading, because it isn\u0027t reset by normal GC (perhaps it should be?).\n\nHow about \"recent_native_bytes_allocated_\"?",
      "parentUuid": "ade97f6b_c26c57b1",
      "range": {
        "startLine": 1185,
        "startChar": 17,
        "endLine": 1185,
        "endChar": 40
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f7a50a83_7d5ae60d",
        "filename": "runtime/gc/heap.h",
        "patchSetId": 1
      },
      "lineNbr": 1185,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-12-21T18:27:37Z",
      "side": 1,
      "message": "SGTM.",
      "parentUuid": "17237e9f_7872dd04",
      "range": {
        "startLine": 1185,
        "startChar": 17,
        "endLine": 1185,
        "endChar": 40
      },
      "revId": "bd7d98bea18e868c493518e6260eb9b6320d4489",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}