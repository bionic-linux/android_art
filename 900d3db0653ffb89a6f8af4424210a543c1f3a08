{
  "comments": [
    {
      "key": {
        "uuid": "cd6bef2f_4921c58f",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-04T18:58:06Z",
      "side": 1,
      "message": "What does it mean? When we hunt down original references, we only traverse through null check and bound type.",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edb513f9_1c1eb5a9",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-05T09:45:43Z",
      "side": 1,
      "message": "We could hunt down even further for this particular DCHECK but I\u0027d think it\u0027s not worth the trouble.",
      "parentUuid": "cd6bef2f_4921c58f",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d1763d9_2dbfe50b",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-05T23:48:29Z",
      "side": 1,
      "message": "I just meant the \"the null could be behind a field access\" part of the comment. A null check/bound check on null is still really null. But a field access on a null isn\u0027t really null.",
      "parentUuid": "edb513f9_1c1eb5a9",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd53efc8_e317b292",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-06T09:58:53Z",
      "side": 1,
      "message": "Sure, it\u0027s an NPE. But I don\u0027t think we need to care.",
      "parentUuid": "6d1763d9_2dbfe50b",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "928758d1_6107b6bd",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-06T23:17:02Z",
      "side": 1,
      "message": "I just meant it\u0027s enough to say \"the null could be behind a null check or a bound type\". That\u0027s actually what we did when we hunt for the original ref.",
      "parentUuid": "cd53efc8_e317b292",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2fb3484_cc520f23",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-09T11:45:58Z",
      "side": 1,
      "message": "Not sure I understand. The comment says \"..originates from the null constant\", which IMO includes HFieldGet on a null. Is the comment confusing?",
      "parentUuid": "928758d1_6107b6bd",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f266d435_9d0de72a",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-09T16:48:32Z",
      "side": 1,
      "message": "Ok. Probably I was still thinking about after field is strongly typed. In that case, we would create different heap locations when fields are different, even for the same null constant. Then we\u0027d stop wrong typing right at the field/array get at the null constant, instead of letting it propagate further and do special asserts downstream. I think we actually can turn line 733 into asserts once CL 220683 and its follow-up in done in LSE.",
      "parentUuid": "f2fb3484_cc520f23",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "72af4490_389e89c7",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 737,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-09T17:02:21Z",
      "side": 1,
      "message": "As you noted in CL 220683, array access on null is still a problem. Not sure how we want to tackle this though.",
      "parentUuid": "f266d435_9d0de72a",
      "range": {
        "startLine": 737,
        "startChar": 37,
        "endLine": 737,
        "endChar": 68
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd6bef2f_29ed6935",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 739,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-04T18:58:06Z",
      "side": 1,
      "message": "Kind of ambiguous. \"eliminate array gets\" seems more straightforward.",
      "range": {
        "startLine": 739,
        "startChar": 73,
        "endLine": 739,
        "endChar": 93
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edb513f9_fc7789f7",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 739,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-05T09:45:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cd6bef2f_29ed6935",
      "range": {
        "startLine": 739,
        "startChar": 73,
        "endLine": 739,
        "endChar": 93
      },
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd6bef2f_e9b43148",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-04T18:58:06Z",
      "side": 1,
      "message": "I think there may be very rare cases where storing a value into a field of null constant ref, and loading a field (which is actually a different field) with the same offset from null constant ref, may trigger this assert since it\u0027s not array get. So we should probably relax the assert more.\n\nIt\u0027s almost not necessary. FindHeapLocationIndex() does compare GetDeclaringClassDefIndex() of the resolved field (for type based aliasing analysis), however since currently we don\u0027t compare dex_file (which can create unnecessary aliases, but very rare and benign), it might treat two null constant fields that should be different as the same instead,\nand then try to eliminate the load.",
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edb513f9_bc8101d7",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-05T09:45:43Z",
      "side": 1,
      "message": "\u003e I think there may be very rare cases where storing a value into a\n \u003e field of null constant ref, and loading a field (which is actually\n \u003e a different field) with the same offset from null constant ref, may\n \u003e trigger this assert since it\u0027s not array get. So we should probably\n \u003e relax the assert more.\n\nReally? Fields are correctly typed from the beginning, so GVN will not try to merge them. Don\u0027t you do the same type check in lse?\n\n \u003e \n \u003e It\u0027s almost not necessary. FindHeapLocationIndex() does compare\n \u003e GetDeclaringClassDefIndex() of the resolved field (for type based\n \u003e aliasing analysis), however since currently we don\u0027t compare\n \u003e dex_file (which can create unnecessary aliases, but very rare and\n \u003e benign), it might treat two null constant fields that should be\n \u003e different as the same instead,\n \u003e and then try to eliminate the load.\n\nok, so IIUC you agree the DCHECK can stay as it is?",
      "parentUuid": "cd6bef2f_e9b43148",
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edb513f9_dc7ccddc",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-05T09:45:43Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cd6bef2f_e9b43148",
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d1763d9_1fbc84c9",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-05T23:48:29Z",
      "side": 1,
      "message": "LSE currently uses GetDeclaringClassDefIndex() (plus offset) but not dex_file so strictly it\u0027s not correctly typed. If CL 220683 goes in, we can type fields correctly with the ArtField in FieldInfo.\n\nSo the assert can stay the same if we do a follow-up in LSE after CL 220683 goes in, or CL 220683 includes the LSE part of the change.",
      "parentUuid": "edb513f9_bc8101d7",
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd53efc8_a311ba9f",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-06T09:58:53Z",
      "side": 1,
      "message": "I know all this is very confusing, but please consider this change as the fix for b/27831001. CL 220683 will just end up being an optimizing where we cache the ArtField.",
      "parentUuid": "6d1763d9_1fbc84c9",
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "928758d1_24977c4a",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-05-06T23:17:02Z",
      "side": 1,
      "message": "CL 220683 would help the field typing in LSE (with some follow-up by using the ArtField instead of only the declaring class plus offset currently used in LSE). Before that happens, heap_value/instruction on line 741/742 may also be instance field get, although very unlikely.",
      "parentUuid": "cd53efc8_a311ba9f",
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2c25456_b48700c7",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 1
      },
      "lineNbr": 742,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-05-09T11:45:58Z",
      "side": 1,
      "message": "Yes.",
      "parentUuid": "928758d1_24977c4a",
      "revId": "900d3db0653ffb89a6f8af4424210a543c1f3a08",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}