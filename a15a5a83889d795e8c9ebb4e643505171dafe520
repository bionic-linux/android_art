{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c4fad02f_cc2b450c",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-20T15:00:28Z",
      "side": 1,
      "message": "Even for the simple case with two new Phis,\n\n  field \u003d new Object();\n  for (int i \u003d 0; i \u003c n; ++i) {  // LSE: Create Phi1 for `field`\n    if (cond) {\n      field \u003d new Object();\n    }\n    // LSE: Create Phi2 for `field`.\n  }\n  field.foo();\n\nif we passed Phi2 before Phi1, we would not determine the right nullability. The order of updates would be\n\n  VisitPhi(Phi2);  // can_be_null \u003d\u003d true because of the Phi1 input.\n  AddToWorklist(Phi2);\n  VisitPhi(Phi1);  // can_be_null \u003d\u003d false because of the pre-header input.\n    // Adds Phi1 to the work list because it is a loop Phi.\n  AddToWorklist(Phi1);\n  ProcessWorklist()\n    UpdatePhi(Phi1);  // can_be_null \u003d\u003d true because of the Phi2 input.\n      // Add dependent instruction Phi2 to the worklist.\n    UpdatePhi(Phi2);  // can_be_null \u003d\u003d true because of the \"Phi (2)\" input.\n    UpdatePhi(Phi1);  // can_be_null \u003d\u003d true because of the Phi2 input.\n      // No change.\n    UpdatePhi(Phi2);  // can_be_null \u003d\u003d true because of the \"Phi (2)\" input.\n      // No change.\n\nThe type would be correct because MergeTypes() ignores invalid input.",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2682a8a3_0bdbf159",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-11-20T18:25:13Z",
      "side": 1,
      "message": "so is there anything you want me to add here?",
      "parentUuid": "c4fad02f_cc2b450c",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "72a5bce5_7e831622",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-20T18:56:49Z",
      "side": 1,
      "message": "I\u0027m wondering if it would be better to simply enforce the right ordering.",
      "parentUuid": "2682a8a3_0bdbf159",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "afbdd19f_6777fa8c",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-11-20T19:10:42Z",
      "side": 1,
      "message": "There\u0027s no fast way to recover that ordering unfortunately I don\u0027t think. Especially since LSE is the only place this is used I think just having it support any ordering is better. WDYT?",
      "parentUuid": "72a5bce5_7e831622",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92b03f16_a6dc0b4a",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-23T15:26:30Z",
      "side": 1,
      "message": "Now that I think of it, maybe we should validate the ordering and sort if instructions are out of order.\n\nValidating the ordering: O(m + n) where m \u003d graph_-\u003eGetReversePostOrder().size() and n \u003d instructions.size() by going over instructions and \"catching up\" with the block. Sorting: O(m + n) time and memory by assigning instructions to m buckets with singly-linked linked lists and then concatenating them.",
      "parentUuid": "afbdd19f_6777fa8c",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "030b4c65_f9a77825",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-23T18:01:26Z",
      "side": 1,
      "message": "Correction: The sorting needs graph_-\u003eGetBlocks().size() buckets which may be a bit more than graph_-\u003eGetReversePostOrder().size().",
      "parentUuid": "92b03f16_a6dc0b4a",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "32eca3b3_47627e36",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-11-23T18:28:16Z",
      "side": 1,
      "message": "OTOH what we have here is O(n) both mem and time (n \u003d # of PHIs being added). Technically this requires (n + n) iterations but since it doesn\u0027t require a sort step I think this will still be faster in many circumstances.\n\nAlso adding a radix-sort routine is honestly the sort of additional complexity I\u0027d like to avoid if possible.",
      "parentUuid": "030b4c65_f9a77825",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74c897fc_0099128f",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 5
      },
      "lineNbr": 186,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-24T09:48:41Z",
      "side": 1,
      "message": "The problem is that the result still depends on the order of input instructions (at least for CanBeNull()), see the example in my first comment in this thread.",
      "parentUuid": "32eca3b3_47627e36",
      "revId": "a15a5a83889d795e8c9ebb4e643505171dafe520",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}