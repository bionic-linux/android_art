{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "155edafc_1022efef",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-10-07T19:59:44Z",
      "side": 1,
      "message": "Does this happen as part of SuspendAll below? This itself guarantees that a GC cannot happen concurrently. So I\u0027m not sure why is GC critical section required here.",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ae9a161_c6f2a34f",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1894735
      },
      "writtenOn": "2022-10-10T08:37:43Z",
      "side": 1,
      "message": "Yes, that\u0027s a part of SuspendAll. Visiting class loaders is also in SuspendAll scope. From the original bug that introduced this GCCriticalSection (CL: aosp/836451, bug: b/113777552) it appears that there could be a GC in progress and still succeed in SuspendAll. It was a while back though (from 2018).  From the original bug:\n\n* HeapTaskDaemon waits for mutator_lock_: which exclusive held by\nAndroidJUnitRunner.\n*       AndroidJUnitRunner WaitHoldingLocks on\nConditionVariable(weak_globals_add_condition_) which HeapTaskDaemon\nwill do a broadcast.\n\nHeapTaskDaemon:\n\n#0  syscall () at bionic/libc/arch-arm/bionic/syscall.S:44\n#1  0xa59a8606 in art::futex (uaddr\u003d\u003coptimized out\u003e, op\u003d0, val\u003d-1,\ntimeout\u003d\u003coptimized out\u003e, uaddr2\u003d\u003coptimized out\u003e, val3\u003d0)\n   at art/runtime/base/mutex-inl.h:43\n#2  art::ReaderWriterMutex::HandleSharedLockContention\n(this\u003d0xa580e000, self\u003d0x9fe33000, cur_state\u003d-1)\n    at art/runtime/base/mutex.cc:771\n#3  0xa5a5a500 in art::ReaderWriterMutex::SharedLock (this\u003d0xa580e000,\nself\u003d\u003coptimized out\u003e)\n    at art/runtime/base/mutex-inl.h:169\n#4  art::gc::collector::ConcurrentCopying::IssueEmptyCheckpoint\n(this\u003d\u003coptimized out\u003e)\n    at art/runtime/gc/collector/concurrent_copying.cc:1056\n#5  0xa5a5d644 in\nart::gc::collector::ConcurrentCopying::ProcessMarkStackOnce\n(this\u003d0xa5db6a80)\n    at art/runtime/gc/collector/concurrent_copying.cc:1430\n#6  0xa5a5d5d8 in\nart::gc::collector::ConcurrentCopying::ProcessMarkStack\n(this\u003d0xa5db6a80)\n\nAndroidJUnitRunner:\n#2  art::ConditionVariable::WaitHoldingLocks (this\u003d0xa5dcb1ac,\nself\u003d0x9fe3e000) at art/runtime/base/mutex.cc:953\n#3  0xa5b35ae4 in art::JavaVMExt::DecodeWeakGlobalLocked\n(this\u003d0xa5dcb140, self\u003d0x9fe3e000, ref\u003d\u003coptimized out\u003e)\n    at art/runtime/java_vm_ext.cc:799\n#4  0xa5b35a56 in art::JavaVMExt::DecodeWeakGlobal (this\u003d0xa5dcb140,\nself\u003d0x9fe3e000, ref\u003d\u003coptimized out\u003e)\n    at art/runtime/java_vm_ext.cc:788\n#5  0xa5c753a0 in art::Thread::DecodeJObject (this\u003d0x9fe3e000,\nobj\u003d0x187) at art/runtime/thread.cc:2387\n#6  0xa59db902 in art::ClassLinker::VisitClassLoaders (this\u003d\u003coptimized\nout\u003e, visitor\u003d\u003coptimized out\u003e)\n\n\n\nIf things have changed and we do guarantee there is no GC in progress then we can drop this.",
      "parentUuid": "155edafc_1022efef",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "892a5f26_a7b1048d",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-10-10T17:26:35Z",
      "side": 1,
      "message": "Now I recall that there are a bunch of places where the GC has to release the muator_lock_, notably when wanting to issue a checkpoint, which gives an opportunity to other threads to suspend-all, if needed.\n\n@hboehm@google.com, this is why I was saying that it would be actually good if we could make it mandatory for issuing checkpoints to require mutator_lock_ being held in shared mode.\n\nAnother thing that will help would if we could allow lowering mutator_lock_ from exclusive to shared mode, without releasing it.",
      "parentUuid": "2ae9a161_c6f2a34f",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47531dc4_5f806c99",
        "filename": "openjdkjvmti/deopt_manager.cc",
        "patchSetId": 2
      },
      "lineNbr": 331,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-10-10T22:31:31Z",
      "side": 1,
      "message": "My current CL doesn\u0027t specify whether RunCheckpoint holds the mmutator lock because it appears there is an easier way to solve my problems by making sure Run methods don\u0027t suspend. (Which seems to be almost true.) That change also seems a little tricky because there is at least one non-GC caller that doesn\u0027t specify whether it holds the mutator lock. Independently, that may still be a good change, though.\n\nI looked a little bit at adding lock downgrades. I think it would be more painful to provide that facility than I thought. I still think that our futex-based implementation could provide it. But on some non-Android platforms, we rely on pthread_rwlock, which doesn\u0027t. And I believe it\u0027s specified as writer-preference, which may make the semantics slightly controversial, though I don\u0027t see any showstopper issues.\n\nI wonder whether that old deadlock is still real. Some of this code has changed. HeapTaskDaemon was trying to run an empty checkpoint. Whenever we wait for weak globals, we first wait for empty checkpoint requests. And the theory is that if there aren\u0027t any, and we\u0027re processing references, then we will issue no more such requests before finishing reference processing.\n\nDo we have something like a deopt stress test? Can we try removing the GC critical section? If nothing else, a more recent set of stack traces for the deadlock would be helpful.",
      "parentUuid": "892a5f26_a7b1048d",
      "range": {
        "startLine": 331,
        "startChar": 16,
        "endLine": 331,
        "endChar": 50
      },
      "revId": "52683971729b038dcda912ed2c2d226c9dededf9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}