{
  "comments": [
    {
      "key": {
        "uuid": "6a773b0f_46a532bf",
        "filename": "compiler/optimizing/builder.cc",
        "patchSetId": 7
      },
      "lineNbr": 472,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2015-12-27T11:00:31Z",
      "side": 1,
      "message": "Not necessary - arena allocated memory is always zeroed.",
      "range": {
        "startLine": 472,
        "startChar": 0,
        "endLine": 472,
        "endChar": 48
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a8e5b43_2eee47df",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2015-12-27T11:00:31Z",
      "side": 1,
      "message": "Are you sure this is safe? The runtime assumes that there is at most one stack map per native_pc_offset, e.g. when searching for a deoptimize or try/catch stack map (go/stack-map-native). If the previous HIR instruction generated a stack map for its last native instruction, this will generate another one with the same native pc offset.\n\nIt\u0027s probably fine for the moment because GetStackMapForNativePcOffset does a linear search and will thus always return the first encountered stack map, but we\u0027ve been planning to change it to binary search.\n\nEither way, I feel like this is breaking an implicit agreement between the compiler and the runtime (which we should probably try to enforce in the stack map stream) and should at least be better documented. If it were up to me, I\u0027d emit a NOP to bump the native_pc as a safety net.",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a31fb81_593a270b",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-01-06T15:19:24Z",
      "side": 1,
      "message": "Good point. dsrbecky@ any thoughts?",
      "parentUuid": "6a8e5b43_2eee47df",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a31fb81_b9e1fbbc",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2016-01-06T16:59:32Z",
      "side": 1,
      "message": "If there are two stack maps generated for the same native_pc, aren\u0027t they essentially guaranteed to be equivalent?  Does it matter which one the run-time picks?\n\nI think my only concern is that this might waste a bit of memory due to the redundancy.",
      "parentUuid": "6a8e5b43_2eee47df",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a5f3bcc_896dbd0a",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-01-07T09:55:03Z",
      "side": 1,
      "message": "They are *not* guaranteed to be equivalent. Each is generated for a different HInstruction, likely with a different HEnvironment because the non-NativeDebugInfo instruction will have overwritten its output vreg. Since you generate NativeDebugInfos at the beginning of basic blocks, they\u0027re not even guaranteed to come from two subsequent HInstructions.\n\nAnd yes, it is absolutely critical that the runtime picks the correct one, otherwise it will look for values of vregs in the wrong locations. Deoptimization might then wrongly initialize the interpreter and try/catch will set wrong values of phis in the catch block.",
      "parentUuid": "6a31fb81_b9e1fbbc",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a54ffaf_46d1f47e",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2016-01-07T11:49:53Z",
      "side": 1,
      "message": "Oh.  I assumed the dex mapping would correspond to the state at native_pc.  This is not the case?  (i.e. does the dex mapping store state before the HInstruction, but native_pc the PC after the HInstruction?)",
      "parentUuid": "6a5f3bcc_896dbd0a",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}