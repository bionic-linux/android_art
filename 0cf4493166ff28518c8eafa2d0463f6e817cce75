{
  "comments": [
    {
      "key": {
        "uuid": "6a773b0f_46a532bf",
        "filename": "compiler/optimizing/builder.cc",
        "patchSetId": 7
      },
      "lineNbr": 472,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2015-12-27T11:00:31Z",
      "side": 1,
      "message": "Not necessary - arena allocated memory is always zeroed.",
      "range": {
        "startLine": 472,
        "startChar": 0,
        "endLine": 472,
        "endChar": 48
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a8e5b43_2eee47df",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2015-12-27T11:00:31Z",
      "side": 1,
      "message": "Are you sure this is safe? The runtime assumes that there is at most one stack map per native_pc_offset, e.g. when searching for a deoptimize or try/catch stack map (go/stack-map-native). If the previous HIR instruction generated a stack map for its last native instruction, this will generate another one with the same native pc offset.\n\nIt\u0027s probably fine for the moment because GetStackMapForNativePcOffset does a linear search and will thus always return the first encountered stack map, but we\u0027ve been planning to change it to binary search.\n\nEither way, I feel like this is breaking an implicit agreement between the compiler and the runtime (which we should probably try to enforce in the stack map stream) and should at least be better documented. If it were up to me, I\u0027d emit a NOP to bump the native_pc as a safety net.",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a31fb81_593a270b",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-01-06T15:19:24Z",
      "side": 1,
      "message": "Good point. dsrbecky@ any thoughts?",
      "parentUuid": "6a8e5b43_2eee47df",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a31fb81_b9e1fbbc",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2016-01-06T16:59:32Z",
      "side": 1,
      "message": "If there are two stack maps generated for the same native_pc, aren\u0027t they essentially guaranteed to be equivalent?  Does it matter which one the run-time picks?\n\nI think my only concern is that this might waste a bit of memory due to the redundancy.",
      "parentUuid": "6a8e5b43_2eee47df",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a5f3bcc_896dbd0a",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-01-07T09:55:03Z",
      "side": 1,
      "message": "They are *not* guaranteed to be equivalent. Each is generated for a different HInstruction, likely with a different HEnvironment because the non-NativeDebugInfo instruction will have overwritten its output vreg. Since you generate NativeDebugInfos at the beginning of basic blocks, they\u0027re not even guaranteed to come from two subsequent HInstructions.\n\nAnd yes, it is absolutely critical that the runtime picks the correct one, otherwise it will look for values of vregs in the wrong locations. Deoptimization might then wrongly initialize the interpreter and try/catch will set wrong values of phis in the catch block.",
      "parentUuid": "6a31fb81_b9e1fbbc",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0a54ffaf_46d1f47e",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2016-01-07T11:49:53Z",
      "side": 1,
      "message": "Oh.  I assumed the dex mapping would correspond to the state at native_pc.  This is not the case?  (i.e. does the dex mapping store state before the HInstruction, but native_pc the PC after the HInstruction?)",
      "parentUuid": "6a5f3bcc_896dbd0a",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8a68ef71_2a9cbf2c",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-01-07T12:17:14Z",
      "side": 1,
      "message": "Nope. The dex register map is generated from the HEnvironment of the HInstruction which reflects the mapping state before the HInstruction, not the native instruction. Since an HInstruction may emit multiple native instructions, the stack map reflects neither the state before nor after that native instruction. It is simply generated at an address where it is easily locatable by the runtime, typically at the end.\n\nYou also need to realize that the location mapping is not generated by codegen but by the register allocator. Each HInstruction is given its own linear-scan position and the register allocator can generate a different mapping at each position. Since the debug info has its own HInstruction, it will also get its own position different from other HInstructions. There\u0027s no connection to the resulting native pcs whatsoever.\n\nBut as I said from the start, all you need to do is emit a NOP before you call RecordPcInfo. Your stack map will get a unique native_pc and life will be swell again. Since that\u0027s a single instruction, you can also assume that such stack map reflects the state of the world before it.",
      "parentUuid": "0a54ffaf_46d1f47e",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a5f3bcc_894e1d70",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-01-07T13:51:39Z",
      "side": 1,
      "message": "Sorry, brain freeze. With normal stack maps you can of course assume that the stack map reflects the state just before the corresponding native instruction.\n\nEverything else still stands...",
      "parentUuid": "8a68ef71_2a9cbf2c",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a5f3bcc_a953d918",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2016-01-07T13:57:16Z",
      "side": 1,
      "message": "Would it be crazy to set the native_pc to point at the first native instruction? (so it actually corresponds to the location of dex maps)\n\nI am thinking what I need to do in the debugger when looking at the backtrace.  Let\u0027s say I am interested in local variables of non-leaf function.  The debugger will tell me the the PC of the call instruction, but there is no useful stack map there, I need to know to actually lookup the data a bit further down.  Even worse, if I wanted to see variables after finishing step out (and thus have PC right after the native call instruction), I would be in even bigger trouble.",
      "parentUuid": "8a68ef71_2a9cbf2c",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "37313583_f69f8088",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1037563
      },
      "writtenOn": "2016-03-10T08:27:37Z",
      "side": 1,
      "message": "Please, do not emit extra NOPs. The debug line info can be used not only for debugging with gdb or lldb, but for low-level profiling with tools like the linux perf, Streamline or VTune. The extra NOPs might affect performance dramatically. Is it so important to have a distinct debugging PcInfo record if we have already put one at the same place? I suggest that in such cases we just omit the PcInfo for the sake of keeping the generated code as if it is not native-debuggable.\nIf you agree, I will prepare a simple patch.",
      "parentUuid": "8a68ef71_2a9cbf2c",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "37313583_768cd063",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2016-03-10T09:12:38Z",
      "side": 1,
      "message": "I agree that those NOPs are nasty and it took a bit of convincing for me to add them in the first place, but I do not see a better solution.  The trouble is that the run-time like to puts its stackmaps after the instruction rather then before.  Let say you have function call followed by add:\n 0x10: brl\n (stackmap: pc 0x12 dex_pc 40)\n 0x12: add\nIf you dully add line mapping before each java statement:\n (stackmap: pc 0x10 dex_pc 40)\n 0x10: brl\n (stackmap: pc 0x12 dex_pc 40)\n (stackmap: pc 0x12 dex_pc 41)\n 0x12: add\nNote the we have non-unique pc and the dex_pc (and thus mapped java line differ).  Removing the second stack map would generate wrong java line number for the \"add\".  Thus the NOP was added.\n\nPossible solutions:\n1) Emit run-time\u0027s stackmap before the \"br\", not after. I think this is the right solution, but it is significant change and it is just not happening for N. Even I am too worried.\n2) Keep the NOPs.  Performance is already affected since the code as compiled debuggable and the NOPs are only emitted when strictly necessary (which is somewhat rare).\n3) Distinguish run-time\u0027s stackmaps, and debugging stackmaps.  I keep going back on forth on whether stackmap entries should have generic \"flags\" field (variable sized).  The only non-debuggale cost would be single extra uint8_t in the header.\n4) Store all stackmaps off-by-one.  That is, run-times stackmaps stay untouched, but debugging ones get offset by one.  This is hacky and there is couple of corner cases, but I think it could be made to work.  It assumes that the run-time always stores stackmaps after the instruction.  I am not sure if that is the case.\n\nAs a side note, I currently trying to figure out how to generate reasonable data for the non-debuggable case.  That is, the debugger asks for line number at \"0x10 brl\" when doing the backtrace, and gets back non-sense, because the stackmap only maps the line on 0x12.",
      "parentUuid": "37313583_f69f8088",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5706a9d0_f7076068",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1037563
      },
      "writtenOn": "2016-03-10T10:01:35Z",
      "side": 1,
      "message": "I would vote for 3.\nAnother option is to maintain the separate map https://android-review.googlesource.com/186220\nI\u0027m not sure we should care about correct line number info for non-debuggable case.",
      "parentUuid": "37313583_768cd063",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "37313583_59a9c7a7",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 7
      },
      "lineNbr": 1626,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2016-03-10T10:18:46Z",
      "side": 1,
      "message": "Before doing 3, this CL really should go first:\nhttps://android-review.googlesource.com/#/c/202929/",
      "parentUuid": "5706a9d0_f7076068",
      "range": {
        "startLine": 1626,
        "startChar": 0,
        "endLine": 1626,
        "endChar": 49
      },
      "revId": "0cf4493166ff28518c8eafa2d0463f6e817cce75",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}