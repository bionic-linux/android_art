{
  "comments": [
    {
      "key": {
        "uuid": "9143cc4f_5225d252",
        "filename": "compiler/optimizing/intrinsics_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 2423,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-02-02T11:10:23Z",
      "side": 1,
      "message": "Could we replace the call to actual HInstruction? We already do optimizations around long/float/double compares...",
      "range": {
        "startLine": 2388,
        "startChar": 0,
        "endLine": 2423,
        "endChar": 1
      },
      "revId": "7b91525f9f8ac4bd98f11eb82c092c93b016fbdf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5116b490_85f8e22d",
        "filename": "compiler/optimizing/intrinsics_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 2423,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-02-02T17:17:00Z",
      "side": 1,
      "message": "Replacing intrinsics with HIR has certain advantage (like better folding), but keeping the exact semantics of an intrinsic has certain advantages too. In this case probably the latter wins, at least for e.g. arm.",
      "parentUuid": "9143cc4f_5225d252",
      "range": {
        "startLine": 2388,
        "startChar": 0,
        "endLine": 2423,
        "endChar": 1
      },
      "revId": "7b91525f9f8ac4bd98f11eb82c092c93b016fbdf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d1b8e4d6_597ee38d",
        "filename": "compiler/optimizing/intrinsics_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 2423,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-02-02T18:07:20Z",
      "side": 1,
      "message": "what advantages for the intrinsics? Which exact semantics?",
      "parentUuid": "5116b490_85f8e22d",
      "range": {
        "startLine": 2388,
        "startChar": 0,
        "endLine": 2423,
        "endChar": 1
      },
      "revId": "7b91525f9f8ac4bd98f11eb82c092c93b016fbdf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "11e51cf3_3b62f7ec",
        "filename": "compiler/optimizing/intrinsics_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 2423,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-02-02T21:21:46Z",
      "side": 1,
      "message": "ping?",
      "parentUuid": "d1b8e4d6_597ee38d",
      "range": {
        "startLine": 2388,
        "startChar": 0,
        "endLine": 2423,
        "endChar": 1
      },
      "revId": "7b91525f9f8ac4bd98f11eb82c092c93b016fbdf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "31fce07c_d240e43b",
        "filename": "compiler/optimizing/intrinsics_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 2423,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-02-02T21:35:34Z",
      "side": 1,
      "message": "Well, unless you map the intrinsic to a very specific HIR node, something like signum allows us to do a single test followed by two conditional jumps on the same condition code. If you rewrite this into the HIR equivalent of (x \u003d\u003d 0 ? 0 : (x \u003e 0) ? 1 : -1)) you get two cmp instructions. Of course we can pattern match on this and avoid it, but hopefully you get my point.\n\nNote that I tried to bring this up a few days back, but I don\u0027t think I made my email very clear. I was bringing up we have several paths (method call -\u003e inlined -\u003e codegen, method  call -\u003e intrinsic -\u003e HIR -\u003e codegen and method call -\u003e intrinsic  -\u003e instrinsic codegen). All make certain things simpler, but ultimately all could in theory yield the same code. So I was asking for a preference, but did not hear any.",
      "parentUuid": "d1b8e4d6_597ee38d",
      "range": {
        "startLine": 2388,
        "startChar": 0,
        "endLine": 2423,
        "endChar": 1
      },
      "revId": "7b91525f9f8ac4bd98f11eb82c092c93b016fbdf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "317b00b0_14e87430",
        "filename": "compiler/optimizing/intrinsics_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 2680,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-02-02T10:24:47Z",
      "side": 1,
      "message": "This is valid for the long case as well.\n\nAnd if you special-case this here, you should also special-case this in the CreateSignLocations() to avoid the unnecessary register allocations.",
      "range": {
        "startLine": 2680,
        "startChar": 13,
        "endLine": 2680,
        "endChar": 45
      },
      "revId": "7b91525f9f8ac4bd98f11eb82c092c93b016fbdf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "31c3005d_147434ae",
        "filename": "compiler/optimizing/intrinsics_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 2680,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-02-02T17:17:00Z",
      "side": 1,
      "message": "Yes, fair enough. This was a bit half-baked. Fixed.",
      "parentUuid": "317b00b0_14e87430",
      "range": {
        "startLine": 2680,
        "startChar": 13,
        "endLine": 2680,
        "endChar": 45
      },
      "revId": "7b91525f9f8ac4bd98f11eb82c092c93b016fbdf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}