{
  "comments": [
    {
      "key": {
        "uuid": "c039b5f9_fea5ab51",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-20T10:25:54Z",
      "side": 1,
      "message": "Given we\u0027re taking locks _always_, why not taking the lock (multiple readers, one writer) at the very beginning of WalkStack, and then the instrumentation install stack visitor needs to take that writer lock to install the stubs?",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afa3479f_0b5ce28b",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-20T20:27:37Z",
      "side": 1,
      "message": "Several important stack-visitors (including things like the CatchFinder and SIGQUIT stack-dumper) pass suspend-points (allocation, class-loading, etc) during their VisitFrame call. Many of these handlers are rather enormous and rather important making me hesitant to do the (rather drastic) modifications needed to remove this.\n\nSince these visitors can suspend during the WalkStack function it is not safe to hold any locks for the duration of WalkStack.\n\nI actually tried to do this approach at first. It is at go/aog/1206897. I also mentioned why the approach was not viable in a comment on go/aog/1206896.",
      "parentUuid": "c039b5f9_fea5ab51",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0443adbc_2a6db3d7",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-21T13:01:30Z",
      "side": 1,
      "message": "Ack, I see why you\u0027d be hesitant.\n\nSo here\u0027s another suggestion: the instrumentation feature has always been fundamentally broken as multiple threads are manipulating the same data structure concurrently (nice work finding it btw!). I think we can fix this by having locks around the handling of that data structure, eg:\n\nif (reinterpret_cast\u003cuintptr_t\u003e(GetQuickInstrumentationExitPc()) \u003d\u003d *return_pc_addr) {\n MutexLock mu(self, instrumentation_lock);\n // Check if it\u0027s still the instrumentation_stub.\n if (*return_pc_addr \u003d\u003d GetQuickInstruementationExitPc()) {\n   // current_stack_depth is the actual stack depth.\n   InstrumentationFrame frame \u003d GetInstrumentationFrameAtDepth(current_stack_depth);\n   ...\n }\n}\n\nAnd then when installing the exit pc stubs on InstrumentInstallStack:\nMutexLock mu(self, instrumentation_lock);\nAddInstrumentationFrame(current_stack_depth, frame);",
      "parentUuid": "afa3479f_0b5ce28b",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7780c999_03e294dc",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-21T17:08:48Z",
      "side": 1,
      "message": "Having to perform a recursive stack-walk relying on a recursive mutex and a sequence-number to avoid infinite an loop frankly seems worse (complexity \u0026 understandability wise) than the fairly classic Seqlock approach we have here TBH.",
      "parentUuid": "0443adbc_2a6db3d7",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "190bbb88_eb3ff639",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-21T18:55:22Z",
      "side": 1,
      "message": "Where did I suggest a recursive stack walk? \n\nMy goal here is to avoid the skip_to_depth / increment_depth which I see as error-prone, and the retry logic unintuitive when it happens on code that shouldn\u0027t have to deal with instrumentation. The code that would be added to handle what I\u0027m suggesting should only be local to this \"if (reinterpret_cast\u003cuintptr_t\u003e(GetQuickInstrumentationExitPc()) \u003d\u003d return_pc):\n\nI will cook up a CL and make use of your test to check what I\u0027m suggesting makes sense. Maybe that will clarify my point.",
      "parentUuid": "7780c999_03e294dc",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ed8f417_e2534f60",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-21T21:07:49Z",
      "side": 1,
      "message": "Just taking note of what was discussed over hangouts.\n\n\u003e Where did I suggest a recursive stack walk? \n\nA recursive stack walk is the only way to accomplish something like the API you suggest without entirely rewriting the instrumentation system. We need to keep track of how many instrumentation frames we have used since there is no mapping between java depth and instrumentation depth.\n\nIf you wish I can rewrite this to avoid the retry-loop by using a recursive stack-walk. I don\u0027t believe it will be much more elegant or shorter than this is though.\n\nDo you want me to do this or is what I have here basically sufficient?",
      "parentUuid": "190bbb88_eb3ff639",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}