{
  "comments": [
    {
      "key": {
        "uuid": "c039b5f9_fea5ab51",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-20T10:25:54Z",
      "side": 1,
      "message": "Given we\u0027re taking locks _always_, why not taking the lock (multiple readers, one writer) at the very beginning of WalkStack, and then the instrumentation install stack visitor needs to take that writer lock to install the stubs?",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afa3479f_0b5ce28b",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-20T20:27:37Z",
      "side": 1,
      "message": "Several important stack-visitors (including things like the CatchFinder and SIGQUIT stack-dumper) pass suspend-points (allocation, class-loading, etc) during their VisitFrame call. Many of these handlers are rather enormous and rather important making me hesitant to do the (rather drastic) modifications needed to remove this.\n\nSince these visitors can suspend during the WalkStack function it is not safe to hold any locks for the duration of WalkStack.\n\nI actually tried to do this approach at first. It is at go/aog/1206897. I also mentioned why the approach was not viable in a comment on go/aog/1206896.",
      "parentUuid": "c039b5f9_fea5ab51",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0443adbc_2a6db3d7",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-21T13:01:30Z",
      "side": 1,
      "message": "Ack, I see why you\u0027d be hesitant.\n\nSo here\u0027s another suggestion: the instrumentation feature has always been fundamentally broken as multiple threads are manipulating the same data structure concurrently (nice work finding it btw!). I think we can fix this by having locks around the handling of that data structure, eg:\n\nif (reinterpret_cast\u003cuintptr_t\u003e(GetQuickInstrumentationExitPc()) \u003d\u003d *return_pc_addr) {\n MutexLock mu(self, instrumentation_lock);\n // Check if it\u0027s still the instrumentation_stub.\n if (*return_pc_addr \u003d\u003d GetQuickInstruementationExitPc()) {\n   // current_stack_depth is the actual stack depth.\n   InstrumentationFrame frame \u003d GetInstrumentationFrameAtDepth(current_stack_depth);\n   ...\n }\n}\n\nAnd then when installing the exit pc stubs on InstrumentInstallStack:\nMutexLock mu(self, instrumentation_lock);\nAddInstrumentationFrame(current_stack_depth, frame);",
      "parentUuid": "afa3479f_0b5ce28b",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7780c999_03e294dc",
        "filename": "runtime/stack.cc",
        "patchSetId": 6
      },
      "lineNbr": 898,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-21T17:08:48Z",
      "side": 1,
      "message": "Having to perform a recursive stack-walk relying on a recursive mutex and a sequence-number to avoid infinite an loop frankly seems worse (complexity \u0026 understandability wise) than the fairly classic Seqlock approach we have here TBH.",
      "parentUuid": "0443adbc_2a6db3d7",
      "range": {
        "startLine": 894,
        "startChar": 0,
        "endLine": 898,
        "endChar": 87
      },
      "revId": "d2b8462b2da3a6c8df404f74d2650889adc0b681",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}