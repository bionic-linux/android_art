{
  "comments": [
    {
      "key": {
        "uuid": "70f6329f_6b90214c",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 2
      },
      "lineNbr": 115,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-04-21T08:07:42Z",
      "side": 1,
      "message": "I don\u0027t understand this comment. Why would a instanceof A be transformed into a boolean not?",
      "range": {
        "startLine": 112,
        "startChar": 0,
        "endLine": 115,
        "endChar": 30
      },
      "revId": "5f4f098f6c7a1fa8e32676ce691a836912254577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "102176e2_28962b4b",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 2
      },
      "lineNbr": 115,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2015-04-21T08:38:00Z",
      "side": 1,
      "message": "It\u0027s the instruction simplifier actually... What he means is that the condition can be either \u0027if (x instanceof y)\u0027 or \u0027if (!(x instanceof y))\u0027. Simplification should get rid of the HCondition (HEqual or HNotEqual) and transform it to either InstanceOf-\u003eIf or InstanceOf-\u003eBooleanNot-\u003eIf.",
      "parentUuid": "70f6329f_6b90214c",
      "range": {
        "startLine": 112,
        "startChar": 0,
        "endLine": 115,
        "endChar": 30
      },
      "revId": "5f4f098f6c7a1fa8e32676ce691a836912254577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "70f6329f_4b95653a",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 2
      },
      "lineNbr": 117,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-04-21T08:07:42Z",
      "side": 1,
      "message": "Why do you need a guarantee?",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 117,
        "endChar": 82
      },
      "revId": "5f4f098f6c7a1fa8e32676ce691a836912254577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "102176e2_6890234c",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 2
      },
      "lineNbr": 117,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2015-04-21T08:38:00Z",
      "side": 1,
      "message": "Because if the simplification does not happen, the code will still contain Equal/NotEqual and won\u0027t match the pattern recognized here. But I\u0027ve given this a thought and I can\u0027t find an example when the condition would not be simplified. The simplifier transforms Value-\u003eEqual-\u003eIf to Value-\u003eIf which is not even affected by inlining. So unless some pass produces that pattern, we should be safe here. Another option would be running the instruction simplifier before this pass. Have you tried DCHECKing this?",
      "parentUuid": "70f6329f_4b95653a",
      "range": {
        "startLine": 117,
        "startChar": 2,
        "endLine": 117,
        "endChar": 82
      },
      "revId": "5f4f098f6c7a1fa8e32676ce691a836912254577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}