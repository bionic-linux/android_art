{
  "comments": [
    {
      "key": {
        "uuid": "4deed135_39efff9c",
        "filename": "compiler/dex/quick/x86/codegen_x86.h",
        "patchSetId": 1
      },
      "lineNbr": 260,
      "author": {
        "id": 1013855
      },
      "writtenOn": "2014-01-15T21:11:31Z",
      "side": 1,
      "message": "immediate",
      "range": {
        "startLine": 260,
        "startChar": 20,
        "endLine": 260,
        "endChar": 30
      },
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0df0590e_8ccecf68",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 864,
      "author": {
        "id": 1013855
      },
      "writtenOn": "2014-01-15T21:11:31Z",
      "side": 1,
      "message": "Even though the destination may be a dalvik register, it is possible it has been promoted or is in a physical register. I wonder if there are additional checks needed here before you do the operation in memory.",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0df0590e_0c08ffb8",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 864,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2014-01-15T21:22:27Z",
      "side": 1,
      "message": "If the location is DalvikFrame or CompilerTemp after an UpdateLoc, then the value isn\u0027t in registers (as far as I know)",
      "parentUuid": "0df0590e_8ccecf68",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0df0590e_2c74db14",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 864,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-15T21:43:09Z",
      "side": 1,
      "message": "Correct.",
      "parentUuid": "0df0590e_0c08ffb8",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0df0590e_2c25fb93",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 901,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-15T21:43:09Z",
      "side": 1,
      "message": "[my first comment here was going to be \"don\u0027t do this!\", but now I think I see what you\u0027re after.  Note, though, that it\u0027s really dangerous to directly modify the register fields of RegLocations.  Avoid doing so if possible.].\n\n\nAs you\u0027ve no doubt noticed, the general structure of Quick codegen has a 3-address bias.  I\u0027m assuming that you are intending this routine to better support 2-address operations.  Let\u0027s move this to gen_loadstore.cc, and make it available for all targets.  Also, don\u0027t pass RegLocations by reference.  They are small enough to frequently be held in registers, so make this a function that returns a RegLocation.  I could envision a similar use for int, single and double - but let\u0027s not worry about that now.  Just call this one RegLocation ForceTempWide(RegLocation loc) and DCHECK to make sure that your incoming registers are core.\n\nI\u0027m in the midst of a rework of register handling (part of the \"pair\" cleanup).  As part of that, I\u0027ll rework your new ForceTempWide() to handle core and FP regs.",
      "range": {
        "startLine": 901,
        "startChar": 17,
        "endLine": 901,
        "endChar": 26
      },
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4deed135_74e18eed",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 901,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2014-01-15T22:03:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0df0590e_2c25fb93",
      "range": {
        "startLine": 901,
        "startChar": 17,
        "endLine": 901,
        "endChar": 26
      },
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edaa25eb_d2606420",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 921,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-15T21:43:09Z",
      "side": 1,
      "message": "The various UpdateLocs tell you if the desired value happens to already be live in a register.  It will not, however, allocate any registers.  For rl_dest, what you generaly want is EvalLoc().  EvalLoc() will ensure that physical registers are allocated for your eventual result.  Your use of UpdateLoc to snoop on the current state of the world is fine, but if you can\u0027t do the operation directly into registers you may end up at the final StoreValue with no registers having been allocated.\n\nYou may generally get away with this, but I think you may get caught if one of the two Dalvik vregs that makes up the wide value here was promoted, but the other wasn\u0027t.  EvalLocWide() deals with this case.\n\n\nAdd an EvalLocWide below, immediately before the final StoreValueWide().",
      "range": {
        "startLine": 921,
        "startChar": 33,
        "endLine": 921,
        "endChar": 35
      },
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edaa25eb_b2983863",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 943,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2014-01-15T20:27:58Z",
      "side": 1,
      "message": "Is this necessary?  I couldn\u0027t figure out if LoadValueWide returns a temporary copy if the home location is in Core registers.",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0df0590e_2caa1b6c",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 943,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2014-01-15T21:11:15Z",
      "side": 1,
      "message": "I think EvalLocWide is what I really wanted.",
      "parentUuid": "edaa25eb_b2983863",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4deed135_14ff62d5",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 943,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-15T21:43:09Z",
      "side": 1,
      "message": "The above call to LoadValueWide lets you specify the register class you want (which could be anything - float even if it\u0027s core, or core if it\u0027s float).  It will ensure that the value is loaded into physical register[s] of the specified class.  However, you cannot assume that the register[s] will be temp.  If the value has been promoted, you\u0027ll get the promoted register.",
      "parentUuid": "edaa25eb_b2983863",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edaa25eb_32460896",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 952,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-15T21:43:09Z",
      "side": 1,
      "message": "EvalLocWide() here.",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0df0590e_6c26e3e7",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 952,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2014-01-15T22:03:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "edaa25eb_32460896",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4deed135_74950edb",
        "filename": "compiler/dex/quick/x86/int_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 952,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-15T22:34:07Z",
      "side": 1,
      "message": "Now that I think about it, my advice about needing an EvalLocWide() here was wrong.  What threw me here was not seeing an EvalLoc anywhere - which is something that\u0027s usually required.  However, your new ForceTempWide() plays a similar role to EvalLoc elsewhere.  Normally, you\u0027d:\n\nrl_src1 \u003d LoadValue()\n\nrl_src2 \u003d LoadValue()\n\nrl_result \u003d EvalLoc(rl_dest)\n\n... do operations into rl_result\u0027s registers\n\nStoreValue(rl_dest, rl_result);  // flush to home location\n\n\nYour ForceTempWide can be looked at as the functional equivalent of\n\n\nrl_src \u003d LoadValue(rl_src)\n\nrl_result \u003d EvalLoc(rl_dest)\n\ncopy(rl_result, rl_src)\n\n\nSo, I don\u0027t think you need the explicit EvalLoc after all.  However, to make this code fit in better with the existing scheme, go ahead and use the \"rl_result\" name for the result of ForceTempWide:\n\nRegLocation rl_result \u003d ForceTempWide(rl_src)\n\n.. then operate on rl_result\n\nStoreValue(rl_dest, rl_result);\n\n\nNow, I think there may be another problem that I overlooked.  In your ForceTempWide, if either of the registers is already a temp you leave it alone and use it as-is.  In this case, you also need to Clobber() it to break the association between that temp register and the src vReg it was loaded from.  Otherwise, a subsequent operation may attempt to reuse that register assuming the original vreg\u0027s value is still live in it (and you\u0027ve since stepped on it).",
      "parentUuid": "edaa25eb_32460896",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edaa25eb_d2bea4b6",
        "filename": "compiler/dex/quick/x86/target_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 682,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2014-01-15T20:27:58Z",
      "side": 1,
      "message": "This is a bug fix.  IsFpReg(INVALID_REG) returns \u0027true\u0027",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4deed135_54228abe",
        "filename": "compiler/dex/quick/x86/target_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 682,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-15T21:43:09Z",
      "side": 1,
      "message": "Ah, yes.  I\u0027ll keep that in mind during my register rework. 0xff does match all of the bit mask flags.  Yuck.",
      "parentUuid": "edaa25eb_d2bea4b6",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "edaa25eb_12c14c3c",
        "filename": "compiler/dex/quick/x86/target_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 700,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2014-01-15T20:27:58Z",
      "side": 1,
      "message": "More fixes..",
      "revId": "b23811a68bdda4fb1d171fef6965b907c7997988",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}