{
  "comments": [
    {
      "key": {
        "uuid": "64912617_458e48ab",
        "filename": "compiler/optimizing/optimizing_compiler.cc",
        "patchSetId": 1
      },
      "lineNbr": 677,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-09-21T14:56:16Z",
      "side": 1,
      "message": "Is this beneficial without an architecture-specific simplifier (as on ARM/ARM64)?",
      "revId": "b8e9c35df4058834afc95e2dbfb0e8114b1991da",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ad19799_c907b63d",
        "filename": "compiler/optimizing/optimizing_compiler.cc",
        "patchSetId": 1
      },
      "lineNbr": 677,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-09-21T16:20:41Z",
      "side": 1,
      "message": "I had prototyped the same for x86/x86_64 since it does help to clean up e.g. the code generated by dynamic BCE quite a bit (and thus avoids the need to add a simplifier to that part of the code).\n\nIf we go this route, and I am supportive, I would propose to make one last GVN at the end of the general optimization, and remove all arch specific GVNs. That way, we unify the six archs a bit, exposing them all to the same paths again.",
      "parentUuid": "64912617_458e48ab",
      "revId": "b8e9c35df4058834afc95e2dbfb0e8114b1991da",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "764a2977_430b8cd3",
        "filename": "compiler/optimizing/optimizing_compiler.cc",
        "patchSetId": 1
      },
      "lineNbr": 677,
      "author": {
        "id": 1057043
      },
      "writtenOn": "2017-09-21T20:58:42Z",
      "side": 1,
      "message": "This reduces .oat files by 0.1-0.15% in size on MIPS.\n\nAlso I hear that this is needed (or helpful) for HIntermediateArrayAddressIndex (we want to avoid duplicate index scaling in e.g. a[i] \u003d b[i] + c[i]), which is in the works.",
      "parentUuid": "64912617_458e48ab",
      "revId": "b8e9c35df4058834afc95e2dbfb0e8114b1991da",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "781c6c1f_883ab77b",
        "filename": "compiler/optimizing/optimizing_compiler.cc",
        "patchSetId": 1
      },
      "lineNbr": 677,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-09-21T21:05:47Z",
      "side": 1,
      "message": "In my dynamic peeling experiment for SIMD code, which uses something very similar to the intermediate address construct, calling GVN was crucial too getting very tight and clean inner loop code. \n\nSo +1 on using GVN, but also +1 on doing this for all architectures now.",
      "parentUuid": "764a2977_430b8cd3",
      "revId": "b8e9c35df4058834afc95e2dbfb0e8114b1991da",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "db91a500_23270d20",
        "filename": "compiler/optimizing/optimizing_compiler.cc",
        "patchSetId": 1
      },
      "lineNbr": 677,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-09-22T09:18:14Z",
      "side": 1,
      "message": "Where would you do it? After architecture optimizations? But maybe ARM wants to make sure scheduling is last?",
      "parentUuid": "781c6c1f_883ab77b",
      "revId": "b8e9c35df4058834afc95e2dbfb0e8114b1991da",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}