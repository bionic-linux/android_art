{
  "comments": [
    {
      "key": {
        "uuid": "77be2d84_d9ec3c5a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 23,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T15:52:24Z",
      "side": 1,
      "message": "\"copied\" methods? Do you mean default methods?",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bbc23170_7a148d23",
        "filename": "/COMMIT_MSG",
        "patchSetId": 9
      },
      "lineNbr": 23,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-21T16:36:51Z",
      "side": 1,
      "message": "According to the documentation in class.h: \"methods that are copied from interfaces such as miranda or default methods\".",
      "parentUuid": "77be2d84_d9ec3c5a",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "31e0c73e_f23c0626",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 943,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T15:52:24Z",
      "side": 1,
      "message": "Can a private method in a subclass shadow a virtual method in a base class?",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e760ef0c_813a97d0",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 943,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-21T16:36:51Z",
      "side": 1,
      "message": "Depends on the interpretation of \"shadowing\".\n\n  class B { public void foo() { } };\n  class D extends B { private void foo(); }\n  class U { void bar() {\n    ((B) new D()).foo();  // OK\n    new D().foo();  // IllegalAccessError, exactly as in RI.\n  }}\n\nOld ART behavior was inconsistent, User and User2 had different behavior just because they were in different dex files, see the new test.",
      "parentUuid": "31e0c73e_f23c0626",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ea8b866_cdc477cf",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 943,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T20:34:20Z",
      "side": 1,
      "message": "I think the intention is to allow shadowing?\n\nhttp://www.artima.com/underthehood/invocationP.html \"invokespecial and private methods\"\n\n class Superclass {\n\n    private void interestingMethod() {\n        System.out.println(\"Superclass\u0027s interesting method.\");\n    }\n\n    void exampleMethod() {\n        interestingMethod(); //invokespecial here\n    }\n }\n\n  class Subclass extends Superclass {\n\n    void interestingMethod() {\n        System.out.println(\"Subclass\u0027s interesting method.\");\n    }\n\n    public static void main(String args[]) {\n        Subclass me \u003d new Subclass();\n        me.exampleMethod();\n    }\n  }\n\nIt will print \"Superclass\u0027s interesting method\" with invokespecial and \"Subclass\u0027s interesting method\" with invokevirtual [which javac I suppose would never emit].\n\nShall we add this test case if we don\u0027t have it already?",
      "parentUuid": "e760ef0c_813a97d0",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "61fa5778_02f76252",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 943,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-22T09:28:34Z",
      "side": 1,
      "message": "That article is mistaken.\n\nWith invokevirtual (use jasmin if needed) it should either complain about access (with -Xverify) or print \"Superclass\u0027s interesting method.\" (without -Xverify) because the lookup finds a _private_ method and a private method cannot be overridden. (But the private method is considered as overriding itself for the purposes of processing the invokevirtual.)",
      "parentUuid": "9ea8b866_cdc477cf",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c2c9bba4_157a6e89",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 943,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-22T22:28:57Z",
      "side": 1,
      "message": "I fact-checked the article, and yeah, it\u0027s partially mistaken. Nicely spotted :).\n\nIt always prints \"Superclass\u0027s interesting method\". I tried it on RI, then changed invokespecial to invokevirtual (with jasmin) and tried again (with or without -Xverify:all). It always prints the same thing.\n\n---------------------------\n\nUnder JVMS 5.4.5:\n\n\u003e An instance method m1 declared in class C overrides another instance method m2 declared in class A iff all of the following are true:\n\u003e\n\u003e C is a subclass of A.\n\u003e m2 has the same name and descriptor as m1.\n\u003e Either:\n\u003e\n\u003e m2 is marked ACC_PUBLIC; or is marked ACC_PROTECTED; or is marked neither ACC_PUBLIC nor ACC_PROTECTED nor ACC_PRIVATE and belongs to the same run-time package as C, or\n\u003e m1 overrides a method m3, m3 distinct from m1, m3 distinct from m2, such that m3 overrides m2.\n\nConsider this even simpler example:\n\n   class A { private void x(){ print(\"A\"); } public static void Main() { invoke-virtual A#x; }}\n\nOn RI, this calls \"A#x\" successfully , checked with jasmin. However in JVMS it is unspecified behavior. Does a method M override itself? It doesn\u0027t say it anywhere, but that\u0027s the assumption.\n\n-----------------\n\nand we should probably add a test for this if we don\u0027t have one already.",
      "parentUuid": "61fa5778_02f76252",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1724e717_d6f5dcee",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 948,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T15:52:24Z",
      "side": 1,
      "message": "I take it now we can\u0027t distinguish between direct/virtual when we do the method lookup, and its intentional?",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6162246a_92d6d8a4",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 948,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-21T16:36:51Z",
      "side": 1,
      "message": "Yes, that\u0027s fully intentional and exactly the same as RI behavior.",
      "parentUuid": "1724e717_d6f5dcee",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "459a34d2_598e06a5",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 948,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T20:34:20Z",
      "side": 1,
      "message": "I\u0027m not convinced this is right, maybe I\u0027m missing the bigger picture?\n\ninvokespecial should map to invoke-super and invoke-direct.\n\n\u003cinit\u003e, private invokes should be invoke-direct\ninvokes of ACC_SUPER classes (+ the other super contraints) should be invoke-super\n\nAs we demonstrated in above example, invokevirtual/invokedirect will change behavior even if same exact symbolic method reference is used, just by changing opcode.",
      "parentUuid": "6162246a_92d6d8a4",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "95780fd8_a5642945",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 948,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-22T09:28:34Z",
      "side": 1,
      "message": "Changing the opcode changes the behavior, that\u0027s to be expected. The lookup shall now be the same but we do different things with the method we found.",
      "parentUuid": "459a34d2_598e06a5",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "401cab9e_097cd369",
        "filename": "runtime/mirror/class.h",
        "patchSetId": 9
      },
      "lineNbr": 948,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-22T22:28:57Z",
      "side": 1,
      "message": "Ok, so if this is \"resolution\" then it\u0027s fine.\n\nHowever, invokestatic also shares same resolution rules. Why is there a separate FindStaticMethod? Only invokeinterface (and invokecustom) have different resolution rules.\n\nI suppose the only real difference is that exception it throws? Which could be handled at the call site?",
      "parentUuid": "95780fd8_a5642945",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0c616033_9d01c047",
        "filename": "runtime/verifier/method_resolution_kind.h",
        "patchSetId": 9
      },
      "lineNbr": 25,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T15:52:24Z",
      "side": 1,
      "message": "How does the RI equivalent of invoke-special get handled now?",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "162d8651_d247c202",
        "filename": "runtime/verifier/method_resolution_kind.h",
        "patchSetId": 9
      },
      "lineNbr": 25,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-21T16:36:51Z",
      "side": 1,
      "message": "invoke-super performs lookup based on whether the resolved class is interface or not. That\u0027s actually what I\u0027m going to do for other invokes as well, stay tuned. (And this enum shall be eliminated.)",
      "parentUuid": "0c616033_9d01c047",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "132e71e6_a732393c",
        "filename": "test/162-method-idx-clash/smali/UserOfDerivedWithStaticFooInBaseAndImplementedFooInInterface.smali",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T15:52:24Z",
      "side": 1,
      "message": "Can you do this with partial compilation somehow without the smali?\n\nI\u0027m just thinking that this test should probably work with run-test --jvm since it\u0027s supposed to make it more conforming to RI.",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8e473c3b_2b94ed89",
        "filename": "test/162-method-idx-clash/smali/UserOfDerivedWithStaticFooInBaseAndImplementedFooInInterface.smali",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-21T16:36:51Z",
      "side": 1,
      "message": "What do you mean by \"partial compilation\"? I\u0027d be happy to have java files if I find out how. (Maybe I should investigate some other tests that have 2 different versions of the same class.)",
      "parentUuid": "132e71e6_a732393c",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "51800256_a018b2c5",
        "filename": "test/162-method-idx-clash/smali/UserOfDerivedWithStaticFooInBaseAndImplementedFooInInterface.smali",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-06-21T20:34:20Z",
      "side": 1,
      "message": "If you have src,src2 directory then you can compile classes in src directory but then later recompile those classes again with src2 classes.\n\nFor example\n\n   src\\A.java\n   src\\Main.java\n   src2\\A.java\n\nsrc\\Main.java will compile with src\\A.java but use src2\\A.java at runtime",
      "parentUuid": "8e473c3b_2b94ed89",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59c98526_fe9118bb",
        "filename": "test/162-method-idx-clash/smali/UserOfDerivedWithStaticFooInBaseAndImplementedFooInInterface.smali",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-06-22T12:52:46Z",
      "side": 1,
      "message": "Done in PS10. I had to extend the default-build with \"src3\".",
      "parentUuid": "51800256_a018b2c5",
      "revId": "05ae38a5b5422f96e8cbb4761aecd8ea9f62e2ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}