{
  "comments": [
    {
      "key": {
        "uuid": "edaa25eb_35f8b231",
        "filename": "runtime/signal_catcher.cc",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1003723
      },
      "writtenOn": "2014-01-15T22:33:04Z",
      "side": 1,
      "message": "wouldn\u0027t it be cleaner to make the checkpoint restore the world the way it found it?",
      "range": {
        "startLine": 150,
        "startChar": 0,
        "endLine": 151,
        "endChar": 30
      },
      "revId": "d8076864565a9cd4fd4fc22a3d34f88f4caf3d01",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4deed135_94cd32f8",
        "filename": "runtime/signal_catcher.cc",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-01-15T22:41:59Z",
      "side": 1,
      "message": "This function runs with all of the threads suspended. The profiler checkpoint does has a ScopedObjectAccess. This would normally work if we were in kRunnable, but since we SetStateUnsafe back to the old_state, it ends up trying to acquire the mutator lock which is already exclusively held. This causes a deadlock since we don\u0027t support recursive reader writer locks. I can\u0027t think of any clean ways to change the profiler checkpoint to deal with this issue, maybe irogers can.",
      "parentUuid": "edaa25eb_35f8b231",
      "revId": "d8076864565a9cd4fd4fc22a3d34f88f4caf3d01",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4deed135_68bed2e7",
        "filename": "runtime/signal_catcher.cc",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2014-01-15T23:05:54Z",
      "side": 1,
      "message": "Our reader writer lock is non-reentrant. Scoped object access ignores transitions in the runnable case, and so this change achieves that. I\u0027d rather that we were running checkpoints with all threads suspended, so we should be able to move the checkpoint to after the ResumeAll.",
      "parentUuid": "4deed135_94cd32f8",
      "revId": "d8076864565a9cd4fd4fc22a3d34f88f4caf3d01",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0df0590e_378b88c5",
        "filename": "runtime/signal_catcher.cc",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-01-15T23:15:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "4deed135_68bed2e7",
      "revId": "d8076864565a9cd4fd4fc22a3d34f88f4caf3d01",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}