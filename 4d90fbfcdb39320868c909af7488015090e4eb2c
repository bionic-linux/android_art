{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4f2c9cf1_f0bec584",
        "filename": "libartservice/service/java/com/android/server/art/ArtManagerLocal.java",
        "patchSetId": 4
      },
      "lineNbr": 1331,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-18T21:14:05Z",
      "side": 1,
      "message": "Suggest `create` or `getNew`, since it never returns an existing instance.\n\nBtw, why is this injector wrapper necessary? I don\u0027t see it being overridden in any tests.",
      "range": {
        "startLine": 1331,
        "startChar": 32,
        "endLine": 1331,
        "endChar": 35
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "83e9324f_dfea9f9d",
        "filename": "libartservice/service/java/com/android/server/art/ArtManagerLocal.java",
        "patchSetId": 4
      },
      "lineNbr": 1331,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-19T12:31:40Z",
      "side": 1,
      "message": "Tests don\u0027t implement this method, so the method returns null by default, making the pinning a no-op. Without this injector wrapper, `ArtManagerLocal` will call into the real `ArtdRefCache`, and the latter will fail during initialization on\n`ArtModuleServiceInitializer.getArtModuleServiceManager()`.\n\nMaybe relying on the default behavior is not great. I changed ArtManagerLocalTest to return a mock pin instead, to make it more explicit.",
      "parentUuid": "4f2c9cf1_f0bec584",
      "range": {
        "startLine": 1331,
        "startChar": 32,
        "endLine": 1331,
        "endChar": 35
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca4be8af_01713a31",
        "filename": "libartservice/service/java/com/android/server/art/ArtManagerLocal.java",
        "patchSetId": 4
      },
      "lineNbr": 1331,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-19T16:12:57Z",
      "side": 1,
      "message": "\u003e Without this injector wrapper, ArtManagerLocal will call into the real ArtdRefCache, and the latter will fail during initialization on\nArtModuleServiceInitializer.getArtModuleServiceManager().\n\nSounds like we should fix that and not mock `ArtdRefCache` at all in any tests. There\u0027s only logic in it, so there\u0027s no reason to not use the real thing in the tests. It\u0027d make them better and give us confidence that the `getArtd` calls are in pinned code.\n\nI suppose an `@After` method is necessary that checks the state of the cache and resets it so that no caching happens between tests, but I think it\u0027s well worth it to get better testing.",
      "parentUuid": "83e9324f_dfea9f9d",
      "range": {
        "startLine": 1331,
        "startChar": 32,
        "endLine": 1331,
        "endChar": 35
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d25d7b10_599f3700",
        "filename": "libartservice/service/java/com/android/server/art/ArtManagerLocal.java",
        "patchSetId": 4
      },
      "lineNbr": 1331,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-19T17:11:28Z",
      "side": 1,
      "message": "We can fix this problem and use the real `ArtdRefCache`, but I doubt the value of doing this. Checking the `getArtd` calls in `ArtManagerLocalTest` does not guarantee us that all `getArtd` calls are in pinned scope because `getArtd` is called everywhere: not just in `ArtManagerLocal` itself but also in its dependencies, which we have mocked in `ArtManagerLocalTest` and cannot be checked.\n\nIf we really want to make sure that all `getArtd` calls are in pinned scope, we\u0027ll have to do something like what Jared suggested in another comment: we expose `getArtd` from the pin object instead of from the global `ArtdRefCache`. Then we\u0027ll have to do a lot of refactoring to pass the pin object around. I think it\u0027s an overkill for a non-performance-sensitive service like ART Service.\n\nI missed your suggestion on the naming. Changed to `createArtdPin`.",
      "parentUuid": "ca4be8af_01713a31",
      "range": {
        "startLine": 1331,
        "startChar": 32,
        "endLine": 1331,
        "endChar": 35
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49561463_35dd1741",
        "filename": "libartservice/service/java/com/android/server/art/ArtManagerLocal.java",
        "patchSetId": 4
      },
      "lineNbr": 1331,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-22T23:11:13Z",
      "side": 1,
      "message": "Ok, it\u0027s probably not worth the effort to check that invariant. With the change in `getArtd` there are only a few long winded invocations where the pinning would make a difference.\n\n\u003e not just in ArtManagerLocal itself but also in its dependencies, which we have mocked in ArtManagerLocalTest and cannot be checked.\n\nRight, I haven\u0027t reflected much on that before, but ideally nothing internal in ART Service should be mocked in its own tests, only the external dependencies should be*. Mocks always introduce the risk of gaps in tests since they may not mimic the real thing properly. Anyway, that\u0027s for another time.\n\n*) At least in the tests for the main successful code paths from the entry points - mocking for error conditions is another matter.",
      "parentUuid": "d25d7b10_599f3700",
      "range": {
        "startLine": 1331,
        "startChar": 32,
        "endLine": 1331,
        "endChar": 35
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5db914e7_846003a0",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-18T21:14:05Z",
      "side": 1,
      "message": "This means we\u0027re not timeout caching the artd instance if `getArtd` is called outside a pinned section. Why not do that?\n\nAnother option is to make it an error to call `getArtd` when there are no pins. That\u0027d enforce the pattern to pin at all entry points, rather than relying on the timeout cache.",
      "range": {
        "startLine": 92,
        "startChar": 12,
        "endLine": 92,
        "endChar": 30
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5493e3fd_03f6b3ef",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-19T12:31:40Z",
      "side": 1,
      "message": "Calling `getArtd` outside a pinned section is not expected, so I don\u0027t want to do caching for that.\n\nHowever, making it an error seems too strict. Unlike in C++, we don\u0027t have static analysis support in Java to make sure this doesn\u0027t happen. One can introduce a `getArtd` call in a code path that is rarely hit, and then we\u0027ll find it out very late that it causes system server crashes under certain conditions. If a call is rarely hit, performance is not that important, so it\u0027s not necessary to trade stability for it.",
      "parentUuid": "5db914e7_846003a0",
      "range": {
        "startLine": 92,
        "startChar": 12,
        "endLine": 92,
        "endChar": 30
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee81b512_ca5d3657",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-19T16:12:57Z",
      "side": 1,
      "message": "Apropos the discussion in the other thread, we should exercise the pinner in all the `ArtManagerLocal` tests, and check that `getArtd` only is called from pinned code.\n\nStill, I agree we cannot be confident no call is missed (it shouldn\u0027t be if tests are decent, but it\u0027s not safe to assume that). Given that, besides more predictable runtime behaviour, I think it gets overall more consistent and simpler if this code caches artd the same way regardless of the pin state. Then all artd instances are configured and handled the same way. In practice it means deleting this condition, making a function out of lines 137-147, and call it just before the return below.",
      "parentUuid": "5493e3fd_03f6b3ef",
      "range": {
        "startLine": 92,
        "startChar": 12,
        "endLine": 92,
        "endChar": 30
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "49e1beec_a251de8f",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-19T17:11:28Z",
      "side": 1,
      "message": "Checking the `getArtd` calls in `ArtManagerLocalTest` does not guarantee us that all `getArtd` calls are in pinned scope. See my explanation in another comment.\n\nBut I get your point on consistent caching. I made the change as you suggested.",
      "parentUuid": "ee81b512_ca5d3657",
      "range": {
        "startLine": 92,
        "startChar": 12,
        "endLine": 92,
        "endChar": 30
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f0575ac_7d67231e",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 149,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-18T21:14:05Z",
      "side": 1,
      "message": "Please fix this WARNING reported by Error Prone: [ReachabilityFenceUsage] reachabilityFence should always be called inside a finally block\n\nAnalyzer Description: Warnings generated by errorprone.\nOwner: farivar@google.com\n\n    [ReachabilityFenceUsage] reachabilityFence should always be called inside a finally block\n                Reference.reachabilityFence(this);\n                                           ^\n        (see https://errorprone.info/bugpattern/ReachabilityFenceUsage)\n\nUse `m RUN_ERROR_PRONE\u003dtrue MyModule` to reproduce locally.\n\nThis finding was found on https://android-build.googleplex.com/builds/build-details/P68180093/targets/errorprone-trunk_staging, but may also be present on other builds.\n\nThis is a different branch than your cl originated on (it was automerged), and thus might better reflect the state of the code in the git_main branch.",
      "range": {
        "startLine": 149,
        "startChar": 0,
        "endLine": 149,
        "endChar": 46
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63f3481a_a4e3ae19",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 149,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-19T12:31:40Z",
      "side": 1,
      "message": "Interesting. I followed the example in the public doc (https://developer.android.com/reference/android/util/CloseGuard). Maybe the doc needs an update.",
      "parentUuid": "7f0575ac_7d67231e",
      "range": {
        "startLine": 149,
        "startChar": 0,
        "endLine": 149,
        "endChar": 46
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65946492_2ac4ecdd",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 152,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-18T21:14:05Z",
      "side": 1,
      "message": "This looks like a false positive. Is it possible to suppress errorprone warnings? Does `@SuppressWarnings` work here?\n\n---\n\nAnalyzer Description: Warnings generated by errorprone.\nOwner: farivar@google.com\n\n    [Finalize] Do not override finalize\n            protected void finalize() throws Throwable {\n                           ^\n        (see https://errorprone.info/bugpattern/Finalize)\n\nUse `m RUN_ERROR_PRONE\u003dtrue MyModule` to reproduce locally.\n\nThis finding was found on https://android-build.googleplex.com/builds/build-details/P68180093/targets/errorprone-trunk_staging, but may also be present on other builds.\n\nThis is a different branch than your cl originated on (it was automerged), and thus might better reflect the state of the code in the git_main branch.",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 152,
        "endChar": 52
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd6f1828_cd077512",
        "filename": "libartservice/service/java/com/android/server/art/ArtdRefCache.java",
        "patchSetId": 4
      },
      "lineNbr": 152,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-19T12:31:40Z",
      "side": 1,
      "message": "Added @SuppressWarnings.",
      "parentUuid": "65946492_2ac4ecdd",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 152,
        "endChar": 52
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "650135cb_1941d99f",
        "filename": "libartservice/service/javatests/com/android/server/art/ArtdRefCacheTest.java",
        "patchSetId": 4
      },
      "lineNbr": 158,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-18T21:14:05Z",
      "side": 1,
      "message": "Please test a call with a different binder instance.",
      "range": {
        "startLine": 158,
        "startChar": 38,
        "endLine": 158,
        "endChar": 57
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c59b028_d22ecc6a",
        "filename": "libartservice/service/javatests/com/android/server/art/ArtdRefCacheTest.java",
        "patchSetId": 4
      },
      "lineNbr": 158,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-01-19T12:31:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "650135cb_1941d99f",
      "range": {
        "startLine": 158,
        "startChar": 38,
        "endLine": 158,
        "endChar": 57
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "322a76e3_9d8c24af",
        "filename": "libartservice/service/javatests/com/android/server/art/ArtdRefCacheTest.java",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-18T21:14:05Z",
      "side": 1,
      "message": "Please comment the locations where instances get created.",
      "range": {
        "startLine": 201,
        "startChar": 26,
        "endLine": 201,
        "endChar": 34
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43b0c695_037ca5a4",
        "filename": "libartservice/service/javatests/com/android/server/art/ArtdRefCacheTest.java",
        "patchSetId": 4
      },
      "lineNbr": 201,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-01-18T21:31:00Z",
      "side": 1,
      "message": "Ah, \"Cache miss\" implies that. NVM then.",
      "parentUuid": "322a76e3_9d8c24af",
      "range": {
        "startLine": 201,
        "startChar": 26,
        "endLine": 201,
        "endChar": 34
      },
      "revId": "4d90fbfcdb39320868c909af7488015090e4eb2c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}