{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0a0f4bf9_95e3bd5b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-11-15T18:23:51Z",
      "side": 1,
      "message": "I don\u0027t see a fundamental issue with this, but I do have a couple of questions about the monitor case.",
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d434b815_618e720d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2023-11-23T09:29:41Z",
      "side": 1,
      "message": "Hans, let me know if you have further comments. Otherwise, this is ready to be submitted",
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "00cab0be_f0b9285b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2023-12-01T11:38:58Z",
      "side": 1,
      "message": "Hans, friendly ping",
      "parentUuid": "d434b815_618e720d",
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9370ad47_bd023cbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2024-01-09T15:58:42Z",
      "side": 1,
      "message": "Hans, friendly ping",
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "78a9ab5b_851daf8a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-01-09T19:09:29Z",
      "side": 1,
      "message": "Sorry for the delay. I don\u0027t see a real problem. One more question to make sure we\u0027re not overlooking corner cases with monitors.",
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "821d69a4_841df4ce",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-11-15T18:23:51Z",
      "side": 1,
      "message": "There is no concern about MonitorEnter and MonitorExit operating on different copies of the same reference in different registers, and only being able to remove one of them due to less complete information about the other?\n\nAs in (pseudocode, since this can\u0027t be written in Java):\nx.MonitorEnter();\ny \u003d (unanalyzable expression that always yields true) ? x : z;\ny.MonitorExit();\n\nI think we may still be able to prove that x doesn\u0027t escape, but we won\u0027t know that the MonitorExit() can be eliminated?\n\nRelated question: Do we do enough analysis to preclude an IllegalMonitorStateException on MonitorExit?\n\nMonitor operations can presumably still be eliminated even if there is a fairly arbitrary function call inside a synchronized block. So this potentially visibly affects monitor information in stack traces. Do we care? I\u0027m not sure either way. But I wouldn\u0027t be surprised if this caused some test failures.",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "547321c0_4133f21c",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2023-11-16T11:54:49Z",
      "side": 1,
      "message": "\u003e There is no concern about MonitorEnter and MonitorExit operating on different copies of the same reference in different registers, and only being able to remove one of them due to less complete information about the other?\n\u003e \n\u003e As in (pseudocode, since this can\u0027t be written in Java):\n\u003e x.MonitorEnter();\n\u003e y \u003d (unanalyzable expression that always yields true) ? x : z;\n\u003e y.MonitorExit();\n\u003e I think we may still be able to prove that x doesn\u0027t escape, but we won\u0027t know that the MonitorExit() can be eliminated?\n\nIs that valid DEX? I don\u0027t think you could do that from a Java program for example.\n\n\u003e Related question: Do we do enough analysis to preclude an IllegalMonitorStateException on MonitorExit?\n\nNot in the optimizing compiler as far as I could see.\n\n\u003e Monitor operations can presumably still be eliminated even if there is a fairly arbitrary function call inside a synchronized block. So this potentially visibly affects monitor information in stack traces. Do we care? I\u0027m not sure either way. But I wouldn\u0027t be surprised if this caused some test failures.\n\nI think it would be fine since the synchronization was not used in the first place.",
      "parentUuid": "821d69a4_841df4ce",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1530f953_cad79fe0",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2023-11-16T13:06:48Z",
      "side": 1,
      "message": "We have a `VERIFY_ERROR_LOCKING` and a related flag `kAccMustCountLocks`. I think it prevents method compilation, but I\u0027m not really sure.",
      "parentUuid": "547321c0_4133f21c",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b8a16082_1c354d0e",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2023-11-21T14:52:33Z",
      "side": 1,
      "message": "Looks like `VERIFY_ERROR_LOCKING` during class verification would check that the locks are balanced. Such methods would not run through the optimized pipeline",
      "parentUuid": "1530f953_cad79fe0",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f17d8a2c_d03fbc38",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-01-09T19:09:29Z",
      "side": 1,
      "message": "So I guess the question becomes: If the verifier can determine that locks are balanced, are we also guaranteed that IsSingletonAndRemovable is consistent here? Or could the latter analysis be weaker?\n\nI suspect we don\u0027t actually currently need balanced locking, so that restriction on compilation may currently be spurious. That\u0027s probably irrelevant, so long as we document that we are using the assumption here. I can\u0027t imagine that performance of lock-unbalanced code will matter; we just need to be correct. (Lock-unbalanced code is very useful, but I don\u0027t think people would trust Java runtimes to handle it correctly, and it\u0027s way too hard to generate.)",
      "parentUuid": "b8a16082_1c354d0e",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04a54f9f_f114effe",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2024-01-10T18:03:32Z",
      "side": 1,
      "message": "What do you mean by `IsSingletonAndRemovable` being potentially weaker?\n\nI don\u0027t expect the balanced locking going away any time soon. It has been there for many years. I can add a comment that we are relying on `VERIFY_ERROR_LOCKING` existing.",
      "parentUuid": "f17d8a2c_d03fbc38",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b655549_baf25410",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2024-01-10T18:51:07Z",
      "side": 1,
      "message": "I don\u0027t understand either the LSE analysis or the verifier\u0027s analysis enough. My concern is that we have basically\n\nMonitorEnter x\n...\ny \u003d x; // May involve a more complicated chain of assignments\n...\nMonitorExit y\n\nand the verifier understands that x and y are the same, and hence locking is balanced, but we decide to eliminate only one of the Monitor... instructions because we don\u0027t get the same answer for removability in the two cases.\n\nI have no idea whether this is an actual issue, given the way things are implemented. But superficially we seem to be assuming that two analyses give us related results, which can be problematic.",
      "parentUuid": "04a54f9f_f114effe",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b408af14_617bd06c",
        "filename": "compiler/optimizing/load_store_elimination.cc",
        "patchSetId": 5
      },
      "lineNbr": 1079,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2024-01-11T08:33:54Z",
      "side": 1,
      "message": "The verifier does not perform LSE or any other analysis to uncover references that could be hidden outside dex registers. Therefore, if the verifier can see across those assignments, surely the compiler can - we\u0027re using SSA, so those assignments do not even exist in HIR.",
      "parentUuid": "5b655549_baf25410",
      "range": {
        "startLine": 1079,
        "startChar": 8,
        "endLine": 1079,
        "endChar": 43
      },
      "revId": "0b0b0c9a4d2320f5e398802b4f70a0d3cac2bf8e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}