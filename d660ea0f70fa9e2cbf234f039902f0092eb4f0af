{
  "comments": [
    {
      "key": {
        "uuid": "f49a3677_72702de0",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2447,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T02:46:13Z",
      "side": 1,
      "message": "Allow src2 to be Any?",
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "54c4e260_f2318191",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2447,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "Well, I could with some efforts, but then it will be very hard to deal with immediates (cmpq only supports 32 bit immediate). Is it really worth the extra logic?",
      "parentUuid": "f49a3677_72702de0",
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "94b2daf4_b4a619dc",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2448,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T01:21:41Z",
      "side": 1,
      "message": "Note that this does not have a constant folding section (yet; I wonder if we really should do this every time rather than just folding this in the HIR).\n\nAlso note that low level testing allows us to do a single compare and short branches. So we get\n\n\n      0x00002094:                   3BF2               cmp esi, edx\n      0x00002096:                   7C06               jl/nge +6 (0x0000209e)\n      0x00002098:                   7F0B               jnle/g +11 (0x000020a5)\n      0x0000209a:                   33C0               xor eax, eax\n      0x0000209c:                   EB0C               jmp +12 (0x000020aa)\n      0x0000209e:             B8FFFFFFFF               mov eax, -1\n      0x000020a3:                   EB05               jmp +5 (0x000020aa)\n      0x000020a5:             B801000000               mov eax, 1\n\n\nwhile the reference implementation can do no better than\n\n      0x000020cc:                   3BF2               cmp esi, edx\n      0x000020ce:           0F8D0A000000               jnl/ge +10 (0x000020de)\n      0x000020d4:             B8FFFFFFFF               mov eax, -1\n      0x000020d9:             E914000000               jmp +20 (0x000020f2)\n      0x000020de:                   3BF2               cmp esi, edx\n      0x000020e0:           0F8507000000               jnz/ne +7 (0x000020ed)\n      0x000020e6:                   33C0               xor eax, eax\n      0x000020e8:             E905000000               jmp +5 (0x000020f2)\n      0x000020ed:             B801000000               mov eax, 1",
      "range": {
        "startLine": 2448,
        "startChar": 0,
        "endLine": 2448,
        "endChar": 63
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34520eae_9f0bb773",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2448,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-01-28T15:31:49Z",
      "side": 1,
      "message": "Since you allow the default kOutputOverlap for the \"out\", why don\u0027t you set it to 0 first and save code size on jumps (three instead of 4)? You can then also save code size on movs by using smaller inc/dec, assuming it doesn\u0027t impact the performance:\n\n    xor eax, eax\n    cmp esi, edx\n    je end\n    jl lower\n    inc eax\n    jmp end\n  lower:\n    dec eax\n  end:",
      "parentUuid": "94b2daf4_b4a619dc",
      "range": {
        "startLine": 2448,
        "startChar": 0,
        "endLine": 2448,
        "endChar": 63
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14beeac6_a1e095b9",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2448,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T15:42:27Z",
      "side": 1,
      "message": "inc/dec have some slight performance issues compared to add/sub, but I am sure that they are irrelevant here.  I would go for the smaller code like Vladimir is suggesting.",
      "parentUuid": "34520eae_9f0bb773",
      "range": {
        "startLine": 2448,
        "startChar": 0,
        "endLine": 2448,
        "endChar": 63
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4a43ebb_a62df783",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2448,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "I like the compactness but then I will have to add the inc/dec instructions first. Will consider that in a follow up CL.\n\nFor now I have moved the xor up so we save one branch.",
      "parentUuid": "34520eae_9f0bb773",
      "range": {
        "startLine": 2448,
        "startChar": 0,
        "endLine": 2448,
        "endChar": 63
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f49a3677_32d145f2",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2514,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T02:46:13Z",
      "side": 1,
      "message": "Can just use xorl.  That will clear the upper bits too.",
      "range": {
        "startLine": 2510,
        "startChar": 6,
        "endLine": 2514,
        "endChar": 7
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14beeac6_210485f4",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2514,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "OK",
      "parentUuid": "f49a3677_32d145f2",
      "range": {
        "startLine": 2510,
        "startChar": 6,
        "endLine": 2514,
        "endChar": 7
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f49a3677_b2e455cd",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2526,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T02:46:13Z",
      "side": 1,
      "message": "movq only handles 32 bit values! You can use codegen_-\u003eLoad64BitValue",
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f4b5d6da_3a7e76f8",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2526,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T03:46:18Z",
      "side": 1,
      "message": "No, movq handles all values.  It is inefficient for ones that fit in int32_t.  Load64BitValue is still better.",
      "parentUuid": "f49a3677_b2e455cd",
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "542ce22d_7ed10524",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2526,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "Yes, the movd() method does the right thing for wider constants (otherwise my tests, and a lot of other code in this file would fail). But I like this Load() method since it avoids duplicating all the decisions every time. I am using that at more places now.",
      "parentUuid": "f4b5d6da_3a7e76f8",
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4bb5ef1_bb1353e8",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2559,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-01-28T15:31:49Z",
      "side": 1,
      "message": "Use movl() and pull it out of the `if`.",
      "range": {
        "startLine": 2553,
        "startChar": 0,
        "endLine": 2559,
        "endChar": 5
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d4b8d2d6_71f013b9",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2559,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b4bb5ef1_bb1353e8",
      "range": {
        "startLine": 2553,
        "startChar": 0,
        "endLine": 2559,
        "endChar": 5
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "94b2daf4_2f90f4fd",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2566,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T02:46:13Z",
      "side": 1,
      "message": "xorl",
      "range": {
        "startLine": 2562,
        "startChar": 4,
        "endLine": 2566,
        "endChar": 5
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "542ce22d_1eced187",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2566,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "94b2daf4_2f90f4fd",
      "range": {
        "startLine": 2562,
        "startChar": 4,
        "endLine": 2566,
        "endChar": 5
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d4c4527f_1c69193a",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2785,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-01-28T14:26:58Z",
      "side": 1,
      "message": "Add a comment that you need a writable register, so you are going to move the input into the temp register.",
      "range": {
        "startLine": 2785,
        "startChar": 0,
        "endLine": 2785,
        "endChar": 51
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34c3ee5c_f56c00de",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2785,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T14:32:52Z",
      "side": 1,
      "message": "Could there be some way of asking if the input goes dead, so it could be used as the temp instead?  In other words it could be safely clobbered?",
      "parentUuid": "d4c4527f_1c69193a",
      "range": {
        "startLine": 2785,
        "startChar": 0,
        "endLine": 2785,
        "endChar": 51
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34b68e05_4207b6fa",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2785,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-01-28T15:21:20Z",
      "side": 1,
      "message": "that\u0027s not supported right now, but could be an improvement of the register allocator.",
      "parentUuid": "34c3ee5c_f56c00de",
      "range": {
        "startLine": 2785,
        "startChar": 0,
        "endLine": 2785,
        "endChar": 51
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "542ce22d_3ecb8d78",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2785,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d4c4527f_1c69193a",
      "range": {
        "startLine": 2785,
        "startChar": 0,
        "endLine": 2785,
        "endChar": 51
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "542ce22d_78591ddd",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2822,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-28T02:46:13Z",
      "side": 1,
      "message": "31/63 to handle int/long cases",
      "range": {
        "startLine": 2822,
        "startChar": 44,
        "endLine": 2822,
        "endChar": 46
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f49a3677_12b7e10c",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2822,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-01-28T18:58:58Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "542ce22d_78591ddd",
      "range": {
        "startLine": 2822,
        "startChar": 44,
        "endLine": 2822,
        "endChar": 46
      },
      "revId": "d660ea0f70fa9e2cbf234f039902f0092eb4f0af",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}