{
  "comments": [
    {
      "key": {
        "uuid": "5cf6375e_fea97e73",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T18:16:19Z",
      "side": 1,
      "message": "Consider the following scenario while GC is going on:\n1) Mutator1 reads the reference to a non-moving object without the read barrier. So it\u0027s on its stack now.\n2) Assume that it was the last reference to that object on the heap. Now another mutator2 comes and set the reference to null.\n3) GC thread now traces the holder object as it was in the mark stack. But since the reference is null, it is unmarked.\n4) GC finishes, and since the object is unmarked, it will be reclaimed.\n5) Mutator1 assigns the reference that is on the stack to some reference on the heap.\n\nAnd we have a heap corruption.",
      "range": {
        "startLine": 28,
        "startChar": 5,
        "endLine": 29,
        "endChar": 68
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afd5c0b9_9ae23166",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-03-18T12:09:01Z",
      "side": 1,
      "message": "Good point, I\u0027ll refine this bullet point and the similar bullet point below. I\u0027ll also add another one on reading for comparison involving non-moving space objects.",
      "parentUuid": "5cf6375e_fea97e73",
      "range": {
        "startLine": 28,
        "startChar": 5,
        "endLine": 29,
        "endChar": 68
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0750706e_a518a166",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T18:16:19Z",
      "side": 1,
      "message": "Even if we assume that the reference that is read (during GC) for comparison with null is not used for any other purpose, but it will be in some register for the comparison. At this point if the mutator gets scheduled out by the kernel, then we could run into a situation where by the end of GC we will have a reference in a register to heap which could have anything in there, and if the mutator doesn\u0027t get scheduled till next GC cycle, then we will try to mark the referent during thread flip.",
      "range": {
        "startLine": 30,
        "startChar": 6,
        "endLine": 30,
        "endChar": 64
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "771b7170_6ab50744",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2019-03-15T18:48:38Z",
      "side": 1,
      "message": "I don\u0027t think that can happen if there is no suspend point between the time where the reference is loaded and the time where it is compared with null (I think this precision should be part of the comment, BTW), as in that case it should not be seen by the GC at all (it should not be recorded as a stack root).",
      "parentUuid": "0750706e_a518a166",
      "range": {
        "startLine": 30,
        "startChar": 6,
        "endLine": 30,
        "endChar": 64
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75feb053_8b53562b",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T19:26:16Z",
      "side": 1,
      "message": "Makes sense. Basically, you are saying that the register will be cleared before the next suspend point and hence will not be visible to GC, right?",
      "parentUuid": "771b7170_6ab50744",
      "range": {
        "startLine": 30,
        "startChar": 6,
        "endLine": 30,
        "endChar": 64
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0da5009c_ea427a4e",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-03-18T12:09:01Z",
      "side": 1,
      "message": "Yes, I\u0027ll add another sentence about liveness at the next suspend point.",
      "parentUuid": "75feb053_8b53562b",
      "range": {
        "startLine": 30,
        "startChar": 6,
        "endLine": 30,
        "endChar": 64
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0cd869ee_70b40e65",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T18:16:19Z",
      "side": 1,
      "message": "I believe the same thing applies here to the load of reference to the holder here that applied to my comment above to (2).",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4db601c1_3ecb8f08",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T19:26:16Z",
      "side": 1,
      "message": "In light of Roland\u0027s comment to the above comment thread, I\u0027d change my comment here a bit.\n\nConsider the following scenario:\n\nAssumption: There is only one reference to the holder object in some other object (holder\u0027s holder) on the heap.\n\n1) Mutator1 read the holder reference without read-barrier and stores it on its stack and gets scheduled out.\n2) Mutator2 sets the reference to the holder object in the holder\u0027s holder object, before it got traced by GC thread\n3) GC thread traces holder\u0027s holder but doesn\u0027t find reference to holder\n4) GC marking finishes, and the holder is reclaimed\n5) Mutator1 tries to read any constant field in the holder.",
      "parentUuid": "0cd869ee_70b40e65",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0eec380_b8301d68",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-15T22:53:39Z",
      "side": 1,
      "message": "By step (2), you mean that Mutator2 removes the reference that Mutator1 followed to find the holder object?\n\nIf (4) is possible without Mutator1 executing a suspend point, then I agree. Otherwise this would all need to happen between suspend points.",
      "parentUuid": "4db601c1_3ecb8f08",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "608b4e07_ec373887",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T23:04:12Z",
      "side": 1,
      "message": "\u003e By step (2), you mean that Mutator2 removes the reference that Mutator1 followed to find the holder object?\n\u003e \n\nYes. It was a typo on my end. I meant to say that mutator2 set that reference to null (or some other reference).\n\n\u003e If (4) is possible without Mutator1 executing a suspend point, then I agree. Otherwise this would all need to happen between suspend points.\n\nThe only time when we mark objects referred by the stack is while flipping threads prior to marking. The scenario I\u0027m presenting is all happening after the GC marking has started. Therefore, I\u0027m not sure why you think having a suspend point makes a difference. With the scenario, we have created a white reference on the stack. As soon as marking is finished everything white will be reclaimed, and therefore, as per my understanding, any attempts to load fields of the holder after GC is finished are fatal.\n\n\nIn general, one of the invariants of read-barrier based algorithm that we have is that thread stacks will always refer to non-white objects once marking has started. This invariant is broken by removing the read-barrier.",
      "parentUuid": "c0eec380_b8301d68",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac22a617_b2ff160a",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-15T23:24:08Z",
      "side": 1,
      "message": "Sorry I mis-phrased that. I should have said something like \"participating in a handshake\". I don\u0027t think this can happen if from-space objects remain valid, and nothing is reclaimed until a handshake that occurs after marking is done. In that case we\u0027d be weakening the invariant to \"Any references to white objects must have been obtained since the last suspend point, and will be dropped before the next one.\"",
      "parentUuid": "608b4e07_ec373887",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c603e9d0_29411fa9",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-16T00:44:07Z",
      "side": 1,
      "message": "After discussion with Hans here is some more clarity on this handshake that he is proposing:\n\nAt the GC\u0027s end, handshake is just another checkpoint that we already perform several times during marking-phase for capturing thread-local mark stacks. This handshake requires doing another checkpoint *after* marking to ensure that all mutators have reached there nearest suspend points.\n\nOn the mutators\u0027 end, it must guarantee that no non-black loaded reference (which indirectly means reference loaded without read-barrier) should survive past the next suspend point. By survive I mean that neither it should be made global (for example by storing in another object on the heap), nor should it stay on the thread-stack beyond the suspend point.\n\nHans, have I covered everything we discussed here?",
      "parentUuid": "ac22a617_b2ff160a",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0258825_e4e84186",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-16T04:41:33Z",
      "side": 1,
      "message": "Yes, thanks. That\u0027s right. It\u0027s unclear to me whether the benefit is worth this additional handshake/checkpoint. It may be. I was hoping that we already had it for another reason.",
      "parentUuid": "c603e9d0_29411fa9",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f9f0f87_9f77c24c",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-03-18T12:09:01Z",
      "side": 1,
      "message": "There must be a checkpoint (\"handshake\") between the end of the GC marking phase and actual reclaiming of the memory to tell threads to stop marking. If this was done without a checkpoint, then the marking itself would have been broken anyway:\n\n  - Thread 1 loads a from-space reference R and gets descheduled,\n  - Thread 2 replaces the reference with another value,\n  - GC Thread finishes marking without ever seeing R,\n  - GC Thread tells other threads to stop marking without a checkpoint,\n  - Thread 1 resumes, determines that we\u0027re not marking and keeps from-space reference R,\n  - Thread 1 reads something from reclaimed memory through R.",
      "parentUuid": "e0258825_e4e84186",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a43ac200_26d7eeb2",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-18T16:13:10Z",
      "side": 1,
      "message": "Firstly, I apologize for missing the checkpoint at the end of marking. We do have the checkpoint to inform all the mutators that marking is finished and hence to update their marking registers.\n\nComing to the scenario that @vmarko is pointing out. It will not arise simply because Thread 1 can never load a from-space reference with read-barriers around. That\u0027s what these read-barriers guarantee.\n\nI should also point out that the checkpoint at the end of marking phase is not sufficient. It has to be matched by a guarantee from the compiler that references loaded without read-barrier do not survive across the next suspend point, as I described in my previous comment. Also, the same guarantee would be required for vmarko@\u0027s first proposal above of loading a reference to a non-moving object without read-barrier.",
      "parentUuid": "3f9f0f87_9f77c24c",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f44d0db7_fde21fc0",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-03-18T16:43:33Z",
      "side": 1,
      "message": "My scenario is about the theoretical situation without the checkpoint which I show to be broken, i.e. read barrier would not be able to guarantee the necessary invariants because the implementation _has_ to load the from-space reference to start with. To be a bit more specific, just consider what would happen if Thread 1 was descheduled in the middle of the read barrier implementation, in ReadBarrier::BarrierForRoot\u003cT, kWithReadBarrier\u003e(...) between\n\n  MirrorType* ref \u003d root-\u003eAsMirrorPtr();\n\nand\n\n    if (self !\u003d nullptr \u0026\u0026 self-\u003eGetIsGcMarking())\n\nwith kUseBakerReadBarrier \u003d true.\n\nAnd I have already added another sentence about the liveness at the next suspend point, see PS3 and later.",
      "parentUuid": "a43ac200_26d7eeb2",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}