{
  "comments": [
    {
      "key": {
        "uuid": "5cf6375e_fea97e73",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 29,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T18:16:19Z",
      "side": 1,
      "message": "Consider the following scenario while GC is going on:\n1) Mutator1 reads the reference to a non-moving object without the read barrier. So it\u0027s on its stack now.\n2) Assume that it was the last reference to that object on the heap. Now another mutator2 comes and set the reference to null.\n3) GC thread now traces the holder object as it was in the mark stack. But since the reference is null, it is unmarked.\n4) GC finishes, and since the object is unmarked, it will be reclaimed.\n5) Mutator1 assigns the reference that is on the stack to some reference on the heap.\n\nAnd we have a heap corruption.",
      "range": {
        "startLine": 28,
        "startChar": 5,
        "endLine": 29,
        "endChar": 68
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0750706e_a518a166",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T18:16:19Z",
      "side": 1,
      "message": "Even if we assume that the reference that is read (during GC) for comparison with null is not used for any other purpose, but it will be in some register for the comparison. At this point if the mutator gets scheduled out by the kernel, then we could run into a situation where by the end of GC we will have a reference in a register to heap which could have anything in there, and if the mutator doesn\u0027t get scheduled till next GC cycle, then we will try to mark the referent during thread flip.",
      "range": {
        "startLine": 30,
        "startChar": 6,
        "endLine": 30,
        "endChar": 64
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "771b7170_6ab50744",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2019-03-15T18:48:38Z",
      "side": 1,
      "message": "I don\u0027t think that can happen if there is no suspend point between the time where the reference is loaded and the time where it is compared with null (I think this precision should be part of the comment, BTW), as in that case it should not be seen by the GC at all (it should not be recorded as a stack root).",
      "parentUuid": "0750706e_a518a166",
      "range": {
        "startLine": 30,
        "startChar": 6,
        "endLine": 30,
        "endChar": 64
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75feb053_8b53562b",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 30,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T19:26:16Z",
      "side": 1,
      "message": "Makes sense. Basically, you are saying that the register will be cleared before the next suspend point and hence will not be visible to GC, right?",
      "parentUuid": "771b7170_6ab50744",
      "range": {
        "startLine": 30,
        "startChar": 6,
        "endLine": 30,
        "endChar": 64
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0cd869ee_70b40e65",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T18:16:19Z",
      "side": 1,
      "message": "I believe the same thing applies here to the load of reference to the holder here that applied to my comment above to (2).",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4db601c1_3ecb8f08",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-03-15T19:26:16Z",
      "side": 1,
      "message": "In light of Roland\u0027s comment to the above comment thread, I\u0027d change my comment here a bit.\n\nConsider the following scenario:\n\nAssumption: There is only one reference to the holder object in some other object (holder\u0027s holder) on the heap.\n\n1) Mutator1 read the holder reference without read-barrier and stores it on its stack and gets scheduled out.\n2) Mutator2 sets the reference to the holder object in the holder\u0027s holder object, before it got traced by GC thread\n3) GC thread traces holder\u0027s holder but doesn\u0027t find reference to holder\n4) GC marking finishes, and the holder is reclaimed\n5) Mutator1 tries to read any constant field in the holder.",
      "parentUuid": "0cd869ee_70b40e65",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0eec380_b8301d68",
        "filename": "runtime/read_barrier_option.h",
        "patchSetId": 2
      },
      "lineNbr": 41,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-03-15T22:53:39Z",
      "side": 1,
      "message": "By step (2), you mean that Mutator2 removes the reference that Mutator1 followed to find the holder object?\n\nIf (4) is possible without Mutator1 executing a suspend point, then I agree. Otherwise this would all need to happen between suspend points.",
      "parentUuid": "4db601c1_3ecb8f08",
      "range": {
        "startLine": 31,
        "startChar": 6,
        "endLine": 41,
        "endChar": 44
      },
      "revId": "69205ccd12a4b9a5b73ae9c7bd670931c4f77825",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}