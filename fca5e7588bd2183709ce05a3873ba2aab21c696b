{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "972a7e89_0ce96bbf",
        "filename": "compiler/linker/linker_patch.h",
        "patchSetId": 1
      },
      "lineNbr": 50,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-10-08T09:02:20Z",
      "side": 1,
      "message": "Rename this to kCriticalJniEntrypointRelative",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 26
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ce78907_225b8bf3",
        "filename": "compiler/linker/linker_patch.h",
        "patchSetId": 1
      },
      "lineNbr": 50,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-10-10T09:00:11Z",
      "side": 1,
      "message": "The linker does not need to know that we\u0027re using this only for @CriticalNative. If we try to inline @FastNative in the future, the same patch type would apply for patching references to the JNI entrypoint for those.",
      "parentUuid": "972a7e89_0ce96bbf",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 26
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a9a64bd_29bed0e6",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 4576,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-10-08T09:02:20Z",
      "side": 1,
      "message": "Why no inline this line 4597?",
      "range": {
        "startLine": 4574,
        "startChar": 0,
        "endLine": 4576,
        "endChar": 14
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "59a75e81_52fca52b",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 4576,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-10-12T11:58:57Z",
      "side": 1,
      "message": "And line 4629? Done.",
      "parentUuid": "9a9a64bd_29bed0e6",
      "range": {
        "startLine": 4574,
        "startChar": 0,
        "endLine": 4576,
        "endChar": 14
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71023459_2eb3abe8",
        "filename": "dex2oat/linker/oat_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 1898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-10-08T09:02:20Z",
      "side": 1,
      "message": "Can you add a comment what is being put here (the native method being called) - but also how do we guarantee there is always one and it does correspond to a native method and not a stub?",
      "range": {
        "startLine": 1891,
        "startChar": 0,
        "endLine": 1898,
        "endChar": 20
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a05079d2_19a5a5a6",
        "filename": "dex2oat/linker/oat_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 1898,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-10-12T11:58:57Z",
      "side": 1,
      "message": "The \"what\" is the address of the JniEntrypoint. That is included in the patch type and does not need an extra comment.\n\nI added an extra DCHECK() for the target method being native to address the second part of your comment.",
      "parentUuid": "71023459_2eb3abe8",
      "range": {
        "startLine": 1891,
        "startChar": 0,
        "endLine": 1898,
        "endChar": 20
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e91d5581_e201fdb7",
        "filename": "dex2oat/linker/oat_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 1898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-10-12T12:56:52Z",
      "side": 1,
      "message": "But even though it\u0027s native, how do we guarantee it doesn\u0027t contain a runtime stub that will lookup the native address?",
      "parentUuid": "a05079d2_19a5a5a6",
      "range": {
        "startLine": 1891,
        "startChar": 0,
        "endLine": 1898,
        "endChar": 20
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7e459d33_57cb5b4d",
        "filename": "dex2oat/linker/oat_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 1898,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-10-19T13:23:24Z",
      "side": 1,
      "message": "For @CriticalNative, it initially _does_ contain a pointer to a lookup stub (or to a trampoline to the lookup stub for methods in the boot/app image). That\u0027s WAI and covered by the tests.\n\nFor non-@CriticalNative, we\u0027re not using this patch type at the moment but if we start using it, it shall have the same behavior and initially point to a lookup stub or trampoline.",
      "parentUuid": "e91d5581_e201fdb7",
      "range": {
        "startLine": 1891,
        "startChar": 0,
        "endLine": 1898,
        "endChar": 20
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e4e2d095_9f69b210",
        "filename": "dex2oat/linker/oat_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 1898,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-10-19T13:37:16Z",
      "side": 1,
      "message": "Oh, right, so what we end up putting in the generated code is a load of the entrypoint, and then call? I read the CL as actually loading directly the code pointer, is that doable?",
      "parentUuid": "7e459d33_57cb5b4d",
      "range": {
        "startLine": 1891,
        "startChar": 0,
        "endLine": 1898,
        "endChar": 20
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4cfa3efb_43e4e84d",
        "filename": "dex2oat/linker/oat_writer.cc",
        "patchSetId": 1
      },
      "lineNbr": 1898,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-10-19T13:48:11Z",
      "side": 1,
      "message": "That\u0027s not doable as we do not even know which function shall be registered at runtime. (If we did, and if we knew that the .so file shall be loaded when we\u0027re loading the oat file, we could use standard ELF relocations. But those conditions cannot be guaranteed in the JNI world.)",
      "parentUuid": "e4e2d095_9f69b210",
      "range": {
        "startLine": 1891,
        "startChar": 0,
        "endLine": 1898,
        "endChar": 20
      },
      "revId": "fca5e7588bd2183709ce05a3873ba2aab21c696b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}