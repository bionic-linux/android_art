{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5fd68956_e1d5bd55",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-05-14T19:35:05Z",
      "side": 1,
      "message": "Unfortunately, I\u0027m afraid this is going to break elsewhere because we call the getter from a context, like a signal handler, in which we can\u0027t lock. If we\u0027re sure that\u0027s not the case, then this CL looks fine to me.\n\nIf we\u0027re not, I\u0027m afraid we\u0027re going to need a messier solution. If Android had something like an RCU facility, we could maybe use that. As it stands, I would probably allocate the C++ thread name as a struct containing a C character array and an atomic reference count. The updater deallocates it if the refcount is zero, and enqueues the deletion if not. Later updates check for enqueued deletions with a zero refcount, so that readers never have to deallocate. I don\u0027t think a straight shared_ptr solution works, unless atomic\u003cshared_ptr\u003e is lock-free, which it probably isn\u0027t.",
      "revId": "14d41c80c00d9980597e830a177ba38af07e2c58",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cff04e5a_2dcbab32",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2021-05-17T13:50:01Z",
      "side": 1,
      "message": "I don\u0027t think atomic\u003cshared_ptr\u003e is lock-free (before C++20), but is that a practical problem?\n\nAs a bit more messy solution, could it just be atomic\u003cconst char[]\u003e where the readers are naive, but updates will delay the free past GC suspend point?",
      "parentUuid": "5fd68956_e1d5bd55",
      "revId": "14d41c80c00d9980597e830a177ba38af07e2c58",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04d575b4_9b7aabc7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-05-17T23:30:35Z",
      "side": 1,
      "message": "I think atomic\u003cshared_ptr\u003e is still not required to be lock-free. The C++ committee debates occasionally whether a fully-conforming lock-free implementation is feasible. It\u0027s tricky.\nThis again matters because otherwise the signal handler may run while the lock it needs to read is already held by the same thread.\nIf you can delay the deallocation long enough for all readers of the old value to finish, that should work. But since the readers don\u0027t have to be runnable, I don\u0027t think suspend points give us a handle on that. A count of the number of active readers would. There are lower overhead ways to enforce this, but I can\u0027t immediately think of any simpler ones. And I suspect we care more about simplicity than overhead here.",
      "parentUuid": "cff04e5a_2dcbab32",
      "revId": "14d41c80c00d9980597e830a177ba38af07e2c58",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "08314b77_bddee8e0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2021-05-18T09:52:23Z",
      "side": 1,
      "message": "What about read-write lock?\nI think the underlying question here is when can the signal handler that would read the thread be called.",
      "parentUuid": "04d575b4_9b7aabc7",
      "revId": "14d41c80c00d9980597e830a177ba38af07e2c58",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a31de8fb_adc92ca6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-05-18T16:28:44Z",
      "side": 1,
      "message": "I think a rwlock with writers blocking signal delivery might work in practice in our current environment. But it\u0027s certainly not conforming. (See \"man signal-safety\".) But this makes rwlock implementation assumptions. And there\u0027s some risk that some rwlock slow path will effectively end up acquiring another lock in the future. We also can\u0027t easily check that the atomics used inside the rwlock are in fact lock-free.\n\nNone of these options seem clean to me. If this is indeed called in a signal handler, I think we should do something lock-free that\u0027s actually conforming. It\u0027s a small amount of moderately tricky code, but I think less tricky than reasoning about the unsanctioned solutions. I can do that, but it will take me a little while to get to it.",
      "parentUuid": "08314b77_bddee8e0",
      "revId": "14d41c80c00d9980597e830a177ba38af07e2c58",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eabf1fda_fc270e34",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2021-11-03T12:59:28Z",
      "side": 1,
      "message": "Basic question - does the thread name need to be in native memory, or can we allocate it on managed heap and thus bypass the whole freeing issue?",
      "parentUuid": "a31de8fb_adc92ca6",
      "revId": "14d41c80c00d9980597e830a177ba38af07e2c58",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}