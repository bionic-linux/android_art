{
  "comments": [
    {
      "key": {
        "uuid": "f055c239_664160f8",
        "filename": "runtime/base/mutex.h",
        "patchSetId": 1
      },
      "lineNbr": 547,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2015-04-20T16:13:10Z",
      "side": 1,
      "message": "The Dekker approach is well-known and inefficient, for GC, precisely because of this - what is the polling interval the garbage collector should use and how do you avoid what Dalvik had of 1ms of sleep before re-polling? Note the 1ms, and without load, leads to 500us of extra GC pause on average, and 1ms at the high-end. It also requires memory barriers on architectures without TSO, meaning an x86 only analysis isn\u0027t properly representative. The current Mutex and ReaderWriterMutex are known to be inefficient:\nhttps://android-review.googlesource.com/#/c/143024/\nWhy not fix them as shown in that patch? Your 25% performance improvement is very unspecific and an analysis of GC pause time is also necessary. Pragmatically, given the trade-offs in this patch the option to use a Dekker style approach for the mutator lock should be behind a flag.",
      "range": {
        "startLine": 547,
        "startChar": 54,
        "endLine": 547,
        "endChar": 92
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0150a85_a8ddf30c",
        "filename": "runtime/base/mutex.h",
        "patchSetId": 1
      },
      "lineNbr": 547,
      "author": {
        "id": 1039961
      },
      "writtenOn": "2015-04-21T10:12:59Z",
      "side": 1,
      "message": "I am sorry to misguide you by a wrong word \"polling\" used in the comments. This patch does not use the polling mechanism to suspend threads. SuspendAll succeeds when the last runnable thread transits to the suspended state. The only difference is that originally the SuspendAll is achieved by grabbing the mutator lock exclusively and now it is achieved by all other threads pass a barrier. A thread in runnable state will pass the barrier when it transits to suspended state and threads already in suspended will get their barrier passed by the thread requesting the SuspendAll. This modification removes the lock/unlock on the mutator lock when threads transit between runnable and suspended.\nA study shows that in ART thread state change is the costliest part of the JNI. One big problem is that the mutator lock needs CAS to acquire and release between the thread state changes. The 25% JNI performance improvement by this patch is measured by a small benchmark (repeatedly call the same native function which does nothing but return). The benefit could also be observed in some benchmarks like smartbench.Mandelbrot +4%, SmartBench.String +12% and CFBench.javaMIPS +50%. I only observe 2% regression on one benchmark and did not find other negative effects.\nAbout the GC, Iâ€™ve tested this modification on Android GC Bench, the patch does not influence the pause time and we are evaluating the influence on the real apps.\nI will test the effects of this patch on ARM later and also will read the patch you mentioned.",
      "parentUuid": "f055c239_664160f8",
      "range": {
        "startLine": 547,
        "startChar": 54,
        "endLine": 547,
        "endChar": 92
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "90148689_07f6b8a5",
        "filename": "runtime/base/mutex.h",
        "patchSetId": 1
      },
      "lineNbr": 547,
      "author": {
        "id": 1039961
      },
      "writtenOn": "2015-04-21T11:59:51Z",
      "side": 1,
      "message": "When multiple threads change their states intensively, there would be severe cache line invalidations caused by the CAS on mutator lock. I think that is why the patch boosts certain multi-thread benchmarks.",
      "parentUuid": "f055c239_664160f8",
      "range": {
        "startLine": 547,
        "startChar": 54,
        "endLine": 547,
        "endChar": 92
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "90148689_a72b647c",
        "filename": "runtime/base/mutex.h",
        "patchSetId": 1
      },
      "lineNbr": 547,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2015-04-21T14:42:12Z",
      "side": 1,
      "message": "I agree that CAS operations are expensive, the patch I linked above reduces the number by half without losing the locking abstraction and the use of futexes to ensure the last man out wakes the GC. If there is heavy contention on the lock then this may be indicative of other issues going on such as GC thrashing. I don\u0027t disagree with the patch but would prefer the behavior were optional. As I stated, the implementation of this was deliberately to the detriment of mutator performance but to the benefit of GC pause times which directly translate into jank in Android.\n\nGiven the feedback this patch has generated I expect you can clean it up, including this comment, if its not truly reflective of the implementation. Again, I think this is useful work but looking at mutator performance without GC pause times misses the point of the original implementation.",
      "parentUuid": "90148689_07f6b8a5",
      "range": {
        "startLine": 547,
        "startChar": 54,
        "endLine": 547,
        "endChar": 92
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "305cba63_6d7c9d34",
        "filename": "runtime/interpreter/interpreter_goto_table_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 75,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-04-20T15:53:44Z",
      "side": 1,
      "message": "What does this have to do with your CL\u0027s stated intent? Different CL, please.",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 75,
        "endChar": 17
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0150a85_68e49bd6",
        "filename": "runtime/interpreter/interpreter_goto_table_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 75,
      "author": {
        "id": 1039961
      },
      "writtenOn": "2015-04-21T10:12:59Z",
      "side": 1,
      "message": "I will refactor the code and reupload.",
      "parentUuid": "305cba63_6d7c9d34",
      "range": {
        "startLine": 66,
        "startChar": 0,
        "endLine": 75,
        "endChar": 17
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d06c3e17_cb5af50a",
        "filename": "runtime/thread-inl.h",
        "patchSetId": 1
      },
      "lineNbr": 131,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-04-20T15:53:44Z",
      "side": 1,
      "message": "Why this change? Can you share your analysis that shows this is better? For a simple branch predictor it sounds like this will be worse.",
      "range": {
        "startLine": 131,
        "startChar": 4,
        "endLine": 131,
        "endChar": 18
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "700f1279_d7bd6ca5",
        "filename": "runtime/thread-inl.h",
        "patchSetId": 1
      },
      "lineNbr": 131,
      "author": {
        "id": 1039961
      },
      "writtenOn": "2015-04-21T10:12:59Z",
      "side": 1,
      "message": "Not tested yet, maybe this change is wrong, I will check it later. Thanks.",
      "parentUuid": "d06c3e17_cb5af50a",
      "range": {
        "startLine": 131,
        "startChar": 4,
        "endLine": 131,
        "endChar": 18
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d06c3e17_4b5ee57c",
        "filename": "runtime/thread_list.cc",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2015-04-20T16:13:10Z",
      "side": 1,
      "message": "This is missing documentation.",
      "range": {
        "startLine": 556,
        "startChar": 2,
        "endLine": 556,
        "endChar": 40
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0150a85_48e9dfac",
        "filename": "runtime/thread_list.cc",
        "patchSetId": 1
      },
      "lineNbr": 556,
      "author": {
        "id": 1039961
      },
      "writtenOn": "2015-04-21T10:12:59Z",
      "side": 1,
      "message": "10s time out for suspend all. Will add the comment.\nActually, we do not need a timed increment here. just need to increase the barrier number here.",
      "parentUuid": "d06c3e17_4b5ee57c",
      "range": {
        "startLine": 556,
        "startChar": 2,
        "endLine": 556,
        "endChar": 40
      },
      "revId": "27d63633c3ba0db27508ac1fe4018fbc3930deb0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}