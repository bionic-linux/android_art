{
  "comments": [
    {
      "key": {
        "uuid": "349a0eef_a5f2e400",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-29T11:49:35Z",
      "side": 1,
      "message": "I thought about this some more.  This check will cause  selects with a long compare to be quite inefficient on x86, as the comparison will have to be materialized.\n\nIn addition, there is no easy way that I know to generate a single condition code representing a long comparison on X86, which is needed to control CMOV.\n\nI am planning to move this check to the HSelect generation, and avoid HSelect on x86 if the comparison is between longs.  That is sufficient to remove this check and generate efficient code.",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d468d2a0_ff18f705",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-29T11:55:45Z",
      "side": 1,
      "message": "Okay, you will generate a single CC by comparing the materialized compare result with 0, but it is still slow, and undoes the work to merge the long compare with the HIf",
      "parentUuid": "349a0eef_a5f2e400",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7153b827_a664c623",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-01-29T12:44:45Z",
      "side": 1,
      "message": "Yep, I agree that this is not very efficient - the point was to get Selects in already and find a better solution later, so feel free to tweak this.\n\nThat said, we typically try to avoid platform-specific code in the HIR optimizations and assume that codegens can always generate the code they want from the HIR. Now I know that I\u0027ve already broken that by forcing input0 of the Select to be the false value, but would be a shame to spread such assumptions further.\n\nThe \"right\" way of doing this would be to investigate how the register allocator could spill the true value (input1) of the Select. What happens in the highlighted case here is that the Select has effectively 4 inputs - val_false, val_true, cond_lhs, cond_rhs. We set out\u003dval_false\u003dneeds_reg_pair, cond_lhs\u003dneeds_reg_pair, cond_rhs\u003dneeds_reg_pair. If we could set val_true\u003dneeds_double_stack, then we\u0027d have no problem at all.",
      "parentUuid": "d468d2a0_ff18f705",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14950abd_019e2e48",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-29T13:14:00Z",
      "side": 1,
      "message": "I disagree.  Even if we allowed an input to be forced to the  stack, the x86 long compare would still need to materialize -1/0/1, which will then be compared to 0 to set the CC in order to implement the select.  This is VERY inefficient.  The same applies if the compare was FP.\n\nWhat I would really prefer is a virtual function in CodeGenerator called ShouldGenerateSelect, which is passed in all 4 inputs (or just the types of the compare and moves), and returns a boolean.  That allows the code generator to proactively decide before getting into trouble later.  Last time I suggested something like that, it was shot down.",
      "parentUuid": "7153b827_a664c623",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9143cc4f_ef950104",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-01-29T13:49:27Z",
      "side": 1,
      "message": "Or we could have the HCondition generate the CC, HSelect use the CC and modify the parallel move resolver to not touch the CC.\n\nWhen does the parallel move resolver touch the CC? Is it just for loading a zero with XOR?",
      "parentUuid": "14950abd_019e2e48",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5422228b_082f4762",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-29T13:54:42Z",
      "side": 1,
      "message": "I see some subl/addl that could become lea for stack manipulation, the xorl for 0, a xorpd for 0.0, and xorls to do an exchange of registers",
      "parentUuid": "9143cc4f_ef950104",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "712ad87b_2ec54717",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-01-29T13:59:03Z",
      "side": 1,
      "message": "Vladimir: I think Mark is trying to say that that doesn\u0027t work for long compares + CMOV.\n\nMark: \nI\u0027m not saying that you need to generate a CMOV for every Select. The codegen should be able to generate the most efficient code for any HIR Select it is given. It can decide whether to emit a CMOV or fall back to the if-then-else implementation. The fallback should be equivalent to not generating the Select in the first place, only here we are having trouble with the register allocator policies.\n\nWe would like to avoid adding the CodeGenerator::ShouldGenerateSelect as a means of preventing SelectGenerator from removing the if-then-else pattern. It would make the compiler high-level optimizations behave differently on different platforms and make testing/debugging much more difficult. We might also miss out on optimization opportunities.\n\nI\u0027d suggest a workaround. Run an x86-specific pass at the end of the pipeline that will regenerate the if-then-else pattern for this case.",
      "parentUuid": "9143cc4f_ef950104",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b486fe94_262fc262",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2016-01-29T14:02:39Z",
      "side": 1,
      "message": "I can live with fixing it in an x86 specific pass.  It does seem like a bit of a waste to run a pass just for this one fixup, but I can do it.  There may be other examples later.  I can then remove this code and replace it with a DCHECK in VisitSelect for x86.",
      "parentUuid": "712ad87b_2ec54717",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5125d4a7_8dea0194",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-01-29T14:06:33Z",
      "side": 1,
      "message": "Just make it part of the pc_relative fixups. Might make sense to turn that into a more general x86 prep for code gen (arm64 has something like that).",
      "parentUuid": "b486fe94_262fc262",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b140d043_d009bc47",
        "filename": "compiler/optimizing/prepare_for_register_allocation.cc",
        "patchSetId": 32
      },
      "lineNbr": 150,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-01-29T14:54:29Z",
      "side": 1,
      "message": "\u003e I see some subl/addl that could become lea for stack manipulation,\n \u003e the xorl for 0, a xorpd for 0.0, and xorls to do an exchange of\n \u003e registers\n\nThe exchange could be rewritten as PUSH+MOV+POP (reducing code size by 2 bytes). Would that impact performance?\n\nCould we tell the move resolver to preserve flags (and emit different code for 0 and 0.0) in certain situations?",
      "parentUuid": "5125d4a7_8dea0194",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 150,
        "endChar": 3
      },
      "revId": "74eb1b264691c4eb399d0858015a7fc13c476ac6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}