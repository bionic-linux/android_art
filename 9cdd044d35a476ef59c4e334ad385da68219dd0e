{
  "comments": [
    {
      "key": {
        "uuid": "8395c7c9_79dcb8a1",
        "filename": "test/079-phantom/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2017-07-05T13:11:14Z",
      "side": 1,
      "message": "This might be slightly better as an atomic counter with the loops spinning on having the expected count and with assertions of expected value between the nulling X printlns.",
      "range": {
        "startLine": 92,
        "startChar": 28,
        "endLine": 92,
        "endChar": 52
      },
      "revId": "9cdd044d35a476ef59c4e334ad385da68219dd0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "320815c1_e60a0302",
        "filename": "test/079-phantom/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-07-05T13:47:37Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8395c7c9_79dcb8a1",
      "range": {
        "startLine": 92,
        "startChar": 28,
        "endLine": 92,
        "endChar": 52
      },
      "revId": "9cdd044d35a476ef59c4e334ad385da68219dd0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ffa82640_ae7fac69",
        "filename": "test/079-phantom/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-07-05T15:24:14Z",
      "side": 1,
      "message": "Is there any good reason not to use java.util.concurrent lock objects to fully synchronize this?",
      "parentUuid": "320815c1_e60a0302",
      "range": {
        "startLine": 92,
        "startChar": 28,
        "endLine": 92,
        "endChar": 52
      },
      "revId": "9cdd044d35a476ef59c4e334ad385da68219dd0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "317216c4_277e686e",
        "filename": "test/079-phantom/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-07-05T15:30:28Z",
      "side": 1,
      "message": "Besides the fact I don\u0027t know anything of the concurrent API, I guess not. But I\u0027d take any suggestion (like Orion did).",
      "parentUuid": "ffa82640_ae7fac69",
      "range": {
        "startLine": 92,
        "startChar": 28,
        "endLine": 92,
        "endChar": 52
      },
      "revId": "9cdd044d35a476ef59c4e334ad385da68219dd0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb7c14d1_25a0f72e",
        "filename": "test/079-phantom/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2017-07-05T15:37:57Z",
      "side": 1,
      "message": "I think it depends on what the goal is. E.g., the commit message says to de-flakify, for which synchronization is all you need, and it\u0027s more expressive to use a CountdownLatch or CyclicBarrier (and avoids the loop and rather long sleeps).\n\nHowever, looking at PS2, having exact counts does stronger checks, so I guess that\u0027s fine, too.",
      "parentUuid": "317216c4_277e686e",
      "range": {
        "startLine": 92,
        "startChar": 28,
        "endLine": 92,
        "endChar": 52
      },
      "revId": "9cdd044d35a476ef59c4e334ad385da68219dd0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08605904_776fc64b",
        "filename": "test/079-phantom/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 92,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2017-07-05T16:40:37Z",
      "side": 1,
      "message": "It seems that Andreas has a good point, it is very confusing to use an AtomicInteger right now. Using the volatiles/atomics/etc just makes reasoning about it much more difficult, why bother for non-performance-sensitive code?\n\nPhantomWrapper could expose a CountDownLatch and the main code would then await on it.\n\n      import java.util.concurrent.CountDownLatch;\n\n      class PhantomWrapper {\n         public CountDownLatch freeSignal \u003d new CountDownLatch(1);\n      }\n      freeNativeStorage(PhantomWrapper wrapper) {\n          wrapper.freeSignal.countDown();\n      }\n\n      void main() {\n          mBitmap1 \u003d null;\n          nativeWrapper1.await();\n\n\n          mBitmap4 \u003d null;\n          nativeWrapper2.await();\n      }\n\nIt\u0027s quite simple and expresses a direct relation on the object that is being synchronized around.",
      "parentUuid": "eb7c14d1_25a0f72e",
      "range": {
        "startLine": 92,
        "startChar": 28,
        "endLine": 92,
        "endChar": 52
      },
      "revId": "9cdd044d35a476ef59c4e334ad385da68219dd0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}