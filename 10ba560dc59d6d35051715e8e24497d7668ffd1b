{
  "comments": [
    {
      "key": {
        "uuid": "5acfc472_86746ce2",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 4
      },
      "lineNbr": 2197,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2016-07-13T22:38:35Z",
      "side": 1,
      "message": "Clarify this comment a bit? Mathieu says in person that this means we can\u0027t use h_class-\u003eMonitorEnter (or block in any way) to avoid a deadlock.",
      "range": {
        "startLine": 2196,
        "startChar": 54,
        "endLine": 2197,
        "endChar": 28
      },
      "revId": "10ba560dc59d6d35051715e8e24497d7668ffd1b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5acfc472_91e908b4",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 4
      },
      "lineNbr": 2198,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-07-13T23:26:22Z",
      "side": 1,
      "message": "In my experience, sched_yield loops are prone to livelock, especially if you\u0027re adjusting priorities, as we do.  If we are one of the N highest priority threads, all waiting, and the thread we are waiting for has a lower priority, and the number of cores is \u003c\u003d N, we never make progress.  This is probably unlikely here, but I would call usleep after the first few iterations, on general principles.",
      "range": {
        "startLine": 2198,
        "startChar": 4,
        "endLine": 2198,
        "endChar": 18
      },
      "revId": "10ba560dc59d6d35051715e8e24497d7668ffd1b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}