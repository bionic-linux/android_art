{
  "comments": [
    {
      "key": {
        "uuid": "0815f483_e45c3a56",
        "filename": "compiler/optimizing/nodes.cc",
        "patchSetId": 5
      },
      "lineNbr": 1246,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-04-19T10:02:29Z",
      "side": 1,
      "message": "Same as below, you only need to compare return types to preserve type consistency after GVN, don\u0027t you? This case is arguably more complicated because it you would still GVN IGETs with the same field offset on different classes. Could we compare the class idx (in FieldInfo) in InstructionDataEqual instead?",
      "range": {
        "startLine": 1246,
        "startChar": 9,
        "endLine": 1246,
        "endChar": 53
      },
      "revId": "60efa3a3be0c119b6f76522d2a2759ef166dc3f3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a82a28bd_b2756198",
        "filename": "compiler/optimizing/nodes.cc",
        "patchSetId": 5
      },
      "lineNbr": 1246,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-04-19T19:03:38Z",
      "side": 1,
      "message": "The offset comparison is taken care of by InstructionDataEquals(). This method strictly only compares inputs. And HNullConstant is considered different from each other for just field loads.",
      "parentUuid": "0815f483_e45c3a56",
      "range": {
        "startLine": 1246,
        "startChar": 9,
        "endLine": 1246,
        "endChar": 53
      },
      "revId": "60efa3a3be0c119b6f76522d2a2759ef166dc3f3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0815f483_c4801eec",
        "filename": "compiler/optimizing/nodes.cc",
        "patchSetId": 5
      },
      "lineNbr": 1251,
      "author": {
        "id": 1059815
      },
      "writtenOn": "2016-04-19T10:02:29Z",
      "side": 1,
      "message": "I still think you\u0027re being too conservative here. At least for primitive types (wouldn\u0027t go so far with RTP), the return type of the HArrayGet always matches the component type of the input array. That\u0027s guaranteed by the verifier and I/F aliasing is resolved in the SsaBuilder.\n\nThe fact that the input array (Invoke) is replaced with the inlined NullConstant doesn\u0027t make a difference, so why not compare the return types instead? That can be in the generic Equals method and you don\u0027t need any additional virtual calls.",
      "range": {
        "startLine": 1251,
        "startChar": 5,
        "endLine": 1251,
        "endChar": 56
      },
      "revId": "60efa3a3be0c119b6f76522d2a2759ef166dc3f3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a82a28bd_f277d95a",
        "filename": "compiler/optimizing/nodes.cc",
        "patchSetId": 5
      },
      "lineNbr": 1251,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-04-19T19:03:38Z",
      "side": 1,
      "message": "This is a really rare case and I don\u0027t think we are trying to squeeze out performance here. The null check proceeding the instruction will throw exception.\n\nTreating NullConstant as different for field load is conceptually simple since null can represent different object types. We don\u0027t need to make Equals() complex by requiring mutator lock (for non primitive type case).\n\nFor the additional virtual call, I just renamed InstructionTypeEquals() to InstructionKindEquals() and got rid of one virtual call. I can use InstructionTypeEquals() for this bug and override that one, but that method seems misnamed in the first place.",
      "parentUuid": "0815f483_c4801eec",
      "range": {
        "startLine": 1251,
        "startChar": 5,
        "endLine": 1251,
        "endChar": 56
      },
      "revId": "60efa3a3be0c119b6f76522d2a2759ef166dc3f3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28e0f9df_fe5ec101",
        "filename": "compiler/optimizing/nodes.cc",
        "patchSetId": 5
      },
      "lineNbr": 1251,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-04-27T10:19:04Z",
      "side": 1,
      "message": "\u003e This is a really rare case and I don\u0027t think we are trying to\n \u003e squeeze out performance here. The null check proceeding the\n \u003e instruction will throw exception.\n \u003e \n \u003e Treating NullConstant as different for field load is conceptually\n \u003e simple since null can represent different object types. We don\u0027t\n \u003e need to make Equals() complex by requiring mutator lock (for non\n \u003e primitive type case).\n\nI agree. But just realized: we don\u0027t need the mutator lock was we\u0027re just doing a pointer comparison. Here\u0027s an alternative shorter CL that does what we should do, that is not GVN\u0027ing things that don\u0027t have the same type:\n\nhttps://android-review.googlesource.com/220683\n\n \u003e \n \u003e For the additional virtual call, I just renamed InstructionTypeEquals()\n \u003e to InstructionKindEquals() and got rid of one virtual call. I can\n \u003e use InstructionTypeEquals() for this bug and override that one, but\n \u003e that method seems misnamed in the first place.",
      "parentUuid": "a82a28bd_f277d95a",
      "range": {
        "startLine": 1251,
        "startChar": 5,
        "endLine": 1251,
        "endChar": 56
      },
      "revId": "60efa3a3be0c119b6f76522d2a2759ef166dc3f3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}