{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ecc7ad89_a4e3012f",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 1
      },
      "lineNbr": 753,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-12-21T23:46:38Z",
      "side": 1,
      "message": "maybe \u0027misaligned (w.r.t. region size) large objects\u0027.",
      "range": {
        "startLine": 753,
        "startChar": 33,
        "endLine": 753,
        "endChar": 65
      },
      "revId": "5374b8d2cf8b666516d08bfba0578fcf4770208a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2040cb40_d20959de",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 1
      },
      "lineNbr": 753,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-12-22T01:10:14Z",
      "side": 1,
      "message": "My conclusion was that it\u0027s probably too complicated to try to summarize here. If they\u0027re really large primitive arrays, they\u0027ll end up in LOS instead. Alignment matters. I\u0027m also not sure about TLAB interaction, though. Can we also waste the tail end of a TLAB reservation? Or do we redirect objects larger than the TLAB expansion interval?",
      "parentUuid": "ecc7ad89_a4e3012f",
      "range": {
        "startLine": 753,
        "startChar": 33,
        "endLine": 753,
        "endChar": 65
      },
      "revId": "5374b8d2cf8b666516d08bfba0578fcf4770208a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4bbd99a_e7b73024",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 1
      },
      "lineNbr": 753,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-12-22T01:38:51Z",
      "side": 1,
      "message": "I\u0027m confused as to how can this situation arise in the first place. We log this when we have exhausted all options to reclaim when an allocation blocks due to GC.\n\nWe have 10MB free space, yet no regions are free. Also, note that our \"less than 1% freed...\" is not the case here either. The only explanation is that there are many threads who allocated all the available regions *before* the thread which did the GC and hence that thread couldn\u0027t allocate and threw exception.\n\nWe could certainly have a situation where a lot of threads have regions, which are mostly empty reserved to themselves. Large objects causing internal fragmentation is also possible, but is less likely as you rightly pointed out that primitive arrays can\u0027t be causing it.\n\nWasting tail end of TLAB was a possibility earlier but I remember fixing it long time back by maintaining a list of revoked TLABs and reusing them.\n\nI think either we can omit large object mention entirely or at least briefly say that it\u0027s only if they are in decent quantity and are misaligned as far as region size is concerned.",
      "parentUuid": "2040cb40_d20959de",
      "range": {
        "startLine": 753,
        "startChar": 33,
        "endLine": 753,
        "endChar": 65
      },
      "revId": "5374b8d2cf8b666516d08bfba0578fcf4770208a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8bc9e45c_aa673a4d",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 1
      },
      "lineNbr": 753,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2022-12-22T10:20:54Z",
      "side": 1,
      "message": "Drop the parens?",
      "range": {
        "startLine": 753,
        "startChar": 11,
        "endLine": 753,
        "endChar": 66
      },
      "revId": "5374b8d2cf8b666516d08bfba0578fcf4770208a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "903d1aaa_49baa6d6",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 1
      },
      "lineNbr": 753,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-12-22T18:12:18Z",
      "side": 1,
      "message": "Actually, do you remember when we revoke TLABs? Under what circumstances will partially occupied TLABs still matter here? They need to be allocated from since the start of the GC? I found Heap::RevokeAllThreadLocalBuffers, and the ConcurrentCopying version, but I\u0027m having trouble finding the right call.\n\nI don\u0027t think we allow large objects smaller than a region to cross region boundaries, right? So there must be cases in which we inherently get fragmentation for large region-allocated objects, right? In the worst case, if we allocate 130KB object arrays in 256KB regions, we get nearly 50% fragmentation, I think. I suspect that we\u0027re not that great at bin packing when copying, so 5% seems plausible in real life, if we have an unusually large number of large object arrays.\n\nI think our default large object threshold for primitive arrays is 12K. So allocating 10K pointerfree objects exclusively, we\u0027d expect 5K fragmentation per region, which would give us 2%. So I don\u0027t think large-object-based fragmentation of various kinds is impossible, especiually in weird test scnarios. But I\u0027ll add something to the comment about this not being expected with a normal allocation mix.",
      "parentUuid": "d4bbd99a_e7b73024",
      "range": {
        "startLine": 753,
        "startChar": 33,
        "endLine": 753,
        "endChar": 65
      },
      "revId": "5374b8d2cf8b666516d08bfba0578fcf4770208a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08da3d1f_3c8d6c48",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 1
      },
      "lineNbr": 753,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-12-22T18:12:18Z",
      "side": 1,
      "message": "Those are operator precedence parens. Maybe use || and \u0026\u0026 instead? Other suggestions? This message is already rather long.",
      "parentUuid": "8bc9e45c_aa673a4d",
      "range": {
        "startLine": 753,
        "startChar": 11,
        "endLine": 753,
        "endChar": 66
      },
      "revId": "5374b8d2cf8b666516d08bfba0578fcf4770208a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b338004a_2933cdf1",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 1
      },
      "lineNbr": 753,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-12-22T23:35:27Z",
      "side": 1,
      "message": "\u003e Actually, do you remember when we revoke TLABs? Under what circumstances will partially occupied TLABs still matter here? They need to be allocated from since the start of the GC? I found Heap::RevokeAllThreadLocalBuffers, and the ConcurrentCopying version, but I\u0027m having trouble finding the right call.\n\u003e \nLook `Heap::AllocWithNewTLAB` calling into `RegionSpace::AllocNewTlab`\n\n\u003e I don\u0027t think we allow large objects smaller than a region to cross region boundaries, right? So there must be cases in which we inherently get fragmentation for large region-allocated objects, right? In the worst case, if we allocate 130KB object arrays in 256KB regions, we get nearly 50% fragmentation, I think. I suspect that we\u0027re not that great at bin packing when copying, so 5% seems plausible in real life, if we have an unusually large number of large object arrays.\n\u003e \nYes we don\u0027t allow `\u003ckRegionSize` objects to cross boundaries. The example of fragmentation you gave won\u0027t hurt I think because of the partial TLAB change in RegionSpace::AllocMewTlab`\n\n\u003e I think our default large object threshold for primitive arrays is 12K. So allocating 10K pointerfree objects exclusively, we\u0027d expect 5K fragmentation per region, which would give us 2%. So I don\u0027t think large-object-based fragmentation of various kinds is impossible, especiually in weird test scnarios. But I\u0027ll add something to the comment about this not being expected with a normal allocation mix.\n\nI agree that large-object based fragmentation is possible. But after the partial-tlab fix in RegionSpace, it shouldn\u0027t be that worse unless the objects are over 256K (say 257K).",
      "parentUuid": "903d1aaa_49baa6d6",
      "range": {
        "startLine": 753,
        "startChar": 33,
        "endLine": 753,
        "endChar": 65
      },
      "revId": "5374b8d2cf8b666516d08bfba0578fcf4770208a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}