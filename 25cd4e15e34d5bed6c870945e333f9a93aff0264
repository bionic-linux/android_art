{
  "comments": [
    {
      "key": {
        "uuid": "9070061a_872ba87c",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3352,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-04-22T13:14:41Z",
      "side": 1,
      "message": "MustDoNullCheck is probably better, as this suggests it it the same thing as Input(0)-\u003eCanBeNull.\n\nA comment that this is only used by code generation might be good too.",
      "range": {
        "startLine": 3352,
        "startChar": 7,
        "endLine": 3352,
        "endChar": 21
      },
      "revId": "25cd4e15e34d5bed6c870945e333f9a93aff0264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "706b9231_c34bd6b5",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-04-22T13:14:41Z",
      "side": 1,
      "message": "I don\u0027t think this is the right place for doing this.\n\nAt the very end of the optimizations, before code generation, you have all the information you need: an HInstanceOf instruction takes an input, and you can just query that input to know whether it can be null.\n\nI think a good place for this could be in prepare_for_register_allocation.cc.",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 97,
        "endChar": 7
      },
      "revId": "25cd4e15e34d5bed6c870945e333f9a93aff0264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "90972654_8ced873b",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2015-04-22T13:29:26Z",
      "side": 1,
      "message": "Doing it here you\u0027ll also miss patterns where the direct input cannot be null anyway (which may result because of inlining).\n\ne.g.\nvoid f() {return new A()}\nvoid g() {\n Object x \u003d f(); // this will be inlined and instanceof will not have a bound type as input.\n if (x instanceof A) {\n }\n}\n\nHowever I\u0027m not sure I\u0027d move this to prepare_for_register_allocation.cc.\n\nThis still deals with nullability propagation which is one thing this analysis does. Having related stuff together seems better to me. An you already have all the info you need for that after this pass. What do you think Nicolas?\n\nAlso, thinking forward we\u0027d like to detect also cases like\na.f()\n...\nif (a instanceOf A){...}\nwhich will probably require to look at the dominators anyway. I wouldn\u0027t do that either in prepare_for_reg_alloc.\n\nIf kept here a good place for it would be as a separate iteration over nodes at the end of ReferenceTypePropagation::Run().",
      "parentUuid": "706b9231_c34bd6b5",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 97,
        "endChar": 7
      },
      "revId": "25cd4e15e34d5bed6c870945e333f9a93aff0264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0718a1d_a838734e",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-04-22T13:38:02Z",
      "side": 1,
      "message": "So ideally, at the code generation, you\u0027d like to just do if (input-\u003eCanBeNull()).\n\nBut we get rid of such information by removing HNullCheck as inputs. So it\u0027s the responsability of whoever does this optimization to preserve that info (so prepare_for_register_allocation.cc).\n\nAlso recognizing a.f().... if (a instanceof A) is a general type propagation optimization that is sort of out of the scope of what Guillaume is doing. You\u0027d still want to have all optimizations prior to code generation be able to do if (my_input-\u003eCanBeNull()) and have the optimized answer.",
      "parentUuid": "90972654_8ced873b",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 97,
        "endChar": 7
      },
      "revId": "25cd4e15e34d5bed6c870945e333f9a93aff0264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "90972654_ec960b93",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2015-04-22T14:02:59Z",
      "side": 1,
      "message": "You convinced me when saying that whoever removes the nodes is responsible for preserving the info.\n\nAs for the a.f()... if (a instanceof A): yeap, that\u0027s a different propagation that we need to make.",
      "parentUuid": "b0718a1d_a838734e",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 97,
        "endChar": 7
      },
      "revId": "25cd4e15e34d5bed6c870945e333f9a93aff0264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b0718a1d_280643a4",
        "filename": "compiler/optimizing/reference_type_propagation.cc",
        "patchSetId": 3
      },
      "lineNbr": 156,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-04-22T13:14:41Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 152,
        "startChar": 0,
        "endLine": 156,
        "endChar": 7
      },
      "revId": "25cd4e15e34d5bed6c870945e333f9a93aff0264",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}