{
  "comments": [
    {
      "key": {
        "uuid": "19211c0e_bc1a81cb",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 42,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2018-03-09T15:31:28Z",
      "side": 1,
      "message": "nit: Add some explanation here?\n\n   Loads using the weakest memory ordering in JLS, program order. Program order actions are not ordered w.r.t to other threads\u0027 actions.\n   This is still stronger than C++ unordered memory loads because it does not allow undefined behavior.\n   See also JLS 17.4.3 \"Programs and Program Order\"",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 16
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8948a538_e6a04dde",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 42,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-09T19:19:10Z",
      "side": 1,
      "message": "I would replace the comment by something like:\n\n\"Promises memory access semantics of ordinary Java data. Does not order other memory accesses. Long and double accesses may be performed 32 bits at a time. There are not even \"cache coherence\" guarantees; e.g. loads from the same location may be reordered. But unlike normal C++ accesses, racing accesses are allowed.\n\nIn my opinion, the use of the term \"Program Order\" in the VarHandle specification is unfortunate, and we shouldn\u0027t use it here. I don\u0027t know how to map it to a mathematically meaningful statement\n\n\"Opaque\" accesses map reasonably well to memory_order_relaxed. There is an argument that C++ compilers are allowed to move relaxed accesses out of longer running loops than \"Opaque\" is intended to allow. But my impression is that C++ compilers are (fortunately, since it can be a huge pessimization!) hesitant to do this.",
      "parentUuid": "19211c0e_bc1a81cb",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 16
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f165c8d0_80a4e539",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 42,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2018-03-09T19:35:01Z",
      "side": 1,
      "message": "I was initially suggesting we quote the JMM, is the JLS citation wrong? Or is it merely confusing because of the VarHandle re-use of the term \u0027program order\u0027 and so we should avoid it entirely?\n\n\u003e Promises memory access semantics of ordinary Java data. Does not order other memory accesses. Long and double accesses may be performed 32 bits at a time. There are not even \"cache coherence\" guarantees; e.g. loads from the same location may be reordered. But unlike normal C++ accesses, racing accesses are allowed.\n\nSounds good to me, and lets use \"semantics of ordinary Java Language data\" here.",
      "parentUuid": "8948a538_e6a04dde",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 16
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a5d9d22_086855b6",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 42,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-09T19:45:21Z",
      "side": 1,
      "message": "The problem is that \"program order\" isn\u0027t really a memory ordering in the sense of memory_order_xyz. It\u0027s a partial order on program actions that doesn\u0027t order actions between threads at all. C++ calls it \"sequenced before\". \"JavaData\" actions don\u0027t necessarily look that they occur in any total order, and if they do, it doesn\u0027t have to be consistent with program order. They can\u0027t see actions that happen later in program order. But the real constraint there is happens-before order, which is stronger. So I\u0027m just not sure what \"program order\" would mean here. Or what it means in the VarHandle spec.",
      "parentUuid": "f165c8d0_80a4e539",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 16
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c4b5448_af123738",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 42,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2018-03-12T22:58:32Z",
      "side": 1,
      "message": "My understanding is that the program order (for non-synchronized actions) from the JMM papers I\u0027ve read !\u003d VarHandle program order described in the APIs (for get/setOpaque).\n\nIf at least that much understanding is correct, then I think I understand why we should avoid \"program order\" in this comment :)",
      "parentUuid": "8a5d9d22_086855b6",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 16
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71466e9e_bb33725e",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 42,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-13T00:50:35Z",
      "side": 1,
      "message": "Yes. With the added complication that I\u0027m not sure what the use of \"program order\" in the VarHandles spec really means.",
      "parentUuid": "6c4b5448_af123738",
      "range": {
        "startLine": 42,
        "startChar": 4,
        "endLine": 42,
        "endChar": 16
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de52010b_ca206eed",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 47,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2018-03-09T15:31:28Z",
      "side": 1,
      "message": "nit: Same as L42",
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1528c23_0ba77b4a",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 53,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2018-03-09T15:31:28Z",
      "side": 1,
      "message": "For later cleanup perhaps?",
      "range": {
        "startLine": 53,
        "startChar": 7,
        "endLine": 53,
        "endChar": 48
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ffe5a15_00fd49bd",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 94,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2018-03-09T15:31:28Z",
      "side": 1,
      "message": "This volatile seems sketchy.",
      "range": {
        "startLine": 94,
        "startChar": 2,
        "endLine": 94,
        "endChar": 10
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f4696a37_37388ee6",
        "filename": "libartbase/base/atomic.h",
        "patchSetId": 8
      },
      "lineNbr": 94,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-09T19:19:10Z",
      "side": 1,
      "message": "Yes. But it seems to be used to generate mainly (only?) a value we can pass to futex(), and it may be the best we can do there. Maybe just add a comment describing its intended use?",
      "parentUuid": "7ffe5a15_00fd49bd",
      "range": {
        "startLine": 94,
        "startChar": 2,
        "endLine": 94,
        "endChar": 10
      },
      "revId": "4212ef4417ba265a431bb9a758cf7b87d9676cd7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}