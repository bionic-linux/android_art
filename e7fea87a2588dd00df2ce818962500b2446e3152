{
  "comments": [
    {
      "key": {
        "uuid": "f2fa0681_128c2cb1",
        "filename": "compiler/dex/quick/gen_common.cc",
        "patchSetId": 3
      },
      "lineNbr": 834,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-27T17:15:42Z",
      "side": 1,
      "message": "Be aware that unless you do an UpdateLoc(), you can only tell if the home location of the value is in a register.  In this particular case, that\u0027s probably what you want - because if Method* happened to be currently live in a temp register (say kArg0 or kArg1), the code below would fail.  Still, it wouldn\u0027t hurt to add a DCHECK to ensture in the (rl_method.location \u003d\u003d kLocPhysReg) case that rl_method.low_reg is *not* a temp.",
      "revId": "e7fea87a2588dd00df2ce818962500b2446e3152",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "12eebac6_b6438e5d",
        "filename": "compiler/dex/quick/gen_common.cc",
        "patchSetId": 3
      },
      "lineNbr": 849,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-27T17:15:42Z",
      "side": 1,
      "message": "We actually can\u0027t put the LoadConstant under the OpIT.  The issue is we can\u0027t know how many instructions are needed to materialize the constant - which is something that must be known and unchanging to use the proper IT form.  You could conceivably enhance IT generation to support this, but you won\u0027t know the answer until the assembly phase when all offsets are known.  If a constant can\u0027t be materialized with ALU ops, we fall back to loading it from the constant pool.  However, it\u0027s possible that after all code is generated we may find that the constant pool is too far to reach in a single load+displacement, so we have to expand the instruction sequence during the assembly fixup stage.  For this reason, OpIT must tread carefully.",
      "revId": "e7fea87a2588dd00df2ce818962500b2446e3152",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2fa0681_928dbcdc",
        "filename": "compiler/dex/quick/gen_common.cc",
        "patchSetId": 3
      },
      "lineNbr": 857,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-27T17:15:42Z",
      "side": 1,
      "message": "For the reasons stated above, this OpRegCopy must result in exactly 1 instruction being generated.  Given the preceeding code and knowledge of fixed register usage, it should never be the case that (r_method \u003d\u003d kArg0) at this point.  However, if it were, OpRegCopy() would try to be clever and delete the copy as unnecessary - breaking the IT.  Add a DCHECK_NE(TargetReg(kArg0), r_method).",
      "revId": "e7fea87a2588dd00df2ce818962500b2446e3152",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2fa0681_526d1417",
        "filename": "compiler/dex/quick/gen_common.cc",
        "patchSetId": 3
      },
      "lineNbr": 864,
      "author": {
        "id": 1001578
      },
      "writtenOn": "2014-01-27T17:15:42Z",
      "side": 1,
      "message": "For instruction scheduling purposes, re-order these such that the LoadConstant (which could turn into a memory load from the literal pool) comes before the OpRegCopy().",
      "revId": "e7fea87a2588dd00df2ce818962500b2446e3152",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}