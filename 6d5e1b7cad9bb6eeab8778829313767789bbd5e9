{
  "comments": [
    {
      "key": {
        "uuid": "63d900d1_d0265dc2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1071150
      },
      "writtenOn": "2020-09-10T09:59:05Z",
      "side": 1,
      "message": "Thanks Vladimir, lgtm.",
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9d96148d_3dccb898",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 3
      },
      "lineNbr": 3351,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2020-09-10T12:56:37Z",
      "side": 1,
      "message": "These are used for loads with immediate offsets (LDP, LDRH); as two scratch registers are acquired from VIXL is that guaranteed that those offsets can be always encoded into raw assembly instructions (satisfying Assembler::IsImmLSPair)?",
      "range": {
        "startLine": 3350,
        "startChar": 2,
        "endLine": 3351,
        "endChar": 82
      },
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4da336d5_7a83660c",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 3
      },
      "lineNbr": 3351,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-09-10T14:04:50Z",
      "side": 1,
      "message": "Yes, the java.lang.invoke.VarHandle instance is small enough for LDP (signed offset can be up to 252) and the Class (excluding variable size data such as vtable) is small enough for LDRH (unsigned offset can be up to 8190).\n\nBut even if they were out of range, the macro assembler can use (one of) the output register(s) as a temporary for loads.",
      "parentUuid": "9d96148d_3dccb898",
      "range": {
        "startLine": 3350,
        "startChar": 2,
        "endLine": 3351,
        "endChar": 82
      },
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "be509a77_a8f33d65",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 3
      },
      "lineNbr": 3351,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2020-09-11T12:51:19Z",
      "side": 1,
      "message": "Oh, yes, you\u0027re right.",
      "parentUuid": "4da336d5_7a83660c",
      "range": {
        "startLine": 3350,
        "startChar": 2,
        "endLine": 3351,
        "endChar": 82
      },
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b46881c5_b069f6d9",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 3
      },
      "lineNbr": 3364,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2020-09-10T12:56:37Z",
      "side": 1,
      "message": "nit: what about using HeapOperand?",
      "range": {
        "startLine": 3364,
        "startChar": 17,
        "endLine": 3364,
        "endChar": 36
      },
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fbeab726_dd41623a",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 3
      },
      "lineNbr": 3364,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-09-10T14:04:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b46881c5_b069f6d9",
      "range": {
        "startLine": 3364,
        "startChar": 17,
        "endLine": 3364,
        "endChar": 36
      },
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b263981b_6b70049c",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 3
      },
      "lineNbr": 3368,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2020-09-10T12:56:37Z",
      "side": 1,
      "message": "The value in this register is considered dead as the UseScratchRegisterScope has been destructed; VIXL macroassembler might emit literal/veneer pool right here, e.g. with reusing IP register. You might want to have a UseScratchRegisterScope in the outer function/pass the Register as a parameter.",
      "range": {
        "startLine": 3368,
        "startChar": 9,
        "endLine": 3368,
        "endChar": 13
      },
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa0946e7_12092b03",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 3
      },
      "lineNbr": 3368,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-09-10T14:04:50Z",
      "side": 1,
      "message": "I thought jumping over a literal/veneer pool uses a single B instruction.\n\nBut passing the register is cleaner, so done in PS5.",
      "parentUuid": "b263981b_6b70049c",
      "range": {
        "startLine": 3368,
        "startChar": 9,
        "endLine": 3368,
        "endChar": 13
      },
      "revId": "6d5e1b7cad9bb6eeab8778829313767789bbd5e9",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}