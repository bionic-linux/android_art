{
  "comments": [
    {
      "key": {
        "uuid": "4e0b93fd_50c39d32",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 2
      },
      "lineNbr": 486,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-07-24T13:45:29Z",
      "side": 1,
      "message": "Update comment.",
      "range": {
        "startLine": 486,
        "startChar": 38,
        "endLine": 486,
        "endChar": 45
      },
      "revId": "acd008d544c60b43c8582bf6aa4bbd2b857b681d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "006222d9_e1a0fc9e",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 2
      },
      "lineNbr": 486,
      "author": {
        "id": 1057043
      },
      "writtenOn": "2017-07-24T15:22:15Z",
      "side": 1,
      "message": "Actually, it is still true. In the sense that the compiler generates calls to __atomic_load_8() / __atomic_load_16() / __atomic_load() because this isn\u0027t directly supported by the CPU or the compiler doesn\u0027t know about such support (there are some dedicated instructions on R6, but currently they aren\u0027t used by the compiler or libatomic as I can see). Those functions do the same thing as AtomicLoadRelaxed16B() in dex_cahe.cc. They take a lock, read the memory and then unlock. At the same time libatomic should work for all architectures and sizes, except it may be non-optimal in some cases (because of the extra code and it might still need to fall back to using locks). For now using libatomic is the most straightforward fix for MIPS.\n\nSo, what kind of comment update would you like? Just a two-liner saying that these are supported directly on aarch64 and indirectly (by libatomic functios) on MIPS?",
      "parentUuid": "4e0b93fd_50c39d32",
      "range": {
        "startLine": 486,
        "startChar": 38,
        "endLine": 486,
        "endChar": 45
      },
      "revId": "acd008d544c60b43c8582bf6aa4bbd2b857b681d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a068c871_1e0a68ab",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 2
      },
      "lineNbr": 486,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2017-07-24T15:41:45Z",
      "side": 1,
      "message": "There was a bug that the shipped library didn\u0027t provide the 16-byte atomics mutex-based fall-back for some architecture(s) and this would simply fail to link. If this links fine for mips, I\u0027d say that it is supported (even if using the mutex-based fall-back) and I\u0027d like the comment updated to say\n\n  16-byte atomics are supported on aarch64, mips and mips64.\n\nDon\u0027t bother with more details. I also didn\u0027t explain the odd details of the arm64 support.",
      "parentUuid": "006222d9_e1a0fc9e",
      "range": {
        "startLine": 486,
        "startChar": 38,
        "endLine": 486,
        "endChar": 45
      },
      "revId": "acd008d544c60b43c8582bf6aa4bbd2b857b681d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc178d63_75b4b44d",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 2
      },
      "lineNbr": 486,
      "author": {
        "id": 1057043
      },
      "writtenOn": "2017-07-24T16:46:37Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a068c871_1e0a68ab",
      "range": {
        "startLine": 486,
        "startChar": 38,
        "endLine": 486,
        "endChar": 45
      },
      "revId": "acd008d544c60b43c8582bf6aa4bbd2b857b681d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}