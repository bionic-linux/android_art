{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c92789f4_d6a9c4c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T00:28:35Z",
      "side": 1,
      "message": "PS3 actually looks plausible to me. Note that I added comments to a couple of existing functions, which I believe correctly describe the operation of those functions as currently implemented. It would be good for Lokesh, Mathieu, and Roland to see whether they\u0027re consistent with the assumptions made by callers; I\u0027m not sure.\n\nAlso if somebody has an idea on how to avoid copying potentially dead referents (as discussed in the commit message and comments) without increasing Copy() cost, that would be very welcome. Note that PS2 was my best, but I now believe incorrect, attempt to do that. But I don\u0027t think that\u0027s necessary to solve the main problem here; we can get by with the read barrier.",
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6978f29_129b128e",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T01:18:55Z",
      "side": 1,
      "message": "I\u0027m not sure this is correct. Getting a referent is like reading a GC root. Once we disable weak references in CC, I don\u0027t think we expect new read-barrier invocations after that. We disable weak references *while* switching to shared mode for mark-stack. Eventually we switch to GC-exclusive mode. Once we are in this mode, calling refersTo would miss the entire object graph initiating out of the referent. Please refer to comment in ConcurrentCopying::CopyingPhase() (line 1579).",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef441a50_e821ef94",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T02:22:47Z",
      "side": 1,
      "message": "Good point. Since we don\u0027t actually access the referent in that case, I\u0027m not sure whether it fundamentally breaks things. But at a minimum, it does seem way too ugly, and there are probably all sorts of issues around the edges.\n\nSo we\u0027re kind of between a rock and a hard place, in that we don\u0027t really want to mark the referent, but we can\u0027t reliably tell whether it has been marked, except by attempting to mark it.\n\nOne fundamental question is whether the current memory ordering is sufficient as it stands. Is the fact that IsMarked() can effectively spuriously return null a problem? Maybe not. Most of the time an error in that direction seems safe?\n\nI\u0027ll think about how to do this better.",
      "parentUuid": "a6978f29_129b128e",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}