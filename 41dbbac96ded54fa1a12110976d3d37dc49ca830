{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c92789f4_d6a9c4c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T00:28:35Z",
      "side": 1,
      "message": "PS3 actually looks plausible to me. Note that I added comments to a couple of existing functions, which I believe correctly describe the operation of those functions as currently implemented. It would be good for Lokesh, Mathieu, and Roland to see whether they\u0027re consistent with the assumptions made by callers; I\u0027m not sure.\n\nAlso if somebody has an idea on how to avoid copying potentially dead referents (as discussed in the commit message and comments) without increasing Copy() cost, that would be very welcome. Note that PS2 was my best, but I now believe incorrect, attempt to do that. But I don\u0027t think that\u0027s necessary to solve the main problem here; we can get by with the read barrier.",
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68c02e5a_61ce9056",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 3
      },
      "lineNbr": 157,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-13T09:40:08Z",
      "side": 1,
      "message": "This looks like something we should fix. (Or do a thorough review all uses to check for potential bugs.)",
      "range": {
        "startLine": 156,
        "startChar": 5,
        "endLine": 157,
        "endChar": 72
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6978f29_129b128e",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T01:18:55Z",
      "side": 1,
      "message": "I\u0027m not sure this is correct. Getting a referent is like reading a GC root. Once we disable weak references in CC, I don\u0027t think we expect new read-barrier invocations after that. We disable weak references *while* switching to shared mode for mark-stack. Eventually we switch to GC-exclusive mode. Once we are in this mode, calling refersTo would miss the entire object graph initiating out of the referent. Please refer to comment in ConcurrentCopying::CopyingPhase() (line 1579).",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef441a50_e821ef94",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T02:22:47Z",
      "side": 1,
      "message": "Good point. Since we don\u0027t actually access the referent in that case, I\u0027m not sure whether it fundamentally breaks things. But at a minimum, it does seem way too ugly, and there are probably all sorts of issues around the edges.\n\nSo we\u0027re kind of between a rock and a hard place, in that we don\u0027t really want to mark the referent, but we can\u0027t reliably tell whether it has been marked, except by attempting to mark it.\n\nOne fundamental question is whether the current memory ordering is sufficient as it stands. Is the fact that IsMarked() can effectively spuriously return null a problem? Maybe not. Most of the time an error in that direction seems safe?\n\nI\u0027ll think about how to do this better.",
      "parentUuid": "a6978f29_129b128e",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4bd1283_20b49442",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2020-11-13T02:28:45Z",
      "side": 1,
      "message": "I agree here, I think we should ConcurrentCopying::IsMarked instead. Since o is in the to-space or marked, it should mean IsMarked wont ever return null if the pointers are equal.",
      "parentUuid": "a6978f29_129b128e",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d104026_fe63f0f6",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T02:58:37Z",
      "side": 1,
      "message": "Unfortunately, there\u0027s a (semi-theoretical) memory ordering issue with that. See the comment below. (PS2 tried something like that.) If another thread marked o, and then handed the to-space reference to us, I don\u0027t think there\u0027s a guarantee that we\u0027ll see the forwarding pointer in the from-space copy of o. The forwarding pointer CAS and the return from Copy() are not ordered. We could add a fence there, and a fake dependency on o here, and make that work. But the fence in Copy() seems problematic. Unless its absence is already a bug.",
      "parentUuid": "c4bd1283_20b49442",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e1511f6_aba41736",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T03:49:37Z",
      "side": 1,
      "message": "I didn\u0027t get how is it possible that after a thread installs the forwarding pointer of o and then shares the to-space address of o with another thread, and the other thread may still not find the forwarding pointer there in the from-space copy of o?\nIf it were possible, then wouldn\u0027t that also allow another thread to succeed in installing its own forwarding pointer of o?\n\nPlease correct me if I\u0027m wrong, but doesn\u0027t an atomic CAS operation (even with relaxed memory ordering) guarantees that if the expected value is there, then the desired value is installed (written to at least the first level cache of a coherent memory system) before anyone else reads it? In other words, before the thread performing CAS can do anything else, isn\u0027t it guaranteed that when the CAS operation completes, the memory location is already updated?\n\nShouldn\u0027t we change the comparison to the following:\nreferent \u003d ref-\u003eGetReferent\u003ckWithoutReadBarrier\u003e();\nreturn (referent \u003d\u003d other || referent.forwarding_pointer \u003d\u003d other);\n\nThe fact that thread A gave us a to-space address of o, should guarantee that the forwarding pointer is already installed. Otherwse, thread A couldn\u0027t have gotten hold of the to-space address.",
      "parentUuid": "4d104026_fe63f0f6",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea1cbece_7967f8fb",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-13T09:40:08Z",
      "side": 1,
      "message": "I agree with Lokesh and we should use the code he proposed, though I would use IsMarked() to retrieve the `referent.forwarding_pointer`.\n\nIf there is a memory visibility issue with that approach, we should fix that issue in IsMarked()/Copy().",
      "parentUuid": "6e1511f6_aba41736",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4146479_f75b8c69",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T19:58:29Z",
      "side": 1,
      "message": "This was basically what PS2 attempted to do, though probably in a suboptimal way. But I think it requires a Copy() fix, with possibly measurable negative performance implications.\n\nCurrently, if you look at Copy() in concurrent_copying.cc, I think it basically does:\n\nmemcpy, filling in object;\nrelease fence;\na: Relaxed CAS to fill in forwarding address;\nPushOntoMarkStack(...);\nb: return to-space-reference;\n\nThe CASes to the same address occur in a single total order, but that\u0027s not related to the order in which other things become visible; it\u0027s just that modifications to a single location always occur in a single total order in C++. By the C++ rules, there is nothing ordering (a) and (b). Thus the CAS can appear to be arbitrarily delayed, including delaying it past a CAS in another thread that saw the to-space-reference. I\u0027m not sure that breaks anything, since everything still needs to be locally consistent, i.e. the delayed CAS is now the one that should fail.\n\nAt the object-code level, this maybe can\u0027t actually happen because the architecture guarantees that the store of to-space-reference that communicates it to another thread can\u0027t be speculative. But I don\u0027t think that\u0027s really sufficient either: I think the architecture allows the load-exclusive to complete, and the store-exclusive to compute its result, without actually making the store-exclusive visible. At that point no other thread can update the forwarding pointer, because we have the cache line holding it, but other stores from this thread can become visible.\n\nSo my reading is that using IsMarked() here would currently be broken.\n\nWe can fix that by using a release CAS instead of the relaxed CAS and moving the fence down. Which is less expensive than I initially thought. I\u0027m coming around to just doing that; the logic in other parts of the collector seems too subtle without that. I\u0027d be happier to do it if I could convince myself that the current code is really broken.\n\nUnless I hear otherwise, I\u0027ll use IsMarked()/Copy() with the Copy() fix.",
      "parentUuid": "ea1cbece_7967f8fb",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfa69c1a_230ffcf0",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T20:31:59Z",
      "side": 1,
      "message": "What stops the following from happening:\n\nLet\u0027s say there is an object obj.\n\n   Thread A                                 Thread B  \n   --------                                 --------\n1. copy obj to objA                         copy obj to objB\n2. relaxed CAS fwd_ptr to objA : success    \n3. PushOntoMarkStack(...)                   relaxed CAS fwd_ptr to objB : success\n4. return objA                              return objB\n5. mutate objA                              mutate objB\n\nAs you said, if the CAS at (2) by thread A could be arbitrarily delayed, the CAS from thread B could succeed, right? But since thread A assumes its CAS succeeded, and same for thread B, they will mutate different copies of obj. Please explain how is this avoided in the current implementation.\n\nI thought that since the return of to-space reference (objA or objB in this example) is happening inside the if condition checking the success of the CAS oepration, due to dependency there is no way that the to-space reference could be used for anything unless CAS becomes visible.",
      "parentUuid": "a4146479_f75b8c69",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6aabbd60_eeedc2b5",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2020-11-13T02:28:45Z",
      "side": 1,
      "message": "static_cast?",
      "range": {
        "startLine": 44,
        "startChar": 9,
        "endLine": 44,
        "endChar": 19
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0fbc2d4_f27431df",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-13T09:40:08Z",
      "side": 1,
      "message": "(...) ? JNI_TRUE : JNI_FALSE",
      "parentUuid": "6aabbd60_eeedc2b5",
      "range": {
        "startLine": 44,
        "startChar": 9,
        "endLine": 44,
        "endChar": 19
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a288c5eb_96dad750",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T19:58:29Z",
      "side": 1,
      "message": "Agreed. Will fix when the rest of this settles down.",
      "parentUuid": "a0fbc2d4_f27431df",
      "range": {
        "startLine": 44,
        "startChar": 9,
        "endLine": 44,
        "endChar": 19
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}