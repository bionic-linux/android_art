{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c92789f4_d6a9c4c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T00:28:35Z",
      "side": 1,
      "message": "PS3 actually looks plausible to me. Note that I added comments to a couple of existing functions, which I believe correctly describe the operation of those functions as currently implemented. It would be good for Lokesh, Mathieu, and Roland to see whether they\u0027re consistent with the assumptions made by callers; I\u0027m not sure.\n\nAlso if somebody has an idea on how to avoid copying potentially dead referents (as discussed in the commit message and comments) without increasing Copy() cost, that would be very welcome. Note that PS2 was my best, but I now believe incorrect, attempt to do that. But I don\u0027t think that\u0027s necessary to solve the main problem here; we can get by with the read barrier.",
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68c02e5a_61ce9056",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 3
      },
      "lineNbr": 157,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-13T09:40:08Z",
      "side": 1,
      "message": "This looks like something we should fix. (Or do a thorough review all uses to check for potential bugs.)",
      "range": {
        "startLine": 156,
        "startChar": 5,
        "endLine": 157,
        "endChar": 72
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6978f29_129b128e",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T01:18:55Z",
      "side": 1,
      "message": "I\u0027m not sure this is correct. Getting a referent is like reading a GC root. Once we disable weak references in CC, I don\u0027t think we expect new read-barrier invocations after that. We disable weak references *while* switching to shared mode for mark-stack. Eventually we switch to GC-exclusive mode. Once we are in this mode, calling refersTo would miss the entire object graph initiating out of the referent. Please refer to comment in ConcurrentCopying::CopyingPhase() (line 1579).",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef441a50_e821ef94",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T02:22:47Z",
      "side": 1,
      "message": "Good point. Since we don\u0027t actually access the referent in that case, I\u0027m not sure whether it fundamentally breaks things. But at a minimum, it does seem way too ugly, and there are probably all sorts of issues around the edges.\n\nSo we\u0027re kind of between a rock and a hard place, in that we don\u0027t really want to mark the referent, but we can\u0027t reliably tell whether it has been marked, except by attempting to mark it.\n\nOne fundamental question is whether the current memory ordering is sufficient as it stands. Is the fact that IsMarked() can effectively spuriously return null a problem? Maybe not. Most of the time an error in that direction seems safe?\n\nI\u0027ll think about how to do this better.",
      "parentUuid": "a6978f29_129b128e",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4bd1283_20b49442",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2020-11-13T02:28:45Z",
      "side": 1,
      "message": "I agree here, I think we should ConcurrentCopying::IsMarked instead. Since o is in the to-space or marked, it should mean IsMarked wont ever return null if the pointers are equal.",
      "parentUuid": "a6978f29_129b128e",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d104026_fe63f0f6",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T02:58:37Z",
      "side": 1,
      "message": "Unfortunately, there\u0027s a (semi-theoretical) memory ordering issue with that. See the comment below. (PS2 tried something like that.) If another thread marked o, and then handed the to-space reference to us, I don\u0027t think there\u0027s a guarantee that we\u0027ll see the forwarding pointer in the from-space copy of o. The forwarding pointer CAS and the return from Copy() are not ordered. We could add a fence there, and a fake dependency on o here, and make that work. But the fence in Copy() seems problematic. Unless its absence is already a bug.",
      "parentUuid": "c4bd1283_20b49442",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e1511f6_aba41736",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T03:49:37Z",
      "side": 1,
      "message": "I didn\u0027t get how is it possible that after a thread installs the forwarding pointer of o and then shares the to-space address of o with another thread, and the other thread may still not find the forwarding pointer there in the from-space copy of o?\nIf it were possible, then wouldn\u0027t that also allow another thread to succeed in installing its own forwarding pointer of o?\n\nPlease correct me if I\u0027m wrong, but doesn\u0027t an atomic CAS operation (even with relaxed memory ordering) guarantees that if the expected value is there, then the desired value is installed (written to at least the first level cache of a coherent memory system) before anyone else reads it? In other words, before the thread performing CAS can do anything else, isn\u0027t it guaranteed that when the CAS operation completes, the memory location is already updated?\n\nShouldn\u0027t we change the comparison to the following:\nreferent \u003d ref-\u003eGetReferent\u003ckWithoutReadBarrier\u003e();\nreturn (referent \u003d\u003d other || referent.forwarding_pointer \u003d\u003d other);\n\nThe fact that thread A gave us a to-space address of o, should guarantee that the forwarding pointer is already installed. Otherwse, thread A couldn\u0027t have gotten hold of the to-space address.",
      "parentUuid": "4d104026_fe63f0f6",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea1cbece_7967f8fb",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-13T09:40:08Z",
      "side": 1,
      "message": "I agree with Lokesh and we should use the code he proposed, though I would use IsMarked() to retrieve the `referent.forwarding_pointer`.\n\nIf there is a memory visibility issue with that approach, we should fix that issue in IsMarked()/Copy().",
      "parentUuid": "6e1511f6_aba41736",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4146479_f75b8c69",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T19:58:29Z",
      "side": 1,
      "message": "This was basically what PS2 attempted to do, though probably in a suboptimal way. But I think it requires a Copy() fix, with possibly measurable negative performance implications.\n\nCurrently, if you look at Copy() in concurrent_copying.cc, I think it basically does:\n\nmemcpy, filling in object;\nrelease fence;\na: Relaxed CAS to fill in forwarding address;\nPushOntoMarkStack(...);\nb: return to-space-reference;\n\nThe CASes to the same address occur in a single total order, but that\u0027s not related to the order in which other things become visible; it\u0027s just that modifications to a single location always occur in a single total order in C++. By the C++ rules, there is nothing ordering (a) and (b). Thus the CAS can appear to be arbitrarily delayed, including delaying it past a CAS in another thread that saw the to-space-reference. I\u0027m not sure that breaks anything, since everything still needs to be locally consistent, i.e. the delayed CAS is now the one that should fail.\n\nAt the object-code level, this maybe can\u0027t actually happen because the architecture guarantees that the store of to-space-reference that communicates it to another thread can\u0027t be speculative. But I don\u0027t think that\u0027s really sufficient either: I think the architecture allows the load-exclusive to complete, and the store-exclusive to compute its result, without actually making the store-exclusive visible. At that point no other thread can update the forwarding pointer, because we have the cache line holding it, but other stores from this thread can become visible.\n\nSo my reading is that using IsMarked() here would currently be broken.\n\nWe can fix that by using a release CAS instead of the relaxed CAS and moving the fence down. Which is less expensive than I initially thought. I\u0027m coming around to just doing that; the logic in other parts of the collector seems too subtle without that. I\u0027d be happier to do it if I could convince myself that the current code is really broken.\n\nUnless I hear otherwise, I\u0027ll use IsMarked()/Copy() with the Copy() fix.",
      "parentUuid": "ea1cbece_7967f8fb",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfa69c1a_230ffcf0",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T20:31:59Z",
      "side": 1,
      "message": "What stops the following from happening:\n\nLet\u0027s say there is an object obj.\n\n   Thread A                                 Thread B  \n   --------                                 --------\n1. copy obj to objA                         copy obj to objB\n2. relaxed CAS fwd_ptr to objA : success    \n3. PushOntoMarkStack(...)                   relaxed CAS fwd_ptr to objB : success\n4. return objA                              return objB\n5. mutate objA                              mutate objB\n\nAs you said, if the CAS at (2) by thread A could be arbitrarily delayed, the CAS from thread B could succeed, right? But since thread A assumes its CAS succeeded, and same for thread B, they will mutate different copies of obj. Please explain how is this avoided in the current implementation.\n\nI thought that since the return of to-space reference (objA or objB in this example) is happening inside the if condition checking the success of the CAS oepration, due to dependency there is no way that the to-space reference could be used for anything unless CAS becomes visible.",
      "parentUuid": "a4146479_f75b8c69",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eda2a683_e62657df",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T21:42:45Z",
      "side": 1,
      "message": "That scenario can\u0027t happen. Based on the C++ spec, there is essentially a total order for all accesses to the same location, in this case to obj-\u003efwd_ptr, and the read access associated with a CAS must see the last write (in that order) before the CAS write. So one of the CASs has to fail. What\u0027s not ordered is the store to the CAS and the possible publication of the result. Or the CAS and any other memory accesses to different locations.\n\nAt the ARM level, exclusive memory operations provide the same guarantee. (Or in v8.1+, there\u0027s a direct implementation that I believe we currently don\u0027t use.)\n\nControl dependencies have a very limited effect on ordering in ARM, and currently none in C++ (due to possible compiler elimination of dependencies). Basically a store that is control-dependent on a load cannot be reordered before the load. Control-dependent loads can be reordered with each other due to branch prediction. I don\u0027t find anything in the documentation that introduces a control dependency from any kind of store, including a store-exclusive. So I don\u0027t think the store-exclusive in the CAS is ordered with respect to a potential subsequent publishing store of e.g. objA. See B2.3.3 in the ARMv8 spec. Data and address dependencies can order loads as well on ARM (again not in C++), but not control dependencies.",
      "parentUuid": "bfa69c1a_230ffcf0",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96a4b167_d4a384df",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T22:28:34Z",
      "side": 1,
      "message": "I think I can understand. But not fully ðŸ˜Š\n\nConsider the following scenario:\n\nreference global \u003d null;\n    thread A                       thread B\n    ---------                      --------\n1. copy obj to objA                copy obj to objB\n2. CAS obj.fwd_ptr to objA\n3. global \u003d objA                      \n   2 and 3 get reordered           if (global !\u003d null) {CAS obj.fwd_ptr to objB}                     \n\nWhat is stopping CAS of thread B from succeeding? If it will fail because of something, then why wouldn\u0027t the same happen with a load of fwd_ptr. Why would a load of same fwd_ptr not return objA (if I replace the CAS in thread B with a normal load)?",
      "parentUuid": "eda2a683_e62657df",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "afb7c73b_d73b84f7",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T23:24:43Z",
      "side": 1,
      "message": "In both cases, the CAS is looking for something that\u0027s not a forwarding pointer, and they try to update the same location to a forwarding pointer, right? By C++ semantics, there is a total order of all accesses to obj.fwd_ptr. And each CAS must read a value and write the next value in the sequence of writes. Thus one of the CAS writes must go first, the next CAS is required to see that write, and will fail. But that all depends on the fact that CAS is an atomic RMW.\n\nIf there\u0027s a load instead of a CAS in thread B, there is no such argument. The load can appear anywhere in the sequence of accesses to fwd_ptr. Accesses to global are not included in the total order for fwd_pointer; they have their own total access order (normally called coherence order).",
      "parentUuid": "96a4b167_d4a384df",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04a25ca1_da8ea6c1",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-11-13T23:52:12Z",
      "side": 1,
      "message": "My concern with the scenario in my previous comment was that thread B took decision of CAS based on thread A\u0027s assumption that A\u0027s CAS has succeeded. Now isn\u0027t it possible that \n\nthread A does exclusive load of fwd_ptr\nthread A stores objA to global\nthread B does exclusive load of fwd_ptr\nthread B does exclusive store of fwd_ptr\nthread A attempts exclusive store of fwd_ptr, which fails.\n\nSo in this case only one of the CAS has succeeded, as you said. But not the right one!\n\n\nAnyways, what if you we were to do the following in refersTo():\n\nif the referent is marked (in to-space or in unevac space but marked) then nothing to worry.\nelse, if referent has a forwarding pointer, then also nothing worry. It must be to the right one!\nelse, if referent has no forwarding pointer, we attempt a CAS with the loaded value (non-forwarded lock-word). If the CAS fails, then we\u0027ll get the to-space ref and hence comparison will be straight-forward. Otherwise, referent can\u0027t be equal to other.\nBasically, with this, we create a TSO, without impacting Copy() performance. WDYT?\n\nOne thing we must ensure is that if GC is running during refersTo(), then it shouldn\u0027t declare marking finished. Because in the reclaim phase, we will get rid of the whole from-space.",
      "parentUuid": "afb7c73b_d73b84f7",
      "range": {
        "startLine": 43,
        "startChar": 42,
        "endLine": 43,
        "endChar": 88
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6aabbd60_eeedc2b5",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2020-11-13T02:28:45Z",
      "side": 1,
      "message": "static_cast?",
      "range": {
        "startLine": 44,
        "startChar": 9,
        "endLine": 44,
        "endChar": 19
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0fbc2d4_f27431df",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-11-13T09:40:08Z",
      "side": 1,
      "message": "(...) ? JNI_TRUE : JNI_FALSE",
      "parentUuid": "6aabbd60_eeedc2b5",
      "range": {
        "startLine": 44,
        "startChar": 9,
        "endLine": 44,
        "endChar": 19
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a288c5eb_96dad750",
        "filename": "runtime/native/java_lang_ref_Reference.cc",
        "patchSetId": 3
      },
      "lineNbr": 44,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-11-13T19:58:29Z",
      "side": 1,
      "message": "Agreed. Will fix when the rest of this settles down.",
      "parentUuid": "a0fbc2d4_f27431df",
      "range": {
        "startLine": 44,
        "startChar": 9,
        "endLine": 44,
        "endChar": 19
      },
      "revId": "41dbbac96ded54fa1a12110976d3d37dc49ca830",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}