{
  "comments": [
    {
      "key": {
        "uuid": "c498e5f7_e2c782d9",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T04:15:12Z",
      "side": 1,
      "message": "Wide32 seems strange to me. I understand what you meant but it looks like wide is overloaded here. Can we do something like kNoneWide and KWide?",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c4462542_4f8eb16b",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-07T05:04:17Z",
      "side": 1,
      "message": "I had that before and changed it. The issue is that ref registers are \"wide\" on 64b systems. So reading kNonWide in the code is ambiguous, too, without changing the name of the function.",
      "parentUuid": "c498e5f7_e2c782d9",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "445eb5fe_5edba5f8",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 540,
      "author": {
        "id": 1037505
      },
      "writtenOn": "2014-07-05T10:19:28Z",
      "side": 1,
      "message": "That\u0027s good. I disliked the true/false. Also, we may end up needing more than the 32 and 64 bit views (e.g. for vector registers).",
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4485d588_86b96e65",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 302,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-05T01:11:05Z",
      "side": 1,
      "message": "Note: this looks strange to me. That looks like on ARM we have a mixed soft-hard-float convention. arg0 is in farg0 if fp, but arg1 is always in arg1.",
      "range": {
        "startLine": 302,
        "startChar": 33,
        "endLine": 302,
        "endChar": 77
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c498e5f7_a23f3a4d",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 302,
      "author": {
        "id": 1037505
      },
      "writtenOn": "2014-07-05T10:19:28Z",
      "side": 1,
      "message": "The first time I looked at this function I could not make sense of it. I preferred to split out the Arm64 case, rather than trying to extend the old (and pretty entropic) logic. I suspect for Arm (32-bit) we may never happen to call the function in a way where the hard/soft float mix matters. In other words, parts of this function may turn out to be dead code. As a positive side, the function is now hugely improved. One thing that may further help to clean up the code, is introducing a TargetArgReg(int n, RegLocation rl) which returns the n-th argument having the same \"type\" of rl (and would have a trivial implementation for Arm64). Another thing - that affects the whole quick compiler - is the wide/non-wide variants of functions. The code is literally scattered with\n\n  if (wide) UseWideVariant(); else UseNonWideVariant();\n\nBut, addressing this issue is a huge refactoring task.",
      "parentUuid": "4485d588_86b96e65",
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4c6c9d8_278369b6",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 302,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-05T17:53:03Z",
      "side": 1,
      "message": "I totally agree with you here and had the same thoughts, but this was a small and contained refactoring. :-)",
      "parentUuid": "c498e5f7_a23f3a4d",
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "043d9d9e_d1524611",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1203,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T04:15:12Z",
      "side": 1,
      "message": "Could you please update a doc indicating that for wide case reg is expected to be only arg?",
      "range": {
        "startLine": 1203,
        "startChar": 8,
        "endLine": 1203,
        "endChar": 81
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04cafddd_41b5b1b8",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1203,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-07T05:04:17Z",
      "side": 1,
      "message": "The main question here is: when can you expect to get a correct result on a 32b system? My first attempt here was \"when wide registers are a pair of consecutive registers,\" for which the arg regs made sense. I would have thought we need ret, too, for long returns, but I did not find such a use case in the code.\n\nSo my try at documentation would be: must be k(F)Arg0-6 when on a 32b system, or any abstract register when on 64b.\n\nWhat do you think?",
      "parentUuid": "043d9d9e_d1524611",
      "range": {
        "startLine": 1203,
        "startChar": 8,
        "endLine": 1203,
        "endChar": 81
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}