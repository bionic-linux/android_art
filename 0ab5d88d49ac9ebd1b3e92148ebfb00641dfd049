{
  "comments": [
    {
      "key": {
        "uuid": "c498e5f7_e2c782d9",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T04:15:12Z",
      "side": 1,
      "message": "Wide32 seems strange to me. I understand what you meant but it looks like wide is overloaded here. Can we do something like kNoneWide and KWide?",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c4462542_4f8eb16b",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-07T05:04:17Z",
      "side": 1,
      "message": "I had that before and changed it. The issue is that ref registers are \"wide\" on 64b systems. So reading kNonWide in the code is ambiguous, too, without changing the name of the function.",
      "parentUuid": "c498e5f7_e2c782d9",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "043d9d9e_f15742fe",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T05:10:51Z",
      "side": 1,
      "message": "I guessed that this enum is not for refs. For refs we use TargetRefReg function without specifying wide kind, isn\u0027t it?",
      "parentUuid": "c4462542_4f8eb16b",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04cafddd_613d4d49",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-07T06:04:19Z",
      "side": 1,
      "message": "Yes, but we have a lot of code fragments that look like this:\n\nif (arg0.wide\u003d\u003d0) {\n  TargetReg(kArg0, ???)\n}\n\nThe correct use here is arg0, the reg location, which also has the ref flag. It is not correct to say kNotWide, even though it _sounds_ reasonable judging by the condition. This mixup I want to make as hard as possible.\n\nMaybe it makes sense to use OpSize, though? And maybe OpSize needs an element for pointer size.",
      "parentUuid": "043d9d9e_f15742fe",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c498e5f7_a2e65a7b",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T06:19:11Z",
      "side": 1,
      "message": "For your example, you are right the best way to use arg0.\nIf you really want to disambiguate kNotWide and  reference, can we add kRef? My understanding is as follows: this enum is for reading the common code. It should not know whether ref is 32-bit or 64-bit one. It should just specify what it needs: NotWide, Wide or Ref (at this moment ref and kNotwide are differed by usage TargetRefReg utility). And it decides it basing on VR information. VR for reference is actually 32-bit and in this term it is ok to use kNotWide for reference but if we really want to disambiguate them so let\u0027s introduce the kRef constant and use it (and eliminate TargetRefReg method).",
      "parentUuid": "04cafddd_613d4d49",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c4462542_effcbd90",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-07T06:36:50Z",
      "side": 1,
      "message": "In that case why not change it to OpSize, which basically has these already (except named k32 and k64)? This is likely also the future-proof way if we want to integrate vector registers, which likely show up in OpSize, too.\n\nAnd it is not OK to use kNotWide for references: the ARM64 backend is already written such that it (correctly) requires ref registers to be 64b (and has conversion in Load/StoreRefXXX where we could easily add compress/uncompress) - something I\u0027d like the x86(-64) backend to get to, too.",
      "parentUuid": "c498e5f7_a2e65a7b",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "445eb5fe_de0ed595",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 538,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T06:45:50Z",
      "side": 1,
      "message": "Right, x64 is also ready for compress/decompress I guess. So I suggest to use kRef.\n\nIMHO, OpSize is worse because TargetReg is supposed to be a portable way to get a RegStorage. So I think it is better if it will decide what size RegStorage is required.",
      "parentUuid": "c4462542_effcbd90",
      "range": {
        "startLine": 538,
        "startChar": 2,
        "endLine": 538,
        "endChar": 9
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "445eb5fe_5edba5f8",
        "filename": "compiler/dex/compiler_enums.h",
        "patchSetId": 1
      },
      "lineNbr": 540,
      "author": {
        "id": 1037505
      },
      "writtenOn": "2014-07-05T10:19:28Z",
      "side": 1,
      "message": "That\u0027s good. I disliked the true/false. Also, we may end up needing more than the 32 and 64 bit views (e.g. for vector registers).",
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4485d588_86b96e65",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 302,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-05T01:11:05Z",
      "side": 1,
      "message": "Note: this looks strange to me. That looks like on ARM we have a mixed soft-hard-float convention. arg0 is in farg0 if fp, but arg1 is always in arg1.",
      "range": {
        "startLine": 302,
        "startChar": 33,
        "endLine": 302,
        "endChar": 77
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c498e5f7_a23f3a4d",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 302,
      "author": {
        "id": 1037505
      },
      "writtenOn": "2014-07-05T10:19:28Z",
      "side": 1,
      "message": "The first time I looked at this function I could not make sense of it. I preferred to split out the Arm64 case, rather than trying to extend the old (and pretty entropic) logic. I suspect for Arm (32-bit) we may never happen to call the function in a way where the hard/soft float mix matters. In other words, parts of this function may turn out to be dead code. As a positive side, the function is now hugely improved. One thing that may further help to clean up the code, is introducing a TargetArgReg(int n, RegLocation rl) which returns the n-th argument having the same \"type\" of rl (and would have a trivial implementation for Arm64). Another thing - that affects the whole quick compiler - is the wide/non-wide variants of functions. The code is literally scattered with\n\n  if (wide) UseWideVariant(); else UseNonWideVariant();\n\nBut, addressing this issue is a huge refactoring task.",
      "parentUuid": "4485d588_86b96e65",
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4c6c9d8_278369b6",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 302,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-05T17:53:03Z",
      "side": 1,
      "message": "I totally agree with you here and had the same thoughts, but this was a small and contained refactoring. :-)",
      "parentUuid": "c498e5f7_a23f3a4d",
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "043d9d9e_d1524611",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1203,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T04:15:12Z",
      "side": 1,
      "message": "Could you please update a doc indicating that for wide case reg is expected to be only arg?",
      "range": {
        "startLine": 1203,
        "startChar": 8,
        "endLine": 1203,
        "endChar": 81
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04cafddd_41b5b1b8",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1203,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-07-07T05:04:17Z",
      "side": 1,
      "message": "The main question here is: when can you expect to get a correct result on a 32b system? My first attempt here was \"when wide registers are a pair of consecutive registers,\" for which the arg regs made sense. I would have thought we need ret, too, for long returns, but I did not find such a use case in the code.\n\nSo my try at documentation would be: must be k(F)Arg0-6 when on a 32b system, or any abstract register when on 64b.\n\nWhat do you think?",
      "parentUuid": "043d9d9e_d1524611",
      "range": {
        "startLine": 1203,
        "startChar": 8,
        "endLine": 1203,
        "endChar": 81
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c498e5f7_22b24a84",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1203,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-07-07T05:10:51Z",
      "side": 1,
      "message": "I want doc is aligned with specification here. So if you allow only args for both fp and core and you have doc, doc should reflect this check.",
      "parentUuid": "04cafddd_41b5b1b8",
      "range": {
        "startLine": 1203,
        "startChar": 8,
        "endLine": 1203,
        "endChar": 81
      },
      "revId": "0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}