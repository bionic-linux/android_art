{
  "comments": [
    {
      "key": {
        "uuid": "8780ea14_8a2bab51",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1580,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-01-18T09:57:04Z",
      "side": 1,
      "message": "Reasonable to think we can? (here and arm64 as well)",
      "range": {
        "startLine": 1580,
        "startChar": 0,
        "endLine": 1580,
        "endChar": 40
      },
      "revId": "77d6a53032cd504918a4d00d8ca4abc44aa0a869",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "47727221_283d639b",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1580,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2016-01-18T11:35:02Z",
      "side": 1,
      "message": "Yes, we should be able to use the SIMD instructions VCNT on ARM and CNT on ARM64.",
      "parentUuid": "8780ea14_8a2bab51",
      "range": {
        "startLine": 1580,
        "startChar": 0,
        "endLine": 1580,
        "endChar": 40
      },
      "revId": "77d6a53032cd504918a4d00d8ca4abc44aa0a869",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8780ea14_aaccefe5",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1580,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-01-18T12:09:13Z",
      "side": 1,
      "message": "For code size, the best option on ARM would be\n\n  vmov sTmp, rInput\n  vcnt.8 sTmp, sTmp\n  vmov rOutput, rOutput\n  add rOutput, rOutput, rOutput, shl #8\n  add rOutput, rOutput, rOutput, shl #16\n  lsr rOutput, rOutput, #24\n\nNote, that LSR can be a 16-bit instruction but AND is always 32-bit, so we should choose to accumulate the result in the highest byte (as above) rather than the lowest.\n\nFor Long, we have two options how to add the results for the two words: VADD or UADD8. VADD should be preferred to avoid clobbering an extra core register.\n\nThe question is, would it be faster if we stick to core registers (with 6 extra instructions for Int and even more for Long)?\n\nSimilar on ARM64, except that for adding the high and low word results for Long should be done in core register. And it doesn\u0027t matter whether the result is accumulated in the high or low byte.",
      "parentUuid": "47727221_283d639b",
      "range": {
        "startLine": 1580,
        "startChar": 0,
        "endLine": 1580,
        "endChar": 40
      },
      "revId": "77d6a53032cd504918a4d00d8ca4abc44aa0a869",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "47727221_882bb751",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2389,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2016-01-18T11:35:02Z",
      "side": 1,
      "message": "I would use the `POPCOUNT` helper provided by runtime/base/bit_utils.h here:\n\n    HInstruction* arg \u003d invoke-\u003eInputAt(0)\n    int32_t count \u003d is_long ?\n        POPCOUNT(arg-\u003eAsLongConstant()-\u003eGetValue()) :\n        POPCOUNT(arg-\u003eAsIntConstant()-\u003eGetValue());",
      "range": {
        "startLine": 2386,
        "startChar": 0,
        "endLine": 2389,
        "endChar": 63
      },
      "revId": "77d6a53032cd504918a4d00d8ca4abc44aa0a869",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "47727221_a8287355",
        "filename": "compiler/optimizing/intrinsics_x86_64.cc",
        "patchSetId": 1
      },
      "lineNbr": 2395,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2016-01-18T11:35:02Z",
      "side": 1,
      "message": "Remove?",
      "range": {
        "startLine": 2395,
        "startChar": 11,
        "endLine": 2395,
        "endChar": 21
      },
      "revId": "77d6a53032cd504918a4d00d8ca4abc44aa0a869",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e783661b_4d71cd75",
        "filename": "test/564-bitcount/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-01-18T09:57:04Z",
      "side": 1,
      "message": "Maybe add an ARCH-X86_64 specific checker test to ensure there is no call?",
      "range": {
        "startLine": 19,
        "startChar": 21,
        "endLine": 19,
        "endChar": 27
      },
      "revId": "77d6a53032cd504918a4d00d8ca4abc44aa0a869",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}