{
  "comments": [
    {
      "key": {
        "uuid": "dcb984a9_00e9eee2",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 5
      },
      "lineNbr": 377,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-12-03T03:13:28Z",
      "side": 1,
      "message": "This may be a question for Lokesh as well:\n\nThis is basically what might traditionally be called the average cons to mark ratio.\n\nIs this really the mathematically correct metric? It seems to give the same weight to what happens in small heap/cheap GCs as it does to collections that happen when the heap is much larger. To me it seems that sum(reclaimed_bytes)/sum(allocated_bytes at GC end) or the inverse (i.e. the total mark to cons ratio) would be a better choice. Effectively that gives larger collections the weight they deserve.",
      "range": {
        "startLine": 377,
        "startChar": 2,
        "endLine": 377,
        "endChar": 35
      },
      "revId": "af9cce1808dbec59d632fe85fb139852751bc479",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9bab1c47_b242f55e",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 5
      },
      "lineNbr": 377,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2018-12-03T20:08:56Z",
      "side": 1,
      "message": "Just to confirm, are you suggesting that we should use bytes allocated after GC and not before for computing the ratio?\n\nOn another thought, instead of having a reclaimed bytes ratio over the bytes allocated of the entire heap, shouldn\u0027t it be over just the regions covered in that type of GC? That will give us an indication of whether generational hypothesis holds for us or not. If it holds, then we can expect to see a larger ratio for young GCs than full GCs. In the current form, I\u0027m not sure if it gives any additional insight than what a simple metric like \"avg bytes freed\" would give.",
      "parentUuid": "dcb984a9_00e9eee2",
      "range": {
        "startLine": 377,
        "startChar": 2,
        "endLine": 377,
        "endChar": 35
      },
      "revId": "af9cce1808dbec59d632fe85fb139852751bc479",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd601204_c6f90aac",
        "filename": "runtime/gc/collector/concurrent_copying.h",
        "patchSetId": 5
      },
      "lineNbr": 425,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-12-03T03:13:28Z",
      "side": 1,
      "message": "Why is this signed? The comment specifies a good reason to cast it to signed before performing the subtraction. But the value itself seems clearly non-negative. I believe the usual convention in this code is to use size_t for such things. I have a pending CL that makes it a bit more consistent that way.",
      "range": {
        "startLine": 425,
        "startChar": 2,
        "endLine": 425,
        "endChar": 41
      },
      "revId": "af9cce1808dbec59d632fe85fb139852751bc479",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}