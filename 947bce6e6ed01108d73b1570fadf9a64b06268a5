{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "324f536c_7a9fbd5a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 11,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-06-01T08:21:15Z",
      "side": 1,
      "message": "not required?",
      "range": {
        "startLine": 11,
        "startChar": 9,
        "endLine": 11,
        "endChar": 12
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "543de19b_805231bf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 11,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-06-01T16:11:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "324f536c_7a9fbd5a",
      "range": {
        "startLine": 11,
        "startChar": 9,
        "endLine": 11,
        "endChar": 12
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91a9605b_c5463670",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 17,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-06-01T08:21:15Z",
      "side": 1,
      "message": "\"in ConcurrentGCTask::Run\"",
      "range": {
        "startLine": 17,
        "startChar": 29,
        "endLine": 17,
        "endChar": 46
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e1e8b132_6cf912fc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 8
      },
      "lineNbr": 17,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-06-01T16:11:20Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "91a9605b_c5463670",
      "range": {
        "startLine": 17,
        "startChar": 29,
        "endLine": 17,
        "endChar": 46
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6ed12efd_e1431f4f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-05-31T04:26:45Z",
      "side": 1,
      "message": "This is once again intended to be ready to submit.",
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fc36581f_033bb680",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1881526
      },
      "writtenOn": "2021-05-31T15:00:44Z",
      "side": 1,
      "message": "resuelto ",
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c46c195_708b3712",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-05-31T17:42:40Z",
      "side": 1,
      "message": "None of the presubmit failures seem to be associated with this CL.",
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a914c8a7_66f8d366",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 2689,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-05-31T04:26:45Z",
      "side": 1,
      "message": "Lokesh - Do you understand why this is here?",
      "range": {
        "startLine": 2689,
        "startChar": 4,
        "endLine": 2689,
        "endChar": 69
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b39fa47c_bc719895",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 2689,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-06-01T08:21:15Z",
      "side": 1,
      "message": "I\u0027m not sure if it serves any purpose. I looked at all the invocations of CollectGarbageInternal, and all they care about is whether it\u0027s \u0027None\u0027 or not.\n\nOnly FinishGC() uses it to set last_gc_type_, which is returned from WaitForGcToComplete().\n\nHowever, I think we should remove this as it can cause problems in AllocateInternalWithGc() (here https://cs.android.com/android/platform/superproject/+/master:art/runtime/gc/heap.cc;drc\u003dmaster;l\u003d1868). I can elaborate more on this if you want.",
      "parentUuid": "a914c8a7_66f8d366",
      "range": {
        "startLine": 2689,
        "startChar": 4,
        "endLine": 2689,
        "endChar": 69
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5c61115b_d882aade",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 2689,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-06-01T16:11:20Z",
      "side": 1,
      "message": "OK. I\u0027ll upload a follow-on CL . It seems a bit risky, and orthogonal to this CL. Filed b/189830999 for further discussion.",
      "parentUuid": "b39fa47c_bc719895",
      "range": {
        "startLine": 2689,
        "startChar": 4,
        "endLine": 2689,
        "endChar": 69
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd8339c1_b8e304a2",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 3759,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-06-01T08:21:15Z",
      "side": 1,
      "message": "I think this is the only place where gcs_requested_ is incremented. This means that any GC with GC_NUM_ANY won\u0027t increment it, right? But these GCs do increment gcs_completed_. This means we allow gcs_completed_ \u003e\u003d gcs_requested_.\n\nTherefore, if multiple GC_NUM_ANY GCs are done and hence gcs_completed_ - gcs_requested_ \u003e 1 (say 5). In this case we will allow multiple simultaneous background GCs. And given that background GCs increment both gcs_requested_ as well as gcs_completed_, it would never catch up. Doesn\u0027t it defeat the whole purpose of introducing the concept of gc-number?\n\nWouldn\u0027t it make sense to increment gcs_requested_ even when a GC_NUM_ANY GC is being done? With this, we can ensure that there are never more than one simultaneous background GCs. At the same time GC_NUM_ANY ensures that such GCs are always performed, as intended.\n\nI guess I\u0027m missing something, but not sure what.",
      "range": {
        "startLine": 3759,
        "startChar": 10,
        "endLine": 3759,
        "endChar": 51
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d662c388_6005302f",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 3759,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-06-01T16:11:20Z",
      "side": 1,
      "message": "I agree entirely with the first paragraph.\n\nLet\u0027s assume that gcs_requested_ \u003d 1, gcs_completed_ \u003d 6. Let\u0027s assume that we then get a call to RequestConcurrentGC() that\u0027s based on current data, i.e. observed_gc_num \u003d 6. We have observed_gc_num \u003e\u003d gcs_requested, so we go ahead and execute the rest of this, replacing the old gcs_requested value of 1 by 7. so I think we\u0027re back to normal. Note that we don\u0027t just increment gcs_requested_ by one. Maybe it should be named max_gc_requested_?\n\nI don\u0027t think we can have more than one GC running at a time anyway. I think we have a complicated custom-mutex equivalent around the GC: We wait for collector_type_running_ to be none, and protect accesses to it by gc_complete_lock_ .\n\nI don\u0027t think gcs_requested_ is essential for correctness. We could always add the task, and all the unnecessary GCs would get filtered out later. But it seems common to get 100s and maybe 1000s of RequestConcurrentGC() calls per GC, so it unfortunately seems useful to put a filtering mechanism here to avoid blowing up the task queue.\n\nTaking this as a request to fix the naming of and comment for gcs_requested_, which I\u0027ve now done.",
      "parentUuid": "dd8339c1_b8e304a2",
      "range": {
        "startLine": 3759,
        "startChar": 10,
        "endLine": 3759,
        "endChar": 51
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "287e3924_a3b70314",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 8
      },
      "lineNbr": 3759,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-06-01T17:08:42Z",
      "side": 1,
      "message": "\u003e I agree entirely with the first paragraph.\n\u003e \n\u003e Let\u0027s assume that gcs_requested_ \u003d 1, gcs_completed_ \u003d 6. Let\u0027s assume that we then get a call to RequestConcurrentGC() that\u0027s based on current data, i.e. observed_gc_num \u003d 6. We have observed_gc_num \u003e\u003d gcs_requested, so we go ahead and execute the rest of this, replacing the old gcs_requested value of 1 by 7. so I think we\u0027re back to normal. Note that we don\u0027t just increment gcs_requested_ by one. Maybe it should be named max_gc_requested_?\n\u003e \nI had missed this part: that it\u0027s not just an increment, but advancing gcs_requested, based on current value of gcs_completed. Thanks for correcting me.\n\n\u003e I don\u0027t think we can have more than one GC running at a time anyway. I think we have a complicated custom-mutex equivalent around the GC: We wait for collector_type_running_ to be none, and protect accesses to it by gc_complete_lock_ .\n\nI meant to say that multiple GC tasks could get queued up. Of course simultaneous GCs isn\u0027t possible. Anyways, it doesn\u0027t matter after your explanation above.\n\u003e \n\u003e I don\u0027t think gcs_requested_ is essential for correctness. We could always add the task, and all the unnecessary GCs would get filtered out later. But it seems common to get 100s and maybe 1000s of RequestConcurrentGC() calls per GC, so it unfortunately seems useful to put a filtering mechanism here to avoid blowing up the task queue.\n\u003e \n\u003e Taking this as a request to fix the naming of and comment for gcs_requested_, which I\u0027ve now done.",
      "parentUuid": "d662c388_6005302f",
      "range": {
        "startLine": 3759,
        "startChar": 10,
        "endLine": 3759,
        "endChar": 51
      },
      "revId": "947bce6e6ed01108d73b1570fadf9a64b06268a5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}