#!/usr/bin/env python
#
# Copyright (C) 2016 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#
# Using instructions from an architecture-specific config file, generate C
# and assembly source files for the Dalvik interpreter.
#

import sys, re
from os import listdir

interp_defs_file = "../../../libdexfile/dex/dex_instruction_list.h" # need opcode list
kNumPackedOpcodes = 256

#
# Extract an ordered list of instructions from the VM sources.  We use the
# "goto table" definition macro, which has exactly kNumPackedOpcodes
# entries.
#
def getOpcodeList():
    opcodes = []
    opcode_fp = open(interp_defs_file)
    opcode_re = re.compile(r"^\s*V\((....), (\w+),.*", re.DOTALL)
    for line in opcode_fp:
        match = opcode_re.match(line)
        if not match:
            continue
        opcodes.append("op_" + match.group(2).lower())
    opcode_fp.close()

    if len(opcodes) != kNumPackedOpcodes:
        print "ERROR: found %d opcodes in Interp.h (expected %d)" \
                % (len(opcodes), kNumPackedOpcodes)
        raise SyntaxError, "bad opcode count"
    return opcodes

# Finds variable references in text: $foo or ${foo}
escape_re = re.compile(r'''
    (?<!\$)        # Look-back: must not be preceded by another $.
    \$
    (\{)?          # May be enclosed by { } pair.
    (?P<name>\w+)  # Save the symbol in named group.
    (?(1)\})       # Expect } if and only if { was present.
''', re.VERBOSE)

script_head = r"""
import sys

out = sys.stdout
handler_size_bytes = "128"
handler_size_bits = "7"
opcode = ""
opnum = ""

def write_line(line):
  out.write(line + "\n")

def balign():
  write_line("    .balign {}".format(handler_size_bytes))

def write_opcode(num, name, write_method, is_alt):
  global opnum, opcode
  opnum, opcode = str(num), name
  if is_alt:
    name = "ALT_" + name
  write_line("/* ------------------------------ */")
  balign()
  write_line(".L_{1}: /* {0:#04x} */".format(num, name))
  if is_alt:
    alt_stub()
  else:
    write_method()
  write_line("")
  opnum, opcode = None, None

def generate(output_file):
  global out
  out = output_file
  write_line("/* DO NOT EDIT: This file was generated by gen-mterp.py. */")
  header()
  entry()

  instruction_start()
  opcodes(is_alt = False)
  balign()
  instruction_end()

  instruction_start_sister()
  write_sister()
  instruction_end_sister()

  # We need to footer sooner so that branch instruction can reach it.
  # TODO: Clean up.
  if arch == "arm64":
    footer()

  instruction_start_alt()
  opcodes(is_alt = True)
  balign()
  instruction_end_alt()

  if arch == "arm64":
    close_cfi()
  else:
    footer()

  out.truncate()

"""

def generate(arch):
    script = open("out/mterp_" + arch + ".py", "w")
    script.write("# DO NOT EDIT: This file was generated by gen-mterp.py.\n")
    script.write('arch = "' + arch + '"\n')
    script.write(script_head)
    opcodes = getOpcodeList()
    script.write("def opcodes(is_alt):\n")
    for i in xrange(kNumPackedOpcodes):
        script.write('  write_opcode({0}, "{1}", {1}, is_alt)\n'.format(i, opcodes[i]))

    # TODO: Remove the concept of sister snippets. It is barely used.
    script.write("def write_sister():\n")
    script.write("  global opnum, opcode\n")
    if arch == "arm":
        script.write("  op_float_to_long_sister_code()\n")
        script.write("  op_double_to_long_sister_code()\n")
    if arch == "mips":
        names = [
            "op_float_to_long",
            "op_double_to_long",
            "op_mul_long",
            "op_shl_long",
            "op_shr_long",
            "op_ushr_long",
            "op_shl_long_2addr",
            "op_shr_long_2addr",
            "op_ushr_long_2addr"
        ]
        for name in names:
          script.write('  opcode = "' + name + '"\n')
          script.write("  " + name + "_sister_code()\n")
    script.write("  pass\n")

    files = listdir(arch)
    for file in sorted(files):
        f = open(arch + "/" + file, "r")
        for line in f.readlines():
            if line.startswith("%"):
                script.write(line.lstrip("%"))
            else:
                line = escape_re.sub(r"''' + \g<name> + '''", line)
                line = line.replace("\\", "\\\\")
                line = line.replace("$$", "$")
                script.write("  write_line('''" + line.rstrip("\n") + "''')\n")
        script.write("\n")
        f.close()
    script.close()

# Generate out/mterp_*.py script for each architecture.
for arch in ["arm", "arm64", "mips", "mips64", "x86", "x86_64"]:
    generate(arch)

# Execute the generated python scripts to produce the final assembly files.
import out.mterp_arm
import out.mterp_arm64
import out.mterp_mips
import out.mterp_mips64
import out.mterp_x86
import out.mterp_x86_64
out.mterp_arm.generate(open('out/mterp_arm.S', 'w'))
out.mterp_arm64.generate(open('out/mterp_arm64.S', 'w'))
out.mterp_mips.generate(open('out/mterp_mips.S', 'w'))
out.mterp_mips64.generate(open('out/mterp_mips64.S', 'w'))
out.mterp_x86.generate(open('out/mterp_x86.S', 'w'))
out.mterp_x86_64.generate(open('out/mterp_x86_64.S', 'w'))
