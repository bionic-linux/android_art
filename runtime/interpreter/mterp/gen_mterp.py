#!/usr/bin/env python
#
# Copyright (C) 2016 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys, re
from os import listdir

interp_defs_file = "../../../libdexfile/dex/dex_instruction_list.h" # need opcode list
kNumPackedOpcodes = 256

# Extract an ordered list of instructions from the VM sources.  We use the
# "goto table" definition macro, which has exactly kNumPackedOpcodes entries.
def getOpcodeList():
  opcodes = []
  opcode_fp = open(interp_defs_file)
  opcode_re = re.compile(r"^\s*V\((....), (\w+),.*", re.DOTALL)
  for line in opcode_fp:
    match = opcode_re.match(line)
    if not match:
      continue
    opcodes.append("op_" + match.group(2).lower())
  opcode_fp.close()

  if len(opcodes) != kNumPackedOpcodes:
    print "ERROR: found %d opcodes in Interp.h (expected %d)" \
        % (len(opcodes), kNumPackedOpcodes)
    raise SyntaxError, "bad opcode count"
  return opcodes

# Finds variable references in text: $foo or ${foo}
escape_re = re.compile(r'''
  (?<!\$)        # Look-back: must not be preceded by another $.
  \$
  (\{)?          # May be enclosed by { } pair.
  (?P<name>\w+)  # Save the symbol in named group.
  (?(1)\})       # Expect } if and only if { was present.
''', re.VERBOSE)

def generate(arch):
  # Create new python script and write the initial setup code.
  script = open("out/mterp_" + arch + ".py", "w")
  script.write("# DO NOT EDIT: This file was generated by gen-mterp.py.\n")
  script.write('arch = "' + arch + '"\n')
  script.write(open("common/gen_setup.py", "r").read())
  opcodes = getOpcodeList()
  script.write("def opcodes(is_alt):\n")
  for i in xrange(kNumPackedOpcodes):
    script.write('  write_opcode({0}, "{1}", {1}, is_alt)\n'.format(i, opcodes[i]))

  # Find all template files and translate them into python code.
  files = listdir(arch)
  for file in sorted(files):
    f = open(arch + "/" + file, "r")
    for line in f.readlines():
      if line.startswith("%"):
        script.write(line.lstrip("%"))
      else:
        line = escape_re.sub(r"''' + \g<name> + '''", line)
        line = line.replace("\\", "\\\\")
        line = line.replace("$$", "$")
        script.write("  write_line('''" + line.rstrip("\n") + "''')\n")
    script.write("\n")
    f.close()

  # TODO: Remove the concept of sister snippets. It is barely used.
  script.write("def write_sister():\n")
  if arch == "arm":
    script.write("  op_float_to_long_sister_code()\n")
    script.write("  op_double_to_long_sister_code()\n")
  if arch == "mips":
    script.write("  global opnum, opcode\n")
    names = [
      "op_float_to_long",
      "op_double_to_long",
      "op_mul_long",
      "op_shl_long",
      "op_shr_long",
      "op_ushr_long",
      "op_shl_long_2addr",
      "op_shr_long_2addr",
      "op_ushr_long_2addr"
    ]
    for name in names:
      script.write('  opcode = "' + name + '"\n')
      script.write("  " + name + "_sister_code()\n")
  script.write("  pass\n")

  script.close()

# Generate out/mterp_*.py script for each architecture.
for arch in ["arm", "arm64", "mips", "mips64", "x86", "x86_64"]:
  generate(arch)

# Execute the generated python scripts to produce the final assembly files.
import out.mterp_arm
import out.mterp_arm64
import out.mterp_mips
import out.mterp_mips64
import out.mterp_x86
import out.mterp_x86_64
out.mterp_arm.generate(open('out/mterp_arm.S', 'w'))
out.mterp_arm64.generate(open('out/mterp_arm64.S', 'w'))
out.mterp_mips.generate(open('out/mterp_mips.S', 'w'))
out.mterp_mips64.generate(open('out/mterp_mips64.S', 'w'))
out.mterp_x86.generate(open('out/mterp_x86.S', 'w'))
out.mterp_x86_64.generate(open('out/mterp_x86_64.S', 'w'))
