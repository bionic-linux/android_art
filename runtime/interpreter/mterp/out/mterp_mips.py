# DO NOT EDIT: This file was generated by gen-mterp.py.
arch = "mips"

import sys

out = sys.stdout
handler_size_bytes = "128"
handler_size_bits = "7"
opcode = ""
opnum = ""

def write_line(line):
  out.write(line + "\n")

def balign():
  write_line("    .balign {}".format(handler_size_bytes))

def write_opcode(num, name, write_method, is_alt):
  global opnum, opcode
  opnum, opcode = str(num), name
  if is_alt:
    name = "ALT_" + name
  write_line("/* ------------------------------ */")
  balign()
  write_line(".L_{1}: /* {0:#04x} */".format(num, name))
  if is_alt:
    alt_stub()
  else:
    write_method()
  write_line("")
  opnum, opcode = None, None

def generate(output_file):
  global out
  out = output_file
  write_line("/* DO NOT EDIT: This file was generated by gen-mterp.py. */")
  header()
  entry()

  instruction_start()
  opcodes(is_alt = False)
  balign()
  instruction_end()

  instruction_start_sister()
  write_sister()
  instruction_end_sister()

  # We need to footer sooner so that branch instruction can reach it.
  # TODO: Clean up.
  if arch == "arm64":
    footer()

  instruction_start_alt()
  opcodes(is_alt = True)
  balign()
  instruction_end_alt()

  if arch == "arm64":
    close_cfi()
  else:
    footer()

  out.truncate()

def opcodes(is_alt):
  write_opcode(0, "op_nop", op_nop, is_alt)
  write_opcode(1, "op_move", op_move, is_alt)
  write_opcode(2, "op_move_from16", op_move_from16, is_alt)
  write_opcode(3, "op_move_16", op_move_16, is_alt)
  write_opcode(4, "op_move_wide", op_move_wide, is_alt)
  write_opcode(5, "op_move_wide_from16", op_move_wide_from16, is_alt)
  write_opcode(6, "op_move_wide_16", op_move_wide_16, is_alt)
  write_opcode(7, "op_move_object", op_move_object, is_alt)
  write_opcode(8, "op_move_object_from16", op_move_object_from16, is_alt)
  write_opcode(9, "op_move_object_16", op_move_object_16, is_alt)
  write_opcode(10, "op_move_result", op_move_result, is_alt)
  write_opcode(11, "op_move_result_wide", op_move_result_wide, is_alt)
  write_opcode(12, "op_move_result_object", op_move_result_object, is_alt)
  write_opcode(13, "op_move_exception", op_move_exception, is_alt)
  write_opcode(14, "op_return_void", op_return_void, is_alt)
  write_opcode(15, "op_return", op_return, is_alt)
  write_opcode(16, "op_return_wide", op_return_wide, is_alt)
  write_opcode(17, "op_return_object", op_return_object, is_alt)
  write_opcode(18, "op_const_4", op_const_4, is_alt)
  write_opcode(19, "op_const_16", op_const_16, is_alt)
  write_opcode(20, "op_const", op_const, is_alt)
  write_opcode(21, "op_const_high16", op_const_high16, is_alt)
  write_opcode(22, "op_const_wide_16", op_const_wide_16, is_alt)
  write_opcode(23, "op_const_wide_32", op_const_wide_32, is_alt)
  write_opcode(24, "op_const_wide", op_const_wide, is_alt)
  write_opcode(25, "op_const_wide_high16", op_const_wide_high16, is_alt)
  write_opcode(26, "op_const_string", op_const_string, is_alt)
  write_opcode(27, "op_const_string_jumbo", op_const_string_jumbo, is_alt)
  write_opcode(28, "op_const_class", op_const_class, is_alt)
  write_opcode(29, "op_monitor_enter", op_monitor_enter, is_alt)
  write_opcode(30, "op_monitor_exit", op_monitor_exit, is_alt)
  write_opcode(31, "op_check_cast", op_check_cast, is_alt)
  write_opcode(32, "op_instance_of", op_instance_of, is_alt)
  write_opcode(33, "op_array_length", op_array_length, is_alt)
  write_opcode(34, "op_new_instance", op_new_instance, is_alt)
  write_opcode(35, "op_new_array", op_new_array, is_alt)
  write_opcode(36, "op_filled_new_array", op_filled_new_array, is_alt)
  write_opcode(37, "op_filled_new_array_range", op_filled_new_array_range, is_alt)
  write_opcode(38, "op_fill_array_data", op_fill_array_data, is_alt)
  write_opcode(39, "op_throw", op_throw, is_alt)
  write_opcode(40, "op_goto", op_goto, is_alt)
  write_opcode(41, "op_goto_16", op_goto_16, is_alt)
  write_opcode(42, "op_goto_32", op_goto_32, is_alt)
  write_opcode(43, "op_packed_switch", op_packed_switch, is_alt)
  write_opcode(44, "op_sparse_switch", op_sparse_switch, is_alt)
  write_opcode(45, "op_cmpl_float", op_cmpl_float, is_alt)
  write_opcode(46, "op_cmpg_float", op_cmpg_float, is_alt)
  write_opcode(47, "op_cmpl_double", op_cmpl_double, is_alt)
  write_opcode(48, "op_cmpg_double", op_cmpg_double, is_alt)
  write_opcode(49, "op_cmp_long", op_cmp_long, is_alt)
  write_opcode(50, "op_if_eq", op_if_eq, is_alt)
  write_opcode(51, "op_if_ne", op_if_ne, is_alt)
  write_opcode(52, "op_if_lt", op_if_lt, is_alt)
  write_opcode(53, "op_if_ge", op_if_ge, is_alt)
  write_opcode(54, "op_if_gt", op_if_gt, is_alt)
  write_opcode(55, "op_if_le", op_if_le, is_alt)
  write_opcode(56, "op_if_eqz", op_if_eqz, is_alt)
  write_opcode(57, "op_if_nez", op_if_nez, is_alt)
  write_opcode(58, "op_if_ltz", op_if_ltz, is_alt)
  write_opcode(59, "op_if_gez", op_if_gez, is_alt)
  write_opcode(60, "op_if_gtz", op_if_gtz, is_alt)
  write_opcode(61, "op_if_lez", op_if_lez, is_alt)
  write_opcode(62, "op_unused_3e", op_unused_3e, is_alt)
  write_opcode(63, "op_unused_3f", op_unused_3f, is_alt)
  write_opcode(64, "op_unused_40", op_unused_40, is_alt)
  write_opcode(65, "op_unused_41", op_unused_41, is_alt)
  write_opcode(66, "op_unused_42", op_unused_42, is_alt)
  write_opcode(67, "op_unused_43", op_unused_43, is_alt)
  write_opcode(68, "op_aget", op_aget, is_alt)
  write_opcode(69, "op_aget_wide", op_aget_wide, is_alt)
  write_opcode(70, "op_aget_object", op_aget_object, is_alt)
  write_opcode(71, "op_aget_boolean", op_aget_boolean, is_alt)
  write_opcode(72, "op_aget_byte", op_aget_byte, is_alt)
  write_opcode(73, "op_aget_char", op_aget_char, is_alt)
  write_opcode(74, "op_aget_short", op_aget_short, is_alt)
  write_opcode(75, "op_aput", op_aput, is_alt)
  write_opcode(76, "op_aput_wide", op_aput_wide, is_alt)
  write_opcode(77, "op_aput_object", op_aput_object, is_alt)
  write_opcode(78, "op_aput_boolean", op_aput_boolean, is_alt)
  write_opcode(79, "op_aput_byte", op_aput_byte, is_alt)
  write_opcode(80, "op_aput_char", op_aput_char, is_alt)
  write_opcode(81, "op_aput_short", op_aput_short, is_alt)
  write_opcode(82, "op_iget", op_iget, is_alt)
  write_opcode(83, "op_iget_wide", op_iget_wide, is_alt)
  write_opcode(84, "op_iget_object", op_iget_object, is_alt)
  write_opcode(85, "op_iget_boolean", op_iget_boolean, is_alt)
  write_opcode(86, "op_iget_byte", op_iget_byte, is_alt)
  write_opcode(87, "op_iget_char", op_iget_char, is_alt)
  write_opcode(88, "op_iget_short", op_iget_short, is_alt)
  write_opcode(89, "op_iput", op_iput, is_alt)
  write_opcode(90, "op_iput_wide", op_iput_wide, is_alt)
  write_opcode(91, "op_iput_object", op_iput_object, is_alt)
  write_opcode(92, "op_iput_boolean", op_iput_boolean, is_alt)
  write_opcode(93, "op_iput_byte", op_iput_byte, is_alt)
  write_opcode(94, "op_iput_char", op_iput_char, is_alt)
  write_opcode(95, "op_iput_short", op_iput_short, is_alt)
  write_opcode(96, "op_sget", op_sget, is_alt)
  write_opcode(97, "op_sget_wide", op_sget_wide, is_alt)
  write_opcode(98, "op_sget_object", op_sget_object, is_alt)
  write_opcode(99, "op_sget_boolean", op_sget_boolean, is_alt)
  write_opcode(100, "op_sget_byte", op_sget_byte, is_alt)
  write_opcode(101, "op_sget_char", op_sget_char, is_alt)
  write_opcode(102, "op_sget_short", op_sget_short, is_alt)
  write_opcode(103, "op_sput", op_sput, is_alt)
  write_opcode(104, "op_sput_wide", op_sput_wide, is_alt)
  write_opcode(105, "op_sput_object", op_sput_object, is_alt)
  write_opcode(106, "op_sput_boolean", op_sput_boolean, is_alt)
  write_opcode(107, "op_sput_byte", op_sput_byte, is_alt)
  write_opcode(108, "op_sput_char", op_sput_char, is_alt)
  write_opcode(109, "op_sput_short", op_sput_short, is_alt)
  write_opcode(110, "op_invoke_virtual", op_invoke_virtual, is_alt)
  write_opcode(111, "op_invoke_super", op_invoke_super, is_alt)
  write_opcode(112, "op_invoke_direct", op_invoke_direct, is_alt)
  write_opcode(113, "op_invoke_static", op_invoke_static, is_alt)
  write_opcode(114, "op_invoke_interface", op_invoke_interface, is_alt)
  write_opcode(115, "op_return_void_no_barrier", op_return_void_no_barrier, is_alt)
  write_opcode(116, "op_invoke_virtual_range", op_invoke_virtual_range, is_alt)
  write_opcode(117, "op_invoke_super_range", op_invoke_super_range, is_alt)
  write_opcode(118, "op_invoke_direct_range", op_invoke_direct_range, is_alt)
  write_opcode(119, "op_invoke_static_range", op_invoke_static_range, is_alt)
  write_opcode(120, "op_invoke_interface_range", op_invoke_interface_range, is_alt)
  write_opcode(121, "op_unused_79", op_unused_79, is_alt)
  write_opcode(122, "op_unused_7a", op_unused_7a, is_alt)
  write_opcode(123, "op_neg_int", op_neg_int, is_alt)
  write_opcode(124, "op_not_int", op_not_int, is_alt)
  write_opcode(125, "op_neg_long", op_neg_long, is_alt)
  write_opcode(126, "op_not_long", op_not_long, is_alt)
  write_opcode(127, "op_neg_float", op_neg_float, is_alt)
  write_opcode(128, "op_neg_double", op_neg_double, is_alt)
  write_opcode(129, "op_int_to_long", op_int_to_long, is_alt)
  write_opcode(130, "op_int_to_float", op_int_to_float, is_alt)
  write_opcode(131, "op_int_to_double", op_int_to_double, is_alt)
  write_opcode(132, "op_long_to_int", op_long_to_int, is_alt)
  write_opcode(133, "op_long_to_float", op_long_to_float, is_alt)
  write_opcode(134, "op_long_to_double", op_long_to_double, is_alt)
  write_opcode(135, "op_float_to_int", op_float_to_int, is_alt)
  write_opcode(136, "op_float_to_long", op_float_to_long, is_alt)
  write_opcode(137, "op_float_to_double", op_float_to_double, is_alt)
  write_opcode(138, "op_double_to_int", op_double_to_int, is_alt)
  write_opcode(139, "op_double_to_long", op_double_to_long, is_alt)
  write_opcode(140, "op_double_to_float", op_double_to_float, is_alt)
  write_opcode(141, "op_int_to_byte", op_int_to_byte, is_alt)
  write_opcode(142, "op_int_to_char", op_int_to_char, is_alt)
  write_opcode(143, "op_int_to_short", op_int_to_short, is_alt)
  write_opcode(144, "op_add_int", op_add_int, is_alt)
  write_opcode(145, "op_sub_int", op_sub_int, is_alt)
  write_opcode(146, "op_mul_int", op_mul_int, is_alt)
  write_opcode(147, "op_div_int", op_div_int, is_alt)
  write_opcode(148, "op_rem_int", op_rem_int, is_alt)
  write_opcode(149, "op_and_int", op_and_int, is_alt)
  write_opcode(150, "op_or_int", op_or_int, is_alt)
  write_opcode(151, "op_xor_int", op_xor_int, is_alt)
  write_opcode(152, "op_shl_int", op_shl_int, is_alt)
  write_opcode(153, "op_shr_int", op_shr_int, is_alt)
  write_opcode(154, "op_ushr_int", op_ushr_int, is_alt)
  write_opcode(155, "op_add_long", op_add_long, is_alt)
  write_opcode(156, "op_sub_long", op_sub_long, is_alt)
  write_opcode(157, "op_mul_long", op_mul_long, is_alt)
  write_opcode(158, "op_div_long", op_div_long, is_alt)
  write_opcode(159, "op_rem_long", op_rem_long, is_alt)
  write_opcode(160, "op_and_long", op_and_long, is_alt)
  write_opcode(161, "op_or_long", op_or_long, is_alt)
  write_opcode(162, "op_xor_long", op_xor_long, is_alt)
  write_opcode(163, "op_shl_long", op_shl_long, is_alt)
  write_opcode(164, "op_shr_long", op_shr_long, is_alt)
  write_opcode(165, "op_ushr_long", op_ushr_long, is_alt)
  write_opcode(166, "op_add_float", op_add_float, is_alt)
  write_opcode(167, "op_sub_float", op_sub_float, is_alt)
  write_opcode(168, "op_mul_float", op_mul_float, is_alt)
  write_opcode(169, "op_div_float", op_div_float, is_alt)
  write_opcode(170, "op_rem_float", op_rem_float, is_alt)
  write_opcode(171, "op_add_double", op_add_double, is_alt)
  write_opcode(172, "op_sub_double", op_sub_double, is_alt)
  write_opcode(173, "op_mul_double", op_mul_double, is_alt)
  write_opcode(174, "op_div_double", op_div_double, is_alt)
  write_opcode(175, "op_rem_double", op_rem_double, is_alt)
  write_opcode(176, "op_add_int_2addr", op_add_int_2addr, is_alt)
  write_opcode(177, "op_sub_int_2addr", op_sub_int_2addr, is_alt)
  write_opcode(178, "op_mul_int_2addr", op_mul_int_2addr, is_alt)
  write_opcode(179, "op_div_int_2addr", op_div_int_2addr, is_alt)
  write_opcode(180, "op_rem_int_2addr", op_rem_int_2addr, is_alt)
  write_opcode(181, "op_and_int_2addr", op_and_int_2addr, is_alt)
  write_opcode(182, "op_or_int_2addr", op_or_int_2addr, is_alt)
  write_opcode(183, "op_xor_int_2addr", op_xor_int_2addr, is_alt)
  write_opcode(184, "op_shl_int_2addr", op_shl_int_2addr, is_alt)
  write_opcode(185, "op_shr_int_2addr", op_shr_int_2addr, is_alt)
  write_opcode(186, "op_ushr_int_2addr", op_ushr_int_2addr, is_alt)
  write_opcode(187, "op_add_long_2addr", op_add_long_2addr, is_alt)
  write_opcode(188, "op_sub_long_2addr", op_sub_long_2addr, is_alt)
  write_opcode(189, "op_mul_long_2addr", op_mul_long_2addr, is_alt)
  write_opcode(190, "op_div_long_2addr", op_div_long_2addr, is_alt)
  write_opcode(191, "op_rem_long_2addr", op_rem_long_2addr, is_alt)
  write_opcode(192, "op_and_long_2addr", op_and_long_2addr, is_alt)
  write_opcode(193, "op_or_long_2addr", op_or_long_2addr, is_alt)
  write_opcode(194, "op_xor_long_2addr", op_xor_long_2addr, is_alt)
  write_opcode(195, "op_shl_long_2addr", op_shl_long_2addr, is_alt)
  write_opcode(196, "op_shr_long_2addr", op_shr_long_2addr, is_alt)
  write_opcode(197, "op_ushr_long_2addr", op_ushr_long_2addr, is_alt)
  write_opcode(198, "op_add_float_2addr", op_add_float_2addr, is_alt)
  write_opcode(199, "op_sub_float_2addr", op_sub_float_2addr, is_alt)
  write_opcode(200, "op_mul_float_2addr", op_mul_float_2addr, is_alt)
  write_opcode(201, "op_div_float_2addr", op_div_float_2addr, is_alt)
  write_opcode(202, "op_rem_float_2addr", op_rem_float_2addr, is_alt)
  write_opcode(203, "op_add_double_2addr", op_add_double_2addr, is_alt)
  write_opcode(204, "op_sub_double_2addr", op_sub_double_2addr, is_alt)
  write_opcode(205, "op_mul_double_2addr", op_mul_double_2addr, is_alt)
  write_opcode(206, "op_div_double_2addr", op_div_double_2addr, is_alt)
  write_opcode(207, "op_rem_double_2addr", op_rem_double_2addr, is_alt)
  write_opcode(208, "op_add_int_lit16", op_add_int_lit16, is_alt)
  write_opcode(209, "op_rsub_int", op_rsub_int, is_alt)
  write_opcode(210, "op_mul_int_lit16", op_mul_int_lit16, is_alt)
  write_opcode(211, "op_div_int_lit16", op_div_int_lit16, is_alt)
  write_opcode(212, "op_rem_int_lit16", op_rem_int_lit16, is_alt)
  write_opcode(213, "op_and_int_lit16", op_and_int_lit16, is_alt)
  write_opcode(214, "op_or_int_lit16", op_or_int_lit16, is_alt)
  write_opcode(215, "op_xor_int_lit16", op_xor_int_lit16, is_alt)
  write_opcode(216, "op_add_int_lit8", op_add_int_lit8, is_alt)
  write_opcode(217, "op_rsub_int_lit8", op_rsub_int_lit8, is_alt)
  write_opcode(218, "op_mul_int_lit8", op_mul_int_lit8, is_alt)
  write_opcode(219, "op_div_int_lit8", op_div_int_lit8, is_alt)
  write_opcode(220, "op_rem_int_lit8", op_rem_int_lit8, is_alt)
  write_opcode(221, "op_and_int_lit8", op_and_int_lit8, is_alt)
  write_opcode(222, "op_or_int_lit8", op_or_int_lit8, is_alt)
  write_opcode(223, "op_xor_int_lit8", op_xor_int_lit8, is_alt)
  write_opcode(224, "op_shl_int_lit8", op_shl_int_lit8, is_alt)
  write_opcode(225, "op_shr_int_lit8", op_shr_int_lit8, is_alt)
  write_opcode(226, "op_ushr_int_lit8", op_ushr_int_lit8, is_alt)
  write_opcode(227, "op_iget_quick", op_iget_quick, is_alt)
  write_opcode(228, "op_iget_wide_quick", op_iget_wide_quick, is_alt)
  write_opcode(229, "op_iget_object_quick", op_iget_object_quick, is_alt)
  write_opcode(230, "op_iput_quick", op_iput_quick, is_alt)
  write_opcode(231, "op_iput_wide_quick", op_iput_wide_quick, is_alt)
  write_opcode(232, "op_iput_object_quick", op_iput_object_quick, is_alt)
  write_opcode(233, "op_invoke_virtual_quick", op_invoke_virtual_quick, is_alt)
  write_opcode(234, "op_invoke_virtual_range_quick", op_invoke_virtual_range_quick, is_alt)
  write_opcode(235, "op_iput_boolean_quick", op_iput_boolean_quick, is_alt)
  write_opcode(236, "op_iput_byte_quick", op_iput_byte_quick, is_alt)
  write_opcode(237, "op_iput_char_quick", op_iput_char_quick, is_alt)
  write_opcode(238, "op_iput_short_quick", op_iput_short_quick, is_alt)
  write_opcode(239, "op_iget_boolean_quick", op_iget_boolean_quick, is_alt)
  write_opcode(240, "op_iget_byte_quick", op_iget_byte_quick, is_alt)
  write_opcode(241, "op_iget_char_quick", op_iget_char_quick, is_alt)
  write_opcode(242, "op_iget_short_quick", op_iget_short_quick, is_alt)
  write_opcode(243, "op_unused_f3", op_unused_f3, is_alt)
  write_opcode(244, "op_unused_f4", op_unused_f4, is_alt)
  write_opcode(245, "op_unused_f5", op_unused_f5, is_alt)
  write_opcode(246, "op_unused_f6", op_unused_f6, is_alt)
  write_opcode(247, "op_unused_f7", op_unused_f7, is_alt)
  write_opcode(248, "op_unused_f8", op_unused_f8, is_alt)
  write_opcode(249, "op_unused_f9", op_unused_f9, is_alt)
  write_opcode(250, "op_invoke_polymorphic", op_invoke_polymorphic, is_alt)
  write_opcode(251, "op_invoke_polymorphic_range", op_invoke_polymorphic_range, is_alt)
  write_opcode(252, "op_invoke_custom", op_invoke_custom, is_alt)
  write_opcode(253, "op_invoke_custom_range", op_invoke_custom_range, is_alt)
  write_opcode(254, "op_const_method_handle", op_const_method_handle, is_alt)
  write_opcode(255, "op_const_method_type", op_const_method_type, is_alt)
def write_sister():
  global opnum, opcode
  opcode = "op_float_to_long"
  op_float_to_long_sister_code()
  opcode = "op_double_to_long"
  op_double_to_long_sister_code()
  opcode = "op_mul_long"
  op_mul_long_sister_code()
  opcode = "op_shl_long"
  op_shl_long_sister_code()
  opcode = "op_shr_long"
  op_shr_long_sister_code()
  opcode = "op_ushr_long"
  op_ushr_long_sister_code()
  opcode = "op_shl_long_2addr"
  op_shl_long_2addr_sister_code()
  opcode = "op_shr_long_2addr"
  op_shr_long_2addr_sister_code()
  opcode = "op_ushr_long_2addr"
  op_ushr_long_2addr_sister_code()
  pass
def alt_stub():
  write_line('''/*''')
  write_line(''' * Inter-instruction transfer stub.  Call out to MterpCheckBefore to handle''')
  write_line(''' * any interesting requests and then jump to the real instruction''')
  write_line(''' * handler.    Note that the call to MterpCheckBefore is done as a tail call.''')
  write_line(''' */''')
  write_line('''    .extern MterpCheckBefore''')
  write_line('''    la     ra, artMterpAsmInstructionStart + (''' + opnum + ''' * 128)   # Addr of primary handler''')
  write_line('''    lw     rIBASE, THREAD_CURRENT_IBASE_OFFSET(rSELF)           # refresh IBASE''')
  write_line('''    move   a0, rSELF                    # arg0''')
  write_line('''    addu   a1, rFP, OFF_FP_SHADOWFRAME  # arg1''')
  write_line('''    move   a2, rPC''')
  write_line('''    la     t9, MterpCheckBefore''')
  write_line('''    jalr   zero, t9                     # Tail call to Mterp(self, shadow_frame, dex_pc_ptr)''')

def bincmp(condition=""):
  write_line('''    /*''')
  write_line('''     * Generic two-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform.''')
  write_line('''     *''')
  write_line('''     * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le''')
  write_line('''     */''')
  write_line('''    /* if-cmp vA, vB, +CCCC */''')
  write_line('''    GET_OPA4(a0)                           #  a0 <- A+''')
  write_line('''    GET_OPB(a1)                            #  a1 <- B''')
  write_line('''    GET_VREG(a3, a1)                       #  a3 <- vB''')
  write_line('''    GET_VREG(a0, a0)                       #  a0 <- vA''')
  write_line('''    FETCH_S(rINST, 1)                      #  rINST<- branch offset, in code units''')
  write_line('''    b''' + condition + ''' a0, a3, MterpCommonTakenBranchNoFlags  #  compare (vA, vB)''')
  write_line('''    li        t0, JIT_CHECK_OSR''')
  write_line('''    beq       rPROFILE, t0, .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        #  jump to next instruction''')

def binop(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be a MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (a1).  Useful for integer division and modulus.  Note that we''')
  write_line('''     * *don't* check for (INT_MIN / -1) here, because the CPU handles it''')
  write_line('''     * correctly.''')
  write_line('''     *''')
  write_line('''     * For: add-int, sub-int, mul-int, div-int, rem-int, and-int, or-int,''')
  write_line('''     *      xor-int, shl-int, shr-int, ushr-int''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    srl       a3, a0, 8                    #  a3 <- CC''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vCC''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vBB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    # is second operand zero?''')
  write_line('''    beqz      a1, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(''' + result + ''', rOBJ, t0)       #  vAA <- ''' + result + '''''')

def binop2addr(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be an MIPS instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (a1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,''')
  write_line('''     *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,''')
  write_line('''     *      shl-int/2addr, shr-int/2addr, ushr-int/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG(a0, rOBJ)                     #  a0 <- vA''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    # is second operand zero?''')
  write_line('''    beqz      a1, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(''' + result + ''', rOBJ, t0)       #  vA <- ''' + result + '''''')

def binopLit16(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit16" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be an MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (a1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit16, rsub-int, mul-int/lit16, div-int/lit16,''')
  write_line('''     *      rem-int/lit16, and-int/lit16, or-int/lit16, xor-int/lit16''')
  write_line('''     */''')
  write_line('''    /* binop/lit16 vA, vB, +CCCC */''')
  write_line('''    FETCH_S(a1, 1)                         #  a1 <- ssssCCCC (sign-extended)''')
  write_line('''    GET_OPB(a2)                            #  a2 <- B''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    # cmp a1, 0; is second operand zero?''')
  write_line('''    beqz      a1, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(''' + result + ''', rOBJ, t0)       #  vA <- ''' + result + '''''')

def binopLit8(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit8" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be an MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (a1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit8, rsub-int/lit8, mul-int/lit8, div-int/lit8,''')
  write_line('''     *      rem-int/lit8, and-int/lit8, or-int/lit8, xor-int/lit8,''')
  write_line('''     *      shl-int/lit8, shr-int/lit8, ushr-int/lit8''')
  write_line('''     */''')
  write_line('''    /* binop/lit8 vAA, vBB, +CC */''')
  write_line('''    FETCH_S(a3, 1)                         #  a3 <- ssssCCBB (sign-extended for CC)''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    and       a2, a3, 255                  #  a2 <- BB''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vBB''')
  write_line('''    sra       a1, a3, 8                    #  a1 <- ssssssCC (sign extended)''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    # is second operand zero?''')
  write_line('''    beqz      a1, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(''' + result + ''', rOBJ, t0)       #  vAA <- ''' + result + '''''')

def binopWide(preinstr="", result0="a0", result1="a1", chkzero="0", arg0="a0", arg1="a1", arg2="a2", arg3="a3", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = a0-a1 op a2-a3".''')
  write_line('''     * This could be a MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register pair other than a0-a1, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (a2-a3).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * for: add-long, sub-long, div-long, rem-long, and-long, or-long,''')
  write_line('''     *      xor-long''')
  write_line('''     *''')
  write_line('''     * IMPORTANT: you may specify "chkzero" or "preinstr" but not both.''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    srl       a3, a0, 8                    #  a3 <- CC''')
  write_line('''    EAS2(a2, rFP, a2)                      #  a2 <- &fp[BB]''')
  write_line('''    EAS2(t1, rFP, a3)                      #  a3 <- &fp[CC]''')
  write_line('''    LOAD64(''' + arg0 + ''', ''' + arg1 + ''', a2)               #  a0/a1 <- vBB/vBB+1''')
  write_line('''    LOAD64(''' + arg2 + ''', ''' + arg3 + ''', t1)               #  a2/a3 <- vCC/vCC+1''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    or        t0, ''' + arg2 + ''', ''' + arg3 + '''             #  second arg (a2-a3) is zero?''')
  write_line('''    beqz      t0, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  result <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(''' + result0 + ''', ''' + result1 + ''', rOBJ, t0)   #  vAA/vAA+1 <- ''' + result0 + '''/''' + result1 + '''''')

def binopWide2addr(preinstr="", result0="a0", result1="a1", chkzero="0", arg0="a0", arg1="a1", arg2="a2", arg3="a3", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0-a1 op a2-a3".''')
  write_line('''     * This could be a MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register pair other than a0-a1, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vB (a2-a3).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-long/2addr, sub-long/2addr, div-long/2addr, rem-long/2addr,''')
  write_line('''     *      and-long/2addr, or-long/2addr, xor-long/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a1)                            #  a1 <- B''')
  write_line('''    EAS2(a1, rFP, a1)                      #  a1 <- &fp[B]''')
  write_line('''    EAS2(t0, rFP, rOBJ)                    #  t0 <- &fp[A]''')
  write_line('''    LOAD64(''' + arg2 + ''', ''' + arg3 + ''', a1)               #  a2/a3 <- vB/vB+1''')
  write_line('''    LOAD64(''' + arg0 + ''', ''' + arg1 + ''', t0)               #  a0/a1 <- vA/vA+1''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    or        t0, ''' + arg2 + ''', ''' + arg3 + '''             #  second arg (a2-a3) is zero?''')
  write_line('''    beqz      t0, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  result <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(''' + result0 + ''', ''' + result1 + ''', rOBJ, t0)   #  vA/vA+1 <- ''' + result0 + '''/''' + result1 + '''''')

def const(helper="UndefinedConstHandler"):
  write_line('''    /* const/class vAA, type@BBBB */''')
  write_line('''    /* const/method-handle vAA, method_handle@BBBB */''')
  write_line('''    /* const/method-type vAA, proto@BBBB */''')
  write_line('''    /* const/string vAA, string@@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC()''')
  write_line('''    FETCH(a0, 1)                        # a0 <- BBBB''')
  write_line('''    GET_OPA(a1)                         # a1 <- AA''')
  write_line('''    addu   a2, rFP, OFF_FP_SHADOWFRAME  # a2 <- shadow frame''')
  write_line('''    move   a3, rSELF''')
  write_line('''    JAL(''' + helper + ''')                        # v0 <- Mterp(index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST(2)                    # load rINST''')
  write_line('''    bnez   v0, MterpPossibleException''')
  write_line('''    ADVANCE(2)                          # advance rPC''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')

def entry():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''/*''')
  write_line(''' * Interpreter entry point.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    .align 2''')
  write_line('''    .global ExecuteMterpImpl''')
  write_line('''    .ent    ExecuteMterpImpl''')
  write_line('''    .frame sp, STACK_SIZE, ra''')
  write_line('''/*''')
  write_line(''' * On entry:''')
  write_line(''' *  a0  Thread* self''')
  write_line(''' *  a1  dex_instructions''')
  write_line(''' *  a2  ShadowFrame''')
  write_line(''' *  a3  JValue* result_register''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''''')
  write_line('''ExecuteMterpImpl:''')
  write_line('''    .cfi_startproc''')
  write_line('''    .set noreorder''')
  write_line('''    .cpload t9''')
  write_line('''    .set reorder''')
  write_line('''/* Save to the stack. Frame size = STACK_SIZE */''')
  write_line('''    STACK_STORE_FULL()''')
  write_line('''/* This directive will make sure all subsequent jal restore gp at a known offset */''')
  write_line('''    .cprestore STACK_OFFSET_GP''')
  write_line('''''')
  write_line('''    /* Remember the return register */''')
  write_line('''    sw      a3, SHADOWFRAME_RESULT_REGISTER_OFFSET(a2)''')
  write_line('''''')
  write_line('''    /* Remember the dex instruction pointer */''')
  write_line('''    sw      a1, SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET(a2)''')
  write_line('''''')
  write_line('''    /* set up "named" registers */''')
  write_line('''    move    rSELF, a0''')
  write_line('''    lw      a0, SHADOWFRAME_NUMBER_OF_VREGS_OFFSET(a2)''')
  write_line('''    addu    rFP, a2, SHADOWFRAME_VREGS_OFFSET     # point to vregs.''')
  write_line('''    EAS2(rREFS, rFP, a0)                          # point to reference array in shadow frame''')
  write_line('''    lw      a0, SHADOWFRAME_DEX_PC_OFFSET(a2)     # Get starting dex_pc''')
  write_line('''    EAS1(rPC, a1, a0)                             # Create direct pointer to 1st dex opcode''')
  write_line('''    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)''')
  write_line('''''')
  write_line('''    EXPORT_PC()''')
  write_line('''''')
  write_line('''    /* Starting ibase */''')
  write_line('''    lw      rIBASE, THREAD_CURRENT_IBASE_OFFSET(rSELF)''')
  write_line('''''')
  write_line('''    /* Set up for backwards branches & osr profiling */''')
  write_line('''    lw      a0, OFF_FP_METHOD(rFP)''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rSELF''')
  write_line('''    JAL(MterpSetUpHotnessCountdown)        # (method, shadow_frame, self)''')
  write_line('''    move    rPROFILE, v0                   # Starting hotness countdown to rPROFILE''')
  write_line('''''')
  write_line('''    /* start executing the instruction at rPC */''')
  write_line('''    FETCH_INST()                           # load rINST from rPC''')
  write_line('''    GET_INST_OPCODE(t0)                    # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        # jump to next instruction''')
  write_line('''    /* NOTE: no fallthrough */''')

def fallback():
  write_line('''/* Transfer stub to alternate interpreter */''')
  write_line('''    b    MterpFallback''')

def fbinop(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit binary float operation.''')
  write_line('''     *''')
  write_line('''     * For: add-fp, sub-fp, mul-fp, div-fp, rem-fp''')
  write_line('''     */''')
  write_line('''''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    srl       a3, a0, 8                    #  a3 <- CC''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    GET_VREG_F(fa1, a3)                    #  a1 <- vCC''')
  write_line('''    GET_VREG_F(fa0, a2)                    #  a0 <- vBB''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                                 #  f0 = result''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_F_GOTO(fv0, rOBJ, t0)         #  vAA <- fv0''')

def fbinop2addr(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "/2addr" binary operation.  Provide an "instr"''')
  write_line('''     * that specifies an instruction that performs "fv0 = fa0 op fa1".''')
  write_line('''     * This could be an MIPS instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * For: add-float/2addr, sub-float/2addr, mul-float/2addr,''')
  write_line('''     *      div-float/2addr, rem-float/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG_F(fa0, rOBJ)''')
  write_line('''    GET_VREG_F(fa1, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + instr + '''''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_F_GOTO(fv0, rOBJ, t0)         #  vA <- result''')

def fbinopWide(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit floating-point binary operation.  Provide an "instr"''')
  write_line('''     * line that specifies an instruction that performs "fv0 = fa0 op fa1".''')
  write_line('''     * This could be an MIPS instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * for: add-double, sub-double, mul-double, div-double,''')
  write_line('''     *      rem-double''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    srl       a3, a0, 8                    #  a3 <- CC''')
  write_line('''    EAS2(a2, rFP, a2)                      #  a2 <- &fp[BB]''')
  write_line('''    EAS2(t1, rFP, a3)                      #  a3 <- &fp[CC]''')
  write_line('''    LOAD64_F(fa0, fa0f, a2)''')
  write_line('''    LOAD64_F(fa1, fa1f, t1)''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    ''' + instr + '''''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_F_GOTO(fv0, fv0f, rOBJ, t0)  #  vAA/vAA+1 <- fv0''')

def fbinopWide2addr(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit floating-point "/2addr" binary operation.''')
  write_line('''     * Provide an "instr" line that specifies an instruction that''')
  write_line('''     * performs "fv0 = fa0 op fa1".''')
  write_line('''     * This could be an MIPS instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * For: add-double/2addr, sub-double/2addr, mul-double/2addr,''')
  write_line('''     *      div-double/2addr, rem-double/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a1)                            #  a1 <- B''')
  write_line('''    EAS2(a1, rFP, a1)                      #  a1 <- &fp[B]''')
  write_line('''    EAS2(t0, rFP, rOBJ)                    #  t0 <- &fp[A]''')
  write_line('''    LOAD64_F(fa0, fa0f, t0)''')
  write_line('''    LOAD64_F(fa1, fa1f, a1)''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    ''' + instr + '''''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_F_GOTO(fv0, fv0f, rOBJ, t0)  #  vA/vA+1 <- fv0''')

def field(helper=""):
  write_line('''TODO''')

def footer():
  write_line('''/*''')
  write_line(''' * ===========================================================================''')
  write_line(''' *  Common subroutines and data''')
  write_line(''' * ===========================================================================''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    .align 2''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We've detected a condition that will result in an exception, but the exception''')
  write_line(''' * has not yet been thrown.  Just bail out to the reference interpreter to deal with it.''')
  write_line(''' * TUNING: for consistency, we may want to just go ahead and handle these here.''')
  write_line(''' */''')
  write_line('''common_errDivideByZero:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpLogDivideByZeroException)''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errArrayIndex:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpLogArrayIndexException)''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNegativeArraySize:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpLogNegativeArraySizeException)''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNoSuchMethod:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpLogNoSuchMethodException)''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNullObject:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpLogNullObjectException)''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_exceptionThrown:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpLogExceptionThrownException)''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''MterpSuspendFallback:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    lw    a2, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    JAL(MterpLogSuspendFallback)''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * If we're here, something is out of the ordinary.  If there is a pending''')
  write_line(''' * exception, handle it.  Otherwise, roll back and retry with the reference''')
  write_line(''' * interpreter.''')
  write_line(''' */''')
  write_line('''MterpPossibleException:''')
  write_line('''    lw      a0, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    beqz    a0, MterpFallback          # If exception, fall back to reference interpreter.''')
  write_line('''    /* intentional fallthrough - handle pending exception. */''')
  write_line('''/*''')
  write_line(''' * On return from a runtime helper routine, we've found a pending exception.''')
  write_line(''' * Can we handle it here - or need to bail out to caller?''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpException:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpHandleException)                    # (self, shadow_frame)''')
  write_line('''    beqz    v0, MterpExceptionReturn             # no local catch, back to caller.''')
  write_line('''    lw      a0, OFF_FP_DEX_INSTRUCTIONS(rFP)''')
  write_line('''    lw      a1, OFF_FP_DEX_PC(rFP)''')
  write_line('''    lw      rIBASE, THREAD_CURRENT_IBASE_OFFSET(rSELF)''')
  write_line('''    EAS1(rPC, a0, a1)                            # generate new dex_pc_ptr''')
  write_line('''    /* Do we need to switch interpreters? */''')
  write_line('''    JAL(MterpShouldSwitchInterpreters)''')
  write_line('''    bnez    v0, MterpFallback''')
  write_line('''    /* resume execution at catch block */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    FETCH_INST()''')
  write_line('''    GET_INST_OPCODE(t0)''')
  write_line('''    GOTO_OPCODE(t0)''')
  write_line('''    /* NOTE: no fallthrough */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Common handling for branches with support for Jit profiling.''')
  write_line(''' * On entry:''')
  write_line(''' *    rINST          <= signed offset''')
  write_line(''' *    rPROFILE       <= signed hotness countdown (expanded to 32 bits)''')
  write_line(''' *''')
  write_line(''' * We have quite a few different cases for branch profiling, OSR detection and''')
  write_line(''' * suspend check support here.''')
  write_line(''' *''')
  write_line(''' * Taken backward branches:''')
  write_line(''' *    If profiling active, do hotness countdown and report if we hit zero.''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *    Is there a pending suspend request?  If so, suspend.''')
  write_line(''' *''')
  write_line(''' * Taken forward branches and not-taken backward branches:''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *''')
  write_line(''' * Our most common case is expected to be a taken backward branch with active jit profiling,''')
  write_line(''' * but no full OSR check and no pending suspend request.''')
  write_line(''' * Next most common case is not-taken branch with no full OSR check.''')
  write_line(''' */''')
  write_line('''MterpCommonTakenBranchNoFlags:''')
  write_line('''    bgtz    rINST, .L_forward_branch    # don't add forward branches to hotness''')
  write_line('''/*''')
  write_line(''' * We need to subtract 1 from positive values and we should not see 0 here,''')
  write_line(''' * so we may use the result of the comparison with -1.''')
  write_line(''' */''')
  write_line('''#if JIT_CHECK_OSR != -1''')
  write_line('''#  error "JIT_CHECK_OSR must be -1."''')
  write_line('''#endif''')
  write_line('''    li      t0, JIT_CHECK_OSR''')
  write_line('''    beq     rPROFILE, t0, .L_osr_check''')
  write_line('''    blt     rPROFILE, t0, .L_resume_backward_branch''')
  write_line('''    subu    rPROFILE, 1''')
  write_line('''    beqz    rPROFILE, .L_add_batch      # counted down to zero - report''')
  write_line('''.L_resume_backward_branch:''')
  write_line('''    lw      ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    REFRESH_IBASE()''')
  write_line('''    addu    a2, rINST, rINST            # a2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB(a2)           # update rPC, load rINST''')
  write_line('''    and     ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    bnez    ra, .L_suspend_request_pending''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')
  write_line('''''')
  write_line('''.L_suspend_request_pending:''')
  write_line('''    EXPORT_PC()''')
  write_line('''    move    a0, rSELF''')
  write_line('''    JAL(MterpSuspendCheck)              # (self)''')
  write_line('''    bnez    v0, MterpFallback''')
  write_line('''    REFRESH_IBASE()                     # might have changed during suspend''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')
  write_line('''''')
  write_line('''.L_no_count_backwards:''')
  write_line('''    li      t0, JIT_CHECK_OSR           # check for possible OSR re-entry''')
  write_line('''    bne     rPROFILE, t0, .L_resume_backward_branch''')
  write_line('''.L_osr_check:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rINST''')
  write_line('''    EXPORT_PC()''')
  write_line('''    JAL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    bnez    v0, MterpOnStackReplacement''')
  write_line('''    b       .L_resume_backward_branch''')
  write_line('''''')
  write_line('''.L_forward_branch:''')
  write_line('''    li      t0, JIT_CHECK_OSR           # check for possible OSR re-entry''')
  write_line('''    beq     rPROFILE, t0, .L_check_osr_forward''')
  write_line('''.L_resume_forward_branch:''')
  write_line('''    add     a2, rINST, rINST            # a2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB(a2)           # update rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')
  write_line('''''')
  write_line('''.L_check_osr_forward:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rINST''')
  write_line('''    EXPORT_PC()''')
  write_line('''    JAL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    bnez    v0, MterpOnStackReplacement''')
  write_line('''    b       .L_resume_forward_branch''')
  write_line('''''')
  write_line('''.L_add_batch:''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    sh      rPROFILE, SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET(a1)''')
  write_line('''    lw      a0, OFF_FP_METHOD(rFP)''')
  write_line('''    move    a2, rSELF''')
  write_line('''    JAL(MterpAddHotnessBatch)           # (method, shadow_frame, self)''')
  write_line('''    move    rPROFILE, v0                # restore new hotness countdown to rPROFILE''')
  write_line('''    b       .L_no_count_backwards''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Entered from the conditional branch handlers when OSR check request active on''')
  write_line(''' * not-taken path.  All Dalvik not-taken conditional branch offsets are 2.''')
  write_line(''' */''')
  write_line('''.L_check_not_taken_osr:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    li      a2, 2''')
  write_line('''    EXPORT_PC()''')
  write_line('''    JAL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    bnez    v0, MterpOnStackReplacement''')
  write_line('''    FETCH_ADVANCE_INST(2)''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On-stack replacement has happened, and now we've returned from the compiled method.''')
  write_line(''' */''')
  write_line('''MterpOnStackReplacement:''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move    a0, rSELF''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rINST''')
  write_line('''    JAL(MterpLogOSR)''')
  write_line('''#endif''')
  write_line('''    li      v0, 1                       # Signal normal return''')
  write_line('''    b       MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Bail out to reference interpreter.''')
  write_line(''' */''')
  write_line('''MterpFallback:''')
  write_line('''    EXPORT_PC()''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move  a0, rSELF''')
  write_line('''    addu  a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    JAL(MterpLogFallback)''')
  write_line('''#endif''')
  write_line('''MterpCommonFallback:''')
  write_line('''    move    v0, zero                    # signal retry with reference interpreter.''')
  write_line('''    b       MterpDone''')
  write_line('''/*''')
  write_line(''' * We pushed some registers on the stack in ExecuteMterpImpl, then saved''')
  write_line(''' * SP and LR.  Here we restore SP, restore the registers, and then restore''')
  write_line(''' * LR to PC.''')
  write_line(''' *''')
  write_line(''' * On entry:''')
  write_line(''' *  uint32_t* rFP  (should still be live, pointer to base of vregs)''')
  write_line(''' */''')
  write_line('''MterpExceptionReturn:''')
  write_line('''    li      v0, 1                       # signal return to caller.''')
  write_line('''    b       MterpDone''')
  write_line('''MterpReturn:''')
  write_line('''    lw      a2, OFF_FP_RESULT_REGISTER(rFP)''')
  write_line('''    sw      v0, 0(a2)''')
  write_line('''    sw      v1, 4(a2)''')
  write_line('''    li      v0, 1                       # signal return to caller.''')
  write_line('''MterpDone:''')
  write_line('''/*''')
  write_line(''' * At this point, we expect rPROFILE to be non-zero.  If negative, hotness is disabled or we're''')
  write_line(''' * checking for OSR.  If greater than zero, we might have unreported hotness to register''')
  write_line(''' * (the difference between the ending rPROFILE and the cached hotness counter).  rPROFILE''')
  write_line(''' * should only reach zero immediately after a hotness decrement, and is then reset to either''')
  write_line(''' * a negative special state or the new non-zero countdown value.''')
  write_line(''' */''')
  write_line('''    blez    rPROFILE, .L_pop_and_return # if > 0, we may have some counts to report.''')
  write_line('''''')
  write_line('''MterpProfileActive:''')
  write_line('''    move    rINST, v0                   # stash return value''')
  write_line('''    /* Report cached hotness counts */''')
  write_line('''    lw      a0, OFF_FP_METHOD(rFP)''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rSELF''')
  write_line('''    sh      rPROFILE, SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET(a1)''')
  write_line('''    JAL(MterpAddHotnessBatch)           # (method, shadow_frame, self)''')
  write_line('''    move    v0, rINST                   # restore return value''')
  write_line('''''')
  write_line('''.L_pop_and_return:''')
  write_line('''/* Restore from the stack and return. Frame size = STACK_SIZE */''')
  write_line('''    STACK_LOAD_FULL()''')
  write_line('''    jalr    zero, ra''')
  write_line('''''')
  write_line('''    .cfi_endproc''')
  write_line('''    .end ExecuteMterpImpl''')

def funop(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit floating-point unary operation.  Provide an "instr"''')
  write_line('''     * line that specifies an instruction that performs "fv0 = op fa0".''')
  write_line('''     * This could be a MIPS instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * for: int-to-float''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_VREG_F(fa0, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    ''' + instr + '''''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_F_GOTO(fv0, rOBJ, t1)         #  vA <- fv0''')

def funopWider(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32bit-to-64bit floating-point unary operation.  Provide an "instr"''')
  write_line('''     * line that specifies an instruction that performs "fv0 = op fa0".''')
  write_line('''     *''')
  write_line('''     * For: int-to-double, float-to-double''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG_F(fa0, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    ''' + instr + '''''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_F_GOTO(fv0, fv0f, rOBJ, t0) #  vA/vA+1 <- fv0''')

def header():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''  Art assembly interpreter notes:''')
  write_line('''''')
  write_line('''  First validate assembly code by implementing ExecuteXXXImpl() style body (doesn't''')
  write_line('''  handle invoke, allows higher-level code to create frame & shadow frame.''')
  write_line('''''')
  write_line('''  Once that's working, support direct entry code & eliminate shadow frame (and''')
  write_line('''  excess locals allocation.''')
  write_line('''''')
  write_line('''  Some (hopefully) temporary ugliness.  We'll treat rFP as pointing to the''')
  write_line('''  base of the vreg array within the shadow frame.  Access the other fields,''')
  write_line('''  dex_pc_, method_ and number_of_vregs_ via negative offsets.  For now, we'll continue''')
  write_line('''  the shadow frame mechanism of double-storing object references - via rFP &''')
  write_line('''  number_of_vregs_.''')
  write_line('''''')
  write_line(''' */''')
  write_line('''''')
  write_line('''#include "asm_support.h"''')
  write_line('''#include "interpreter/cfi_asm_support.h"''')
  write_line('''''')
  write_line('''#if (__mips==32) && (__mips_isa_rev>=2)''')
  write_line('''#define MIPS32REVGE2    /* mips32r2 and greater */''')
  write_line('''#if (__mips==32) && (__mips_isa_rev>=5)''')
  write_line('''#define FPU64           /* 64 bit FPU */''')
  write_line('''#if (__mips==32) && (__mips_isa_rev>=6)''')
  write_line('''#define MIPS32REVGE6    /* mips32r6 and greater */''')
  write_line('''#endif''')
  write_line('''#endif''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''/* MIPS definitions and declarations''')
  write_line('''''')
  write_line('''   reg  nick      purpose''')
  write_line('''   s0   rPC       interpreted program counter, used for fetching instructions''')
  write_line('''   s1   rFP       interpreted frame pointer, used for accessing locals and args''')
  write_line('''   s2   rSELF     self (Thread) pointer''')
  write_line('''   s3   rIBASE    interpreted instruction base pointer, used for computed goto''')
  write_line('''   s4   rINST     first 16-bit code unit of current instruction''')
  write_line('''   s5   rOBJ      object pointer''')
  write_line('''   s6   rREFS     base of object references in shadow frame (ideally, we'll get rid of this later).''')
  write_line('''   s7   rTEMP     used as temp storage that can survive a function call''')
  write_line('''   s8   rPROFILE  branch profiling countdown''')
  write_line('''''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/* single-purpose registers, given names for clarity */''')
  write_line('''#define rPC s0''')
  write_line('''#define CFI_DEX 16  // DWARF register number of the register holding dex-pc (s0).''')
  write_line('''#define CFI_TMP 4   // DWARF register number of the first argument register (a0).''')
  write_line('''#define rFP s1''')
  write_line('''#define rSELF s2''')
  write_line('''#define rIBASE s3''')
  write_line('''#define rINST s4''')
  write_line('''#define rOBJ s5''')
  write_line('''#define rREFS s6''')
  write_line('''#define rTEMP s7''')
  write_line('''#define rPROFILE s8''')
  write_line('''''')
  write_line('''#define rARG0 a0''')
  write_line('''#define rARG1 a1''')
  write_line('''#define rARG2 a2''')
  write_line('''#define rARG3 a3''')
  write_line('''#define rRESULT0 v0''')
  write_line('''#define rRESULT1 v1''')
  write_line('''''')
  write_line('''/* GP register definitions */''')
  write_line('''#define zero    $0      /* always zero */''')
  write_line('''#define AT      $at     /* assembler temp */''')
  write_line('''#define v0      $2      /* return value */''')
  write_line('''#define v1      $3''')
  write_line('''#define a0      $4      /* argument registers */''')
  write_line('''#define a1      $5''')
  write_line('''#define a2      $6''')
  write_line('''#define a3      $7''')
  write_line('''#define t0      $8      /* temp registers (not saved across subroutine calls) */''')
  write_line('''#define t1      $9''')
  write_line('''#define t2      $10''')
  write_line('''#define t3      $11''')
  write_line('''#define t4      $12''')
  write_line('''#define t5      $13''')
  write_line('''#define t6      $14''')
  write_line('''#define t7      $15''')
  write_line('''#define ta0     $12     /* alias */''')
  write_line('''#define ta1     $13''')
  write_line('''#define ta2     $14''')
  write_line('''#define ta3     $15''')
  write_line('''#define s0      $16     /* saved across subroutine calls (callee saved) */''')
  write_line('''#define s1      $17''')
  write_line('''#define s2      $18''')
  write_line('''#define s3      $19''')
  write_line('''#define s4      $20''')
  write_line('''#define s5      $21''')
  write_line('''#define s6      $22''')
  write_line('''#define s7      $23''')
  write_line('''#define t8      $24     /* two more temp registers */''')
  write_line('''#define t9      $25''')
  write_line('''#define k0      $26     /* kernel temporary */''')
  write_line('''#define k1      $27''')
  write_line('''#define gp      $28     /* global pointer */''')
  write_line('''#define sp      $29     /* stack pointer */''')
  write_line('''#define s8      $30     /* one more callee saved */''')
  write_line('''#define ra      $31     /* return address */''')
  write_line('''''')
  write_line('''/* FP register definitions */''')
  write_line('''#define fv0    $f0''')
  write_line('''#define fv0f   $f1''')
  write_line('''#define fv1    $f2''')
  write_line('''#define fv1f   $f3''')
  write_line('''#define fa0    $f12''')
  write_line('''#define fa0f   $f13''')
  write_line('''#define fa1    $f14''')
  write_line('''#define fa1f   $f15''')
  write_line('''#define ft0    $f4''')
  write_line('''#define ft0f   $f5''')
  write_line('''#define ft1    $f6''')
  write_line('''#define ft1f   $f7''')
  write_line('''#define ft2    $f8''')
  write_line('''#define ft2f   $f9''')
  write_line('''#define ft3    $f10''')
  write_line('''#define ft3f   $f11''')
  write_line('''#define ft4    $f16''')
  write_line('''#define ft4f   $f17''')
  write_line('''#define ft5    $f18''')
  write_line('''#define ft5f   $f19''')
  write_line('''#define fs0    $f20''')
  write_line('''#define fs0f   $f21''')
  write_line('''#define fs1    $f22''')
  write_line('''#define fs1f   $f23''')
  write_line('''#define fs2    $f24''')
  write_line('''#define fs2f   $f25''')
  write_line('''#define fs3    $f26''')
  write_line('''#define fs3f   $f27''')
  write_line('''#define fs4    $f28''')
  write_line('''#define fs4f   $f29''')
  write_line('''#define fs5    $f30''')
  write_line('''#define fs5f   $f31''')
  write_line('''''')
  write_line('''#ifndef MIPS32REVGE6''')
  write_line('''#define fcc0   $fcc0''')
  write_line('''#define fcc1   $fcc1''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE2''')
  write_line('''#define SEB(rd, rt) \\''')
  write_line('''    seb       rd, rt''')
  write_line('''#define SEH(rd, rt) \\''')
  write_line('''    seh       rd, rt''')
  write_line('''#define INSERT_HIGH_HALF(rd_lo, rt_hi) \\''')
  write_line('''    ins       rd_lo, rt_hi, 16, 16''')
  write_line('''#else''')
  write_line('''#define SEB(rd, rt) \\''')
  write_line('''    sll       rd, rt, 24; \\''')
  write_line('''    sra       rd, rd, 24''')
  write_line('''#define SEH(rd, rt) \\''')
  write_line('''    sll       rd, rt, 16; \\''')
  write_line('''    sra       rd, rd, 16''')
  write_line('''/* Clobbers rt_hi on pre-R2. */''')
  write_line('''#define INSERT_HIGH_HALF(rd_lo, rt_hi) \\''')
  write_line('''    sll       rt_hi, rt_hi, 16; \\''')
  write_line('''    or        rd_lo, rt_hi''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#ifdef FPU64''')
  write_line('''#define MOVE_TO_FPU_HIGH(r, flo, fhi) \\''')
  write_line('''    mthc1     r, flo''')
  write_line('''#else''')
  write_line('''#define MOVE_TO_FPU_HIGH(r, flo, fhi) \\''')
  write_line('''    mtc1      r, fhi''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define JR(rt) \\''')
  write_line('''    jic       rt, 0''')
  write_line('''#define LSA(rd, rs, rt, sa) \\''')
  write_line('''    .if sa; \\''')
  write_line('''    lsa       rd, rs, rt, sa; \\''')
  write_line('''    .else; \\''')
  write_line('''    addu      rd, rs, rt; \\''')
  write_line('''    .endif''')
  write_line('''#else''')
  write_line('''#define JR(rt) \\''')
  write_line('''    jalr      zero, rt''')
  write_line('''#define LSA(rd, rs, rt, sa) \\''')
  write_line('''    .if sa; \\''')
  write_line('''    .set      push; \\''')
  write_line('''    .set      noat; \\''')
  write_line('''    sll       AT, rs, sa; \\''')
  write_line('''    addu      rd, AT, rt; \\''')
  write_line('''    .set      pop; \\''')
  write_line('''    .else; \\''')
  write_line('''    addu      rd, rs, rt; \\''')
  write_line('''    .endif''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Instead of holding a pointer to the shadow frame, we keep rFP at the base of the vregs.  So,''')
  write_line(''' * to access other shadow frame fields, we need to use a backwards offset.  Define those here.''')
  write_line(''' */''')
  write_line('''#define OFF_FP(a) (a - SHADOWFRAME_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_NUMBER_OF_VREGS OFF_FP(SHADOWFRAME_NUMBER_OF_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC OFF_FP(SHADOWFRAME_DEX_PC_OFFSET)''')
  write_line('''#define OFF_FP_LINK OFF_FP(SHADOWFRAME_LINK_OFFSET)''')
  write_line('''#define OFF_FP_METHOD OFF_FP(SHADOWFRAME_METHOD_OFFSET)''')
  write_line('''#define OFF_FP_RESULT_REGISTER OFF_FP(SHADOWFRAME_RESULT_REGISTER_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC_PTR OFF_FP(SHADOWFRAME_DEX_PC_PTR_OFFSET)''')
  write_line('''#define OFF_FP_DEX_INSTRUCTIONS OFF_FP(SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET)''')
  write_line('''#define OFF_FP_SHADOWFRAME OFF_FP(0)''')
  write_line('''''')
  write_line('''#define MTERP_PROFILE_BRANCHES 1''')
  write_line('''#define MTERP_LOGGING 0''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * "export" the PC to dex_pc field in the shadow frame, f/b/o future exception objects.  Must''')
  write_line(''' * be done *before* something throws.''')
  write_line(''' *''')
  write_line(''' * It's okay to do this more than once.''')
  write_line(''' *''')
  write_line(''' * NOTE: the fast interpreter keeps track of dex pc as a direct pointer to the mapped''')
  write_line(''' * dex byte codes.  However, the rest of the runtime expects dex pc to be an instruction''')
  write_line(''' * offset into the code_items_[] array.  For effiency, we will "export" the''')
  write_line(''' * current dex pc as a direct pointer using the EXPORT_PC macro, and rely on GetDexPC''')
  write_line(''' * to convert to a dex pc when needed.''')
  write_line(''' */''')
  write_line('''#define EXPORT_PC() \\''')
  write_line('''    sw        rPC, OFF_FP_DEX_PC_PTR(rFP)''')
  write_line('''''')
  write_line('''#define EXPORT_DEX_PC(tmp) \\''')
  write_line('''    lw        tmp, OFF_FP_DEX_INSTRUCTIONS(rFP); \\''')
  write_line('''    sw        rPC, OFF_FP_DEX_PC_PTR(rFP); \\''')
  write_line('''    subu      tmp, rPC, tmp; \\''')
  write_line('''    sra       tmp, tmp, 1; \\''')
  write_line('''    sw        tmp, OFF_FP_DEX_PC(rFP)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from rPC into rINST.  Does not advance rPC.''')
  write_line(''' */''')
  write_line('''#define FETCH_INST() lhu rINST, (rPC)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from the specified offset.  Advances rPC''')
  write_line(''' * to point to the next instruction.  "_count" is in 16-bit code units.''')
  write_line(''' *''')
  write_line(''' * This must come AFTER anything that can throw an exception, or the''')
  write_line(''' * exception catch may miss.  (This also implies that it must come after''')
  write_line(''' * EXPORT_PC().)''')
  write_line(''' */''')
  write_line('''#define FETCH_ADVANCE_INST(_count) \\''')
  write_line('''    lhu       rINST, ((_count)*2)(rPC); \\''')
  write_line('''    addu      rPC, rPC, ((_count) * 2)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Similar to FETCH_ADVANCE_INST, but does not update rPC.  Used to load''')
  write_line(''' * rINST ahead of possible exception point.  Be sure to manually advance rPC''')
  write_line(''' * later.''')
  write_line(''' */''')
  write_line('''#define PREFETCH_INST(_count) lhu rINST, ((_count)*2)(rPC)''')
  write_line('''''')
  write_line('''/* Advance rPC by some number of code units. */''')
  write_line('''#define ADVANCE(_count) addu rPC, rPC, ((_count) * 2)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from an offset specified by rd.  Updates''')
  write_line(''' * rPC to point to the next instruction.  "rd" must specify the distance''')
  write_line(''' * in bytes, *not* 16-bit code units, and may be a signed value.''')
  write_line(''' */''')
  write_line('''#define FETCH_ADVANCE_INST_RB(rd) \\''')
  write_line('''    addu      rPC, rPC, rd; \\''')
  write_line('''    lhu       rINST, (rPC)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch a half-word code unit from an offset past the current PC.  The''')
  write_line(''' * "_count" value is in 16-bit code units.  Does not advance rPC.''')
  write_line(''' *''')
  write_line(''' * The "_S" variant works the same but treats the value as signed.''')
  write_line(''' */''')
  write_line('''#define FETCH(rd, _count) lhu rd, ((_count) * 2)(rPC)''')
  write_line('''#define FETCH_S(rd, _count) lh rd, ((_count) * 2)(rPC)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch one byte from an offset past the current PC.  Pass in the same''')
  write_line(''' * "_count" as you would for FETCH, and an additional 0/1 indicating which''')
  write_line(''' * byte of the halfword you want (lo/hi).''')
  write_line(''' */''')
  write_line('''#define FETCH_B(rd, _count, _byte) lbu rd, ((_count) * 2 + _byte)(rPC)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Put the instruction's opcode field into the specified register.''')
  write_line(''' */''')
  write_line('''#define GET_INST_OPCODE(rd) and rd, rINST, 0xFF''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Transform opcode into branch target address.''')
  write_line(''' */''')
  write_line('''#define GET_OPCODE_TARGET(rd) \\''')
  write_line('''    sll       rd, rd, ''' + handler_size_bits + '''; \\''')
  write_line('''    addu      rd, rIBASE, rd''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Begin executing the opcode in rd.''')
  write_line(''' */''')
  write_line('''#define GOTO_OPCODE(rd) \\''')
  write_line('''    GET_OPCODE_TARGET(rd); \\''')
  write_line('''    JR(rd)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 32-bit value from a Dalvik register.''')
  write_line(''' */''')
  write_line('''#define GET_VREG(rd, rix) LOAD_eas2(rd, rFP, rix)''')
  write_line('''''')
  write_line('''#define GET_VREG_F(rd, rix) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    EAS2(AT, rFP, rix); \\''')
  write_line('''    l.s       rd, (AT); \\''')
  write_line('''    .set at''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG(rd, rix) \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    sw        zero, 0(t8)''')
  write_line('''#else''')
  write_line('''#define SET_VREG(rd, rix) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    sw        zero, 0(t8)''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG_OBJECT(rd, rix) \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    sw        rd, 0(t8)''')
  write_line('''#else''')
  write_line('''#define SET_VREG_OBJECT(rd, rix) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    sw        rd, 0(t8)''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG64(rlo, rhi, rix) \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    sw        rlo, 0(t8); \\''')
  write_line('''    sw        rhi, 4(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    sw        zero, 4(t8)''')
  write_line('''#else''')
  write_line('''#define SET_VREG64(rlo, rhi, rix) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    sw        rlo, 0(t8); \\''')
  write_line('''    sw        rhi, 4(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    sw        zero, 4(t8)''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG_F(rd, rix) \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    s.s       rd, 0(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    sw        zero, 0(t8)''')
  write_line('''#else''')
  write_line('''#define SET_VREG_F(rd, rix) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    s.s       rd, 0(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    sw        zero, 0(t8)''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG64_F(rlo, rhi, rix) \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    .set noat; \\''')
  write_line('''    mfhc1     AT, rlo; \\''')
  write_line('''    s.s       rlo, 0(t8); \\''')
  write_line('''    sw        AT, 4(t8); \\''')
  write_line('''    .set at; \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    sw        zero, 4(t8)''')
  write_line('''#elif defined(FPU64)''')
  write_line('''#define SET_VREG64_F(rlo, rhi, rix) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    sw        zero, 4(t8); \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    mfhc1     AT, rlo; \\''')
  write_line('''    sw        AT, 4(t8); \\''')
  write_line('''    .set at; \\''')
  write_line('''    s.s       rlo, 0(t8)''')
  write_line('''#else''')
  write_line('''#define SET_VREG64_F(rlo, rhi, rix) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    s.s       rlo, 0(t8); \\''')
  write_line('''    s.s       rhi, 4(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    sw        zero, 4(t8)''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''/* Combination of the SET_VREG and GOTO_OPCODE functions to save 1 instruction */''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG_GOTO(rd, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#else''')
  write_line('''#define SET_VREG_GOTO(rd, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''/* Combination of the SET_VREG_OBJECT and GOTO_OPCODE functions to save 1 instruction */''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG_OBJECT_GOTO(rd, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#else''')
  write_line('''#define SET_VREG_OBJECT_GOTO(rd, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        rd, 0(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''/* Combination of the SET_VREG64 and GOTO_OPCODE functions to save 1 instruction */''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG64_GOTO(rlo, rhi, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    sw        rlo, 0(t8); \\''')
  write_line('''    sw        rhi, 4(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 4(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#else''')
  write_line('''#define SET_VREG64_GOTO(rlo, rhi, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    sw        rlo, 0(t8); \\''')
  write_line('''    sw        rhi, 4(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 4(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''/* Combination of the SET_VREG_F and GOTO_OPCODE functions to save 1 instruction */''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG_F_GOTO(rd, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    s.s       rd, 0(t8); \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#else''')
  write_line('''#define SET_VREG_F_GOTO(rd, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    s.s       rd, 0(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''/* Combination of the SET_VREG64_F and GOTO_OPCODE functions to save 1 instruction */''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''#define SET_VREG64_F_GOTO(rlo, rhi, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    lsa       t8, rix, rFP, 2; \\''')
  write_line('''    .set noat; \\''')
  write_line('''    mfhc1     AT, rlo; \\''')
  write_line('''    s.s       rlo, 0(t8); \\''')
  write_line('''    sw        AT, 4(t8); \\''')
  write_line('''    .set at; \\''')
  write_line('''    lsa       t8, rix, rREFS, 2; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 4(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#elif defined(FPU64)''')
  write_line('''#define SET_VREG64_F_GOTO(rlo, rhi, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    sw        zero, 4(t8); \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    mfhc1     AT, rlo; \\''')
  write_line('''    sw        AT, 4(t8); \\''')
  write_line('''    .set at; \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    s.s       rlo, 0(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#else''')
  write_line('''#define SET_VREG64_F_GOTO(rlo, rhi, rix, dst) \\''')
  write_line('''    .set noreorder; \\''')
  write_line('''    GET_OPCODE_TARGET(dst); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    sll       AT, rix, 2; \\''')
  write_line('''    addu      t8, rFP, AT; \\''')
  write_line('''    s.s       rlo, 0(t8); \\''')
  write_line('''    s.s       rhi, 4(t8); \\''')
  write_line('''    addu      t8, rREFS, AT; \\''')
  write_line('''    .set at; \\''')
  write_line('''    sw        zero, 0(t8); \\''')
  write_line('''    jalr      zero, dst; \\''')
  write_line('''    sw        zero, 4(t8); \\''')
  write_line('''    .set reorder''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#define GET_OPA(rd) srl rd, rINST, 8''')
  write_line('''#ifdef MIPS32REVGE2''')
  write_line('''#define GET_OPA4(rd) ext rd, rINST, 8, 4''')
  write_line('''#else''')
  write_line('''#define GET_OPA4(rd) GET_OPA(rd); and rd, 0xf''')
  write_line('''#endif''')
  write_line('''#define GET_OPB(rd) srl rd, rINST, 12''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Form an Effective Address rd = rbase + roff<<shift;''')
  write_line(''' * Uses reg AT on pre-R6.''')
  write_line(''' */''')
  write_line('''#define EASN(rd, rbase, roff, shift) LSA(rd, roff, rbase, shift)''')
  write_line('''''')
  write_line('''#define EAS1(rd, rbase, roff) EASN(rd, rbase, roff, 1)''')
  write_line('''#define EAS2(rd, rbase, roff) EASN(rd, rbase, roff, 2)''')
  write_line('''#define EAS3(rd, rbase, roff) EASN(rd, rbase, roff, 3)''')
  write_line('''#define EAS4(rd, rbase, roff) EASN(rd, rbase, roff, 4)''')
  write_line('''''')
  write_line('''#define LOAD_eas2(rd, rbase, roff) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    EAS2(AT, rbase, roff); \\''')
  write_line('''    lw        rd, 0(AT); \\''')
  write_line('''    .set at''')
  write_line('''''')
  write_line('''#define STORE_eas2(rd, rbase, roff) \\''')
  write_line('''    .set noat; \\''')
  write_line('''    EAS2(AT, rbase, roff); \\''')
  write_line('''    sw        rd, 0(AT); \\''')
  write_line('''    .set at''')
  write_line('''''')
  write_line('''#define LOAD_RB_OFF(rd, rbase, off) lw rd, off(rbase)''')
  write_line('''#define STORE_RB_OFF(rd, rbase, off) sw rd, off(rbase)''')
  write_line('''''')
  write_line('''#define STORE64_off(rlo, rhi, rbase, off) \\''')
  write_line('''    sw        rlo, off(rbase); \\''')
  write_line('''    sw        rhi, (off+4)(rbase)''')
  write_line('''#define LOAD64_off(rlo, rhi, rbase, off) \\''')
  write_line('''    lw        rlo, off(rbase); \\''')
  write_line('''    lw        rhi, (off+4)(rbase)''')
  write_line('''''')
  write_line('''#define STORE64(rlo, rhi, rbase) STORE64_off(rlo, rhi, rbase, 0)''')
  write_line('''#define LOAD64(rlo, rhi, rbase) LOAD64_off(rlo, rhi, rbase, 0)''')
  write_line('''''')
  write_line('''#ifdef FPU64''')
  write_line('''#define STORE64_off_F(rlo, rhi, rbase, off) \\''')
  write_line('''    s.s       rlo, off(rbase); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    mfhc1     AT, rlo; \\''')
  write_line('''    sw        AT, (off+4)(rbase); \\''')
  write_line('''    .set at''')
  write_line('''#define LOAD64_off_F(rlo, rhi, rbase, off) \\''')
  write_line('''    l.s       rlo, off(rbase); \\''')
  write_line('''    .set noat; \\''')
  write_line('''    lw        AT, (off+4)(rbase); \\''')
  write_line('''    mthc1     AT, rlo; \\''')
  write_line('''    .set at''')
  write_line('''#else''')
  write_line('''#define STORE64_off_F(rlo, rhi, rbase, off) \\''')
  write_line('''    s.s       rlo, off(rbase); \\''')
  write_line('''    s.s       rhi, (off+4)(rbase)''')
  write_line('''#define LOAD64_off_F(rlo, rhi, rbase, off) \\''')
  write_line('''    l.s       rlo, off(rbase); \\''')
  write_line('''    l.s       rhi, (off+4)(rbase)''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''#define STORE64_F(rlo, rhi, rbase) STORE64_off_F(rlo, rhi, rbase, 0)''')
  write_line('''#define LOAD64_F(rlo, rhi, rbase) LOAD64_off_F(rlo, rhi, rbase, 0)''')
  write_line('''''')
  write_line('''#define LOAD_base_offMirrorArray_length(rd, rbase) LOAD_RB_OFF(rd, rbase, MIRROR_ARRAY_LENGTH_OFFSET)''')
  write_line('''''')
  write_line('''#define STACK_STORE(rd, off) sw rd, off(sp)''')
  write_line('''#define STACK_LOAD(rd, off) lw rd, off(sp)''')
  write_line('''#define CREATE_STACK(n) subu sp, sp, n''')
  write_line('''#define DELETE_STACK(n) addu sp, sp, n''')
  write_line('''''')
  write_line('''#define LOAD_ADDR(dest, addr) la dest, addr''')
  write_line('''#define LOAD_IMM(dest, imm) li dest, imm''')
  write_line('''#define MOVE_REG(dest, src) move dest, src''')
  write_line('''#define STACK_SIZE 128''')
  write_line('''''')
  write_line('''#define STACK_OFFSET_ARG04 16''')
  write_line('''#define STACK_OFFSET_ARG05 20''')
  write_line('''#define STACK_OFFSET_ARG06 24''')
  write_line('''#define STACK_OFFSET_ARG07 28''')
  write_line('''#define STACK_OFFSET_GP    84''')
  write_line('''''')
  write_line('''#define JAL(n) jal n''')
  write_line('''#define BAL(n) bal n''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * FP register usage restrictions:''')
  write_line(''' * 1) We don't use the callee save FP registers so we don't have to save them.''')
  write_line(''' * 2) We don't use the odd FP registers so we can share code with mips32r6.''')
  write_line(''' */''')
  write_line('''#define STACK_STORE_FULL() CREATE_STACK(STACK_SIZE); \\''')
  write_line('''    STACK_STORE(ra, 124); \\''')
  write_line('''    STACK_STORE(s8, 120); \\''')
  write_line('''    STACK_STORE(s0, 116); \\''')
  write_line('''    STACK_STORE(s1, 112); \\''')
  write_line('''    STACK_STORE(s2, 108); \\''')
  write_line('''    STACK_STORE(s3, 104); \\''')
  write_line('''    STACK_STORE(s4, 100); \\''')
  write_line('''    STACK_STORE(s5, 96); \\''')
  write_line('''    STACK_STORE(s6, 92); \\''')
  write_line('''    STACK_STORE(s7, 88);''')
  write_line('''''')
  write_line('''#define STACK_LOAD_FULL() STACK_LOAD(gp, STACK_OFFSET_GP); \\''')
  write_line('''    STACK_LOAD(s7, 88); \\''')
  write_line('''    STACK_LOAD(s6, 92); \\''')
  write_line('''    STACK_LOAD(s5, 96); \\''')
  write_line('''    STACK_LOAD(s4, 100); \\''')
  write_line('''    STACK_LOAD(s3, 104); \\''')
  write_line('''    STACK_LOAD(s2, 108); \\''')
  write_line('''    STACK_LOAD(s1, 112); \\''')
  write_line('''    STACK_LOAD(s0, 116); \\''')
  write_line('''    STACK_LOAD(s8, 120); \\''')
  write_line('''    STACK_LOAD(ra, 124); \\''')
  write_line('''    DELETE_STACK(STACK_SIZE)''')
  write_line('''''')
  write_line('''#define REFRESH_IBASE() \\''')
  write_line('''    lw        rIBASE, THREAD_CURRENT_IBASE_OFFSET(rSELF)''')
  write_line('''''')
  write_line('''/* Constants for float/double_to_int/long conversions */''')
  write_line('''#define INT_MIN                 0x80000000''')
  write_line('''#define INT_MIN_AS_FLOAT        0xCF000000''')
  write_line('''#define INT_MIN_AS_DOUBLE_HIGH  0xC1E00000''')
  write_line('''#define LONG_MIN_HIGH           0x80000000''')
  write_line('''#define LONG_MIN_AS_FLOAT       0xDF000000''')
  write_line('''#define LONG_MIN_AS_DOUBLE_HIGH 0xC3E00000''')

def instruction_end():
  write_line('''''')
  write_line('''    .global artMterpAsmInstructionEnd''')
  write_line('''artMterpAsmInstructionEnd:''')

def instruction_end_alt():
  write_line('''''')
  write_line('''    .global artMterpAsmAltInstructionEnd''')
  write_line('''artMterpAsmAltInstructionEnd:''')

def instruction_end_sister():
  write_line('''''')
  write_line('''    .global artMterpAsmSisterEnd''')
  write_line('''artMterpAsmSisterEnd:''')

def instruction_start():
  write_line('''''')
  write_line('''    .global artMterpAsmInstructionStart''')
  write_line('''artMterpAsmInstructionStart = .L_op_nop''')
  write_line('''    .text''')

def instruction_start_alt():
  write_line('''''')
  write_line('''    .global artMterpAsmAltInstructionStart''')
  write_line('''artMterpAsmAltInstructionStart = .L_ALT_op_nop''')
  write_line('''    .text''')

def instruction_start_sister():
  write_line('''''')
  write_line('''    .global artMterpAsmSisterStart''')
  write_line('''    .text''')
  write_line('''    .balign 4''')
  write_line('''artMterpAsmSisterStart:''')

def invoke(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * Generic invoke handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC()''')
  write_line('''    move    a0, rSELF''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rPC''')
  write_line('''    move    a3, rINST''')
  write_line('''    JAL(''' + helper + ''')''')
  write_line('''    beqz    v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST(3)''')
  write_line('''    JAL(MterpShouldSwitchInterpreters)''')
  write_line('''    bnez    v0, MterpFallback''')
  write_line('''    GET_INST_OPCODE(t0)''')
  write_line('''    GOTO_OPCODE(t0)''')

def invoke_polymorphic(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * invoke-polymorphic handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB, proto@HHHH */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC()''')
  write_line('''    move    a0, rSELF''')
  write_line('''    addu    a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rPC''')
  write_line('''    move    a3, rINST''')
  write_line('''    JAL(''' + helper + ''')''')
  write_line('''    beqz    v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST(4)''')
  write_line('''    JAL(MterpShouldSwitchInterpreters)''')
  write_line('''    bnez    v0, MterpFallback''')
  write_line('''    GET_INST_OPCODE(t0)''')
  write_line('''    GOTO_OPCODE(t0)''')

def op_add_double():
  fbinopWide(instr="add.d fv0, fa0, fa1")

def op_add_double_2addr():
  fbinopWide2addr(instr="add.d fv0, fa0, fa1")

def op_add_float():
  fbinop(instr="add.s fv0, fa0, fa1")

def op_add_float_2addr():
  fbinop2addr(instr="add.s fv0, fa0, fa1")

def op_add_int():
  binop(instr="addu a0, a0, a1")

def op_add_int_2addr():
  binop2addr(instr="addu a0, a0, a1")

def op_add_int_lit16():
  binopLit16(instr="addu a0, a0, a1")

def op_add_int_lit8():
  binopLit8(instr="addu a0, a0, a1")

def op_add_long():
  write_line('''/*''')
  write_line(''' *  The compiler generates the following sequence for''')
  write_line(''' *  [v1 v0] =  [a1 a0] + [a3 a2];''')
  write_line(''' *    addu v0,a2,a0''')
  write_line(''' *    addu a1,a3,a1''')
  write_line(''' *    sltu v1,v0,a2''')
  write_line(''' *    addu v1,v1,a1''')
  write_line(''' */''')
  binopWide(result0="v0", result1="v1", preinstr="addu v0, a2, a0", instr="addu a1, a3, a1; sltu v1, v0, a2; addu v1, v1, a1")

def op_add_long_2addr():
  write_line('''/*''')
  write_line(''' * See op_add_long.S for details''')
  write_line(''' */''')
  binopWide2addr(result0="v0", result1="v1", preinstr="addu v0, a2, a0", instr="addu a1, a3, a1; sltu v1, v0, a2; addu v1, v1, a1")

def op_aget(load="lw", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''    /*''')
  write_line('''     * Array get, 32 bits or less.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17''')
  write_line('''     * instructions.  We use a pair of FETCH_Bs instead.''')
  write_line('''     *''')
  write_line('''     * for: aget, aget-boolean, aget-byte, aget-char, aget-short''')
  write_line('''     *''')
  write_line('''     * NOTE: assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B(a2, 1, 0)                      #  a2 <- BB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    FETCH_B(a3, 1, 1)                      #  a3 <- CC''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vBB (array object)''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vCC (requested index)''')
  write_line('''    # null array object?''')
  write_line('''    beqz      a0, common_errNullObject     #  yes, bail''')
  write_line('''    LOAD_base_offMirrorArray_length(a3, a0) #  a3 <- arrayObj->length''')
  write_line('''    EASN(a0, a0, a1, ''' + shift + ''')               #  a0 <- arrayObj + index*width''')
  write_line('''    # a1 >= a3; compare unsigned index''')
  write_line('''    bgeu      a1, a3, common_errArrayIndex #  index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    ''' + load + ''' a2, ''' + data_offset + '''(a0)             #  a2 <- vBB[vCC]''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(a2, rOBJ, t0)            #  vAA <- a2''')

def op_aget_boolean():
  op_aget(load="lbu", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aget_byte():
  op_aget(load="lb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aget_char():
  op_aget(load="lhu", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aget_object():
  write_line('''    /*''')
  write_line('''     * Array object get.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * for: aget-object''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B(a2, 1, 0)                      #  a2 <- BB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    FETCH_B(a3, 1, 1)                      #  a3 <- CC''')
  write_line('''    EXPORT_PC()''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vBB (array object)''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vCC (requested index)''')
  write_line('''    JAL(artAGetObjectFromMterp)            #  v0 <- GetObj(array, index)''')
  write_line('''    lw   a1, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    PREFETCH_INST(2)                       #  load rINST''')
  write_line('''    bnez a1, MterpException''')
  write_line('''    ADVANCE(2)                             #  advance rPC''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_OBJECT_GOTO(v0, rOBJ, t0)     #  vAA <- v0''')

def op_aget_short():
  op_aget(load="lh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aget_wide():
  write_line('''    /*''')
  write_line('''     * Array get, 64 bits.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * Arrays of long/double are 64-bit aligned.''')
  write_line('''     */''')
  write_line('''    /* aget-wide vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    srl       a3, a0, 8                    #  a3 <- CC''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vBB (array object)''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vCC (requested index)''')
  write_line('''    # null array object?''')
  write_line('''    beqz      a0, common_errNullObject     #  yes, bail''')
  write_line('''    LOAD_base_offMirrorArray_length(a3, a0) #  a3 <- arrayObj->length''')
  write_line('''    EAS3(a0, a0, a1)                       #  a0 <- arrayObj + index*width''')
  write_line('''    bgeu      a1, a3, common_errArrayIndex #  index >= length, bail''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    LOAD64_off(a2, a3, a0, MIRROR_WIDE_ARRAY_DATA_OFFSET)''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a2, a3, rOBJ, t0)      #  vAA/vAA+1 <- a2/a3''')

def op_and_int():
  binop(instr="and a0, a0, a1")

def op_and_int_2addr():
  binop2addr(instr="and a0, a0, a1")

def op_and_int_lit16():
  binopLit16(instr="and a0, a0, a1")

def op_and_int_lit8():
  binopLit8(instr="and a0, a0, a1")

def op_and_long():
  binopWide(preinstr="and a0, a0, a2", instr="and a1, a1, a3")

def op_and_long_2addr():
  binopWide2addr(preinstr="and a0, a0, a2", instr="and a1, a1, a3")

def op_aput(store="sw", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''''')
  write_line('''    /*''')
  write_line('''     * Array put, 32 bits or less.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     * for: aput, aput-boolean, aput-byte, aput-char, aput-short''')
  write_line('''     *''')
  write_line('''     * NOTE: this assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B(a2, 1, 0)                      #  a2 <- BB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    FETCH_B(a3, 1, 1)                      #  a3 <- CC''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vBB (array object)''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vCC (requested index)''')
  write_line('''    # null array object?''')
  write_line('''    beqz      a0, common_errNullObject     #  yes, bail''')
  write_line('''    LOAD_base_offMirrorArray_length(a3, a0) #  a3 <- arrayObj->length''')
  write_line('''    EASN(a0, a0, a1, ''' + shift + ''')               #  a0 <- arrayObj + index*width''')
  write_line('''    bgeu      a1, a3, common_errArrayIndex #  index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_VREG(a2, rOBJ)                     #  a2 <- vAA''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GET_OPCODE_TARGET(t0)''')
  write_line('''    ''' + store + ''' a2, ''' + data_offset + '''(a0)            #  vBB[vCC] <- a2''')
  write_line('''    JR(t0)                                 #  jump to next instruction''')

def op_aput_boolean():
  op_aput(store="sb", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aput_byte():
  op_aput(store="sb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aput_char():
  op_aput(store="sh", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aput_object():
  write_line('''    /*''')
  write_line('''     * Store an object into an array.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    addu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move   a1, rPC''')
  write_line('''    move   a2, rINST''')
  write_line('''    JAL(MterpAputObject)''')
  write_line('''    beqz   v0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST(2)               # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')

def op_aput_short():
  op_aput(store="sh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aput_wide():
  write_line('''    /*''')
  write_line('''     * Array put, 64 bits.  vBB[vCC] <- vAA.''')
  write_line('''     */''')
  write_line('''    /* aput-wide vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(t0)                            #  t0 <- AA''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    srl       a3, a0, 8                    #  a3 <- CC''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- vBB (array object)''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vCC (requested index)''')
  write_line('''    # null array object?''')
  write_line('''    beqz      a0, common_errNullObject     #  yes, bail''')
  write_line('''    LOAD_base_offMirrorArray_length(a3, a0) #  a3 <- arrayObj->length''')
  write_line('''    EAS3(a0, a0, a1)                       #  a0 <- arrayObj + index*width''')
  write_line('''    EAS2(rOBJ, rFP, t0)                    #  rOBJ <- &fp[AA]''')
  write_line('''    # compare unsigned index, length''')
  write_line('''    bgeu      a1, a3, common_errArrayIndex #  index >= length, bail''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    LOAD64(a2, a3, rOBJ)                   #  a2/a3 <- vAA/vAA+1''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GET_OPCODE_TARGET(t0)''')
  write_line('''    STORE64_off(a2, a3, a0, MIRROR_WIDE_ARRAY_DATA_OFFSET) #  a2/a3 <- vBB[vCC]''')
  write_line('''    JR(t0)                                 #  jump to next instruction''')

def op_array_length():
  write_line('''    /*''')
  write_line('''     * Return the length of an array.''')
  write_line('''     */''')
  write_line('''    /* array-length vA, vB */''')
  write_line('''    GET_OPB(a1)                            #  a1 <- B''')
  write_line('''    GET_OPA4(a2)                           #  a2 <- A+''')
  write_line('''    GET_VREG(a0, a1)                       #  a0 <- vB (object ref)''')
  write_line('''    # is object null?''')
  write_line('''    beqz      a0, common_errNullObject     #  yup, fail''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    LOAD_base_offMirrorArray_length(a3, a0) #  a3 <- array length''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(a3, a2, t0)              #  vA <- length''')

def op_check_cast():
  write_line('''    /*''')
  write_line('''     * Check to see if a cast from one class to another is allowed.''')
  write_line('''     */''')
  write_line('''    /* check-cast vAA, class@BBBB */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- BBBB''')
  write_line('''    GET_OPA(a1)                            #  a1 <- AA''')
  write_line('''    EAS2(a1, rFP, a1)                      #  a1 <- &object''')
  write_line('''    lw     a2, OFF_FP_METHOD(rFP)          #  a2 <- method''')
  write_line('''    move   a3, rSELF                       #  a3 <- self''')
  write_line('''    JAL(MterpCheckCast)                    #  v0 <- CheckCast(index, &obj, method, self)''')
  write_line('''    PREFETCH_INST(2)''')
  write_line('''    bnez   v0, MterpPossibleException''')
  write_line('''    ADVANCE(2)''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        #  jump to next instruction''')

def op_cmp_long():
  write_line('''    /*''')
  write_line('''     * Compare two 64-bit values''')
  write_line('''     *    x = y     return  0''')
  write_line('''     *    x < y     return -1''')
  write_line('''     *    x > y     return  1''')
  write_line('''     *''')
  write_line('''     * I think I can improve on the ARM code by the following observation''')
  write_line('''     *    slt   t0,  x.hi, y.hi;        # (x.hi < y.hi) ? 1:0''')
  write_line('''     *    sgt   t1,  x.hi, y.hi;        # (y.hi > x.hi) ? 1:0''')
  write_line('''     *    subu  v0, t0, t1              # v0= -1:1:0 for [ < > = ]''')
  write_line('''     */''')
  write_line('''    /* cmp-long vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    srl       a3, a0, 8                    #  a3 <- CC''')
  write_line('''    EAS2(a2, rFP, a2)                      #  a2 <- &fp[BB]''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[CC]''')
  write_line('''    LOAD64(a0, a1, a2)                     #  a0/a1 <- vBB/vBB+1''')
  write_line('''    LOAD64(a2, a3, a3)                     #  a2/a3 <- vCC/vCC+1''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    slt       t0, a1, a3                   #  compare hi''')
  write_line('''    sgt       t1, a1, a3''')
  write_line('''    subu      v0, t1, t0                   #  v0 <- (-1, 1, 0)''')
  write_line('''    bnez      v0, .L''' + opcode + '''_finish''')
  write_line('''    # at this point x.hi==y.hi''')
  write_line('''    sltu      t0, a0, a2                   #  compare lo''')
  write_line('''    sgtu      t1, a0, a2''')
  write_line('''    subu      v0, t1, t0                   #  v0 <- (-1, 1, 0) for [< > =]''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(v0, rOBJ, t0)            #  vAA <- v0''')

def op_cmpg_double():
  op_cmpl_double(gt_bias="1")

def op_cmpg_float():
  op_cmpl_float(gt_bias="1")

def op_cmpl_double(gt_bias="0"):
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values. Puts 0(==), 1(>), or -1(<)''')
  write_line('''     * into the destination register based on the comparison results.''')
  write_line('''     *''')
  write_line('''     * For: cmpl-double, cmpg-double''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    and       rOBJ, a0, 255                #  rOBJ <- BB''')
  write_line('''    srl       t0, a0, 8                    #  t0 <- CC''')
  write_line('''    EAS2(rOBJ, rFP, rOBJ)                  #  rOBJ <- &fp[BB]''')
  write_line('''    EAS2(t0, rFP, t0)                      #  t0 <- &fp[CC]''')
  write_line('''    LOAD64_F(ft0, ft0f, rOBJ)''')
  write_line('''    LOAD64_F(ft1, ft1f, t0)''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    cmp.eq.d  ft2, ft0, ft1''')
  write_line('''    li        rTEMP, 0''')
  write_line('''    bc1nez    ft2, 1f                      # done if vBB == vCC (ordered)''')
  write_line('''    .if ''' + gt_bias + '''''')
  write_line('''    cmp.lt.d  ft2, ft0, ft1''')
  write_line('''    li        rTEMP, -1''')
  write_line('''    bc1nez    ft2, 1f                      # done if vBB < vCC (ordered)''')
  write_line('''    li        rTEMP, 1                     # vBB > vCC or unordered''')
  write_line('''    .else''')
  write_line('''    cmp.lt.d  ft2, ft1, ft0''')
  write_line('''    li        rTEMP, 1''')
  write_line('''    bc1nez    ft2, 1f                      # done if vBB > vCC (ordered)''')
  write_line('''    li        rTEMP, -1                    # vBB < vCC or unordered''')
  write_line('''    .endif''')
  write_line('''#else''')
  write_line('''    c.eq.d    fcc0, ft0, ft1''')
  write_line('''    li        rTEMP, 0''')
  write_line('''    bc1t      fcc0, 1f                     # done if vBB == vCC (ordered)''')
  write_line('''    .if ''' + gt_bias + '''''')
  write_line('''    c.olt.d   fcc0, ft0, ft1''')
  write_line('''    li        rTEMP, -1''')
  write_line('''    bc1t      fcc0, 1f                     # done if vBB < vCC (ordered)''')
  write_line('''    li        rTEMP, 1                     # vBB > vCC or unordered''')
  write_line('''    .else''')
  write_line('''    c.olt.d   fcc0, ft1, ft0''')
  write_line('''    li        rTEMP, 1''')
  write_line('''    bc1t      fcc0, 1f                     # done if vBB > vCC (ordered)''')
  write_line('''    li        rTEMP, -1                    # vBB < vCC or unordered''')
  write_line('''    .endif''')
  write_line('''#endif''')
  write_line('''1:''')
  write_line('''    GET_OPA(rOBJ)''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(rTEMP, rOBJ, t0)         #  vAA <- rTEMP''')

def op_cmpl_float(gt_bias="0"):
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values. Puts 0(==), 1(>), or -1(<)''')
  write_line('''     * into the destination register based on the comparison results.''')
  write_line('''     *''')
  write_line('''     * for: cmpl-float, cmpg-float''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    and       a2, a0, 255                  #  a2 <- BB''')
  write_line('''    srl       a3, a0, 8''')
  write_line('''    GET_VREG_F(ft0, a2)''')
  write_line('''    GET_VREG_F(ft1, a3)''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    cmp.eq.s  ft2, ft0, ft1''')
  write_line('''    li        rTEMP, 0''')
  write_line('''    bc1nez    ft2, 1f                      # done if vBB == vCC (ordered)''')
  write_line('''    .if ''' + gt_bias + '''''')
  write_line('''    cmp.lt.s  ft2, ft0, ft1''')
  write_line('''    li        rTEMP, -1''')
  write_line('''    bc1nez    ft2, 1f                      # done if vBB < vCC (ordered)''')
  write_line('''    li        rTEMP, 1                     # vBB > vCC or unordered''')
  write_line('''    .else''')
  write_line('''    cmp.lt.s  ft2, ft1, ft0''')
  write_line('''    li        rTEMP, 1''')
  write_line('''    bc1nez    ft2, 1f                      # done if vBB > vCC (ordered)''')
  write_line('''    li        rTEMP, -1                    # vBB < vCC or unordered''')
  write_line('''    .endif''')
  write_line('''#else''')
  write_line('''    c.eq.s    fcc0, ft0, ft1''')
  write_line('''    li        rTEMP, 0''')
  write_line('''    bc1t      fcc0, 1f                     # done if vBB == vCC (ordered)''')
  write_line('''    .if ''' + gt_bias + '''''')
  write_line('''    c.olt.s   fcc0, ft0, ft1''')
  write_line('''    li        rTEMP, -1''')
  write_line('''    bc1t      fcc0, 1f                     # done if vBB < vCC (ordered)''')
  write_line('''    li        rTEMP, 1                     # vBB > vCC or unordered''')
  write_line('''    .else''')
  write_line('''    c.olt.s   fcc0, ft1, ft0''')
  write_line('''    li        rTEMP, 1''')
  write_line('''    bc1t      fcc0, 1f                     # done if vBB > vCC (ordered)''')
  write_line('''    li        rTEMP, -1                    # vBB < vCC or unordered''')
  write_line('''    .endif''')
  write_line('''#endif''')
  write_line('''1:''')
  write_line('''    GET_OPA(rOBJ)''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(rTEMP, rOBJ, t0)         #  vAA <- rTEMP''')

def op_const():
  write_line('''    /* const vAA, +BBBBbbbb */''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- bbbb (low)''')
  write_line('''    FETCH(a1, 2)                           #  a1 <- BBBB (high)''')
  write_line('''    FETCH_ADVANCE_INST(3)                  #  advance rPC, load rINST''')
  write_line('''    INSERT_HIGH_HALF(a0, a1)               #  a0 <- BBBBbbbb''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(a0, a3, t0)              #  vAA <- a0''')

def op_const_16():
  write_line('''    /* const/16 vAA, +BBBB */''')
  write_line('''    FETCH_S(a0, 1)                         #  a0 <- ssssBBBB (sign-extended)''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(a0, a3, t0)              #  vAA <- a0''')

def op_const_4():
  write_line('''    /* const/4 vA, +B */''')
  write_line('''    sll       a1, rINST, 16                #  a1 <- Bxxx0000''')
  write_line('''    GET_OPA(a0)                            #  a0 <- A+''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    sra       a1, a1, 28                   #  a1 <- sssssssB (sign-extended)''')
  write_line('''    and       a0, a0, 15''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(a1, a0, t0)              #  fp[A] <- a1''')

def op_const_class():
  const(helper="MterpConstClass")

def op_const_high16():
  write_line('''    /* const/high16 vAA, +BBBB0000 */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- 0000BBBB (zero-extended)''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    sll       a0, a0, 16                   #  a0 <- BBBB0000''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(a0, a3, t0)              #  vAA <- a0''')

def op_const_method_handle():
  const(helper="MterpConstMethodHandle")

def op_const_method_type():
  const(helper="MterpConstMethodType")

def op_const_string():
  const(helper="MterpConstString")

def op_const_string_jumbo():
  write_line('''    /* const/string vAA, string@BBBBBBBB */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    FETCH(a0, 1)                        # a0 <- bbbb (low)''')
  write_line('''    FETCH(a2, 2)                        # a2 <- BBBB (high)''')
  write_line('''    GET_OPA(a1)                         # a1 <- AA''')
  write_line('''    INSERT_HIGH_HALF(a0, a2)            # a0 <- BBBBbbbb''')
  write_line('''    addu   a2, rFP, OFF_FP_SHADOWFRAME  # a2 <- shadow frame''')
  write_line('''    move   a3, rSELF''')
  write_line('''    JAL(MterpConstString)               # v0 <- Mterp(index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST(3)                    # load rINST''')
  write_line('''    bnez   v0, MterpPossibleException''')
  write_line('''    ADVANCE(3)                          # advance rPC''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')

def op_const_wide():
  write_line('''    /* const-wide vAA, +HHHHhhhhBBBBbbbb */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- bbbb (low)''')
  write_line('''    FETCH(a1, 2)                           #  a1 <- BBBB (low middle)''')
  write_line('''    FETCH(a2, 3)                           #  a2 <- hhhh (high middle)''')
  write_line('''    INSERT_HIGH_HALF(a0, a1)               #  a0 <- BBBBbbbb (low word)''')
  write_line('''    FETCH(a3, 4)                           #  a3 <- HHHH (high)''')
  write_line('''    GET_OPA(t1)                            #  t1 <- AA''')
  write_line('''    INSERT_HIGH_HALF(a2, a3)               #  a2 <- HHHHhhhh (high word)''')
  write_line('''    FETCH_ADVANCE_INST(5)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a2, t1, t0)        #  vAA/vAA+1 <- a0/a2''')

def op_const_wide_16():
  write_line('''    /* const-wide/16 vAA, +BBBB */''')
  write_line('''    FETCH_S(a0, 1)                         #  a0 <- ssssBBBB (sign-extended)''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    sra       a1, a0, 31                   #  a1 <- ssssssss''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a3, t0)        #  vAA/vAA+1 <- a0/a1''')

def op_const_wide_32():
  write_line('''    /* const-wide/32 vAA, +BBBBbbbb */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- 0000bbbb (low)''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    FETCH_S(a2, 2)                         #  a2 <- ssssBBBB (high)''')
  write_line('''    FETCH_ADVANCE_INST(3)                  #  advance rPC, load rINST''')
  write_line('''    INSERT_HIGH_HALF(a0, a2)               #  a0 <- BBBBbbbb''')
  write_line('''    sra       a1, a0, 31                   #  a1 <- ssssssss''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a3, t0)        #  vAA/vAA+1 <- a0/a1''')

def op_const_wide_high16():
  write_line('''    /* const-wide/high16 vAA, +BBBB000000000000 */''')
  write_line('''    FETCH(a1, 1)                           #  a1 <- 0000BBBB (zero-extended)''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    li        a0, 0                        #  a0 <- 00000000''')
  write_line('''    sll       a1, 16                       #  a1 <- BBBB0000''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a3, t0)        #  vAA/vAA+1 <- a0/a1''')

def op_div_double():
  fbinopWide(instr="div.d fv0, fa0, fa1")

def op_div_double_2addr():
  fbinopWide2addr(instr="div.d fv0, fa0, fa1")

def op_div_float():
  fbinop(instr="div.s fv0, fa0, fa1")

def op_div_float_2addr():
  fbinop2addr(instr="div.s fv0, fa0, fa1")

def op_div_int():
  write_line('''#ifdef MIPS32REVGE6''')
  binop(instr="div a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binop(preinstr="div zero, a0, a1", instr="mflo a0", chkzero="1")
  write_line('''#endif''')

def op_div_int_2addr():
  write_line('''#ifdef MIPS32REVGE6''')
  binop2addr(instr="div a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binop2addr(preinstr="div zero, a0, a1", instr="mflo a0", chkzero="1")
  write_line('''#endif''')

def op_div_int_lit16():
  write_line('''#ifdef MIPS32REVGE6''')
  binopLit16(instr="div a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binopLit16(preinstr="div zero, a0, a1", instr="mflo a0", chkzero="1")
  write_line('''#endif''')

def op_div_int_lit8():
  write_line('''#ifdef MIPS32REVGE6''')
  binopLit8(instr="div a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binopLit8(preinstr="div zero, a0, a1", instr="mflo a0", chkzero="1")
  write_line('''#endif''')

def op_div_long():
  binopWide(result0="v0", result1="v1", instr="JAL(__divdi3)", chkzero="1")

def op_div_long_2addr():
  binopWide2addr(result0="v0", result1="v1", instr="JAL(__divdi3)", chkzero="1")

def op_double_to_float():
  unopNarrower(instr="cvt.s.d fv0, fa0")

def op_double_to_int():
  write_line('''    /*''')
  write_line('''     * double-to-int''')
  write_line('''     *''')
  write_line('''     * We have to clip values to int min/max per the specification.  The''')
  write_line('''     * expected common case is a "reasonable" value that converts directly''')
  write_line('''     * to modest integer.  The EABI convert function isn't doing this for us''')
  write_line('''     * for pre-R6.''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[B]''')
  write_line('''    LOAD64_F(fa0, fa0f, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''#ifndef MIPS32REVGE6''')
  write_line('''    li        t0, INT_MIN_AS_DOUBLE_HIGH''')
  write_line('''    mtc1      zero, fa1''')
  write_line('''    MOVE_TO_FPU_HIGH(t0, fa1, fa1f)''')
  write_line('''    c.ole.d   fcc0, fa1, fa0''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''#ifndef MIPS32REVGE6''')
  write_line('''    bc1t      fcc0, 1f                     #  if INT_MIN <= vB, proceed to truncation''')
  write_line('''    c.eq.d    fcc0, fa0, fa0''')
  write_line('''    mtc1      zero, fa0''')
  write_line('''    MOVE_TO_FPU_HIGH(zero, fa0, fa0f)''')
  write_line('''    movt.d    fa0, fa1, fcc0               #  fa0 = ordered(vB) ? INT_MIN_AS_DOUBLE : 0''')
  write_line('''1:''')
  write_line('''#endif''')
  write_line('''    trunc.w.d fa0, fa0''')
  write_line('''    SET_VREG_F_GOTO(fa0, rOBJ, t1)         #  vA <- result''')

def op_double_to_long():
  write_line('''    /*''')
  write_line('''     * double-to-long''')
  write_line('''     *''')
  write_line('''     * We have to clip values to long min/max per the specification.  The''')
  write_line('''     * expected common case is a "reasonable" value that converts directly''')
  write_line('''     * to modest integer.  The EABI convert function isn't doing this for us''')
  write_line('''     * for pre-R6.''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[B]''')
  write_line('''    LOAD64_F(fa0, fa0f, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    trunc.l.d fa0, fa0''')
  write_line('''    SET_VREG64_F_GOTO(fa0, fa0f, rOBJ, t1) #  vA <- result''')
  write_line('''#else''')
  write_line('''    c.eq.d    fcc0, fa0, fa0''')
  write_line('''    li        rRESULT0, 0''')
  write_line('''    li        rRESULT1, 0''')
  write_line('''    bc1f      fcc0, .L''' + opcode + '''_get_opcode''')
  write_line('''''')
  write_line('''    li        t0, LONG_MIN_AS_DOUBLE_HIGH''')
  write_line('''    mtc1      zero, fa1''')
  write_line('''    MOVE_TO_FPU_HIGH(t0, fa1, fa1f)''')
  write_line('''    c.ole.d   fcc0, fa0, fa1''')
  write_line('''    li        rRESULT1, LONG_MIN_HIGH''')
  write_line('''    bc1t      fcc0, .L''' + opcode + '''_get_opcode''')
  write_line('''''')
  write_line('''    neg.d     fa1, fa1''')
  write_line('''    c.ole.d   fcc0, fa1, fa0''')
  write_line('''    nor       rRESULT0, rRESULT0, zero''')
  write_line('''    nor       rRESULT1, rRESULT1, zero''')
  write_line('''    bc1t      fcc0, .L''' + opcode + '''_get_opcode''')
  write_line('''''')
  write_line('''    JAL(__fixdfdi)''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    b         .L''' + opcode + '''_set_vreg''')
  write_line('''#endif''')
def op_double_to_long_sister_code():
  write_line('''''')
  write_line('''#ifndef MIPS32REVGE6''')
  write_line('''.L''' + opcode + '''_get_opcode:''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''.L''' + opcode + '''_set_vreg:''')
  write_line('''    SET_VREG64_GOTO(rRESULT0, rRESULT1, rOBJ, t1)   #  vA/vA+1 <- v0/v1''')
  write_line('''#endif''')

def op_fill_array_data():
  write_line('''    /* fill-array-data vAA, +BBBBBBBB */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    FETCH(a1, 1)                           #  a1 <- bbbb (lo)''')
  write_line('''    FETCH(a0, 2)                           #  a0 <- BBBB (hi)''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    INSERT_HIGH_HALF(a1, a0)               #  a1 <- BBBBbbbb''')
  write_line('''    GET_VREG(a0, a3)                       #  a0 <- vAA (array object)''')
  write_line('''    EAS1(a1, rPC, a1)                      #  a1 <- PC + BBBBbbbb*2 (array data off.)''')
  write_line('''    JAL(MterpFillArrayData)                #  v0 <- Mterp(obj, payload)''')
  write_line('''    beqz      v0,  MterpPossibleException  #  has exception''')
  write_line('''    FETCH_ADVANCE_INST(3)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        #  jump to next instruction''')

def op_filled_new_array(helper="MterpFilledNewArray"):
  write_line('''    /*''')
  write_line('''     * Create a new array with elements filled from registers.''')
  write_line('''     *''')
  write_line('''     * for: filled-new-array, filled-new-array/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, type@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC()''')
  write_line('''    addu   a0, rFP, OFF_FP_SHADOWFRAME     # a0 <- shadow frame''')
  write_line('''    move   a1, rPC''')
  write_line('''    move   a2, rSELF''')
  write_line('''    JAL(''' + helper + ''')                           #  v0 <- helper(shadow_frame, pc, self)''')
  write_line('''    beqz      v0,  MterpPossibleException  #  has exception''')
  write_line('''    FETCH_ADVANCE_INST(3)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        #  jump to next instruction''')

def op_filled_new_array_range():
  op_filled_new_array(helper="MterpFilledNewArrayRange")

def op_float_to_double():
  funopWider(instr="cvt.d.s fv0, fa0")

def op_float_to_int():
  write_line('''    /*''')
  write_line('''     * float-to-int''')
  write_line('''     *''')
  write_line('''     * We have to clip values to int min/max per the specification.  The''')
  write_line('''     * expected common case is a "reasonable" value that converts directly''')
  write_line('''     * to modest integer.  The EABI convert function isn't doing this for us''')
  write_line('''     * for pre-R6.''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_VREG_F(fa0, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifndef MIPS32REVGE6''')
  write_line('''    li        t0, INT_MIN_AS_FLOAT''')
  write_line('''    mtc1      t0, fa1''')
  write_line('''    c.ole.s   fcc0, fa1, fa0''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''#ifndef MIPS32REVGE6''')
  write_line('''    bc1t      fcc0, 1f                     #  if INT_MIN <= vB, proceed to truncation''')
  write_line('''    c.eq.s    fcc0, fa0, fa0''')
  write_line('''    mtc1      zero, fa0''')
  write_line('''    movt.s    fa0, fa1, fcc0               #  fa0 = ordered(vB) ? INT_MIN_AS_FLOAT : 0''')
  write_line('''1:''')
  write_line('''#endif''')
  write_line('''    trunc.w.s fa0, fa0''')
  write_line('''    SET_VREG_F_GOTO(fa0, rOBJ, t1)         #  vA <- result''')

def op_float_to_long():
  write_line('''    /*''')
  write_line('''     * float-to-long''')
  write_line('''     *''')
  write_line('''     * We have to clip values to long min/max per the specification.  The''')
  write_line('''     * expected common case is a "reasonable" value that converts directly''')
  write_line('''     * to modest integer.  The EABI convert function isn't doing this for us''')
  write_line('''     * for pre-R6.''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG_F(fa0, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    trunc.l.s fa0, fa0''')
  write_line('''    SET_VREG64_F_GOTO(fa0, fa0f, rOBJ, t1) #  vA <- result''')
  write_line('''#else''')
  write_line('''    c.eq.s    fcc0, fa0, fa0''')
  write_line('''    li        rRESULT0, 0''')
  write_line('''    li        rRESULT1, 0''')
  write_line('''    bc1f      fcc0, .L''' + opcode + '''_get_opcode''')
  write_line('''''')
  write_line('''    li        t0, LONG_MIN_AS_FLOAT''')
  write_line('''    mtc1      t0, fa1''')
  write_line('''    c.ole.s   fcc0, fa0, fa1''')
  write_line('''    li        rRESULT1, LONG_MIN_HIGH''')
  write_line('''    bc1t      fcc0, .L''' + opcode + '''_get_opcode''')
  write_line('''''')
  write_line('''    neg.s     fa1, fa1''')
  write_line('''    c.ole.s   fcc0, fa1, fa0''')
  write_line('''    nor       rRESULT0, rRESULT0, zero''')
  write_line('''    nor       rRESULT1, rRESULT1, zero''')
  write_line('''    bc1t      fcc0, .L''' + opcode + '''_get_opcode''')
  write_line('''''')
  write_line('''    JAL(__fixsfdi)''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    b         .L''' + opcode + '''_set_vreg''')
  write_line('''#endif''')
def op_float_to_long_sister_code():
  write_line('''''')
  write_line('''#ifndef MIPS32REVGE6''')
  write_line('''.L''' + opcode + '''_get_opcode:''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''.L''' + opcode + '''_set_vreg:''')
  write_line('''    SET_VREG64_GOTO(rRESULT0, rRESULT1, rOBJ, t1)   #  vA/vA+1 <- v0/v1''')
  write_line('''#endif''')

def op_goto():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 8-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto +AA */''')
  write_line('''    sll       a0, rINST, 16                #  a0 <- AAxx0000''')
  write_line('''    sra       rINST, a0, 24                #  rINST <- ssssssAA (sign-extended)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_16():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 16-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto/16 +AAAA */''')
  write_line('''    FETCH_S(rINST, 1)                      #  rINST <- ssssAAAA (sign-extended)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_32():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 32-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     *''')
  write_line('''     * Unlike most opcodes, this one is allowed to branch to itself, so''')
  write_line('''     * our "backward branch" test must be "<=0" instead of "<0".''')
  write_line('''     */''')
  write_line('''    /* goto/32 +AAAAAAAA */''')
  write_line('''    FETCH(rINST, 1)                        #  rINST <- aaaa (lo)''')
  write_line('''    FETCH(a1, 2)                           #  a1 <- AAAA (hi)''')
  write_line('''    INSERT_HIGH_HALF(rINST, a1)            #  rINST <- AAAAaaaa''')
  write_line('''    b         MterpCommonTakenBranchNoFlags''')

def op_if_eq():
  bincmp(condition="eq")

def op_if_eqz():
  zcmp(condition="eq")

def op_if_ge():
  bincmp(condition="ge")

def op_if_gez():
  zcmp(condition="ge")

def op_if_gt():
  bincmp(condition="gt")

def op_if_gtz():
  zcmp(condition="gt")

def op_if_le():
  bincmp(condition="le")

def op_if_lez():
  zcmp(condition="le")

def op_if_lt():
  bincmp(condition="lt")

def op_if_ltz():
  zcmp(condition="lt")

def op_if_ne():
  bincmp(condition="ne")

def op_if_nez():
  zcmp(condition="ne")

def op_iget(is_object="0", helper="MterpIGetU32"):
  field(helper=helper)

def op_iget_boolean():
  op_iget(helper="MterpIGetU8")

def op_iget_boolean_quick():
  op_iget_quick(load="lbu")

def op_iget_byte():
  op_iget(helper="MterpIGetI8")

def op_iget_byte_quick():
  op_iget_quick(load="lb")

def op_iget_char():
  op_iget(helper="MterpIGetU16")

def op_iget_char_quick():
  op_iget_quick(load="lhu")

def op_iget_object():
  op_iget(is_object="1", helper="MterpIGetObj")

def op_iget_object_quick():
  write_line('''    /* For: iget-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    GET_OPB(a2)                            #  a2 <- B''')
  write_line('''    FETCH(a1, 1)                           #  a1 <- field byte offset''')
  write_line('''    EXPORT_PC()''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- object we're operating on''')
  write_line('''    JAL(artIGetObjectFromMterp)            #  v0 <- GetObj(obj, offset)''')
  write_line('''    lw   a3, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    GET_OPA4(a2)                           #  a2<- A+''')
  write_line('''    PREFETCH_INST(2)                       #  load rINST''')
  write_line('''    bnez a3, MterpPossibleException        #  bail out''')
  write_line('''    ADVANCE(2)                             #  advance rPC''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_OBJECT_GOTO(v0, a2, t0)       #  fp[A] <- v0''')

def op_iget_quick(load="lw"):
  write_line('''    /* For: iget-quick, iget-boolean-quick, iget-byte-quick, iget-char-quick, iget-short-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    GET_OPB(a2)                            #  a2 <- B''')
  write_line('''    GET_VREG(a3, a2)                       #  a3 <- object we're operating on''')
  write_line('''    FETCH(a1, 1)                           #  a1 <- field byte offset''')
  write_line('''    GET_OPA4(a2)                           #  a2 <- A(+)''')
  write_line('''    # check object for null''')
  write_line('''    beqz      a3, common_errNullObject     #  object was null''')
  write_line('''    addu      t0, a3, a1''')
  write_line('''    ''' + load + '''     a0, 0(t0)                    #  a0 <- obj.field (8/16/32 bits)''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(a0, a2, t0)              #  fp[A] <- a0''')

def op_iget_short():
  op_iget(helper="MterpIGetI16")

def op_iget_short_quick():
  op_iget_quick(load="lh")

def op_iget_wide():
  op_iget(helper="MterpIGetU64")

def op_iget_wide_quick():
  write_line('''    /* iget-wide-quick vA, vB, offset@CCCC */''')
  write_line('''    GET_OPB(a2)                            #  a2 <- B''')
  write_line('''    GET_VREG(a3, a2)                       #  a3 <- object we're operating on''')
  write_line('''    FETCH(a1, 1)                           #  a1 <- field byte offset''')
  write_line('''    GET_OPA4(a2)                           #  a2 <- A(+)''')
  write_line('''    # check object for null''')
  write_line('''    beqz      a3, common_errNullObject     #  object was null''')
  write_line('''    addu      t0, a3, a1                   #  t0 <- a3 + a1''')
  write_line('''    LOAD64(a0, a1, t0)                     #  a0 <- obj.field (64 bits, aligned)''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a2, t0)        #  fp[A] <- a0/a1''')

def op_instance_of():
  write_line('''    /*''')
  write_line('''     * Check to see if an object reference is an instance of a class.''')
  write_line('''     *''')
  write_line('''     * Most common situation is a non-null object, being compared against''')
  write_line('''     * an already-resolved class.''')
  write_line('''     */''')
  write_line('''    /* instance-of vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    FETCH(a0, 1)                           # a0 <- CCCC''')
  write_line('''    GET_OPB(a1)                            # a1 <- B''')
  write_line('''    EAS2(a1, rFP, a1)                      # a1 <- &object''')
  write_line('''    lw    a2, OFF_FP_METHOD(rFP)           # a2 <- method''')
  write_line('''    move  a3, rSELF                        # a3 <- self''')
  write_line('''    GET_OPA4(rOBJ)                         # rOBJ <- A+''')
  write_line('''    JAL(MterpInstanceOf)                   # v0 <- Mterp(index, &obj, method, self)''')
  write_line('''    lw   a1, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    PREFETCH_INST(2)                       # load rINST''')
  write_line('''    bnez a1, MterpException''')
  write_line('''    ADVANCE(2)                             # advance rPC''')
  write_line('''    GET_INST_OPCODE(t0)                    # extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(v0, rOBJ, t0)            # vA <- v0''')

def op_int_to_byte():
  unop(instr="SEB(a0, a0)")

def op_int_to_char():
  unop(preinstr="", instr="and a0, 0xffff")

def op_int_to_double():
  funopWider(instr="cvt.d.w fv0, fa0")

def op_int_to_float():
  funop(instr="cvt.s.w fv0, fa0")

def op_int_to_long():
  unopWider(instr="sra a1, a0, 31")

def op_int_to_short():
  unop(instr="SEH(a0, a0)")

def op_invoke_custom():
  invoke(helper="MterpInvokeCustom")

def op_invoke_custom_range():
  invoke(helper="MterpInvokeCustomRange")

def op_invoke_direct():
  invoke(helper="MterpInvokeDirect")

def op_invoke_direct_range():
  invoke(helper="MterpInvokeDirectRange")

def op_invoke_interface():
  invoke(helper="MterpInvokeInterface")

def op_invoke_interface_range():
  invoke(helper="MterpInvokeInterfaceRange")

def op_invoke_polymorphic():
  invoke_polymorphic(helper="MterpInvokePolymorphic")

def op_invoke_polymorphic_range():
  invoke_polymorphic(helper="MterpInvokePolymorphicRange")

def op_invoke_static():
  invoke(helper="MterpInvokeStatic")

def op_invoke_static_range():
  invoke(helper="MterpInvokeStaticRange")

def op_invoke_super():
  invoke(helper="MterpInvokeSuper")

def op_invoke_super_range():
  invoke(helper="MterpInvokeSuperRange")

def op_invoke_virtual():
  invoke(helper="MterpInvokeVirtual")

def op_invoke_virtual_quick():
  invoke(helper="MterpInvokeVirtualQuick")

def op_invoke_virtual_range():
  invoke(helper="MterpInvokeVirtualRange")

def op_invoke_virtual_range_quick():
  invoke(helper="MterpInvokeVirtualQuickRange")

def op_iput(is_object="0", helper="MterpIPutU32"):
  field(helper=helper)

def op_iput_boolean():
  op_iput(helper="MterpIPutU8")

def op_iput_boolean_quick():
  op_iput_quick(store="sb")

def op_iput_byte():
  op_iput(helper="MterpIPutI8")

def op_iput_byte_quick():
  op_iput_quick(store="sb")

def op_iput_char():
  op_iput(helper="MterpIPutU16")

def op_iput_char_quick():
  op_iput_quick(store="sh")

def op_iput_object():
  op_iput(is_object="1", helper="MterpIPutObj")

def op_iput_object_quick():
  write_line('''    /* For: iput-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    addu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move   a1, rPC''')
  write_line('''    move   a2, rINST''')
  write_line('''    JAL(MterpIputObjectQuick)''')
  write_line('''    beqz   v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST(2)               # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')

def op_iput_quick(store="sw"):
  write_line('''    /* For: iput-quick, iput-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    GET_OPB(a2)                            #  a2 <- B''')
  write_line('''    GET_VREG(a3, a2)                       #  a3 <- fp[B], the object pointer''')
  write_line('''    FETCH(a1, 1)                           #  a1 <- field byte offset''')
  write_line('''    GET_OPA4(a2)                           #  a2 <- A(+)''')
  write_line('''    beqz      a3, common_errNullObject     #  object was null''')
  write_line('''    GET_VREG(a0, a2)                       #  a0 <- fp[A]''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    addu      t0, a3, a1''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    GET_OPCODE_TARGET(t1)''')
  write_line('''    ''' + store + '''    a0, 0(t0)                    #  obj.field (8/16/32 bits) <- a0''')
  write_line('''    JR(t1)                                 #  jump to next instruction''')

def op_iput_short():
  op_iput(helper="MterpIPutI16")

def op_iput_short_quick():
  op_iput_quick(store="sh")

def op_iput_wide():
  op_iput(helper="MterpIPutU64")

def op_iput_wide_quick():
  write_line('''    /* iput-wide-quick vA, vB, offset@CCCC */''')
  write_line('''    GET_OPA4(a0)                           #  a0 <- A(+)''')
  write_line('''    GET_OPB(a1)                            #  a1 <- B''')
  write_line('''    GET_VREG(a2, a1)                       #  a2 <- fp[B], the object pointer''')
  write_line('''    # check object for null''')
  write_line('''    beqz      a2, common_errNullObject     #  object was null''')
  write_line('''    EAS2(a3, rFP, a0)                      #  a3 <- &fp[A]''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- fp[A]''')
  write_line('''    FETCH(a3, 1)                           #  a3 <- field byte offset''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    addu      a2, a2, a3                   #  obj.field (64 bits, aligned) <- a0/a1''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GET_OPCODE_TARGET(t0)''')
  write_line('''    STORE64(a0, a1, a2)                    #  obj.field (64 bits, aligned) <- a0/a1''')
  write_line('''    JR(t0)                                 #  jump to next instruction''')

def op_long_to_double():
  write_line('''    /*''')
  write_line('''     * long-to-double''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[B]''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    LOAD64_F(fv0, fv0f, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    cvt.d.l   fv0, fv0''')
  write_line('''#else''')
  write_line('''    LOAD64(rARG0, rARG1, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    JAL(__floatdidf)                       #  a0/a1 <- op, a2-a3 changed''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_F_GOTO(fv0, fv0f, rOBJ, t0) #  vA/vA+1 <- result''')

def op_long_to_float():
  write_line('''    /*''')
  write_line('''     * long-to-float''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[B]''')
  write_line('''''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    LOAD64_F(fv0, fv0f, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    cvt.s.l   fv0, fv0''')
  write_line('''#else''')
  write_line('''    LOAD64(rARG0, rARG1, a3)''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    JAL(__floatdisf)''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_F_GOTO(fv0, rOBJ, t0)         #  vA <- fv0''')

def op_long_to_int():
  write_line('''/* we ignore the high word, making this equivalent to a 32-bit reg move */''')
  op_move()

def op_monitor_enter():
  write_line('''    /*''')
  write_line('''     * Synchronize on an object.''')
  write_line('''     */''')
  write_line('''    /* monitor-enter vAA */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    GET_OPA(a2)                            # a2 <- AA''')
  write_line('''    GET_VREG(a0, a2)                       # a0 <- vAA (object)''')
  write_line('''    move   a1, rSELF                       # a1 <- self''')
  write_line('''    JAL(artLockObjectFromCode)             # v0 <- artLockObject(obj, self)''')
  write_line('''    bnez v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST(1)                  # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        # jump to next instruction''')

def op_monitor_exit():
  write_line('''    /*''')
  write_line('''     * Unlock an object.''')
  write_line('''     *''')
  write_line('''     * Exceptions that occur when unlocking a monitor need to appear as''')
  write_line('''     * if they happened at the following instruction.  See the Dalvik''')
  write_line('''     * instruction spec.''')
  write_line('''     */''')
  write_line('''    /* monitor-exit vAA */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    GET_OPA(a2)                            # a2 <- AA''')
  write_line('''    GET_VREG(a0, a2)                       # a0 <- vAA (object)''')
  write_line('''    move   a1, rSELF                       # a1 <- self''')
  write_line('''    JAL(artUnlockObjectFromCode)           # v0 <- artUnlockObject(obj, self)''')
  write_line('''    bnez v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST(1)                  # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        # jump to next instruction''')

def op_move(is_object="0"):
  write_line('''    /* for move, move-object, long-to-int */''')
  write_line('''    /* op vA, vB */''')
  write_line('''    GET_OPB(a1)                            #  a1 <- B from 15:12''')
  write_line('''    GET_OPA4(a0)                           #  a0 <- A from 11:8''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_VREG(a2, a1)                       #  a2 <- fp[B]''')
  write_line('''    GET_INST_OPCODE(t0)                    #  t0 <- opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT_GOTO(a2, a0, t0)       #  fp[A] <- a2''')
  write_line('''    .else''')
  write_line('''    SET_VREG_GOTO(a2, a0, t0)              #  fp[A] <- a2''')
  write_line('''    .endif''')

def op_move_16(is_object="0"):
  write_line('''    /* for: move/16, move-object/16 */''')
  write_line('''    /* op vAAAA, vBBBB */''')
  write_line('''    FETCH(a1, 2)                           #  a1 <- BBBB''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- AAAA''')
  write_line('''    FETCH_ADVANCE_INST(3)                  #  advance rPC, load rINST''')
  write_line('''    GET_VREG(a2, a1)                       #  a2 <- fp[BBBB]''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT_GOTO(a2, a0, t0)       #  fp[AAAA] <- a2''')
  write_line('''    .else''')
  write_line('''    SET_VREG_GOTO(a2, a0, t0)              #  fp[AAAA] <- a2''')
  write_line('''    .endif''')

def op_move_exception():
  write_line('''    /* move-exception vAA */''')
  write_line('''    GET_OPA(a2)                                 #  a2 <- AA''')
  write_line('''    lw    a3, THREAD_EXCEPTION_OFFSET(rSELF)    #  get exception obj''')
  write_line('''    FETCH_ADVANCE_INST(1)                       #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                         #  extract opcode from rINST''')
  write_line('''    GET_OPCODE_TARGET(t0)''')
  write_line('''    SET_VREG_OBJECT(a3, a2)                     #  fp[AA] <- exception obj''')
  write_line('''    sw    zero, THREAD_EXCEPTION_OFFSET(rSELF)  #  clear exception''')
  write_line('''    JR(t0)                                      #  jump to next instruction''')

def op_move_from16(is_object="0"):
  write_line('''    /* for: move/from16, move-object/from16 */''')
  write_line('''    /* op vAA, vBBBB */''')
  write_line('''    FETCH(a1, 1)                           #  a1 <- BBBB''')
  write_line('''    GET_OPA(a0)                            #  a0 <- AA''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_VREG(a2, a1)                       #  a2 <- fp[BBBB]''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT_GOTO(a2, a0, t0)       #  fp[AA] <- a2''')
  write_line('''    .else''')
  write_line('''    SET_VREG_GOTO(a2, a0, t0)              #  fp[AA] <- a2''')
  write_line('''    .endif''')

def op_move_object():
  op_move(is_object="1")

def op_move_object_16():
  op_move_16(is_object="1")

def op_move_object_from16():
  op_move_from16(is_object="1")

def op_move_result(is_object="0"):
  write_line('''    /* for: move-result, move-result-object */''')
  write_line('''    /* op vAA */''')
  write_line('''    GET_OPA(a2)                            #  a2 <- AA''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    lw    a0, OFF_FP_RESULT_REGISTER(rFP)  #  get pointer to result JType''')
  write_line('''    lw    a0, 0(a0)                        #  a0 <- result.i''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT_GOTO(a0, a2, t0)       #  fp[AA] <- a0''')
  write_line('''    .else''')
  write_line('''    SET_VREG_GOTO(a0, a2, t0)              #  fp[AA] <- a0''')
  write_line('''    .endif''')

def op_move_result_object():
  op_move_result(is_object="1")

def op_move_result_wide():
  write_line('''    /* move-result-wide vAA */''')
  write_line('''    GET_OPA(a2)                            #  a2 <- AA''')
  write_line('''    lw    a3, OFF_FP_RESULT_REGISTER(rFP)  #  get pointer to result JType''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- retval.j''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a2, t0)        #  fp[AA] <- a0/a1''')

def op_move_wide():
  write_line('''    /* move-wide vA, vB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6, v7" or "move v7, v6" */''')
  write_line('''    GET_OPA4(a2)                           #  a2 <- A(+)''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[B]''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- fp[B]''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a2, t0)        #  fp[A] <- a0/a1''')

def op_move_wide_16():
  write_line('''    /* move-wide/16 vAAAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6, v7" or "move v7, v6" */''')
  write_line('''    FETCH(a3, 2)                           #  a3 <- BBBB''')
  write_line('''    FETCH(a2, 1)                           #  a2 <- AAAA''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[BBBB]''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- fp[BBBB]''')
  write_line('''    FETCH_ADVANCE_INST(3)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a2, t0)        #  fp[AAAA] <- a0/a1''')

def op_move_wide_from16():
  write_line('''    /* move-wide/from16 vAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6, v7" or "move v7, v6" */''')
  write_line('''    FETCH(a3, 1)                           #  a3 <- BBBB''')
  write_line('''    GET_OPA(a2)                            #  a2 <- AA''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[BBBB]''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- fp[BBBB]''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(a0, a1, a2, t0)        #  fp[AA] <- a0/a1''')

def op_mul_double():
  fbinopWide(instr="mul.d fv0, fa0, fa1")

def op_mul_double_2addr():
  fbinopWide2addr(instr="mul.d fv0, fa0, fa1")

def op_mul_float():
  fbinop(instr="mul.s fv0, fa0, fa1")

def op_mul_float_2addr():
  fbinop2addr(instr="mul.s fv0, fa0, fa1")

def op_mul_int():
  binop(instr="mul a0, a0, a1")

def op_mul_int_2addr():
  binop2addr(instr="mul a0, a0, a1")

def op_mul_int_lit16():
  binopLit16(instr="mul a0, a0, a1")

def op_mul_int_lit8():
  binopLit8(instr="mul a0, a0, a1")

def op_mul_long():
  write_line('''    /*''')
  write_line('''     * Signed 64-bit integer multiply.''')
  write_line('''     *         a1   a0''')
  write_line('''     *   x     a3   a2''')
  write_line('''     *   -------------''')
  write_line('''     *       a2a1 a2a0''')
  write_line('''     *       a3a0''')
  write_line('''     *  a3a1 (<= unused)''')
  write_line('''     *  ---------------''')
  write_line('''     *         v1   v0''')
  write_line('''     */''')
  write_line('''    /* mul-long vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    and       t0, a0, 255                  #  a2 <- BB''')
  write_line('''    srl       t1, a0, 8                    #  a3 <- CC''')
  write_line('''    EAS2(t0, rFP, t0)                      #  t0 <- &fp[BB]''')
  write_line('''    LOAD64(a0, a1, t0)                     #  a0/a1 <- vBB/vBB+1''')
  write_line('''''')
  write_line('''    EAS2(t1, rFP, t1)                      #  t0 <- &fp[CC]''')
  write_line('''    LOAD64(a2, a3, t1)                     #  a2/a3 <- vCC/vCC+1''')
  write_line('''''')
  write_line('''    mul       v1, a3, a0                   #  v1= a3a0''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    mulu      v0, a2, a0                   #  v0= a2a0''')
  write_line('''    muhu      t1, a2, a0''')
  write_line('''#else''')
  write_line('''    multu     a2, a0''')
  write_line('''    mfhi      t1''')
  write_line('''    mflo      v0                           #  v0= a2a0''')
  write_line('''#endif''')
  write_line('''    mul       t0, a2, a1                   #  t0= a2a1''')
  write_line('''    addu      v1, v1, t1                   #  v1+= hi(a2a0)''')
  write_line('''    addu      v1, v1, t0                   #  v1= a3a0 + a2a1;''')
  write_line('''''')
  write_line('''    GET_OPA(a0)                            #  a0 <- AA''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    b         .L''' + opcode + '''_finish''')
def op_mul_long_sister_code():
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(v0, v1, a0, t0)        #  vAA/vAA+1 <- v0(low)/v1(high)''')

def op_mul_long_2addr():
  write_line('''    /*''')
  write_line('''     * See op_mul_long.S for more details''')
  write_line('''     */''')
  write_line('''    /* mul-long/2addr vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''''')
  write_line('''    EAS2(t0, rFP, rOBJ)                    #  t0 <- &fp[A]''')
  write_line('''    LOAD64(a0, a1, t0)                     #  vAA.low / high''')
  write_line('''''')
  write_line('''    GET_OPB(t1)                            #  t1 <- B''')
  write_line('''    EAS2(t1, rFP, t1)                      #  t1 <- &fp[B]''')
  write_line('''    LOAD64(a2, a3, t1)                     #  vBB.low / high''')
  write_line('''''')
  write_line('''    mul       v1, a3, a0                   #  v1= a3a0''')
  write_line('''#ifdef MIPS32REVGE6''')
  write_line('''    mulu      v0, a2, a0                   #  v0= a2a0''')
  write_line('''    muhu      t1, a2, a0''')
  write_line('''#else''')
  write_line('''    multu     a2, a0''')
  write_line('''    mfhi      t1''')
  write_line('''    mflo      v0                           #  v0= a2a0''')
  write_line(''' #endif''')
  write_line('''    mul       t2, a2, a1                   #  t2= a2a1''')
  write_line('''    addu      v1, v1, t1                   #  v1= a3a0 + hi(a2a0)''')
  write_line('''    addu      v1, v1, t2                   #  v1= v1 + a2a1;''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(v0, v1, rOBJ, t1)      #  vA/vA+1 <- v0(low)/v1(high)''')

def op_neg_double():
  unopWide(instr="addu a1, a1, 0x80000000")

def op_neg_float():
  unop(instr="addu a0, a0, 0x80000000")

def op_neg_int():
  unop(instr="negu a0, a0")

def op_neg_long():
  unopWide(result0="v0", result1="v1", preinstr="negu v0, a0", instr="negu v1, a1; sltu a0, zero, v0; subu v1, v1, a0")

def op_new_array():
  write_line('''    /*''')
  write_line('''     * Allocate an array of objects, specified with the array class''')
  write_line('''     * and a count.''')
  write_line('''     *''')
  write_line('''     * The verifier guarantees that this is an array class, so we don't''')
  write_line('''     * check for it here.''')
  write_line('''     */''')
  write_line('''    /* new-array vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    addu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move   a1, rPC''')
  write_line('''    move   a2, rINST''')
  write_line('''    move   a3, rSELF''')
  write_line('''    JAL(MterpNewArray)''')
  write_line('''    beqz   v0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST(2)               # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')

def op_new_instance():
  write_line('''    /*''')
  write_line('''     * Create a new instance of a class.''')
  write_line('''     */''')
  write_line('''    /* new-instance vAA, class@BBBB */''')
  write_line('''    EXPORT_PC()''')
  write_line('''    addu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move   a1, rSELF''')
  write_line('''    move   a2, rINST''')
  write_line('''    JAL(MterpNewInstance)''')
  write_line('''    beqz   v0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST(2)               # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                 # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                     # jump to next instruction''')

def op_nop():
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        #  jump to next instruction''')

def op_not_int():
  unop(instr="not a0, a0")

def op_not_long():
  unopWide(preinstr="not a0, a0", instr="not a1, a1")

def op_or_int():
  binop(instr="or a0, a0, a1")

def op_or_int_2addr():
  binop2addr(instr="or a0, a0, a1")

def op_or_int_lit16():
  binopLit16(instr="or a0, a0, a1")

def op_or_int_lit8():
  binopLit8(instr="or a0, a0, a1")

def op_or_long():
  binopWide(preinstr="or a0, a0, a2", instr="or a1, a1, a3")

def op_or_long_2addr():
  binopWide2addr(preinstr="or a0, a0, a2", instr="or a1, a1, a3")

def op_packed_switch(func="MterpDoPackedSwitch"):
  write_line('''    /*''')
  write_line('''     * Handle a packed-switch or sparse-switch instruction.  In both cases''')
  write_line('''     * we decode it and hand it off to a helper function.''')
  write_line('''     *''')
  write_line('''     * We don't really expect backward branches in a switch statement, but''')
  write_line('''     * they're perfectly legal, so we check for them here.''')
  write_line('''     *''')
  write_line('''     * for: packed-switch, sparse-switch''')
  write_line('''     */''')
  write_line('''    /* op vAA, +BBBB */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- bbbb (lo)''')
  write_line('''    FETCH(a1, 2)                           #  a1 <- BBBB (hi)''')
  write_line('''    GET_OPA(a3)                            #  a3 <- AA''')
  write_line('''    INSERT_HIGH_HALF(a0, a1)               #  a0 <- BBBBbbbb''')
  write_line('''    GET_VREG(a1, a3)                       #  a1 <- vAA''')
  write_line('''    EAS1(a0, rPC, a0)                      #  a0 <- PC + BBBBbbbb*2''')
  write_line('''    JAL(''' + func + ''')                             #  a0 <- code-unit branch offset''')
  write_line('''    move      rINST, v0''')
  write_line('''    b         MterpCommonTakenBranchNoFlags''')

def op_rem_double():
  fbinopWide(instr="JAL(fmod)")

def op_rem_double_2addr():
  fbinopWide2addr(instr="JAL(fmod)")

def op_rem_float():
  fbinop(instr="JAL(fmodf)")

def op_rem_float_2addr():
  fbinop2addr(instr="JAL(fmodf)")

def op_rem_int():
  write_line('''#ifdef MIPS32REVGE6''')
  binop(instr="mod a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binop(preinstr="div zero, a0, a1", instr="mfhi a0", chkzero="1")
  write_line('''#endif''')

def op_rem_int_2addr():
  write_line('''#ifdef MIPS32REVGE6''')
  binop2addr(instr="mod a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binop2addr(preinstr="div zero, a0, a1", instr="mfhi a0", chkzero="1")
  write_line('''#endif''')

def op_rem_int_lit16():
  write_line('''#ifdef MIPS32REVGE6''')
  binopLit16(instr="mod a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binopLit16(preinstr="div zero, a0, a1", instr="mfhi a0", chkzero="1")
  write_line('''#endif''')

def op_rem_int_lit8():
  write_line('''#ifdef MIPS32REVGE6''')
  binopLit8(instr="mod a0, a0, a1", chkzero="1")
  write_line('''#else''')
  binopLit8(preinstr="div zero, a0, a1", instr="mfhi a0", chkzero="1")
  write_line('''#endif''')

def op_rem_long():
  binopWide(result0="v0", result1="v1", instr="JAL(__moddi3)", chkzero="1")

def op_rem_long_2addr():
  binopWide2addr(result0="v0", result1="v1", instr="JAL(__moddi3)", chkzero="1")

def op_return():
  write_line('''    /*''')
  write_line('''     * Return a 32-bit value.''')
  write_line('''     *''')
  write_line('''     * for: return, return-object''')
  write_line('''     */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    JAL(MterpThreadFenceForConstructor)''')
  write_line('''    lw        ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move      a0, rSELF''')
  write_line('''    and       ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqz      ra, 1f''')
  write_line('''    JAL(MterpSuspendCheck)                 # (self)''')
  write_line('''1:''')
  write_line('''    GET_OPA(a2)                            #  a2 <- AA''')
  write_line('''    GET_VREG(v0, a2)                       #  v0 <- vAA''')
  write_line('''    move      v1, zero''')
  write_line('''    b         MterpReturn''')

def op_return_object():
  op_return()

def op_return_void():
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    JAL(MterpThreadFenceForConstructor)''')
  write_line('''    lw        ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move      a0, rSELF''')
  write_line('''    and       ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqz      ra, 1f''')
  write_line('''    JAL(MterpSuspendCheck)                 # (self)''')
  write_line('''1:''')
  write_line('''    move      v0, zero''')
  write_line('''    move      v1, zero''')
  write_line('''    b         MterpReturn''')

def op_return_void_no_barrier():
  write_line('''    lw     ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move   a0, rSELF''')
  write_line('''    and    ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqz   ra, 1f''')
  write_line('''    JAL(MterpSuspendCheck)                 # (self)''')
  write_line('''1:''')
  write_line('''    move   v0, zero''')
  write_line('''    move   v1, zero''')
  write_line('''    b      MterpReturn''')

def op_return_wide():
  write_line('''    /*''')
  write_line('''     * Return a 64-bit value.''')
  write_line('''     */''')
  write_line('''    /* return-wide vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    JAL(MterpThreadFenceForConstructor)''')
  write_line('''    lw        ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move      a0, rSELF''')
  write_line('''    and       ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqz      ra, 1f''')
  write_line('''    JAL(MterpSuspendCheck)                 # (self)''')
  write_line('''1:''')
  write_line('''    GET_OPA(a2)                            #  a2 <- AA''')
  write_line('''    EAS2(a2, rFP, a2)                      #  a2 <- &fp[AA]''')
  write_line('''    LOAD64(v0, v1, a2)                     #  v0/v1 <- vAA/vAA+1''')
  write_line('''    b         MterpReturn''')

def op_rsub_int():
  write_line('''/* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */''')
  binopLit16(instr="subu a0, a1, a0")

def op_rsub_int_lit8():
  binopLit8(instr="subu a0, a1, a0")

def op_sget(is_object="0", helper="MterpSGetU32"):
  field(helper=helper)

def op_sget_boolean():
  op_sget(helper="MterpSGetU8")

def op_sget_byte():
  op_sget(helper="MterpSGetI8")

def op_sget_char():
  op_sget(helper="MterpSGetU16")

def op_sget_object():
  op_sget(is_object="1", helper="MterpSGetObj")

def op_sget_short():
  op_sget(helper="MterpSGetI16")

def op_sget_wide():
  op_sget(helper="MterpSGetU64")

def op_shl_int():
  binop(instr="sll a0, a0, a1")

def op_shl_int_2addr():
  binop2addr(instr="sll a0, a0, a1")

def op_shl_int_lit8():
  binopLit8(instr="sll a0, a0, a1")

def op_shl_long():
  write_line('''    /*''')
  write_line('''     * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line('''     * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line('''     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line('''     * 6 bits of the shift distance.''')
  write_line('''     */''')
  write_line('''    /* shl-long vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(t2)                            #  t2 <- AA''')
  write_line('''    and       a3, a0, 255                  #  a3 <- BB''')
  write_line('''    srl       a0, a0, 8                    #  a0 <- CC''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[BB]''')
  write_line('''    GET_VREG(a2, a0)                       #  a2 <- vCC''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- vBB/vBB+1''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''''')
  write_line('''    andi    v1, a2, 0x20                   #  shift< shift & 0x20''')
  write_line('''    sll     v0, a0, a2                     #  rlo<- alo << (shift&31)''')
  write_line('''    bnez    v1, .L''' + opcode + '''_finish''')
  write_line('''    not     v1, a2                         #  rhi<- 31-shift  (shift is 5b)''')
  write_line('''    srl     a0, 1''')
  write_line('''    srl     a0, v1                         #  alo<- alo >> (32-(shift&31))''')
  write_line('''    sll     v1, a1, a2                     #  rhi<- ahi << (shift&31)''')
  write_line('''    or      v1, a0                         #  rhi<- rhi | alo''')
  write_line('''    SET_VREG64_GOTO(v0, v1, t2, t0)        #  vAA/vAA+1 <- v0/v1''')
def op_shl_long_sister_code():
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG64_GOTO(zero, v0, t2, t0)      #  vAA/vAA+1 <- rlo/rhi''')

def op_shl_long_2addr():
  write_line('''    /*''')
  write_line('''     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line('''     * 32-bit shift distance.''')
  write_line('''     */''')
  write_line('''    /* shl-long/2addr vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG(a2, a3)                       #  a2 <- vB''')
  write_line('''    EAS2(t2, rFP, rOBJ)                    #  t2 <- &fp[A]''')
  write_line('''    LOAD64(a0, a1, t2)                     #  a0/a1 <- vA/vA+1''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''''')
  write_line('''    andi    v1, a2, 0x20                   #  shift< shift & 0x20''')
  write_line('''    sll     v0, a0, a2                     #  rlo<- alo << (shift&31)''')
  write_line('''    bnez    v1, .L''' + opcode + '''_finish''')
  write_line('''    not     v1, a2                         #  rhi<- 31-shift  (shift is 5b)''')
  write_line('''    srl     a0, 1''')
  write_line('''    srl     a0, v1                         #  alo<- alo >> (32-(shift&31))''')
  write_line('''    sll     v1, a1, a2                     #  rhi<- ahi << (shift&31)''')
  write_line('''    or      v1, a0                         #  rhi<- rhi | alo''')
  write_line('''    SET_VREG64_GOTO(v0, v1, rOBJ, t0)      #  vA/vA+1 <- v0/v1''')
def op_shl_long_2addr_sister_code():
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG64_GOTO(zero, v0, rOBJ, t0)    #  vA/vA+1 <- rlo/rhi''')

def op_shr_int():
  binop(instr="sra a0, a0, a1")

def op_shr_int_2addr():
  binop2addr(instr="sra a0, a0, a1")

def op_shr_int_lit8():
  binopLit8(instr="sra a0, a0, a1")

def op_shr_long():
  write_line('''    /*''')
  write_line('''     * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line('''     * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line('''     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line('''     * 6 bits of the shift distance.''')
  write_line('''     */''')
  write_line('''    /* shr-long vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(t3)                            #  t3 <- AA''')
  write_line('''    and       a3, a0, 255                  #  a3 <- BB''')
  write_line('''    srl       a0, a0, 8                    #  a0 <- CC''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[BB]''')
  write_line('''    GET_VREG(a2, a0)                       #  a2 <- vCC''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- vBB/vBB+1''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''''')
  write_line('''    andi    v0, a2, 0x20                   #  shift & 0x20''')
  write_line('''    sra     v1, a1, a2                     #  rhi<- ahi >> (shift&31)''')
  write_line('''    bnez    v0, .L''' + opcode + '''_finish''')
  write_line('''    srl     v0, a0, a2                     #  rlo<- alo >> (shift&31)''')
  write_line('''    not     a0, a2                         #  alo<- 31-shift (shift is 5b)''')
  write_line('''    sll     a1, 1''')
  write_line('''    sll     a1, a0                         #  ahi<- ahi << (32-(shift&31))''')
  write_line('''    or      v0, a1                         #  rlo<- rlo | ahi''')
  write_line('''    SET_VREG64_GOTO(v0, v1, t3, t0)        #  vAA/VAA+1 <- v0/v1''')
def op_shr_long_sister_code():
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    sra     a3, a1, 31                     #  a3<- sign(ah)''')
  write_line('''    SET_VREG64_GOTO(v1, a3, t3, t0)        #  vAA/VAA+1 <- rlo/rhi''')

def op_shr_long_2addr():
  write_line('''    /*''')
  write_line('''     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line('''     * 32-bit shift distance.''')
  write_line('''     */''')
  write_line('''    /* shr-long/2addr vA, vB */''')
  write_line('''    GET_OPA4(t2)                           #  t2 <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG(a2, a3)                       #  a2 <- vB''')
  write_line('''    EAS2(t0, rFP, t2)                      #  t0 <- &fp[A]''')
  write_line('''    LOAD64(a0, a1, t0)                     #  a0/a1 <- vA/vA+1''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''''')
  write_line('''    andi    v0, a2, 0x20                   #  shift & 0x20''')
  write_line('''    sra     v1, a1, a2                     #  rhi<- ahi >> (shift&31)''')
  write_line('''    bnez    v0, .L''' + opcode + '''_finish''')
  write_line('''    srl     v0, a0, a2                     #  rlo<- alo >> (shift&31)''')
  write_line('''    not     a0, a2                         #  alo<- 31-shift (shift is 5b)''')
  write_line('''    sll     a1, 1''')
  write_line('''    sll     a1, a0                         #  ahi<- ahi << (32-(shift&31))''')
  write_line('''    or      v0, a1                         #  rlo<- rlo | ahi''')
  write_line('''    SET_VREG64_GOTO(v0, v1, t2, t0)        #  vA/vA+1 <- v0/v1''')
def op_shr_long_2addr_sister_code():
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    sra     a3, a1, 31                     #  a3<- sign(ah)''')
  write_line('''    SET_VREG64_GOTO(v1, a3, t2, t0)        #  vA/vA+1 <- rlo/rhi''')

def op_sparse_switch():
  op_packed_switch(func="MterpDoSparseSwitch")

def op_sput(is_object="0", helper="MterpSPutU32"):
  field(helper=helper)

def op_sput_boolean():
  op_sput(helper="MterpSPutU8")

def op_sput_byte():
  op_sput(helper="MterpSPutI8")

def op_sput_char():
  op_sput(helper="MterpSPutU16")

def op_sput_object():
  op_sput(is_object="1", helper="MterpSPutObj")

def op_sput_short():
  op_sput(helper="MterpSPutI16")

def op_sput_wide():
  op_sput(helper="MterpSPutU64")

def op_sub_double():
  fbinopWide(instr="sub.d fv0, fa0, fa1")

def op_sub_double_2addr():
  fbinopWide2addr(instr="sub.d fv0, fa0, fa1")

def op_sub_float():
  fbinop(instr="sub.s fv0, fa0, fa1")

def op_sub_float_2addr():
  fbinop2addr(instr="sub.s fv0, fa0, fa1")

def op_sub_int():
  binop(instr="subu a0, a0, a1")

def op_sub_int_2addr():
  binop2addr(instr="subu a0, a0, a1")

def op_sub_long():
  write_line('''/*''')
  write_line(''' * For little endian the code sequence looks as follows:''')
  write_line(''' *    subu    v0,a0,a2''')
  write_line(''' *    subu    v1,a1,a3''')
  write_line(''' *    sltu    a0,a0,v0''')
  write_line(''' *    subu    v1,v1,a0''')
  write_line(''' */''')
  binopWide(result0="v0", result1="v1", preinstr="subu v0, a0, a2", instr="subu v1, a1, a3; sltu a0, a0, v0; subu v1, v1, a0")

def op_sub_long_2addr():
  write_line('''/*''')
  write_line(''' * See op_sub_long.S for more details''')
  write_line(''' */''')
  binopWide2addr(result0="v0", result1="v1", preinstr="subu v0, a0, a2", instr="subu v1, a1, a3; sltu a0, a0, v0; subu v1, v1, a0")

def op_throw():
  write_line('''    /*''')
  write_line('''     * Throw an exception object in the current thread.''')
  write_line('''     */''')
  write_line('''    /* throw vAA */''')
  write_line('''    EXPORT_PC()                              #  exception handler can throw''')
  write_line('''    GET_OPA(a2)                              #  a2 <- AA''')
  write_line('''    GET_VREG(a1, a2)                         #  a1 <- vAA (exception object)''')
  write_line('''    # null object?''')
  write_line('''    beqz  a1, common_errNullObject           #  yes, throw an NPE instead''')
  write_line('''    sw    a1, THREAD_EXCEPTION_OFFSET(rSELF) #  thread->exception <- obj''')
  write_line('''    b         MterpException''')

def op_unused_3e():
  unused()

def op_unused_3f():
  unused()

def op_unused_40():
  unused()

def op_unused_41():
  unused()

def op_unused_42():
  unused()

def op_unused_43():
  unused()

def op_unused_73():
  unused()

def op_unused_79():
  unused()

def op_unused_7a():
  unused()

def op_unused_f3():
  unused()

def op_unused_f4():
  unused()

def op_unused_f5():
  unused()

def op_unused_f6():
  unused()

def op_unused_f7():
  unused()

def op_unused_f8():
  unused()

def op_unused_f9():
  unused()

def op_unused_fc():
  unused()

def op_unused_fd():
  unused()

def op_ushr_int():
  binop(instr="srl a0, a0, a1")

def op_ushr_int_2addr():
  binop2addr(instr="srl a0, a0, a1 ")

def op_ushr_int_lit8():
  binopLit8(instr="srl a0, a0, a1")

def op_ushr_long():
  write_line('''    /*''')
  write_line('''     * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line('''     * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line('''     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line('''     * 6 bits of the shift distance.''')
  write_line('''     */''')
  write_line('''    /* ushr-long vAA, vBB, vCC */''')
  write_line('''    FETCH(a0, 1)                           #  a0 <- CCBB''')
  write_line('''    GET_OPA(rOBJ)                          #  rOBJ <- AA''')
  write_line('''    and       a3, a0, 255                  #  a3 <- BB''')
  write_line('''    srl       a0, a0, 8                    #  a0 <- CC''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[BB]''')
  write_line('''    GET_VREG(a2, a0)                       #  a2 <- vCC''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- vBB/vBB+1''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''''')
  write_line('''    andi      v0, a2, 0x20                 #  shift & 0x20''')
  write_line('''    srl       v1, a1, a2                   #  rhi<- ahi >> (shift&31)''')
  write_line('''    bnez      v0, .L''' + opcode + '''_finish''')
  write_line('''    srl       v0, a0, a2                   #  rlo<- alo >> (shift&31)''')
  write_line('''    not       a0, a2                       #  alo<- 31-n  (shift is 5b)''')
  write_line('''    sll       a1, 1''')
  write_line('''    sll       a1, a0                       #  ahi<- ahi << (32-(shift&31))''')
  write_line('''    or        v0, a1                       #  rlo<- rlo | ahi''')
  write_line('''    SET_VREG64_GOTO(v0, v1, rOBJ, t0)      #  vAA/vAA+1 <- v0/v1''')
def op_ushr_long_sister_code():
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG64_GOTO(v1, zero, rOBJ, t0)    #  vAA/vAA+1 <- rlo/rhi''')

def op_ushr_long_2addr():
  write_line('''    /*''')
  write_line('''     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line('''     * 32-bit shift distance.''')
  write_line('''     */''')
  write_line('''    /* ushr-long/2addr vA, vB */''')
  write_line('''    GET_OPA4(t3)                           #  t3 <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG(a2, a3)                       #  a2 <- vB''')
  write_line('''    EAS2(t0, rFP, t3)                      #  t0 <- &fp[A]''')
  write_line('''    LOAD64(a0, a1, t0)                     #  a0/a1 <- vA/vA+1''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''''')
  write_line('''    andi      v0, a2, 0x20                 #  shift & 0x20''')
  write_line('''    srl       v1, a1, a2                   #  rhi<- ahi >> (shift&31)''')
  write_line('''    bnez      v0, .L''' + opcode + '''_finish''')
  write_line('''    srl       v0, a0, a2                   #  rlo<- alo >> (shift&31)''')
  write_line('''    not       a0, a2                       #  alo<- 31-n  (shift is 5b)''')
  write_line('''    sll       a1, 1''')
  write_line('''    sll       a1, a0                       #  ahi<- ahi << (32-(shift&31))''')
  write_line('''    or        v0, a1                       #  rlo<- rlo | ahi''')
  write_line('''    SET_VREG64_GOTO(v0, v1, t3, t0)        #  vA/vA+1 <- v0/v1''')
def op_ushr_long_2addr_sister_code():
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG64_GOTO(v1, zero, t3, t0)      #  vA/vA+1 <- rlo/rhi''')

def op_xor_int():
  binop(instr="xor a0, a0, a1")

def op_xor_int_2addr():
  binop2addr(instr="xor a0, a0, a1")

def op_xor_int_lit16():
  binopLit16(instr="xor a0, a0, a1")

def op_xor_int_lit8():
  binopLit8(instr="xor a0, a0, a1")

def op_xor_long():
  binopWide(preinstr="xor a0, a0, a2", instr="xor a1, a1, a3")

def op_xor_long_2addr():
  binopWide2addr(preinstr="xor a0, a0, a2", instr="xor a1, a1, a3")

def unop(preinstr="", result0="a0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result0 = op a0".''')
  write_line('''     * This could be a MIPS instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * for: int-to-byte, int-to-char, int-to-short,''')
  write_line('''     *      neg-int, not-int, neg-float''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_OPA4(t0)                           #  t0 <- A+''')
  write_line('''    GET_VREG(a0, a3)                       #  a0 <- vB''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  a0 <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t1)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_GOTO(''' + result0 + ''', t0, t1)        #  vA <- result0''')

def unopNarrower(load="LOAD64_F(fa0, fa0f, a3)", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64bit-to-32bit floating-point unary operation.  Provide an "instr"''')
  write_line('''     * line that specifies an instruction that performs "fv0 = op fa0".''')
  write_line('''     *''')
  write_line('''     * For: double-to-float''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[B]''')
  write_line('''    ''' + load + '''''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    ''' + instr + '''''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG_F_GOTO(fv0, rOBJ, t0)         #  vA <- fv0''')

def unopWide(preinstr="", result0="a0", result1="a1", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result0/result1 = op a0/a1".''')
  write_line('''     * This could be MIPS instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * For: neg-long, not-long, neg-double,''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    EAS2(a3, rFP, a3)                      #  a3 <- &fp[B]''')
  write_line('''    LOAD64(a0, a1, a3)                     #  a0/a1 <- vA''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  a0/a1 <- op, a2-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(''' + result0 + ''', ''' + result1 + ''', rOBJ, t0)   #  vA/vA+1 <- a0/a1''')

def unopWider(preinstr="", result0="a0", result1="a1", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32bit-to-64bit unary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result0/result1 = op a0".''')
  write_line('''     *''')
  write_line('''     * For: int-to-long''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    GET_OPA4(rOBJ)                         #  rOBJ <- A+''')
  write_line('''    GET_OPB(a3)                            #  a3 <- B''')
  write_line('''    GET_VREG(a0, a3)                       #  a0 <- vB''')
  write_line('''    FETCH_ADVANCE_INST(1)                  #  advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                              #  optional op''')
  write_line('''    ''' + instr + '''                                 #  result <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    SET_VREG64_GOTO(''' + result0 + ''', ''' + result1 + ''', rOBJ, t0)   #  vA/vA+1 <- a0/a1''')

def unused():
  write_line('''/*''')
  write_line(''' * Bail to reference interpreter to throw.''')
  write_line(''' */''')
  write_line('''  b MterpFallback''')

def zcmp(condition=""):
  write_line('''    /*''')
  write_line('''     * Generic one-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform.''')
  write_line('''     *''')
  write_line('''     * for: if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez''')
  write_line('''     */''')
  write_line('''    /* if-cmp vAA, +BBBB */''')
  write_line('''    GET_OPA(a0)                            #  a0 <- AA''')
  write_line('''    GET_VREG(a0, a0)                       #  a0 <- vAA''')
  write_line('''    FETCH_S(rINST, 1)                      #  rINST <- branch offset, in code units''')
  write_line('''    b''' + condition + ''' a0, zero, MterpCommonTakenBranchNoFlags''')
  write_line('''    li        t0, JIT_CHECK_OSR            # possible OSR re-entry?''')
  write_line('''    beq       rPROFILE, t0, .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST(2)                  #  advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE(t0)                    #  extract opcode from rINST''')
  write_line('''    GOTO_OPCODE(t0)                        #  jump to next instruction''')

