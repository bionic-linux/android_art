# DO NOT EDIT: This file was generated by gen-mterp.py.
arch = "arm"

import sys

out = sys.stdout
handler_size_bytes = "128"
handler_size_bits = "7"
opcode = ""
opnum = ""

def write_line(line):
  out.write(line + "\n")

def balign():
  write_line("    .balign {}".format(handler_size_bytes))

def write_opcode(num, name, write_method, is_alt):
  global opnum, opcode
  opnum, opcode = str(num), name
  if is_alt:
    name = "ALT_" + name
  write_line("/* ------------------------------ */")
  balign()
  write_line(".L_{1}: /* {0:#04x} */".format(num, name))
  if is_alt:
    alt_stub()
  else:
    write_method()
  write_line("")
  opnum, opcode = None, None

def generate(output_file):
  global out
  out = output_file
  write_line("/* DO NOT EDIT: This file was generated by gen-mterp.py. */")
  header()
  entry()

  instruction_start()
  opcodes(is_alt = False)
  balign()
  instruction_end()

  instruction_start_sister()
  write_sister()
  instruction_end_sister()

  # We need to footer sooner so that branch instruction can reach it.
  # TODO: Clean up.
  if arch == "arm64":
    footer()

  instruction_start_alt()
  opcodes(is_alt = True)
  balign()
  instruction_end_alt()

  if arch == "arm64":
    close_cfi()
  else:
    footer()

  out.truncate()

def opcodes(is_alt):
  write_opcode(0, "op_nop", op_nop, is_alt)
  write_opcode(1, "op_move", op_move, is_alt)
  write_opcode(2, "op_move_from16", op_move_from16, is_alt)
  write_opcode(3, "op_move_16", op_move_16, is_alt)
  write_opcode(4, "op_move_wide", op_move_wide, is_alt)
  write_opcode(5, "op_move_wide_from16", op_move_wide_from16, is_alt)
  write_opcode(6, "op_move_wide_16", op_move_wide_16, is_alt)
  write_opcode(7, "op_move_object", op_move_object, is_alt)
  write_opcode(8, "op_move_object_from16", op_move_object_from16, is_alt)
  write_opcode(9, "op_move_object_16", op_move_object_16, is_alt)
  write_opcode(10, "op_move_result", op_move_result, is_alt)
  write_opcode(11, "op_move_result_wide", op_move_result_wide, is_alt)
  write_opcode(12, "op_move_result_object", op_move_result_object, is_alt)
  write_opcode(13, "op_move_exception", op_move_exception, is_alt)
  write_opcode(14, "op_return_void", op_return_void, is_alt)
  write_opcode(15, "op_return", op_return, is_alt)
  write_opcode(16, "op_return_wide", op_return_wide, is_alt)
  write_opcode(17, "op_return_object", op_return_object, is_alt)
  write_opcode(18, "op_const_4", op_const_4, is_alt)
  write_opcode(19, "op_const_16", op_const_16, is_alt)
  write_opcode(20, "op_const", op_const, is_alt)
  write_opcode(21, "op_const_high16", op_const_high16, is_alt)
  write_opcode(22, "op_const_wide_16", op_const_wide_16, is_alt)
  write_opcode(23, "op_const_wide_32", op_const_wide_32, is_alt)
  write_opcode(24, "op_const_wide", op_const_wide, is_alt)
  write_opcode(25, "op_const_wide_high16", op_const_wide_high16, is_alt)
  write_opcode(26, "op_const_string", op_const_string, is_alt)
  write_opcode(27, "op_const_string_jumbo", op_const_string_jumbo, is_alt)
  write_opcode(28, "op_const_class", op_const_class, is_alt)
  write_opcode(29, "op_monitor_enter", op_monitor_enter, is_alt)
  write_opcode(30, "op_monitor_exit", op_monitor_exit, is_alt)
  write_opcode(31, "op_check_cast", op_check_cast, is_alt)
  write_opcode(32, "op_instance_of", op_instance_of, is_alt)
  write_opcode(33, "op_array_length", op_array_length, is_alt)
  write_opcode(34, "op_new_instance", op_new_instance, is_alt)
  write_opcode(35, "op_new_array", op_new_array, is_alt)
  write_opcode(36, "op_filled_new_array", op_filled_new_array, is_alt)
  write_opcode(37, "op_filled_new_array_range", op_filled_new_array_range, is_alt)
  write_opcode(38, "op_fill_array_data", op_fill_array_data, is_alt)
  write_opcode(39, "op_throw", op_throw, is_alt)
  write_opcode(40, "op_goto", op_goto, is_alt)
  write_opcode(41, "op_goto_16", op_goto_16, is_alt)
  write_opcode(42, "op_goto_32", op_goto_32, is_alt)
  write_opcode(43, "op_packed_switch", op_packed_switch, is_alt)
  write_opcode(44, "op_sparse_switch", op_sparse_switch, is_alt)
  write_opcode(45, "op_cmpl_float", op_cmpl_float, is_alt)
  write_opcode(46, "op_cmpg_float", op_cmpg_float, is_alt)
  write_opcode(47, "op_cmpl_double", op_cmpl_double, is_alt)
  write_opcode(48, "op_cmpg_double", op_cmpg_double, is_alt)
  write_opcode(49, "op_cmp_long", op_cmp_long, is_alt)
  write_opcode(50, "op_if_eq", op_if_eq, is_alt)
  write_opcode(51, "op_if_ne", op_if_ne, is_alt)
  write_opcode(52, "op_if_lt", op_if_lt, is_alt)
  write_opcode(53, "op_if_ge", op_if_ge, is_alt)
  write_opcode(54, "op_if_gt", op_if_gt, is_alt)
  write_opcode(55, "op_if_le", op_if_le, is_alt)
  write_opcode(56, "op_if_eqz", op_if_eqz, is_alt)
  write_opcode(57, "op_if_nez", op_if_nez, is_alt)
  write_opcode(58, "op_if_ltz", op_if_ltz, is_alt)
  write_opcode(59, "op_if_gez", op_if_gez, is_alt)
  write_opcode(60, "op_if_gtz", op_if_gtz, is_alt)
  write_opcode(61, "op_if_lez", op_if_lez, is_alt)
  write_opcode(62, "op_unused_3e", op_unused_3e, is_alt)
  write_opcode(63, "op_unused_3f", op_unused_3f, is_alt)
  write_opcode(64, "op_unused_40", op_unused_40, is_alt)
  write_opcode(65, "op_unused_41", op_unused_41, is_alt)
  write_opcode(66, "op_unused_42", op_unused_42, is_alt)
  write_opcode(67, "op_unused_43", op_unused_43, is_alt)
  write_opcode(68, "op_aget", op_aget, is_alt)
  write_opcode(69, "op_aget_wide", op_aget_wide, is_alt)
  write_opcode(70, "op_aget_object", op_aget_object, is_alt)
  write_opcode(71, "op_aget_boolean", op_aget_boolean, is_alt)
  write_opcode(72, "op_aget_byte", op_aget_byte, is_alt)
  write_opcode(73, "op_aget_char", op_aget_char, is_alt)
  write_opcode(74, "op_aget_short", op_aget_short, is_alt)
  write_opcode(75, "op_aput", op_aput, is_alt)
  write_opcode(76, "op_aput_wide", op_aput_wide, is_alt)
  write_opcode(77, "op_aput_object", op_aput_object, is_alt)
  write_opcode(78, "op_aput_boolean", op_aput_boolean, is_alt)
  write_opcode(79, "op_aput_byte", op_aput_byte, is_alt)
  write_opcode(80, "op_aput_char", op_aput_char, is_alt)
  write_opcode(81, "op_aput_short", op_aput_short, is_alt)
  write_opcode(82, "op_iget", op_iget, is_alt)
  write_opcode(83, "op_iget_wide", op_iget_wide, is_alt)
  write_opcode(84, "op_iget_object", op_iget_object, is_alt)
  write_opcode(85, "op_iget_boolean", op_iget_boolean, is_alt)
  write_opcode(86, "op_iget_byte", op_iget_byte, is_alt)
  write_opcode(87, "op_iget_char", op_iget_char, is_alt)
  write_opcode(88, "op_iget_short", op_iget_short, is_alt)
  write_opcode(89, "op_iput", op_iput, is_alt)
  write_opcode(90, "op_iput_wide", op_iput_wide, is_alt)
  write_opcode(91, "op_iput_object", op_iput_object, is_alt)
  write_opcode(92, "op_iput_boolean", op_iput_boolean, is_alt)
  write_opcode(93, "op_iput_byte", op_iput_byte, is_alt)
  write_opcode(94, "op_iput_char", op_iput_char, is_alt)
  write_opcode(95, "op_iput_short", op_iput_short, is_alt)
  write_opcode(96, "op_sget", op_sget, is_alt)
  write_opcode(97, "op_sget_wide", op_sget_wide, is_alt)
  write_opcode(98, "op_sget_object", op_sget_object, is_alt)
  write_opcode(99, "op_sget_boolean", op_sget_boolean, is_alt)
  write_opcode(100, "op_sget_byte", op_sget_byte, is_alt)
  write_opcode(101, "op_sget_char", op_sget_char, is_alt)
  write_opcode(102, "op_sget_short", op_sget_short, is_alt)
  write_opcode(103, "op_sput", op_sput, is_alt)
  write_opcode(104, "op_sput_wide", op_sput_wide, is_alt)
  write_opcode(105, "op_sput_object", op_sput_object, is_alt)
  write_opcode(106, "op_sput_boolean", op_sput_boolean, is_alt)
  write_opcode(107, "op_sput_byte", op_sput_byte, is_alt)
  write_opcode(108, "op_sput_char", op_sput_char, is_alt)
  write_opcode(109, "op_sput_short", op_sput_short, is_alt)
  write_opcode(110, "op_invoke_virtual", op_invoke_virtual, is_alt)
  write_opcode(111, "op_invoke_super", op_invoke_super, is_alt)
  write_opcode(112, "op_invoke_direct", op_invoke_direct, is_alt)
  write_opcode(113, "op_invoke_static", op_invoke_static, is_alt)
  write_opcode(114, "op_invoke_interface", op_invoke_interface, is_alt)
  write_opcode(115, "op_return_void_no_barrier", op_return_void_no_barrier, is_alt)
  write_opcode(116, "op_invoke_virtual_range", op_invoke_virtual_range, is_alt)
  write_opcode(117, "op_invoke_super_range", op_invoke_super_range, is_alt)
  write_opcode(118, "op_invoke_direct_range", op_invoke_direct_range, is_alt)
  write_opcode(119, "op_invoke_static_range", op_invoke_static_range, is_alt)
  write_opcode(120, "op_invoke_interface_range", op_invoke_interface_range, is_alt)
  write_opcode(121, "op_unused_79", op_unused_79, is_alt)
  write_opcode(122, "op_unused_7a", op_unused_7a, is_alt)
  write_opcode(123, "op_neg_int", op_neg_int, is_alt)
  write_opcode(124, "op_not_int", op_not_int, is_alt)
  write_opcode(125, "op_neg_long", op_neg_long, is_alt)
  write_opcode(126, "op_not_long", op_not_long, is_alt)
  write_opcode(127, "op_neg_float", op_neg_float, is_alt)
  write_opcode(128, "op_neg_double", op_neg_double, is_alt)
  write_opcode(129, "op_int_to_long", op_int_to_long, is_alt)
  write_opcode(130, "op_int_to_float", op_int_to_float, is_alt)
  write_opcode(131, "op_int_to_double", op_int_to_double, is_alt)
  write_opcode(132, "op_long_to_int", op_long_to_int, is_alt)
  write_opcode(133, "op_long_to_float", op_long_to_float, is_alt)
  write_opcode(134, "op_long_to_double", op_long_to_double, is_alt)
  write_opcode(135, "op_float_to_int", op_float_to_int, is_alt)
  write_opcode(136, "op_float_to_long", op_float_to_long, is_alt)
  write_opcode(137, "op_float_to_double", op_float_to_double, is_alt)
  write_opcode(138, "op_double_to_int", op_double_to_int, is_alt)
  write_opcode(139, "op_double_to_long", op_double_to_long, is_alt)
  write_opcode(140, "op_double_to_float", op_double_to_float, is_alt)
  write_opcode(141, "op_int_to_byte", op_int_to_byte, is_alt)
  write_opcode(142, "op_int_to_char", op_int_to_char, is_alt)
  write_opcode(143, "op_int_to_short", op_int_to_short, is_alt)
  write_opcode(144, "op_add_int", op_add_int, is_alt)
  write_opcode(145, "op_sub_int", op_sub_int, is_alt)
  write_opcode(146, "op_mul_int", op_mul_int, is_alt)
  write_opcode(147, "op_div_int", op_div_int, is_alt)
  write_opcode(148, "op_rem_int", op_rem_int, is_alt)
  write_opcode(149, "op_and_int", op_and_int, is_alt)
  write_opcode(150, "op_or_int", op_or_int, is_alt)
  write_opcode(151, "op_xor_int", op_xor_int, is_alt)
  write_opcode(152, "op_shl_int", op_shl_int, is_alt)
  write_opcode(153, "op_shr_int", op_shr_int, is_alt)
  write_opcode(154, "op_ushr_int", op_ushr_int, is_alt)
  write_opcode(155, "op_add_long", op_add_long, is_alt)
  write_opcode(156, "op_sub_long", op_sub_long, is_alt)
  write_opcode(157, "op_mul_long", op_mul_long, is_alt)
  write_opcode(158, "op_div_long", op_div_long, is_alt)
  write_opcode(159, "op_rem_long", op_rem_long, is_alt)
  write_opcode(160, "op_and_long", op_and_long, is_alt)
  write_opcode(161, "op_or_long", op_or_long, is_alt)
  write_opcode(162, "op_xor_long", op_xor_long, is_alt)
  write_opcode(163, "op_shl_long", op_shl_long, is_alt)
  write_opcode(164, "op_shr_long", op_shr_long, is_alt)
  write_opcode(165, "op_ushr_long", op_ushr_long, is_alt)
  write_opcode(166, "op_add_float", op_add_float, is_alt)
  write_opcode(167, "op_sub_float", op_sub_float, is_alt)
  write_opcode(168, "op_mul_float", op_mul_float, is_alt)
  write_opcode(169, "op_div_float", op_div_float, is_alt)
  write_opcode(170, "op_rem_float", op_rem_float, is_alt)
  write_opcode(171, "op_add_double", op_add_double, is_alt)
  write_opcode(172, "op_sub_double", op_sub_double, is_alt)
  write_opcode(173, "op_mul_double", op_mul_double, is_alt)
  write_opcode(174, "op_div_double", op_div_double, is_alt)
  write_opcode(175, "op_rem_double", op_rem_double, is_alt)
  write_opcode(176, "op_add_int_2addr", op_add_int_2addr, is_alt)
  write_opcode(177, "op_sub_int_2addr", op_sub_int_2addr, is_alt)
  write_opcode(178, "op_mul_int_2addr", op_mul_int_2addr, is_alt)
  write_opcode(179, "op_div_int_2addr", op_div_int_2addr, is_alt)
  write_opcode(180, "op_rem_int_2addr", op_rem_int_2addr, is_alt)
  write_opcode(181, "op_and_int_2addr", op_and_int_2addr, is_alt)
  write_opcode(182, "op_or_int_2addr", op_or_int_2addr, is_alt)
  write_opcode(183, "op_xor_int_2addr", op_xor_int_2addr, is_alt)
  write_opcode(184, "op_shl_int_2addr", op_shl_int_2addr, is_alt)
  write_opcode(185, "op_shr_int_2addr", op_shr_int_2addr, is_alt)
  write_opcode(186, "op_ushr_int_2addr", op_ushr_int_2addr, is_alt)
  write_opcode(187, "op_add_long_2addr", op_add_long_2addr, is_alt)
  write_opcode(188, "op_sub_long_2addr", op_sub_long_2addr, is_alt)
  write_opcode(189, "op_mul_long_2addr", op_mul_long_2addr, is_alt)
  write_opcode(190, "op_div_long_2addr", op_div_long_2addr, is_alt)
  write_opcode(191, "op_rem_long_2addr", op_rem_long_2addr, is_alt)
  write_opcode(192, "op_and_long_2addr", op_and_long_2addr, is_alt)
  write_opcode(193, "op_or_long_2addr", op_or_long_2addr, is_alt)
  write_opcode(194, "op_xor_long_2addr", op_xor_long_2addr, is_alt)
  write_opcode(195, "op_shl_long_2addr", op_shl_long_2addr, is_alt)
  write_opcode(196, "op_shr_long_2addr", op_shr_long_2addr, is_alt)
  write_opcode(197, "op_ushr_long_2addr", op_ushr_long_2addr, is_alt)
  write_opcode(198, "op_add_float_2addr", op_add_float_2addr, is_alt)
  write_opcode(199, "op_sub_float_2addr", op_sub_float_2addr, is_alt)
  write_opcode(200, "op_mul_float_2addr", op_mul_float_2addr, is_alt)
  write_opcode(201, "op_div_float_2addr", op_div_float_2addr, is_alt)
  write_opcode(202, "op_rem_float_2addr", op_rem_float_2addr, is_alt)
  write_opcode(203, "op_add_double_2addr", op_add_double_2addr, is_alt)
  write_opcode(204, "op_sub_double_2addr", op_sub_double_2addr, is_alt)
  write_opcode(205, "op_mul_double_2addr", op_mul_double_2addr, is_alt)
  write_opcode(206, "op_div_double_2addr", op_div_double_2addr, is_alt)
  write_opcode(207, "op_rem_double_2addr", op_rem_double_2addr, is_alt)
  write_opcode(208, "op_add_int_lit16", op_add_int_lit16, is_alt)
  write_opcode(209, "op_rsub_int", op_rsub_int, is_alt)
  write_opcode(210, "op_mul_int_lit16", op_mul_int_lit16, is_alt)
  write_opcode(211, "op_div_int_lit16", op_div_int_lit16, is_alt)
  write_opcode(212, "op_rem_int_lit16", op_rem_int_lit16, is_alt)
  write_opcode(213, "op_and_int_lit16", op_and_int_lit16, is_alt)
  write_opcode(214, "op_or_int_lit16", op_or_int_lit16, is_alt)
  write_opcode(215, "op_xor_int_lit16", op_xor_int_lit16, is_alt)
  write_opcode(216, "op_add_int_lit8", op_add_int_lit8, is_alt)
  write_opcode(217, "op_rsub_int_lit8", op_rsub_int_lit8, is_alt)
  write_opcode(218, "op_mul_int_lit8", op_mul_int_lit8, is_alt)
  write_opcode(219, "op_div_int_lit8", op_div_int_lit8, is_alt)
  write_opcode(220, "op_rem_int_lit8", op_rem_int_lit8, is_alt)
  write_opcode(221, "op_and_int_lit8", op_and_int_lit8, is_alt)
  write_opcode(222, "op_or_int_lit8", op_or_int_lit8, is_alt)
  write_opcode(223, "op_xor_int_lit8", op_xor_int_lit8, is_alt)
  write_opcode(224, "op_shl_int_lit8", op_shl_int_lit8, is_alt)
  write_opcode(225, "op_shr_int_lit8", op_shr_int_lit8, is_alt)
  write_opcode(226, "op_ushr_int_lit8", op_ushr_int_lit8, is_alt)
  write_opcode(227, "op_iget_quick", op_iget_quick, is_alt)
  write_opcode(228, "op_iget_wide_quick", op_iget_wide_quick, is_alt)
  write_opcode(229, "op_iget_object_quick", op_iget_object_quick, is_alt)
  write_opcode(230, "op_iput_quick", op_iput_quick, is_alt)
  write_opcode(231, "op_iput_wide_quick", op_iput_wide_quick, is_alt)
  write_opcode(232, "op_iput_object_quick", op_iput_object_quick, is_alt)
  write_opcode(233, "op_invoke_virtual_quick", op_invoke_virtual_quick, is_alt)
  write_opcode(234, "op_invoke_virtual_range_quick", op_invoke_virtual_range_quick, is_alt)
  write_opcode(235, "op_iput_boolean_quick", op_iput_boolean_quick, is_alt)
  write_opcode(236, "op_iput_byte_quick", op_iput_byte_quick, is_alt)
  write_opcode(237, "op_iput_char_quick", op_iput_char_quick, is_alt)
  write_opcode(238, "op_iput_short_quick", op_iput_short_quick, is_alt)
  write_opcode(239, "op_iget_boolean_quick", op_iget_boolean_quick, is_alt)
  write_opcode(240, "op_iget_byte_quick", op_iget_byte_quick, is_alt)
  write_opcode(241, "op_iget_char_quick", op_iget_char_quick, is_alt)
  write_opcode(242, "op_iget_short_quick", op_iget_short_quick, is_alt)
  write_opcode(243, "op_unused_f3", op_unused_f3, is_alt)
  write_opcode(244, "op_unused_f4", op_unused_f4, is_alt)
  write_opcode(245, "op_unused_f5", op_unused_f5, is_alt)
  write_opcode(246, "op_unused_f6", op_unused_f6, is_alt)
  write_opcode(247, "op_unused_f7", op_unused_f7, is_alt)
  write_opcode(248, "op_unused_f8", op_unused_f8, is_alt)
  write_opcode(249, "op_unused_f9", op_unused_f9, is_alt)
  write_opcode(250, "op_invoke_polymorphic", op_invoke_polymorphic, is_alt)
  write_opcode(251, "op_invoke_polymorphic_range", op_invoke_polymorphic_range, is_alt)
  write_opcode(252, "op_invoke_custom", op_invoke_custom, is_alt)
  write_opcode(253, "op_invoke_custom_range", op_invoke_custom_range, is_alt)
  write_opcode(254, "op_const_method_handle", op_const_method_handle, is_alt)
  write_opcode(255, "op_const_method_type", op_const_method_type, is_alt)
def write_sister():
  global opnum, opcode
  op_float_to_long_sister_code()
  op_double_to_long_sister_code()
  pass
def alt_stub():
  write_line('''/*''')
  write_line(''' * Inter-instruction transfer stub.  Call out to MterpCheckBefore to handle''')
  write_line(''' * any interesting requests and then jump to the real instruction''')
  write_line(''' * handler.  Note that the call to MterpCheckBefore is done as a tail call.''')
  write_line(''' */''')
  write_line('''    .extern MterpCheckBefore''')
  write_line('''    ldr    rIBASE, [rSELF, #THREAD_CURRENT_IBASE_OFFSET]            @ refresh IBASE.''')
  write_line('''    adr    lr, .L_ALT_''' + opcode + '''''')
  write_line('''    sub    lr, lr, #(.L_ALT_''' + opcode + ''' - .L_''' + opcode + ''')               @ Addr of primary handler.''')
  write_line('''    mov    r0, rSELF''')
  write_line('''    add    r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov    r2, rPC''')
  write_line('''    b      MterpCheckBefore     @ (self, shadow_frame, dex_pc_ptr)  @ Tail call.''')

def bincmp(condition=""):
  write_line('''    /*''')
  write_line('''     * Generic two-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform.''')
  write_line('''     *''')
  write_line('''     * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le''')
  write_line('''     */''')
  write_line('''    /* if-cmp vA, vB, +CCCC */''')
  write_line('''    mov     r1, rINST, lsr #12          @ r1<- B''')
  write_line('''    ubfx    r0, rINST, #8, #4           @ r0<- A''')
  write_line('''    GET_VREG r3, r1                     @ r3<- vB''')
  write_line('''    GET_VREG r0, r0                     @ r0<- vA''')
  write_line('''    FETCH_S rINST, 1                    @ rINST<- branch offset, in code units''')
  write_line('''    cmp     r0, r3                      @ compare (vA, vB)''')
  write_line('''    b''' + condition + ''' MterpCommonTakenBranchNoFlags''')
  write_line('''    cmp     rPROFILE, #JIT_CHECK_OSR    @ possible OSR re-entry?''')
  write_line('''    beq     .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST 2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def binop(preinstr="", result="r0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = r0 op r1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than r0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (r1).  Useful for integer division and modulus.  Note that we''')
  write_line('''     * *don't* check for (INT_MIN / -1) here, because the ARM math lib''')
  write_line('''     * handles it correctly.''')
  write_line('''     *''')
  write_line('''     * For: add-int, sub-int, mul-int, div-int, rem-int, and-int, or-int,''')
  write_line('''     *      xor-int, shl-int, shr-int, ushr-int, add-float, sub-float,''')
  write_line('''     *      mul-float, div-float, rem-float''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              @ ''' + result + '''<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', r9                @ vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 11-14 instructions */''')

def binop2addr(preinstr="", result="r0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = r0 op r1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than r0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (r1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,''')
  write_line('''     *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,''')
  write_line('''     *      shl-int/2addr, shr-int/2addr, ushr-int/2addr, add-float/2addr,''')
  write_line('''     *      sub-float/2addr, mul-float/2addr, div-float/2addr, rem-float/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vB''')
  write_line('''    GET_VREG r0, r9                     @ r0<- vA''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              @ ''' + result + '''<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', r9                @ vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def binopLit16(result="r0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit16" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = r0 op r1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than r0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (r1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit16, rsub-int, mul-int/lit16, div-int/lit16,''')
  write_line('''     *      rem-int/lit16, and-int/lit16, or-int/lit16, xor-int/lit16''')
  write_line('''     */''')
  write_line('''    /* binop/lit16 vA, vB, #+CCCC */''')
  write_line('''    FETCH_S r1, 1                       @ r1<- ssssCCCC (sign-extended)''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + instr + '''                              @ ''' + result + '''<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', r9                @ vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def binopLit8(extract="asr     r1, r3, #8", result="r0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit8" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = r0 op r1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than r0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * You can override "extract" if the extraction of the literal value''')
  write_line('''     * from r3 to r1 is not the default "asr r1, r3, #8". The extraction''')
  write_line('''     * can be omitted completely if the shift is embedded in "instr".''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (r1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit8, rsub-int/lit8, mul-int/lit8, div-int/lit8,''')
  write_line('''     *      rem-int/lit8, and-int/lit8, or-int/lit8, xor-int/lit8,''')
  write_line('''     *      shl-int/lit8, shr-int/lit8, ushr-int/lit8''')
  write_line('''     */''')
  write_line('''    /* binop/lit8 vAA, vBB, #+CC */''')
  write_line('''    FETCH_S r3, 1                       @ r3<- ssssCCBB (sign-extended for CC)''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r3, #255                @ r2<- BB''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB''')
  write_line('''    ''' + extract + '''                            @ optional; typically r1<- ssssssCC (sign extended)''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    @cmp     r1, #0                     @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''    ''' + instr + '''                              @ ''' + result + '''<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', r9                @ vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-12 instructions */''')

def binopWide(preinstr="", result0="r0", result1="r1", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = r0-r1 op r2-r3".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than r0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (r1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * for: add-long, sub-long, div-long, rem-long, and-long, or-long,''')
  write_line('''     *      xor-long, add-double, sub-double, mul-double, div-double,''')
  write_line('''     *      rem-double''')
  write_line('''     *''')
  write_line('''     * IMPORTANT: you may specify "chkzero" or "preinstr" but not both.''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     rINST, rINST, lsr #8        @ rINST<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r9, rINST        @ r9<- &fp[AA]''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &fp[BB]''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[CC]''')
  write_line('''    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1''')
  write_line('''    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    CLEAR_SHADOW_PAIR rINST, lr, ip     @ Zero out the shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              @ result<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {''' + result0 + ''',''' + result1 + '''}     @ vAA/vAA+1<- ''' + result0 + '''/''' + result1 + '''''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 14-17 instructions */''')

def binopWide2addr(preinstr="", result0="r0", result1="r1", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = r0-r1 op r2-r3".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than r0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (r1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-long/2addr, sub-long/2addr, div-long/2addr, rem-long/2addr,''')
  write_line('''     *      and-long/2addr, or-long/2addr, xor-long/2addr, add-double/2addr,''')
  write_line('''     *      sub-double/2addr, mul-double/2addr, div-double/2addr,''')
  write_line('''     *      rem-double/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    mov     r1, rINST, lsr #12          @ r1<- B''')
  write_line('''    ubfx    rINST, rINST, #8, #4        @ rINST<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r1, r1           @ r1<- &fp[B]''')
  write_line('''    VREG_INDEX_TO_ADDR r9, rINST        @ r9<- &fp[A]''')
  write_line('''    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1''')
  write_line('''    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    CLEAR_SHADOW_PAIR rINST, ip, lr     @ Zero shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              @ result<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {''' + result0 + ''',''' + result1 + '''}     @ vAA/vAA+1<- ''' + result0 + '''/''' + result1 + '''''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 12-15 instructions */''')

def const(helper="UndefinedConstHandler"):
  write_line('''    /* const/class vAA, type@BBBB */''')
  write_line('''    /* const/method-handle vAA, method_handle@BBBB */''')
  write_line('''    /* const/method-type vAA, proto@BBBB */''')
  write_line('''    /* const/string vAA, string@@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH   r0, 1                       @ r0<- BBBB''')
  write_line('''    mov     r1, rINST, lsr #8           @ r1<- AA''')
  write_line('''    add     r2, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r3, rSELF''')
  write_line('''    bl      ''' + helper + '''                     @ (index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST 2                     @ load rINST''')
  write_line('''    cmp     r0, #0                      @ fail?''')
  write_line('''    bne     MterpPossibleException      @ let reference interpreter deal with it.''')
  write_line('''    ADVANCE 2                           @ advance rPC''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def entry():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''/*''')
  write_line(''' * Interpreter entry point.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    .align  2''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On entry:''')
  write_line(''' *  r0  Thread* self/''')
  write_line(''' *  r1  insns_''')
  write_line(''' *  r2  ShadowFrame''')
  write_line(''' *  r3  JValue* result_register''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''''')
  write_line('''ENTRY ExecuteMterpImpl''')
  write_line('''    stmfd   sp!, {r3-r10,fp,lr}         @ save 10 regs, (r3 just to align 64)''')
  write_line('''    .cfi_adjust_cfa_offset 40''')
  write_line('''    .cfi_rel_offset r3, 0''')
  write_line('''    .cfi_rel_offset r4, 4''')
  write_line('''    .cfi_rel_offset r5, 8''')
  write_line('''    .cfi_rel_offset r6, 12''')
  write_line('''    .cfi_rel_offset r7, 16''')
  write_line('''    .cfi_rel_offset r8, 20''')
  write_line('''    .cfi_rel_offset r9, 24''')
  write_line('''    .cfi_rel_offset r10, 28''')
  write_line('''    .cfi_rel_offset fp, 32''')
  write_line('''    .cfi_rel_offset lr, 36''')
  write_line('''''')
  write_line('''    /* Remember the return register */''')
  write_line('''    str     r3, [r2, #SHADOWFRAME_RESULT_REGISTER_OFFSET]''')
  write_line('''''')
  write_line('''    /* Remember the dex instruction pointer */''')
  write_line('''    str     r1, [r2, #SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET]''')
  write_line('''''')
  write_line('''    /* set up "named" registers */''')
  write_line('''    mov     rSELF, r0''')
  write_line('''    ldr     r0, [r2, #SHADOWFRAME_NUMBER_OF_VREGS_OFFSET]''')
  write_line('''    add     rFP, r2, #SHADOWFRAME_VREGS_OFFSET     @ point to vregs.''')
  write_line('''    VREG_INDEX_TO_ADDR rREFS, r0                   @ point to reference array in shadow frame''')
  write_line('''    ldr     r0, [r2, #SHADOWFRAME_DEX_PC_OFFSET]   @ Get starting dex_pc.''')
  write_line('''    add     rPC, r1, r0, lsl #1                    @ Create direct pointer to 1st dex opcode''')
  write_line('''    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)''')
  write_line('''    EXPORT_PC''')
  write_line('''''')
  write_line('''    /* Starting ibase */''')
  write_line('''    ldr     rIBASE, [rSELF, #THREAD_CURRENT_IBASE_OFFSET]''')
  write_line('''''')
  write_line('''    /* Set up for backwards branches & osr profiling */''')
  write_line('''    ldr     r0, [rFP, #OFF_FP_METHOD]''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r2, rSELF''')
  write_line('''    bl      MterpSetUpHotnessCountdown''')
  write_line('''    mov     rPROFILE, r0                @ Starting hotness countdown to rPROFILE''')
  write_line('''''')
  write_line('''    /* start executing the instruction at rPC */''')
  write_line('''    FETCH_INST                          @ load rINST from rPC''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* NOTE: no fallthrough */''')

def fallback():
  write_line('''/* Transfer stub to alternate interpreter */''')
  write_line('''    b    MterpFallback''')
  write_line('''''')

def fbinop(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit floating-point operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "s2 = s0 op s1".  Because we''')
  write_line('''     * use the "softfp" ABI, this must be an instruction, not a function call.''')
  write_line('''     *''')
  write_line('''     * For: add-float, sub-float, mul-float, div-float''')
  write_line('''     */''')
  write_line('''    /* floatop vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vCC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &vBB''')
  write_line('''    flds    s1, [r3]                    @ s1<- vCC''')
  write_line('''    flds    s0, [r2]                    @ s0<- vBB''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              @ s2<- op''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &vAA''')
  write_line('''    fsts    s2, [r9]                    @ vAA<- s2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def fbinop2addr(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit floating point "/2addr" binary operation.  Provide''')
  write_line('''     * an "instr" line that specifies an instruction that performs''')
  write_line('''     * "s2 = s0 op s1".''')
  write_line('''     *''')
  write_line('''     * For: add-float/2addr, sub-float/2addr, mul-float/2addr, div-float/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vB''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &vA''')
  write_line('''    flds    s1, [r3]                    @ s1<- vB''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    flds    s0, [r9]                    @ s0<- vA''')
  write_line('''    ''' + instr + '''                              @ s2<- op''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    fsts    s2, [r9]                    @ vAA<- s2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def fbinopWide(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit double-precision floating point binary operation.''')
  write_line('''     * Provide an "instr" line that specifies an instruction that performs''')
  write_line('''     * "d2 = d0 op d1".''')
  write_line('''     *''')
  write_line('''     * for: add-double, sub-double, mul-double, div-double''')
  write_line('''     */''')
  write_line('''    /* doubleop vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vCC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &vBB''')
  write_line('''    fldd    d1, [r3]                    @ d1<- vCC''')
  write_line('''    fldd    d0, [r2]                    @ d0<- vBB''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              @ s2<- op''')
  write_line('''    CLEAR_SHADOW_PAIR r9, ip, lr        @ Zero shadow regs''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &vAA''')
  write_line('''    fstd    d2, [r9]                    @ vAA<- d2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def fbinopWide2addr(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit floating point "/2addr" binary operation.  Provide''')
  write_line('''     * an "instr" line that specifies an instruction that performs''')
  write_line('''     * "d2 = d0 op d1".''')
  write_line('''     *''')
  write_line('''     * For: add-double/2addr, sub-double/2addr, mul-double/2addr,''')
  write_line('''     *      div-double/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vB''')
  write_line('''    CLEAR_SHADOW_PAIR r9, ip, r0        @ Zero out shadow regs''')
  write_line('''    fldd    d1, [r3]                    @ d1<- vB''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &vA''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    fldd    d0, [r9]                    @ d0<- vA''')
  write_line('''    ''' + instr + '''                              @ d2<- op''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    fstd    d2, [r9]                    @ vAA<- d2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def field(helper=""):
  write_line('''    /*''')
  write_line('''     * General field read / write (iget-* iput-* sget-* sput-*).''')
  write_line('''     */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    mov      r0, rPC                       @ arg0: Instruction* inst''')
  write_line('''    mov      r1, rINST                     @ arg1: uint16_t inst_data''')
  write_line('''    add      r2, rFP, #OFF_FP_SHADOWFRAME  @ arg2: ShadowFrame* sf''')
  write_line('''    mov      r3, rSELF                     @ arg3: Thread* self''')
  write_line('''    PREFETCH_INST 2                        @ prefetch next opcode''')
  write_line('''    bl       ''' + helper + '''''')
  write_line('''    cmp      r0, #0''')
  write_line('''    beq      MterpPossibleException''')
  write_line('''    ADVANCE 2''')
  write_line('''    GET_INST_OPCODE ip                     @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                         @ jump to next instruction''')

def footer():
  write_line('''/*''')
  write_line(''' * ===========================================================================''')
  write_line(''' *  Common subroutines and data''')
  write_line(''' * ===========================================================================''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    .align  2''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We've detected a condition that will result in an exception, but the exception''')
  write_line(''' * has not yet been thrown.  Just bail out to the reference interpreter to deal with it.''')
  write_line(''' * TUNING: for consistency, we may want to just go ahead and handle these here.''')
  write_line(''' */''')
  write_line('''common_errDivideByZero:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogDivideByZeroException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errArrayIndex:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogArrayIndexException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNegativeArraySize:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogNegativeArraySizeException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNoSuchMethod:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogNoSuchMethodException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNullObject:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogNullObjectException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_exceptionThrown:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogExceptionThrownException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''MterpSuspendFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    ldr  r2, [rSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    bl MterpLogSuspendFallback''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * If we're here, something is out of the ordinary.  If there is a pending''')
  write_line(''' * exception, handle it.  Otherwise, roll back and retry with the reference''')
  write_line(''' * interpreter.''')
  write_line(''' */''')
  write_line('''MterpPossibleException:''')
  write_line('''    ldr     r0, [rSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    cmp     r0, #0                                  @ Exception pending?''')
  write_line('''    beq     MterpFallback                           @ If not, fall back to reference interpreter.''')
  write_line('''    /* intentional fallthrough - handle pending exception. */''')
  write_line('''/*''')
  write_line(''' * On return from a runtime helper routine, we've found a pending exception.''')
  write_line(''' * Can we handle it here - or need to bail out to caller?''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpException:''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl      MterpHandleException                    @ (self, shadow_frame)''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpExceptionReturn                    @ no local catch, back to caller.''')
  write_line('''    ldr     r0, [rFP, #OFF_FP_DEX_INSTRUCTIONS]''')
  write_line('''    ldr     r1, [rFP, #OFF_FP_DEX_PC]''')
  write_line('''    ldr     rIBASE, [rSELF, #THREAD_CURRENT_IBASE_OFFSET]''')
  write_line('''    add     rPC, r0, r1, lsl #1                     @ generate new dex_pc_ptr''')
  write_line('''    /* Do we need to switch interpreters? */''')
  write_line('''    bl      MterpShouldSwitchInterpreters''')
  write_line('''    cmp     r0, #0''')
  write_line('''    bne     MterpFallback''')
  write_line('''    /* resume execution at catch block */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH_INST''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip''')
  write_line('''    /* NOTE: no fallthrough */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Common handling for branches with support for Jit profiling.''')
  write_line(''' * On entry:''')
  write_line(''' *    rINST          <= signed offset''')
  write_line(''' *    rPROFILE       <= signed hotness countdown (expanded to 32 bits)''')
  write_line(''' *    condition bits <= set to establish sign of offset (use "NoFlags" entry if not)''')
  write_line(''' *''')
  write_line(''' * We have quite a few different cases for branch profiling, OSR detection and''')
  write_line(''' * suspend check support here.''')
  write_line(''' *''')
  write_line(''' * Taken backward branches:''')
  write_line(''' *    If profiling active, do hotness countdown and report if we hit zero.''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *    Is there a pending suspend request?  If so, suspend.''')
  write_line(''' *''')
  write_line(''' * Taken forward branches and not-taken backward branches:''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *''')
  write_line(''' * Our most common case is expected to be a taken backward branch with active jit profiling,''')
  write_line(''' * but no full OSR check and no pending suspend request.''')
  write_line(''' * Next most common case is not-taken branch with no full OSR check.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpCommonTakenBranchNoFlags:''')
  write_line('''    cmp     rINST, #0''')
  write_line('''MterpCommonTakenBranch:''')
  write_line('''    bgt     .L_forward_branch           @ don't add forward branches to hotness''')
  write_line('''/*''')
  write_line(''' * We need to subtract 1 from positive values and we should not see 0 here,''')
  write_line(''' * so we may use the result of the comparison with -1.''')
  write_line(''' */''')
  write_line('''#if JIT_CHECK_OSR != -1''')
  write_line('''#  error "JIT_CHECK_OSR must be -1."''')
  write_line('''#endif''')
  write_line('''    cmp     rPROFILE, #JIT_CHECK_OSR''')
  write_line('''    beq     .L_osr_check''')
  write_line('''    subsgt  rPROFILE, #1''')
  write_line('''    beq     .L_add_batch                @ counted down to zero - report''')
  write_line('''.L_resume_backward_branch:''')
  write_line('''    ldr     lr, [rSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    add     r2, rINST, rINST            @ r2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB r2            @ update rPC, load rINST''')
  write_line('''    ands    lr, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    bne     .L_suspend_request_pending''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''''')
  write_line('''.L_suspend_request_pending:''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    bl      MterpSuspendCheck           @ (self)''')
  write_line('''    cmp     r0, #0''')
  write_line('''    bne     MterpFallback''')
  write_line('''    REFRESH_IBASE                       @ might have changed during suspend''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''''')
  write_line('''.L_no_count_backwards:''')
  write_line('''    cmp     rPROFILE, #JIT_CHECK_OSR    @ possible OSR re-entry?''')
  write_line('''    bne     .L_resume_backward_branch''')
  write_line('''.L_osr_check:''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r2, rINST''')
  write_line('''    EXPORT_PC''')
  write_line('''    bl      MterpMaybeDoOnStackReplacement  @ (self, shadow_frame, offset)''')
  write_line('''    cmp     r0, #0''')
  write_line('''    bne     MterpOnStackReplacement''')
  write_line('''    b       .L_resume_backward_branch''')
  write_line('''''')
  write_line('''.L_forward_branch:''')
  write_line('''    cmp     rPROFILE, #JIT_CHECK_OSR @ possible OSR re-entry?''')
  write_line('''    beq     .L_check_osr_forward''')
  write_line('''.L_resume_forward_branch:''')
  write_line('''    add     r2, rINST, rINST            @ r2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB r2            @ update rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''''')
  write_line('''.L_check_osr_forward:''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r2, rINST''')
  write_line('''    EXPORT_PC''')
  write_line('''    bl      MterpMaybeDoOnStackReplacement  @ (self, shadow_frame, offset)''')
  write_line('''    cmp     r0, #0''')
  write_line('''    bne     MterpOnStackReplacement''')
  write_line('''    b       .L_resume_forward_branch''')
  write_line('''''')
  write_line('''.L_add_batch:''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    strh    rPROFILE, [r1, #SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET]''')
  write_line('''    ldr     r0, [rFP, #OFF_FP_METHOD]''')
  write_line('''    mov     r2, rSELF''')
  write_line('''    bl      MterpAddHotnessBatch        @ (method, shadow_frame, self)''')
  write_line('''    mov     rPROFILE, r0                @ restore new hotness countdown to rPROFILE''')
  write_line('''    b       .L_no_count_backwards''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Entered from the conditional branch handlers when OSR check request active on''')
  write_line(''' * not-taken path.  All Dalvik not-taken conditional branch offsets are 2.''')
  write_line(''' */''')
  write_line('''.L_check_not_taken_osr:''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r2, #2''')
  write_line('''    EXPORT_PC''')
  write_line('''    bl      MterpMaybeDoOnStackReplacement  @ (self, shadow_frame, offset)''')
  write_line('''    cmp     r0, #0''')
  write_line('''    bne     MterpOnStackReplacement''')
  write_line('''    FETCH_ADVANCE_INST 2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On-stack replacement has happened, and now we've returned from the compiled method.''')
  write_line(''' */''')
  write_line('''MterpOnStackReplacement:''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov r0, rSELF''')
  write_line('''    add r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov r2, rINST''')
  write_line('''    bl MterpLogOSR''')
  write_line('''#endif''')
  write_line('''    mov r0, #1                          @ Signal normal return''')
  write_line('''    b MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Bail out to reference interpreter.''')
  write_line(''' */''')
  write_line('''MterpFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  r0, rSELF''')
  write_line('''    add  r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogFallback''')
  write_line('''#endif''')
  write_line('''MterpCommonFallback:''')
  write_line('''    mov     r0, #0                                  @ signal retry with reference interpreter.''')
  write_line('''    b       MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We pushed some registers on the stack in ExecuteMterpImpl, then saved''')
  write_line(''' * SP and LR.  Here we restore SP, restore the registers, and then restore''')
  write_line(''' * LR to PC.''')
  write_line(''' *''')
  write_line(''' * On entry:''')
  write_line(''' *  uint32_t* rFP  (should still be live, pointer to base of vregs)''')
  write_line(''' */''')
  write_line('''MterpExceptionReturn:''')
  write_line('''    mov     r0, #1                                  @ signal return to caller.''')
  write_line('''    b MterpDone''')
  write_line('''MterpReturn:''')
  write_line('''    ldr     r2, [rFP, #OFF_FP_RESULT_REGISTER]''')
  write_line('''    str     r0, [r2]''')
  write_line('''    str     r1, [r2, #4]''')
  write_line('''    mov     r0, #1                                  @ signal return to caller.''')
  write_line('''MterpDone:''')
  write_line('''/*''')
  write_line(''' * At this point, we expect rPROFILE to be non-zero.  If negative, hotness is disabled or we're''')
  write_line(''' * checking for OSR.  If greater than zero, we might have unreported hotness to register''')
  write_line(''' * (the difference between the ending rPROFILE and the cached hotness counter).  rPROFILE''')
  write_line(''' * should only reach zero immediately after a hotness decrement, and is then reset to either''')
  write_line(''' * a negative special state or the new non-zero countdown value.''')
  write_line(''' */''')
  write_line('''    cmp     rPROFILE, #0''')
  write_line('''    bgt     MterpProfileActive                      @ if > 0, we may have some counts to report.''')
  write_line('''    ldmfd   sp!, {r3-r10,fp,pc}                     @ restore 10 regs and return''')
  write_line('''''')
  write_line('''MterpProfileActive:''')
  write_line('''    mov     rINST, r0                               @ stash return value''')
  write_line('''    /* Report cached hotness counts */''')
  write_line('''    ldr     r0, [rFP, #OFF_FP_METHOD]''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r2, rSELF''')
  write_line('''    strh    rPROFILE, [r1, #SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET]''')
  write_line('''    bl      MterpAddHotnessBatch                    @ (method, shadow_frame, self)''')
  write_line('''    mov     r0, rINST                               @ restore return value''')
  write_line('''    ldmfd   sp!, {r3-r10,fp,pc}                     @ restore 10 regs and return''')
  write_line('''''')
  write_line('''    END ExecuteMterpImpl''')
  write_line('''''')

def funop(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit unary floating-point operation.  Provide an "instr"''')
  write_line('''     * line that specifies an instruction that performs "s1 = op s0".''')
  write_line('''     *''')
  write_line('''     * for: int-to-float, float-to-int''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vB''')
  write_line('''    flds    s0, [r3]                    @ s0<- vB''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              @ s1<- op''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &vA''')
  write_line('''    fsts    s1, [r9]                    @ vA<- s1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def funopNarrower(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64bit-to-32bit unary floating point operation.  Provide an''')
  write_line('''     * "instr" line that specifies an instruction that performs "s0 = op d0".''')
  write_line('''     *''')
  write_line('''     * For: double-to-int, double-to-float''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vB''')
  write_line('''    fldd    d0, [r3]                    @ d0<- vB''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              @ s0<- op''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &vA''')
  write_line('''    fsts    s0, [r9]                    @ vA<- s0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def funopWider(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32bit-to-64bit floating point unary operation.  Provide an''')
  write_line('''     * "instr" line that specifies an instruction that performs "d0 = op s0".''')
  write_line('''     *''')
  write_line('''     * For: int-to-double, float-to-double''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vB''')
  write_line('''    flds    s0, [r3]                    @ s0<- vB''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              @ d0<- op''')
  write_line('''    CLEAR_SHADOW_PAIR r9, ip, lr        @ Zero shadow regs''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &vA''')
  write_line('''    fstd    d0, [r9]                    @ vA<- d0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def header():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''  Art assembly interpreter notes:''')
  write_line('''''')
  write_line('''  First validate assembly code by implementing ExecuteXXXImpl() style body (doesn't''')
  write_line('''  handle invoke, allows higher-level code to create frame & shadow frame.''')
  write_line('''''')
  write_line('''  Once that's working, support direct entry code & eliminate shadow frame (and''')
  write_line('''  excess locals allocation.''')
  write_line('''''')
  write_line('''  Some (hopefully) temporary ugliness.  We'll treat rFP as pointing to the''')
  write_line('''  base of the vreg array within the shadow frame.  Access the other fields,''')
  write_line('''  dex_pc_, method_ and number_of_vregs_ via negative offsets.  For now, we'll continue''')
  write_line('''  the shadow frame mechanism of double-storing object references - via rFP &''')
  write_line('''  number_of_vregs_.''')
  write_line('''''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''ARM EABI general notes:''')
  write_line('''''')
  write_line('''r0-r3 hold first 4 args to a method; they are not preserved across method calls''')
  write_line('''r4-r8 are available for general use''')
  write_line('''r9 is given special treatment in some situations, but not for us''')
  write_line('''r10 (sl) seems to be generally available''')
  write_line('''r11 (fp) is used by gcc (unless -fomit-frame-pointer is set)''')
  write_line('''r12 (ip) is scratch -- not preserved across method calls''')
  write_line('''r13 (sp) should be managed carefully in case a signal arrives''')
  write_line('''r14 (lr) must be preserved''')
  write_line('''r15 (pc) can be tinkered with directly''')
  write_line('''''')
  write_line('''r0 holds returns of <= 4 bytes''')
  write_line('''r0-r1 hold returns of 8 bytes, low word in r0''')
  write_line('''''')
  write_line('''Callee must save/restore r4+ (except r12) if it modifies them.  If VFP''')
  write_line('''is present, registers s16-s31 (a/k/a d8-d15, a/k/a q4-q7) must be preserved,''')
  write_line('''s0-s15 (d0-d7, q0-a3) do not need to be.''')
  write_line('''''')
  write_line('''Stack is "full descending".  Only the arguments that don't fit in the first 4''')
  write_line('''registers are placed on the stack.  "sp" points at the first stacked argument''')
  write_line('''(i.e. the 5th arg).''')
  write_line('''''')
  write_line('''VFP: single-precision results in s0, double-precision results in d0.''')
  write_line('''''')
  write_line('''In the EABI, "sp" must be 64-bit aligned on entry to a function, and any''')
  write_line('''64-bit quantities (long long, double) must be 64-bit aligned.''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/*''')
  write_line('''Mterp and ARM notes:''')
  write_line('''''')
  write_line('''The following registers have fixed assignments:''')
  write_line('''''')
  write_line('''  reg nick      purpose''')
  write_line('''  r4  rPC       interpreted program counter, used for fetching instructions''')
  write_line('''  r5  rFP       interpreted frame pointer, used for accessing locals and args''')
  write_line('''  r6  rSELF     self (Thread) pointer''')
  write_line('''  r7  rINST     first 16-bit code unit of current instruction''')
  write_line('''  r8  rIBASE    interpreted instruction base pointer, used for computed goto''')
  write_line('''  r10 rPROFILE  branch profiling countdown''')
  write_line('''  r11 rREFS     base of object references in shadow frame  (ideally, we'll get rid of this later).''')
  write_line('''''')
  write_line('''Macros are provided for common operations.  Each macro MUST emit only''')
  write_line('''one instruction to make instruction-counting easier.  They MUST NOT alter''')
  write_line('''unspecified registers or condition codes.''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * This is a #include, not a %include, because we want the C pre-processor''')
  write_line(''' * to expand the macros into assembler assignment statements.''')
  write_line(''' */''')
  write_line('''#include "asm_support.h"''')
  write_line('''#include "interpreter/cfi_asm_support.h"''')
  write_line('''''')
  write_line('''#define MTERP_PROFILE_BRANCHES 1''')
  write_line('''#define MTERP_LOGGING 0''')
  write_line('''''')
  write_line('''/* During bringup, we'll use the shadow frame model instead of rFP */''')
  write_line('''/* single-purpose registers, given names for clarity */''')
  write_line('''#define rPC      r4''')
  write_line('''#define CFI_DEX  4  // DWARF register number of the register holding dex-pc (xPC).''')
  write_line('''#define CFI_TMP  0  // DWARF register number of the first argument register (r0).''')
  write_line('''#define rFP      r5''')
  write_line('''#define rSELF    r6''')
  write_line('''#define rINST    r7''')
  write_line('''#define rIBASE   r8''')
  write_line('''#define rPROFILE r10''')
  write_line('''#define rREFS    r11''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Instead of holding a pointer to the shadow frame, we keep rFP at the base of the vregs.  So,''')
  write_line(''' * to access other shadow frame fields, we need to use a backwards offset.  Define those here.''')
  write_line(''' */''')
  write_line('''#define OFF_FP(a) (a - SHADOWFRAME_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_NUMBER_OF_VREGS OFF_FP(SHADOWFRAME_NUMBER_OF_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC OFF_FP(SHADOWFRAME_DEX_PC_OFFSET)''')
  write_line('''#define OFF_FP_LINK OFF_FP(SHADOWFRAME_LINK_OFFSET)''')
  write_line('''#define OFF_FP_METHOD OFF_FP(SHADOWFRAME_METHOD_OFFSET)''')
  write_line('''#define OFF_FP_RESULT_REGISTER OFF_FP(SHADOWFRAME_RESULT_REGISTER_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC_PTR OFF_FP(SHADOWFRAME_DEX_PC_PTR_OFFSET)''')
  write_line('''#define OFF_FP_DEX_INSTRUCTIONS OFF_FP(SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET)''')
  write_line('''#define OFF_FP_SHADOWFRAME OFF_FP(0)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * "export" the PC to dex_pc field in the shadow frame, f/b/o future exception objects.  Must''')
  write_line(''' * be done *before* something throws.''')
  write_line(''' *''')
  write_line(''' * It's okay to do this more than once.''')
  write_line(''' *''')
  write_line(''' * NOTE: the fast interpreter keeps track of dex pc as a direct pointer to the mapped''')
  write_line(''' * dex byte codes.  However, the rest of the runtime expects dex pc to be an instruction''')
  write_line(''' * offset into the code_items_[] array.  For effiency, we will "export" the''')
  write_line(''' * current dex pc as a direct pointer using the EXPORT_PC macro, and rely on GetDexPC''')
  write_line(''' * to convert to a dex pc when needed.''')
  write_line(''' */''')
  write_line('''.macro EXPORT_PC''')
  write_line('''    str  rPC, [rFP, #OFF_FP_DEX_PC_PTR]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro EXPORT_DEX_PC tmp''')
  write_line('''    ldr  \\tmp, [rFP, #OFF_FP_DEX_INSTRUCTIONS]''')
  write_line('''    str  rPC, [rFP, #OFF_FP_DEX_PC_PTR]''')
  write_line('''    sub  \\tmp, rPC, \\tmp''')
  write_line('''    asr  \\tmp, #1''')
  write_line('''    str  \\tmp, [rFP, #OFF_FP_DEX_PC]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from rPC into rINST.  Does not advance rPC.''')
  write_line(''' */''')
  write_line('''.macro FETCH_INST''')
  write_line('''    ldrh    rINST, [rPC]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from the specified offset.  Advances rPC''')
  write_line(''' * to point to the next instruction.  "_count" is in 16-bit code units.''')
  write_line(''' *''')
  write_line(''' * Because of the limited size of immediate constants on ARM, this is only''')
  write_line(''' * suitable for small forward movements (i.e. don't try to implement "goto"''')
  write_line(''' * with this).''')
  write_line(''' *''')
  write_line(''' * This must come AFTER anything that can throw an exception, or the''')
  write_line(''' * exception catch may miss.  (This also implies that it must come after''')
  write_line(''' * EXPORT_PC.)''')
  write_line(''' */''')
  write_line('''.macro FETCH_ADVANCE_INST count''')
  write_line('''    ldrh    rINST, [rPC, #((\\count)*2)]!''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * The operation performed here is similar to FETCH_ADVANCE_INST, except the''')
  write_line(''' * src and dest registers are parameterized (not hard-wired to rPC and rINST).''')
  write_line(''' */''')
  write_line('''.macro PREFETCH_ADVANCE_INST dreg, sreg, count''')
  write_line('''    ldrh    \\dreg, [\\sreg, #((\\count)*2)]!''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Similar to FETCH_ADVANCE_INST, but does not update rPC.  Used to load''')
  write_line(''' * rINST ahead of possible exception point.  Be sure to manually advance rPC''')
  write_line(''' * later.''')
  write_line(''' */''')
  write_line('''.macro PREFETCH_INST count''')
  write_line('''    ldrh    rINST, [rPC, #((\\count)*2)]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/* Advance rPC by some number of code units. */''')
  write_line('''.macro ADVANCE count''')
  write_line('''  add  rPC, #((\\count)*2)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from an offset specified by _reg.  Updates''')
  write_line(''' * rPC to point to the next instruction.  "_reg" must specify the distance''')
  write_line(''' * in bytes, *not* 16-bit code units, and may be a signed value.''')
  write_line(''' *''')
  write_line(''' * We want to write "ldrh rINST, [rPC, _reg, lsl #1]!", but some of the''')
  write_line(''' * bits that hold the shift distance are used for the half/byte/sign flags.''')
  write_line(''' * In some cases we can pre-double _reg for free, so we require a byte offset''')
  write_line(''' * here.''')
  write_line(''' */''')
  write_line('''.macro FETCH_ADVANCE_INST_RB reg''')
  write_line('''    ldrh    rINST, [rPC, \\reg]!''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch a half-word code unit from an offset past the current PC.  The''')
  write_line(''' * "_count" value is in 16-bit code units.  Does not advance rPC.''')
  write_line(''' *''')
  write_line(''' * The "_S" variant works the same but treats the value as signed.''')
  write_line(''' */''')
  write_line('''.macro FETCH reg, count''')
  write_line('''    ldrh    \\reg, [rPC, #((\\count)*2)]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro FETCH_S reg, count''')
  write_line('''    ldrsh   \\reg, [rPC, #((\\count)*2)]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch one byte from an offset past the current PC.  Pass in the same''')
  write_line(''' * "_count" as you would for FETCH, and an additional 0/1 indicating which''')
  write_line(''' * byte of the halfword you want (lo/hi).''')
  write_line(''' */''')
  write_line('''.macro FETCH_B reg, count, byte''')
  write_line('''    ldrb     \\reg, [rPC, #((\\count)*2+(\\byte))]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Put the instruction's opcode field into the specified register.''')
  write_line(''' */''')
  write_line('''.macro GET_INST_OPCODE reg''')
  write_line('''    and     \\reg, rINST, #255''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Put the prefetched instruction's opcode field into the specified register.''')
  write_line(''' */''')
  write_line('''.macro GET_PREFETCHED_OPCODE oreg, ireg''')
  write_line('''    and     \\oreg, \\ireg, #255''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Begin executing the opcode in _reg.  Because this only jumps within the''')
  write_line(''' * interpreter, we don't have to worry about pre-ARMv5 THUMB interwork.''')
  write_line(''' */''')
  write_line('''.macro GOTO_OPCODE reg''')
  write_line('''    add     pc, rIBASE, \\reg, lsl #''' + handler_size_bits + '''''')
  write_line('''.endm''')
  write_line('''.macro GOTO_OPCODE_BASE base,reg''')
  write_line('''    add     pc, \\base, \\reg, lsl #''' + handler_size_bits + '''''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 32-bit value from a Dalvik register.''')
  write_line(''' */''')
  write_line('''.macro GET_VREG reg, vreg''')
  write_line('''    ldr     \\reg, [rFP, \\vreg, lsl #2]''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG reg, vreg''')
  write_line('''    str     \\reg, [rFP, \\vreg, lsl #2]''')
  write_line('''    mov     \\reg, #0''')
  write_line('''    str     \\reg, [rREFS, \\vreg, lsl #2]''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_OBJECT reg, vreg, tmpreg''')
  write_line('''    str     \\reg, [rFP, \\vreg, lsl #2]''')
  write_line('''    str     \\reg, [rREFS, \\vreg, lsl #2]''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_SHADOW reg, vreg''')
  write_line('''    str     \\reg, [rREFS, \\vreg, lsl #2]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Clear the corresponding shadow regs for a vreg pair''')
  write_line(''' */''')
  write_line('''.macro CLEAR_SHADOW_PAIR vreg, tmp1, tmp2''')
  write_line('''    mov     \\tmp1, #0''')
  write_line('''    add     \\tmp2, \\vreg, #1''')
  write_line('''    SET_VREG_SHADOW \\tmp1, \\vreg''')
  write_line('''    SET_VREG_SHADOW \\tmp1, \\tmp2''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Convert a virtual register index into an address.''')
  write_line(''' */''')
  write_line('''.macro VREG_INDEX_TO_ADDR reg, vreg''')
  write_line('''    add     \\reg, rFP, \\vreg, lsl #2   /* WARNING/FIXME: handle shadow frame vreg zero if store */''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh handler table.''')
  write_line(''' */''')
  write_line('''.macro REFRESH_IBASE''')
  write_line('''  ldr     rIBASE, [rSELF, #THREAD_CURRENT_IBASE_OFFSET]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * cfi support macros.''')
  write_line(''' */''')
  write_line('''.macro ENTRY name''')
  write_line('''    .arm''')
  write_line('''    .type \\name, #function''')
  write_line('''    .hidden \\name  // Hide this as a global symbol, so we do not incur plt calls.''')
  write_line('''    .global \\name''')
  write_line('''    /* Cache alignment for function entry */''')
  write_line('''    .balign 16''')
  write_line('''\\name:''')
  write_line('''    .cfi_startproc''')
  write_line('''    .fnstart''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro END name''')
  write_line('''    .fnend''')
  write_line('''    .cfi_endproc''')
  write_line('''    .size \\name, .-\\name''')
  write_line('''.endm''')

def instruction_end():
  write_line('''''')
  write_line('''    .type artMterpAsmInstructionEnd, #object''')
  write_line('''    .hidden artMterpAsmInstructionEnd''')
  write_line('''    .global artMterpAsmInstructionEnd''')
  write_line('''artMterpAsmInstructionEnd:''')

def instruction_end_alt():
  write_line('''''')
  write_line('''    .type artMterpAsmAltInstructionEnd, #object''')
  write_line('''    .hidden artMterpAsmAltInstructionEnd''')
  write_line('''    .global artMterpAsmAltInstructionEnd''')
  write_line('''artMterpAsmAltInstructionEnd:''')

def instruction_end_sister():
  write_line('''''')
  write_line('''    .type artMterpAsmSisterEnd, #object''')
  write_line('''    .hidden artMterpAsmSisterEnd''')
  write_line('''    .global artMterpAsmSisterEnd''')
  write_line('''artMterpAsmSisterEnd:''')

def instruction_start():
  write_line('''''')
  write_line('''    .type artMterpAsmInstructionStart, #object''')
  write_line('''    .hidden artMterpAsmInstructionStart''')
  write_line('''    .global artMterpAsmInstructionStart''')
  write_line('''artMterpAsmInstructionStart = .L_op_nop''')
  write_line('''    .text''')

def instruction_start_alt():
  write_line('''''')
  write_line('''    .type artMterpAsmAltInstructionStart, #object''')
  write_line('''    .hidden artMterpAsmAltInstructionStart''')
  write_line('''    .global artMterpAsmAltInstructionStart''')
  write_line('''artMterpAsmAltInstructionStart = .L_ALT_op_nop''')
  write_line('''    .text''')

def instruction_start_sister():
  write_line('''''')
  write_line('''    .type artMterpAsmSisterStart, #object''')
  write_line('''    .hidden artMterpAsmSisterStart''')
  write_line('''    .global artMterpAsmSisterStart''')
  write_line('''    .text''')
  write_line('''    .balign 4''')
  write_line('''artMterpAsmSisterStart:''')

def invoke(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * Generic invoke handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r2, rPC''')
  write_line('''    mov     r3, rINST''')
  write_line('''    bl      ''' + helper + '''''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpException''')
  write_line('''    FETCH_ADVANCE_INST 3''')
  write_line('''    bl      MterpShouldSwitchInterpreters''')
  write_line('''    cmp     r0, #0''')
  write_line('''    bne     MterpFallback''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip''')
  write_line('''''')

def invoke_polymorphic(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * invoke-polymorphic handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB, proto@HHHH */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    add     r1, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r2, rPC''')
  write_line('''    mov     r3, rINST''')
  write_line('''    bl      ''' + helper + '''''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpException''')
  write_line('''    FETCH_ADVANCE_INST 4''')
  write_line('''    bl      MterpShouldSwitchInterpreters''')
  write_line('''    cmp     r0, #0''')
  write_line('''    bne     MterpFallback''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip''')

def op_add_double():
  fbinopWide(instr="faddd   d2, d0, d1")

def op_add_double_2addr():
  fbinopWide2addr(instr="faddd   d2, d0, d1")

def op_add_float():
  fbinop(instr="fadds   s2, s0, s1")

def op_add_float_2addr():
  fbinop2addr(instr="fadds   s2, s0, s1")

def op_add_int():
  binop(instr="add     r0, r0, r1")

def op_add_int_2addr():
  binop2addr(instr="add     r0, r0, r1")

def op_add_int_lit16():
  binopLit16(instr="add     r0, r0, r1")

def op_add_int_lit8():
  binopLit8(extract="", instr="add     r0, r0, r3, asr #8")

def op_add_long():
  binopWide(preinstr="adds    r0, r0, r2", instr="adc     r1, r1, r3")

def op_add_long_2addr():
  binopWide2addr(preinstr="adds    r0, r0, r2", instr="adc     r1, r1, r3")

def op_aget(load="ldr", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''    /*''')
  write_line('''     * Array get, 32 bits or less.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17''')
  write_line('''     * instructions.  We use a pair of FETCH_Bs instead.''')
  write_line('''     *''')
  write_line('''     * for: aget, aget-boolean, aget-byte, aget-char, aget-short''')
  write_line('''     *''')
  write_line('''     * NOTE: assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B r2, 1, 0                    @ r2<- BB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    FETCH_B r3, 1, 1                    @ r3<- CC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB (array object)''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC (requested index)''')
  write_line('''    cmp     r0, #0                      @ null array object?''')
  write_line('''    beq     common_errNullObject        @ yes, bail''')
  write_line('''    ldr     r3, [r0, #MIRROR_ARRAY_LENGTH_OFFSET]    @ r3<- arrayObj->length''')
  write_line('''    add     r0, r0, r1, lsl #''' + shift + '''     @ r0<- arrayObj + index*width''')
  write_line('''    cmp     r1, r3                      @ compare unsigned index, length''')
  write_line('''    bcs     common_errArrayIndex        @ index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    ''' + load + '''   r2, [r0, #''' + data_offset + ''']     @ r2<- vBB[vCC]''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r2, r9                     @ vAA<- r2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_aget_boolean():
  op_aget(load="ldrb", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aget_byte():
  op_aget(load="ldrsb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aget_char():
  op_aget(load="ldrh", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aget_object():
  write_line('''    /*''')
  write_line('''     * Array object get.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * for: aget-object''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B r2, 1, 0                    @ r2<- BB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    FETCH_B r3, 1, 1                    @ r3<- CC''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB (array object)''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC (requested index)''')
  write_line('''    bl       artAGetObjectFromMterp     @ (array, index)''')
  write_line('''    ldr      r1, [rSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cmp      r1, #0''')
  write_line('''    bne      MterpException''')
  write_line('''    SET_VREG_OBJECT r0, r9''')
  write_line('''    ADVANCE 2''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_aget_short():
  op_aget(load="ldrsh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aget_wide():
  write_line('''    /*''')
  write_line('''     * Array get, 64 bits.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * Arrays of long/double are 64-bit aligned, so it's okay to use LDRD.''')
  write_line('''     */''')
  write_line('''    /* aget-wide vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB (array object)''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC (requested index)''')
  write_line('''    cmp     r0, #0                      @ null array object?''')
  write_line('''    beq     common_errNullObject        @ yes, bail''')
  write_line('''    ldr     r3, [r0, #MIRROR_ARRAY_LENGTH_OFFSET]    @ r3<- arrayObj->length''')
  write_line('''    add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width''')
  write_line('''    cmp     r1, r3                      @ compare unsigned index, length''')
  write_line('''    bcs     common_errArrayIndex        @ index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    CLEAR_SHADOW_PAIR r9, lr, ip        @ Zero out the shadow regs''')
  write_line('''    ldrd    r2, [r0, #MIRROR_WIDE_ARRAY_DATA_OFFSET]  @ r2/r3<- vBB[vCC]''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[AA]''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_and_int():
  binop(instr="and     r0, r0, r1")

def op_and_int_2addr():
  binop2addr(instr="and     r0, r0, r1")

def op_and_int_lit16():
  binopLit16(instr="and     r0, r0, r1")

def op_and_int_lit8():
  binopLit8(extract="", instr="and     r0, r0, r3, asr #8")

def op_and_long():
  binopWide(preinstr="and     r0, r0, r2", instr="and     r1, r1, r3")

def op_and_long_2addr():
  binopWide2addr(preinstr="and     r0, r0, r2", instr="and     r1, r1, r3")

def op_aput(store="str", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''    /*''')
  write_line('''     * Array put, 32 bits or less.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17''')
  write_line('''     * instructions.  We use a pair of FETCH_Bs instead.''')
  write_line('''     *''')
  write_line('''     * for: aput, aput-boolean, aput-byte, aput-char, aput-short''')
  write_line('''     *''')
  write_line('''     * NOTE: this assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B r2, 1, 0                    @ r2<- BB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    FETCH_B r3, 1, 1                    @ r3<- CC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB (array object)''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC (requested index)''')
  write_line('''    cmp     r0, #0                      @ null array object?''')
  write_line('''    beq     common_errNullObject        @ yes, bail''')
  write_line('''    ldr     r3, [r0, #MIRROR_ARRAY_LENGTH_OFFSET]     @ r3<- arrayObj->length''')
  write_line('''    add     r0, r0, r1, lsl #''' + shift + '''     @ r0<- arrayObj + index*width''')
  write_line('''    cmp     r1, r3                      @ compare unsigned index, length''')
  write_line('''    bcs     common_errArrayIndex        @ index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    GET_VREG r2, r9                     @ r2<- vAA''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    ''' + store + '''  r2, [r0, #''' + data_offset + ''']     @ vBB[vCC]<- r2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_aput_boolean():
  op_aput(store="strb", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aput_byte():
  op_aput(store="strb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aput_char():
  op_aput(store="strh", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aput_object():
  write_line('''    /*''')
  write_line('''     * Store an object into an array.  vBB[vCC] <- vAA.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     r0, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r1, rPC''')
  write_line('''    mov     r2, rINST''')
  write_line('''    bl      MterpAputObject''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_aput_short():
  op_aput(store="strh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aput_wide():
  write_line('''    /*''')
  write_line('''     * Array put, 64 bits.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     * Arrays of long/double are 64-bit aligned, so it's okay to use STRD.''')
  write_line('''     */''')
  write_line('''    /* aput-wide vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB (array object)''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC (requested index)''')
  write_line('''    cmp     r0, #0                      @ null array object?''')
  write_line('''    beq     common_errNullObject        @ yes, bail''')
  write_line('''    ldr     r3, [r0, #MIRROR_ARRAY_LENGTH_OFFSET]    @ r3<- arrayObj->length''')
  write_line('''    add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width''')
  write_line('''    cmp     r1, r3                      @ compare unsigned index, length''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[AA]''')
  write_line('''    bcs     common_errArrayIndex        @ index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    strd    r2, [r0, #MIRROR_WIDE_ARRAY_DATA_OFFSET]  @ r2/r3<- vBB[vCC]''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_array_length():
  write_line('''    /*''')
  write_line('''     * Return the length of an array.''')
  write_line('''     */''')
  write_line('''    mov     r1, rINST, lsr #12          @ r1<- B''')
  write_line('''    ubfx    r2, rINST, #8, #4           @ r2<- A''')
  write_line('''    GET_VREG r0, r1                     @ r0<- vB (object ref)''')
  write_line('''    cmp     r0, #0                      @ is object null?''')
  write_line('''    beq     common_errNullObject        @ yup, fail''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ldr     r3, [r0, #MIRROR_ARRAY_LENGTH_OFFSET]    @ r3<- array length''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r3, r2                     @ vB<- length''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_check_cast():
  write_line('''    /*''')
  write_line('''     * Check to see if a cast from one class to another is allowed.''')
  write_line('''     */''')
  write_line('''    /* check-cast vAA, class@BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH    r0, 1                      @ r0<- BBBB''')
  write_line('''    mov      r1, rINST, lsr #8          @ r1<- AA''')
  write_line('''    VREG_INDEX_TO_ADDR r1, r1           @ r1<- &object''')
  write_line('''    ldr      r2, [rFP, #OFF_FP_METHOD]  @ r2<- method''')
  write_line('''    mov      r3, rSELF                  @ r3<- self''')
  write_line('''    bl       MterpCheckCast             @ (index, &obj, method, self)''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cmp      r0, #0''')
  write_line('''    bne      MterpPossibleException''')
  write_line('''    ADVANCE  2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_cmp_long():
  write_line('''    /*''')
  write_line('''     * Compare two 64-bit values.  Puts 0, 1, or -1 into the destination''')
  write_line('''     * register based on the results of the comparison.''')
  write_line('''     */''')
  write_line('''    /* cmp-long vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &fp[BB]''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[CC]''')
  write_line('''    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1''')
  write_line('''    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1''')
  write_line('''    cmp     r0, r2''')
  write_line('''    sbcs    ip, r1, r3                  @ Sets correct CCs for checking LT (but not EQ/NE)''')
  write_line('''    mov     ip, #0''')
  write_line('''    mvnlt   ip, #0                      @ -1''')
  write_line('''    cmpeq   r0, r2                      @ For correct EQ/NE, we may need to repeat the first CMP''')
  write_line('''    orrne   ip, #1''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    SET_VREG ip, r9                     @ vAA<- ip''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_cmpg_double():
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line('''     * destination register based on the results of the comparison.''')
  write_line('''     *''')
  write_line('''     * int compare(x, y) {''')
  write_line('''     *     if (x == y) {''')
  write_line('''     *         return 0;''')
  write_line('''     *     } else if (x < y) {''')
  write_line('''     *         return -1;''')
  write_line('''     *     } else if (x > y) {''')
  write_line('''     *         return 1;''')
  write_line('''     *     } else {''')
  write_line('''     *         return 1;''')
  write_line('''     *     }''')
  write_line('''     * }''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &vBB''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vCC''')
  write_line('''    fldd    d0, [r2]                    @ d0<- vBB''')
  write_line('''    fldd    d1, [r3]                    @ d1<- vCC''')
  write_line('''    vcmpe.f64 d0, d1                    @ compare (vBB, vCC)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    mov     r0, #1                      @ r0<- 1 (default)''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    fmstat                              @ export status flags''')
  write_line('''    mvnmi   r0, #0                      @ (less than) r1<- -1''')
  write_line('''    moveq   r0, #0                      @ (equal) r1<- 0''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_cmpg_float():
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line('''     * destination register based on the results of the comparison.''')
  write_line('''     *''')
  write_line('''     * int compare(x, y) {''')
  write_line('''     *     if (x == y) {''')
  write_line('''     *         return 0;''')
  write_line('''     *     } else if (x < y) {''')
  write_line('''     *         return -1;''')
  write_line('''     *     } else if (x > y) {''')
  write_line('''     *         return 1;''')
  write_line('''     *     } else {''')
  write_line('''     *         return 1;''')
  write_line('''     *     }''')
  write_line('''     * }''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &vBB''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vCC''')
  write_line('''    flds    s0, [r2]                    @ s0<- vBB''')
  write_line('''    flds    s1, [r3]                    @ s1<- vCC''')
  write_line('''    vcmpe.f32 s0, s1                    @ compare (vBB, vCC)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    mov     r0, #1                      @ r0<- 1 (default)''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    fmstat                              @ export status flags''')
  write_line('''    mvnmi   r0, #0                      @ (less than) r1<- -1''')
  write_line('''    moveq   r0, #0                      @ (equal) r1<- 0''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_cmpl_double():
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line('''     * destination register based on the results of the comparison.''')
  write_line('''     *''')
  write_line('''     * int compare(x, y) {''')
  write_line('''     *     if (x == y) {''')
  write_line('''     *         return 0;''')
  write_line('''     *     } else if (x > y) {''')
  write_line('''     *         return 1;''')
  write_line('''     *     } else if (x < y) {''')
  write_line('''     *         return -1;''')
  write_line('''     *     } else {''')
  write_line('''     *         return -1;''')
  write_line('''     *     }''')
  write_line('''     * }''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &vBB''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vCC''')
  write_line('''    fldd    d0, [r2]                    @ d0<- vBB''')
  write_line('''    fldd    d1, [r3]                    @ d1<- vCC''')
  write_line('''    vcmpe.f64 d0, d1                    @ compare (vBB, vCC)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    mvn     r0, #0                      @ r0<- -1 (default)''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    fmstat                              @ export status flags''')
  write_line('''    movgt   r0, #1                      @ (greater than) r1<- 1''')
  write_line('''    moveq   r0, #0                      @ (equal) r1<- 0''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_cmpl_float():
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line('''     * destination register based on the results of the comparison.''')
  write_line('''     *''')
  write_line('''     * int compare(x, y) {''')
  write_line('''     *     if (x == y) {''')
  write_line('''     *         return 0;''')
  write_line('''     *     } else if (x > y) {''')
  write_line('''     *         return 1;''')
  write_line('''     *     } else if (x < y) {''')
  write_line('''     *         return -1;''')
  write_line('''     *     } else {''')
  write_line('''     *         return -1;''')
  write_line('''     *     }''')
  write_line('''     * }''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &vBB''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &vCC''')
  write_line('''    flds    s0, [r2]                    @ s0<- vBB''')
  write_line('''    flds    s1, [r3]                    @ s1<- vCC''')
  write_line('''    vcmpe.f32  s0, s1                   @ compare (vBB, vCC)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    mvn     r0, #0                      @ r0<- -1 (default)''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    fmstat                              @ export status flags''')
  write_line('''    movgt   r0, #1                      @ (greater than) r1<- 1''')
  write_line('''    moveq   r0, #0                      @ (equal) r1<- 0''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const():
  write_line('''    /* const vAA, #+BBBBbbbb */''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    FETCH r0, 1                         @ r0<- bbbb (low)''')
  write_line('''    FETCH r1, 2                         @ r1<- BBBB (high)''')
  write_line('''    FETCH_ADVANCE_INST 3                @ advance rPC, load rINST''')
  write_line('''    orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r0, r3                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const_16():
  write_line('''    /* const/16 vAA, #+BBBB */''')
  write_line('''    FETCH_S r0, 1                       @ r0<- ssssBBBB (sign-extended)''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    SET_VREG r0, r3                     @ vAA<- r0''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const_4():
  write_line('''    /* const/4 vA, #+B */''')
  write_line('''    sbfx    r1, rINST, #12, #4          @ r1<- sssssssB (sign-extended)''')
  write_line('''    ubfx    r0, rINST, #8, #4           @ r0<- A''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ ip<- opcode from rINST''')
  write_line('''    SET_VREG r1, r0                     @ fp[A]<- r1''')
  write_line('''    GOTO_OPCODE ip                      @ execute next instruction''')

def op_const_class():
  const(helper="MterpConstClass")

def op_const_high16():
  write_line('''    /* const/high16 vAA, #+BBBB0000 */''')
  write_line('''    FETCH r0, 1                         @ r0<- 0000BBBB (zero-extended)''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    mov     r0, r0, lsl #16             @ r0<- BBBB0000''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    SET_VREG r0, r3                     @ vAA<- r0''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const_method_handle():
  const(helper="MterpConstMethodHandle")

def op_const_method_type():
  const(helper="MterpConstMethodType")

def op_const_string():
  const(helper="MterpConstString")

def op_const_string_jumbo():
  write_line('''    /* const/string vAA, String@BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH r0, 1                         @ r0<- bbbb (low)''')
  write_line('''    FETCH r2, 2                         @ r2<- BBBB (high)''')
  write_line('''    mov     r1, rINST, lsr #8           @ r1<- AA''')
  write_line('''    orr     r0, r0, r2, lsl #16         @ r1<- BBBBbbbb''')
  write_line('''    add     r2, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r3, rSELF''')
  write_line('''    bl      MterpConstString            @ (index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST 3                     @ advance rPC''')
  write_line('''    cmp     r0, #0                      @ fail?''')
  write_line('''    bne     MterpPossibleException      @ let reference interpreter deal with it.''')
  write_line('''    ADVANCE 3                           @ advance rPC''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const_wide():
  write_line('''    /* const-wide vAA, #+HHHHhhhhBBBBbbbb */''')
  write_line('''    FETCH r0, 1                         @ r0<- bbbb (low)''')
  write_line('''    FETCH r1, 2                         @ r1<- BBBB (low middle)''')
  write_line('''    FETCH r2, 3                         @ r2<- hhhh (high middle)''')
  write_line('''    orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb (low word)''')
  write_line('''    FETCH r3, 4                         @ r3<- HHHH (high)''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    orr     r1, r2, r3, lsl #16         @ r1<- HHHHhhhh (high word)''')
  write_line('''    CLEAR_SHADOW_PAIR r9, r2, r3        @ Zero out the shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 5                @ advance rPC, load rINST''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[AA]''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const_wide_16():
  write_line('''    /* const-wide/16 vAA, #+BBBB */''')
  write_line('''    FETCH_S r0, 1                       @ r0<- ssssBBBB (sign-extended)''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    mov     r1, r0, asr #31             @ r1<- ssssssss''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    CLEAR_SHADOW_PAIR r3, r2, lr        @ Zero out the shadow regs''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[AA]''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r3, {r0-r1}                 @ vAA<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const_wide_32():
  write_line('''    /* const-wide/32 vAA, #+BBBBbbbb */''')
  write_line('''    FETCH r0, 1                         @ r0<- 0000bbbb (low)''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    FETCH_S r2, 2                       @ r2<- ssssBBBB (high)''')
  write_line('''    FETCH_ADVANCE_INST 3                @ advance rPC, load rINST''')
  write_line('''    orr     r0, r0, r2, lsl #16         @ r0<- BBBBbbbb''')
  write_line('''    CLEAR_SHADOW_PAIR r3, r2, lr        @ Zero out the shadow regs''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[AA]''')
  write_line('''    mov     r1, r0, asr #31             @ r1<- ssssssss''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r3, {r0-r1}                 @ vAA<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_const_wide_high16():
  write_line('''    /* const-wide/high16 vAA, #+BBBB000000000000 */''')
  write_line('''    FETCH r1, 1                         @ r1<- 0000BBBB (zero-extended)''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    mov     r0, #0                      @ r0<- 00000000''')
  write_line('''    mov     r1, r1, lsl #16             @ r1<- BBBB0000''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    CLEAR_SHADOW_PAIR r3, r0, r2        @ Zero shadow regs''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[AA]''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r3, {r0-r1}                 @ vAA<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_div_double():
  fbinopWide(instr="fdivd   d2, d0, d1")

def op_div_double_2addr():
  fbinopWide2addr(instr="fdivd   d2, d0, d1")

def op_div_float():
  fbinop(instr="fdivs   s2, s0, s1")

def op_div_float_2addr():
  fbinop2addr(instr="fdivs   s2, s0, s1")

def op_div_int():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r0 = r0 div r1". The selection between sdiv or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * div-int''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r0, r0, r1                  @ r0<- op''')
  write_line('''#else''')
  write_line('''    bl    __aeabi_idiv                  @ r0<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 11-14 instructions */''')

def op_div_int_2addr():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r0 = r0 div r1". The selection between sdiv or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * div-int/2addr''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vB''')
  write_line('''    GET_VREG r0, r9                     @ r0<- vA''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r0, r0, r1                  @ r0<- op''')
  write_line('''#else''')
  write_line('''    bl       __aeabi_idiv               @ r0<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')
  write_line('''''')

def op_div_int_lit16():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r0 = r0 div r1". The selection between sdiv or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * div-int/lit16''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    FETCH_S r1, 1                       @ r1<- ssssCCCC (sign-extended)''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vB''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r0, r0, r1                  @ r0<- op''')
  write_line('''#else''')
  write_line('''    bl       __aeabi_idiv               @ r0<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def op_div_int_lit8():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r0 = r0 div r1". The selection between sdiv or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * div-int/lit8''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    FETCH_S r3, 1                       @ r3<- ssssCCBB (sign-extended for CC''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r3, #255                @ r2<- BB''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB''')
  write_line('''    movs    r1, r3, asr #8              @ r1<- ssssssCC (sign extended)''')
  write_line('''    @cmp     r1, #0                     @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r0, r0, r1                  @ r0<- op''')
  write_line('''#else''')
  write_line('''    bl   __aeabi_idiv                   @ r0<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-12 instructions */''')

def op_div_long():
  binopWide(instr="bl      __aeabi_ldivmod", chkzero="1")

def op_div_long_2addr():
  binopWide2addr(instr="bl      __aeabi_ldivmod", chkzero="1")

def op_double_to_float():
  funopNarrower(instr="vcvt.f32.f64  s0, d0")

def op_double_to_int():
  funopNarrower(instr="ftosizd  s0, d0")

def op_double_to_long():
  unopWide(instr="bl      d2l_doconv")
  write_line('''''')
def op_double_to_long_sister_code():
  write_line('''/*''')
  write_line(''' * Convert the double in r0/r1 to a long in r0/r1.''')
  write_line(''' *''')
  write_line(''' * We have to clip values to long min/max per the specification.  The''')
  write_line(''' * expected common case is a "reasonable" value that converts directly''')
  write_line(''' * to modest integer.  The EABI convert function isn't doing this for us.''')
  write_line(''' */''')
  write_line('''d2l_doconv:''')
  write_line('''    ubfx    r2, r1, #20, #11            @ grab the exponent''')
  write_line('''    movw    r3, #0x43e''')
  write_line('''    cmp     r2, r3                      @ MINLONG < x > MAXLONG?''')
  write_line('''    bhs     d2l_special_cases''')
  write_line('''    b       __aeabi_d2lz                @ tail call to convert double to long''')
  write_line('''d2l_special_cases:''')
  write_line('''    movw    r3, #0x7ff''')
  write_line('''    cmp     r2, r3''')
  write_line('''    beq     d2l_maybeNaN                @ NaN?''')
  write_line('''d2l_notNaN:''')
  write_line('''    adds    r1, r1, r1                  @ sign bit to carry''')
  write_line('''    mov     r0, #0xffffffff             @ assume maxlong for lsw''')
  write_line('''    mov     r1, #0x7fffffff             @ assume maxlong for msw''')
  write_line('''    adc     r0, r0, #0''')
  write_line('''    adc     r1, r1, #0                  @ convert maxlong to minlong if exp negative''')
  write_line('''    bx      lr                          @ return''')
  write_line('''d2l_maybeNaN:''')
  write_line('''    orrs    r3, r0, r1, lsl #12''')
  write_line('''    beq     d2l_notNaN                  @ if fraction is non-zero, it's a NaN''')
  write_line('''    mov     r0, #0''')
  write_line('''    mov     r1, #0''')
  write_line('''    bx      lr                          @ return 0 for NaN''')

def op_fill_array_data():
  write_line('''    /* fill-array-data vAA, +BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH r0, 1                         @ r0<- bbbb (lo)''')
  write_line('''    FETCH r1, 2                         @ r1<- BBBB (hi)''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    orr     r1, r0, r1, lsl #16         @ r1<- BBBBbbbb''')
  write_line('''    GET_VREG r0, r3                     @ r0<- vAA (array object)''')
  write_line('''    add     r1, rPC, r1, lsl #1         @ r1<- PC + BBBBbbbb*2 (array data off.)''')
  write_line('''    bl      MterpFillArrayData          @ (obj, payload)''')
  write_line('''    cmp     r0, #0                      @ 0 means an exception is thrown''')
  write_line('''    beq     MterpPossibleException      @ exception?''')
  write_line('''    FETCH_ADVANCE_INST 3                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_filled_new_array(helper="MterpFilledNewArray"):
  write_line('''    /*''')
  write_line('''     * Create a new array with elements filled from registers.''')
  write_line('''     *''')
  write_line('''     * for: filled-new-array, filled-new-array/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, type@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     r0, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r1, rPC''')
  write_line('''    mov     r2, rSELF''')
  write_line('''    bl      ''' + helper + '''''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 3                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_filled_new_array_range():
  op_filled_new_array(helper="MterpFilledNewArrayRange")

def op_float_to_double():
  funopWider(instr="vcvt.f64.f32  d0, s0")

def op_float_to_int():
  funop(instr="ftosizs s1, s0")

def op_float_to_long():
  unopWider(instr="bl      f2l_doconv")
  write_line('''''')
def op_float_to_long_sister_code():
  write_line('''/*''')
  write_line(''' * Convert the float in r0 to a long in r0/r1.''')
  write_line(''' *''')
  write_line(''' * We have to clip values to long min/max per the specification.  The''')
  write_line(''' * expected common case is a "reasonable" value that converts directly''')
  write_line(''' * to modest integer.  The EABI convert function isn't doing this for us.''')
  write_line(''' */''')
  write_line('''f2l_doconv:''')
  write_line('''    ubfx    r2, r0, #23, #8             @ grab the exponent''')
  write_line('''    cmp     r2, #0xbe                   @ MININT < x > MAXINT?''')
  write_line('''    bhs     f2l_special_cases''')
  write_line('''    b       __aeabi_f2lz                @ tail call to convert float to long''')
  write_line('''f2l_special_cases:''')
  write_line('''    cmp     r2, #0xff                   @ NaN or infinity?''')
  write_line('''    beq     f2l_maybeNaN''')
  write_line('''f2l_notNaN:''')
  write_line('''    adds    r0, r0, r0                  @ sign bit to carry''')
  write_line('''    mov     r0, #0xffffffff             @ assume maxlong for lsw''')
  write_line('''    mov     r1, #0x7fffffff             @ assume maxlong for msw''')
  write_line('''    adc     r0, r0, #0''')
  write_line('''    adc     r1, r1, #0                  @ convert maxlong to minlong if exp negative''')
  write_line('''    bx      lr                          @ return''')
  write_line('''f2l_maybeNaN:''')
  write_line('''    lsls    r3, r0, #9''')
  write_line('''    beq     f2l_notNaN                  @ if fraction is non-zero, it's a NaN''')
  write_line('''    mov     r0, #0''')
  write_line('''    mov     r1, #0''')
  write_line('''    bx      lr                          @ return 0 for NaN''')

def op_goto():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 8-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto +AA */''')
  write_line('''    sbfx    rINST, rINST, #8, #8           @ rINST<- ssssssAA (sign-extended)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_16():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 16-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto/16 +AAAA */''')
  write_line('''    FETCH_S rINST, 1                    @ rINST<- ssssAAAA (sign-extended)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_32():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 32-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     *''')
  write_line('''     * Unlike most opcodes, this one is allowed to branch to itself, so''')
  write_line('''     * our "backward branch" test must be "<=0" instead of "<0".  Because''')
  write_line('''     * we need the V bit set, we'll use an adds to convert from Dalvik''')
  write_line('''     * offset to byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto/32 +AAAAAAAA */''')
  write_line('''    FETCH r0, 1                         @ r0<- aaaa (lo)''')
  write_line('''    FETCH r3, 2                         @ r1<- AAAA (hi)''')
  write_line('''    orrs    rINST, r0, r3, lsl #16      @ rINST<- AAAAaaaa''')
  write_line('''    b       MterpCommonTakenBranch''')

def op_if_eq():
  bincmp(condition="eq")

def op_if_eqz():
  zcmp(condition="eq")

def op_if_ge():
  bincmp(condition="ge")

def op_if_gez():
  zcmp(condition="ge")

def op_if_gt():
  bincmp(condition="gt")

def op_if_gtz():
  zcmp(condition="gt")

def op_if_le():
  bincmp(condition="le")

def op_if_lez():
  zcmp(condition="le")

def op_if_lt():
  bincmp(condition="lt")

def op_if_ltz():
  zcmp(condition="lt")

def op_if_ne():
  bincmp(condition="ne")

def op_if_nez():
  zcmp(condition="ne")

def op_iget(is_object="0", helper="MterpIGetU32"):
  field(helper=helper)

def op_iget_boolean():
  op_iget(helper="MterpIGetU8")

def op_iget_boolean_quick():
  op_iget_quick(load="ldrb")

def op_iget_byte():
  op_iget(helper="MterpIGetI8")

def op_iget_byte_quick():
  op_iget_quick(load="ldrsb")

def op_iget_char():
  op_iget(helper="MterpIGetU16")

def op_iget_char_quick():
  op_iget_quick(load="ldrh")

def op_iget_object():
  op_iget(is_object="1", helper="MterpIGetObj")

def op_iget_object_quick():
  write_line('''    /* For: iget-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    FETCH r1, 1                         @ r1<- field byte offset''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- object we're operating on''')
  write_line('''    bl      artIGetObjectFromMterp      @ (obj, offset)''')
  write_line('''    ldr     r3, [rSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    ubfx    r2, rINST, #8, #4           @ r2<- A''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cmp     r3, #0''')
  write_line('''    bne     MterpPossibleException      @ bail out''')
  write_line('''    SET_VREG_OBJECT r0, r2              @ fp[A]<- r0''')
  write_line('''    ADVANCE 2                           @ advance rPC''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_iget_quick(load="ldr"):
  write_line('''    /* For: iget-quick, iget-boolean-quick, iget-byte-quick, iget-char-quick, iget-short-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    FETCH r1, 1                         @ r1<- field byte offset''')
  write_line('''    GET_VREG r3, r2                     @ r3<- object we're operating on''')
  write_line('''    ubfx    r2, rINST, #8, #4           @ r2<- A''')
  write_line('''    cmp     r3, #0                      @ check object for null''')
  write_line('''    beq     common_errNullObject        @ object was null''')
  write_line('''    ''' + load + '''   r0, [r3, r1]                @ r0<- obj.field''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    SET_VREG r0, r2                     @ fp[A]<- r0''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_iget_short():
  op_iget(helper="MterpIGetI16")

def op_iget_short_quick():
  op_iget_quick(load="ldrsh")

def op_iget_wide():
  op_iget(helper="MterpIGetU64")

def op_iget_wide_quick():
  write_line('''    /* iget-wide-quick vA, vB, offset@CCCC */''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    FETCH ip, 1                         @ ip<- field byte offset''')
  write_line('''    GET_VREG r3, r2                     @ r3<- object we're operating on''')
  write_line('''    ubfx    r2, rINST, #8, #4           @ r2<- A''')
  write_line('''    cmp     r3, #0                      @ check object for null''')
  write_line('''    beq     common_errNullObject        @ object was null''')
  write_line('''    ldrd    r0, [r3, ip]                @ r0<- obj.field (64 bits, aligned)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r2           @ r3<- &fp[A]''')
  write_line('''    CLEAR_SHADOW_PAIR r2, ip, lr        @ Zero out the shadow regs''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_instance_of():
  write_line('''    /*''')
  write_line('''     * Check to see if an object reference is an instance of a class.''')
  write_line('''     *''')
  write_line('''     * Most common situation is a non-null object, being compared against''')
  write_line('''     * an already-resolved class.''')
  write_line('''     */''')
  write_line('''    /* instance-of vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH     r0, 1                     @ r0<- CCCC''')
  write_line('''    mov       r1, rINST, lsr #12        @ r1<- B''')
  write_line('''    VREG_INDEX_TO_ADDR r1, r1           @ r1<- &object''')
  write_line('''    ldr       r2, [rFP, #OFF_FP_METHOD] @ r2<- method''')
  write_line('''    mov       r3, rSELF                 @ r3<- self''')
  write_line('''    bl        MterpInstanceOf           @ (index, &obj, method, self)''')
  write_line('''    ldr       r1, [rSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    ubfx      r9, rINST, #8, #4         @ r9<- A''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cmp       r1, #0                    @ exception pending?''')
  write_line('''    bne       MterpException''')
  write_line('''    ADVANCE 2                           @ advance rPC''')
  write_line('''    SET_VREG r0, r9                     @ vA<- r0''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_int_to_byte():
  unop(instr="sxtb    r0, r0")

def op_int_to_char():
  unop(instr="uxth    r0, r0")

def op_int_to_double():
  funopWider(instr="fsitod  d0, s0")

def op_int_to_float():
  funop(instr="fsitos  s1, s0")

def op_int_to_long():
  unopWider(instr="mov     r1, r0, asr #31")

def op_int_to_short():
  unop(instr="sxth    r0, r0")

def op_invoke_custom():
  invoke(helper="MterpInvokeCustom")
  write_line('''    /*''')
  write_line('''     * Handle an invoke-custom invocation.''')
  write_line('''     *''')
  write_line('''     * for: invoke-custom, invoke-custom/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, call_site@BBBB */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, call_site@BBBB */''')

def op_invoke_custom_range():
  invoke(helper="MterpInvokeCustomRange")

def op_invoke_direct():
  invoke(helper="MterpInvokeDirect")

def op_invoke_direct_range():
  invoke(helper="MterpInvokeDirectRange")

def op_invoke_interface():
  invoke(helper="MterpInvokeInterface")
  write_line('''    /*''')
  write_line('''     * Handle an interface method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-interface, invoke-interface/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_interface_range():
  invoke(helper="MterpInvokeInterfaceRange")

def op_invoke_polymorphic():
  invoke_polymorphic(helper="MterpInvokePolymorphic")

def op_invoke_polymorphic_range():
  invoke_polymorphic(helper="MterpInvokePolymorphicRange")

def op_invoke_static():
  invoke(helper="MterpInvokeStatic")
  write_line('''''')

def op_invoke_static_range():
  invoke(helper="MterpInvokeStaticRange")

def op_invoke_super():
  invoke(helper="MterpInvokeSuper")
  write_line('''    /*''')
  write_line('''     * Handle a "super" method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-super, invoke-super/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_super_range():
  invoke(helper="MterpInvokeSuperRange")

def op_invoke_virtual():
  invoke(helper="MterpInvokeVirtual")
  write_line('''    /*''')
  write_line('''     * Handle a virtual method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-virtual, invoke-virtual/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_virtual_quick():
  invoke(helper="MterpInvokeVirtualQuick")

def op_invoke_virtual_range():
  invoke(helper="MterpInvokeVirtualRange")

def op_invoke_virtual_range_quick():
  invoke(helper="MterpInvokeVirtualQuickRange")

def op_iput(is_object="0", helper="MterpIPutU32"):
  field(helper=helper)

def op_iput_boolean():
  op_iput(helper="MterpIPutU8")

def op_iput_boolean_quick():
  op_iput_quick(store="strb")

def op_iput_byte():
  op_iput(helper="MterpIPutI8")

def op_iput_byte_quick():
  op_iput_quick(store="strb")

def op_iput_char():
  op_iput(helper="MterpIPutU16")

def op_iput_char_quick():
  op_iput_quick(store="strh")

def op_iput_object():
  op_iput(is_object="1", helper="MterpIPutObj")

def op_iput_object_quick():
  write_line('''    EXPORT_PC''')
  write_line('''    add     r0, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r1, rPC''')
  write_line('''    mov     r2, rINST''')
  write_line('''    bl      MterpIputObjectQuick''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpException''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_iput_quick(store="str"):
  write_line('''    /* For: iput-quick, iput-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    FETCH r1, 1                         @ r1<- field byte offset''')
  write_line('''    GET_VREG r3, r2                     @ r3<- fp[B], the object pointer''')
  write_line('''    ubfx    r2, rINST, #8, #4           @ r2<- A''')
  write_line('''    cmp     r3, #0                      @ check object for null''')
  write_line('''    beq     common_errNullObject        @ object was null''')
  write_line('''    GET_VREG r0, r2                     @ r0<- fp[A]''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    ''' + store + '''     r0, [r3, r1]             @ obj.field<- r0''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_iput_short():
  op_iput(helper="MterpIPutI16")

def op_iput_short_quick():
  op_iput_quick(store="strh")

def op_iput_wide():
  op_iput(helper="MterpIPutU64")

def op_iput_wide_quick():
  write_line('''    /* iput-wide-quick vA, vB, offset@CCCC */''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    FETCH r3, 1                         @ r3<- field byte offset''')
  write_line('''    GET_VREG r2, r2                     @ r2<- fp[B], the object pointer''')
  write_line('''    ubfx    r0, rINST, #8, #4           @ r0<- A''')
  write_line('''    cmp     r2, #0                      @ check object for null''')
  write_line('''    beq     common_errNullObject        @ object was null''')
  write_line('''    VREG_INDEX_TO_ADDR r0, r0           @ r0<- &fp[A]''')
  write_line('''    ldmia   r0, {r0-r1}                 @ r0/r1<- fp[A]/fp[A+1]''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    strd    r0, [r2, r3]                @ obj.field<- r0/r1''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_long_to_double():
  write_line('''    /*''')
  write_line('''     * Specialised 64-bit floating point operation.''')
  write_line('''     *''')
  write_line('''     * Note: The result will be returned in d2.''')
  write_line('''     *''')
  write_line('''     * For: long-to-double''')
  write_line('''     */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[B]''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[A]''')
  write_line('''    vldr    d0, [r3]                    @ d0<- vAA''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''    vcvt.f64.s32    d1, s1              @ d1<- (double)(vAAh)''')
  write_line('''    vcvt.f64.u32    d2, s0              @ d2<- (double)(vAAl)''')
  write_line('''    vldr            d3, constval''' + opcode + '''''')
  write_line('''    vmla.f64        d2, d1, d3          @ d2<- vAAh*2^32 + vAAl''')
  write_line('''''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    vstr.64 d2, [r9]                    @ vAA<- d2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''''')
  write_line('''    /* literal pool helper */''')
  write_line('''constval''' + opcode + ''':''')
  write_line('''    .8byte          0x41f0000000000000''')

def op_long_to_float():
  unopNarrower(instr="bl      __aeabi_l2f")

def op_long_to_int():
  write_line('''/* we ignore the high word, making this equivalent to a 32-bit reg move */''')
  op_move()

def op_monitor_enter():
  write_line('''    /*''')
  write_line('''     * Synchronize on an object.''')
  write_line('''     */''')
  write_line('''    /* monitor-enter vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov      r2, rINST, lsr #8           @ r2<- AA''')
  write_line('''    GET_VREG r0, r2                      @ r0<- vAA (object)''')
  write_line('''    mov      r1, rSELF                   @ r1<- self''')
  write_line('''    bl       artLockObjectFromCode''')
  write_line('''    cmp      r0, #0''')
  write_line('''    bne      MterpException''')
  write_line('''    FETCH_ADVANCE_INST 1''')
  write_line('''    GET_INST_OPCODE ip                   @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                       @ jump to next instruction''')

def op_monitor_exit():
  write_line('''    /*''')
  write_line('''     * Unlock an object.''')
  write_line('''     *''')
  write_line('''     * Exceptions that occur when unlocking a monitor need to appear as''')
  write_line('''     * if they happened at the following instruction.  See the Dalvik''')
  write_line('''     * instruction spec.''')
  write_line('''     */''')
  write_line('''    /* monitor-exit vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov      r2, rINST, lsr #8          @ r2<- AA''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vAA (object)''')
  write_line('''    mov      r1, rSELF                  @ r0<- self''')
  write_line('''    bl       artUnlockObjectFromCode    @ r0<- success for unlock(self, obj)''')
  write_line('''    cmp     r0, #0                      @ failed?''')
  write_line('''    bne     MterpException''')
  write_line('''    FETCH_ADVANCE_INST 1                @ before throw: advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move(is_object="0"):
  write_line('''    /* for move, move-object, long-to-int */''')
  write_line('''    /* op vA, vB */''')
  write_line('''    mov     r1, rINST, lsr #12          @ r1<- B from 15:12''')
  write_line('''    ubfx    r0, rINST, #8, #4           @ r0<- A from 11:8''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    GET_VREG r2, r1                     @ r2<- fp[B]''')
  write_line('''    GET_INST_OPCODE ip                  @ ip<- opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT r2, r0              @ fp[A]<- r2''')
  write_line('''    .else''')
  write_line('''    SET_VREG r2, r0                     @ fp[A]<- r2''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      @ execute next instruction''')

def op_move_16(is_object="0"):
  write_line('''    /* for: move/16, move-object/16 */''')
  write_line('''    /* op vAAAA, vBBBB */''')
  write_line('''    FETCH r1, 2                         @ r1<- BBBB''')
  write_line('''    FETCH r0, 1                         @ r0<- AAAA''')
  write_line('''    FETCH_ADVANCE_INST 3                @ advance rPC, load rINST''')
  write_line('''    GET_VREG r2, r1                     @ r2<- fp[BBBB]''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT r2, r0              @ fp[AAAA]<- r2''')
  write_line('''    .else''')
  write_line('''    SET_VREG r2, r0                     @ fp[AAAA]<- r2''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move_exception():
  write_line('''    /* move-exception vAA */''')
  write_line('''    mov     r2, rINST, lsr #8           @ r2<- AA''')
  write_line('''    ldr     r3, [rSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    mov     r1, #0                      @ r1<- 0''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    SET_VREG_OBJECT r3, r2              @ fp[AA]<- exception obj''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    str     r1, [rSELF, #THREAD_EXCEPTION_OFFSET]  @ clear exception''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move_from16(is_object="0"):
  write_line('''    /* for: move/from16, move-object/from16 */''')
  write_line('''    /* op vAA, vBBBB */''')
  write_line('''    FETCH r1, 1                         @ r1<- BBBB''')
  write_line('''    mov     r0, rINST, lsr #8           @ r0<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    GET_VREG r2, r1                     @ r2<- fp[BBBB]''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT r2, r0              @ fp[AA]<- r2''')
  write_line('''    .else''')
  write_line('''    SET_VREG r2, r0                     @ fp[AA]<- r2''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move_object():
  op_move(is_object="1")

def op_move_object_16():
  op_move_16(is_object="1")

def op_move_object_from16():
  op_move_from16(is_object="1")

def op_move_result(is_object="0"):
  write_line('''    /* for: move-result, move-result-object */''')
  write_line('''    /* op vAA */''')
  write_line('''    mov     r2, rINST, lsr #8           @ r2<- AA''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ldr     r0, [rFP, #OFF_FP_RESULT_REGISTER]  @ get pointer to result JType.''')
  write_line('''    ldr     r0, [r0]                    @ r0 <- result.i.''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT r0, r2, r1          @ fp[AA]<- r0''')
  write_line('''    .else''')
  write_line('''    SET_VREG r0, r2                     @ fp[AA]<- r0''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move_result_object():
  op_move_result(is_object="1")

def op_move_result_wide():
  write_line('''    /* move-result-wide vAA */''')
  write_line('''    mov     rINST, rINST, lsr #8        @ rINST<- AA''')
  write_line('''    ldr     r3, [rFP, #OFF_FP_RESULT_REGISTER]''')
  write_line('''    VREG_INDEX_TO_ADDR r2, rINST        @ r2<- &fp[AA]''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- retval.j''')
  write_line('''    CLEAR_SHADOW_PAIR rINST, ip, lr     @ Zero out the shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move_wide():
  write_line('''    /* move-wide vA, vB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    rINST, rINST, #8, #4        @ rINST<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[B]''')
  write_line('''    VREG_INDEX_TO_ADDR r2, rINST        @ r2<- &fp[A]''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[B]''')
  write_line('''    CLEAR_SHADOW_PAIR rINST, ip, lr     @ Zero out the shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r2, {r0-r1}                 @ fp[A]<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move_wide_16():
  write_line('''    /* move-wide/16 vAAAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    FETCH r3, 2                         @ r3<- BBBB''')
  write_line('''    FETCH r2, 1                         @ r2<- AAAA''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[BBBB]''')
  write_line('''    VREG_INDEX_TO_ADDR lr, r2           @ r2<- &fp[AAAA]''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]''')
  write_line('''    FETCH_ADVANCE_INST 3                @ advance rPC, load rINST''')
  write_line('''    CLEAR_SHADOW_PAIR r2, r3, ip        @ Zero out the shadow regs''')
  write_line('''    stmia   lr, {r0-r1}                 @ fp[AAAA]<- r0/r1''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_move_wide_from16():
  write_line('''    /* move-wide/from16 vAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    FETCH r3, 1                         @ r3<- BBBB''')
  write_line('''    mov     rINST, rINST, lsr #8        @ rINST<- AA''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[BBBB]''')
  write_line('''    VREG_INDEX_TO_ADDR r2, rINST        @ r2<- &fp[AA]''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]''')
  write_line('''    CLEAR_SHADOW_PAIR rINST, ip, lr     @ Zero out the shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_mul_double():
  fbinopWide(instr="fmuld   d2, d0, d1")

def op_mul_double_2addr():
  fbinopWide2addr(instr="fmuld   d2, d0, d1")

def op_mul_float():
  fbinop(instr="fmuls   s2, s0, s1")

def op_mul_float_2addr():
  fbinop2addr(instr="fmuls   s2, s0, s1")

def op_mul_int():
  write_line('''/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */''')
  binop(instr="mul     r0, r1, r0")

def op_mul_int_2addr():
  write_line('''/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */''')
  binop2addr(instr="mul     r0, r1, r0")

def op_mul_int_lit16():
  write_line('''/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */''')
  binopLit16(instr="mul     r0, r1, r0")

def op_mul_int_lit8():
  write_line('''/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */''')
  binopLit8(instr="mul     r0, r1, r0")

def op_mul_long():
  write_line('''    /*''')
  write_line('''     * Signed 64-bit integer multiply.''')
  write_line('''     *''')
  write_line('''     * Consider WXxYZ (r1r0 x r3r2) with a long multiply:''')
  write_line('''     *        WX''')
  write_line('''     *      x YZ''')
  write_line('''     *  --------''')
  write_line('''     *     ZW ZX''')
  write_line('''     *  YW YX''')
  write_line('''     *''')
  write_line('''     * The low word of the result holds ZX, the high word holds''')
  write_line('''     * (ZW+YX) + (the high overflow from ZX).  YW doesn't matter because''')
  write_line('''     * it doesn't fit in the low 64 bits.''')
  write_line('''     *''')
  write_line('''     * Unlike most ARM math operations, multiply instructions have''')
  write_line('''     * restrictions on using the same register more than once (Rd and Rm''')
  write_line('''     * cannot be the same).''')
  write_line('''     */''')
  write_line('''    /* mul-long vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &fp[BB]''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[CC]''')
  write_line('''    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1''')
  write_line('''    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1''')
  write_line('''    mul     ip, r2, r1                  @ ip<- ZxW''')
  write_line('''    umull   r1, lr, r2, r0              @ r1/lr <- ZxX''')
  write_line('''    mla     r2, r0, r3, ip              @ r2<- YxX + (ZxW)''')
  write_line('''    mov     r0, rINST, lsr #8           @ r0<- AA''')
  write_line('''    add     r2, r2, lr                  @ r2<- lr + low(ZxW + (YxX))''')
  write_line('''    CLEAR_SHADOW_PAIR r0, lr, ip        @ Zero out the shadow regs''')
  write_line('''    VREG_INDEX_TO_ADDR r0, r0           @ r0<- &fp[AA]''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r0, {r1-r2 }                @ vAA/vAA+1<- r1/r2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_mul_long_2addr():
  write_line('''    /*''')
  write_line('''     * Signed 64-bit integer multiply, "/2addr" version.''')
  write_line('''     *''')
  write_line('''     * See op_mul_long for an explanation.''')
  write_line('''     *''')
  write_line('''     * We get a little tight on registers, so to avoid looking up &fp[A]''')
  write_line('''     * again we stuff it into rINST.''')
  write_line('''     */''')
  write_line('''    /* mul-long/2addr vA, vB */''')
  write_line('''    mov     r1, rINST, lsr #12          @ r1<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r1, r1           @ r1<- &fp[B]''')
  write_line('''    VREG_INDEX_TO_ADDR rINST, r9        @ rINST<- &fp[A]''')
  write_line('''    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1''')
  write_line('''    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1''')
  write_line('''    mul     ip, r2, r1                  @ ip<- ZxW''')
  write_line('''    umull   r1, lr, r2, r0              @ r1/lr <- ZxX''')
  write_line('''    mla     r2, r0, r3, ip              @ r2<- YxX + (ZxW)''')
  write_line('''    mov     r0, rINST                   @ r0<- &fp[A] (free up rINST)''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    add     r2, r2, lr                  @ r2<- r2 + low(ZxW + (YxX))''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r0, {r1-r2}                 @ vAA/vAA+1<- r1/r2''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_neg_double():
  unopWide(instr="add     r1, r1, #0x80000000")

def op_neg_float():
  unop(instr="add     r0, r0, #0x80000000")

def op_neg_int():
  unop(instr="rsb     r0, r0, #0")

def op_neg_long():
  unopWide(preinstr="rsbs    r0, r0, #0", instr="rsc     r1, r1, #0")

def op_new_array():
  write_line('''    /*''')
  write_line('''     * Allocate an array of objects, specified with the array class''')
  write_line('''     * and a count.''')
  write_line('''     *''')
  write_line('''     * The verifier guarantees that this is an array class, so we don't''')
  write_line('''     * check for it here.''')
  write_line('''     */''')
  write_line('''    /* new-array vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     r0, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r1, rPC''')
  write_line('''    mov     r2, rINST''')
  write_line('''    mov     r3, rSELF''')
  write_line('''    bl      MterpNewArray''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_new_instance():
  write_line('''    /*''')
  write_line('''     * Create a new instance of a class.''')
  write_line('''     */''')
  write_line('''    /* new-instance vAA, class@BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     r0, rFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     r1, rSELF''')
  write_line('''    mov     r2, rINST''')
  write_line('''    bl      MterpNewInstance           @ (shadow_frame, self, inst_data)''')
  write_line('''    cmp     r0, #0''')
  write_line('''    beq     MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2               @ advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                 @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                     @ jump to next instruction''')

def op_nop():
  write_line('''    FETCH_ADVANCE_INST 1                @ advance to next instr, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  @ ip<- opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ execute it''')

def op_not_int():
  unop(instr="mvn     r0, r0")

def op_not_long():
  unopWide(preinstr="mvn     r0, r0", instr="mvn     r1, r1")

def op_or_int():
  binop(instr="orr     r0, r0, r1")

def op_or_int_2addr():
  binop2addr(instr="orr     r0, r0, r1")

def op_or_int_lit16():
  binopLit16(instr="orr     r0, r0, r1")

def op_or_int_lit8():
  binopLit8(extract="", instr="orr     r0, r0, r3, asr #8")

def op_or_long():
  binopWide(preinstr="orr     r0, r0, r2", instr="orr     r1, r1, r3")

def op_or_long_2addr():
  binopWide2addr(preinstr="orr     r0, r0, r2", instr="orr     r1, r1, r3")

def op_packed_switch(func="MterpDoPackedSwitch"):
  write_line('''    /*''')
  write_line('''     * Handle a packed-switch or sparse-switch instruction.  In both cases''')
  write_line('''     * we decode it and hand it off to a helper function.''')
  write_line('''     *''')
  write_line('''     * We don't really expect backward branches in a switch statement, but''')
  write_line('''     * they're perfectly legal, so we check for them here.''')
  write_line('''     *''')
  write_line('''     * for: packed-switch, sparse-switch''')
  write_line('''     */''')
  write_line('''    /* op vAA, +BBBB */''')
  write_line('''    FETCH r0, 1                         @ r0<- bbbb (lo)''')
  write_line('''    FETCH r1, 2                         @ r1<- BBBB (hi)''')
  write_line('''    mov     r3, rINST, lsr #8           @ r3<- AA''')
  write_line('''    orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vAA''')
  write_line('''    add     r0, rPC, r0, lsl #1         @ r0<- PC + BBBBbbbb*2''')
  write_line('''    bl      ''' + func + '''                       @ r0<- code-unit branch offset''')
  write_line('''    movs    rINST, r0''')
  write_line('''    b       MterpCommonTakenBranch''')

def op_rem_double():
  write_line('''/* EABI doesn't define a double remainder function, but libm does */''')
  binopWide(instr="bl      fmod")

def op_rem_double_2addr():
  write_line('''/* EABI doesn't define a double remainder function, but libm does */''')
  binopWide2addr(instr="bl      fmod")

def op_rem_float():
  write_line('''/* EABI doesn't define a float remainder function, but libm does */''')
  binop(instr="bl      fmodf")

def op_rem_float_2addr():
  write_line('''/* EABI doesn't define a float remainder function, but libm does */''')
  binop2addr(instr="bl      fmodf")

def op_rem_int():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r1 = r0 rem r1". The selection between sdiv block or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * NOTE: idivmod returns quotient in r0 and remainder in r1''')
  write_line('''     *''')
  write_line('''     * rem-int''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    mov     r3, r0, lsr #8              @ r3<- CC''')
  write_line('''    and     r2, r0, #255                @ r2<- BB''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vCC''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r2, r0, r1''')
  write_line('''    mls  r1, r1, r2, r0                 @ r1<- op, r0-r2 changed''')
  write_line('''#else''')
  write_line('''    bl   __aeabi_idivmod                @ r1<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r1, r9                     @ vAA<- r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 11-14 instructions */''')

def op_rem_int_2addr():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r1 = r0 rem r1". The selection between sdiv block or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * NOTE: idivmod returns quotient in r0 and remainder in r1''')
  write_line('''     *''')
  write_line('''     * rem-int/2addr''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r1, r3                     @ r1<- vB''')
  write_line('''    GET_VREG r0, r9                     @ r0<- vA''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r2, r0, r1''')
  write_line('''    mls     r1, r1, r2, r0              @ r1<- op''')
  write_line('''#else''')
  write_line('''    bl      __aeabi_idivmod             @ r1<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r1, r9                     @ vAA<- r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')
  write_line('''''')

def op_rem_int_lit16():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r1 = r0 rem r1". The selection between sdiv block or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * NOTE: idivmod returns quotient in r0 and remainder in r1''')
  write_line('''     *''')
  write_line('''     * rem-int/lit16''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    FETCH_S r1, 1                       @ r1<- ssssCCCC (sign-extended)''')
  write_line('''    mov     r2, rINST, lsr #12          @ r2<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vB''')
  write_line('''    cmp     r1, #0                      @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r2, r0, r1''')
  write_line('''    mls     r1, r1, r2, r0              @ r1<- op''')
  write_line('''#else''')
  write_line('''    bl     __aeabi_idivmod              @ r1<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r1, r9                     @ vAA<- r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def op_rem_int_lit8():
  write_line('''    /*''')
  write_line('''     * Specialized 32-bit binary operation''')
  write_line('''     *''')
  write_line('''     * Performs "r1 = r0 rem r1". The selection between sdiv block or the gcc helper''')
  write_line('''     * depends on the compile time value of __ARM_ARCH_EXT_IDIV__ (defined for''')
  write_line('''     * ARMv7 CPUs that have hardware division support).''')
  write_line('''     *''')
  write_line('''     * NOTE: idivmod returns quotient in r0 and remainder in r1''')
  write_line('''     *''')
  write_line('''     * rem-int/lit8''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    FETCH_S r3, 1                       @ r3<- ssssCCBB (sign-extended for CC)''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r2, r3, #255                @ r2<- BB''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vBB''')
  write_line('''    movs    r1, r3, asr #8              @ r1<- ssssssCC (sign extended)''')
  write_line('''    @cmp     r1, #0                     @ is second operand zero?''')
  write_line('''    beq     common_errDivideByZero''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''''')
  write_line('''#ifdef __ARM_ARCH_EXT_IDIV__''')
  write_line('''    sdiv    r2, r0, r1''')
  write_line('''    mls     r1, r1, r2, r0              @ r1<- op''')
  write_line('''#else''')
  write_line('''    bl       __aeabi_idivmod            @ r1<- op, r0-r3 changed''')
  write_line('''#endif''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r1, r9                     @ vAA<- r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-12 instructions */''')

def op_rem_long():
  write_line('''/* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */''')
  binopWide(instr="bl      __aeabi_ldivmod", result0="r2", result1="r3", chkzero="1")

def op_rem_long_2addr():
  write_line('''/* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */''')
  binopWide2addr(instr="bl      __aeabi_ldivmod", result0="r2", result1="r3", chkzero="1")

def op_return():
  write_line('''    /*''')
  write_line('''     * Return a 32-bit value.''')
  write_line('''     *''')
  write_line('''     * for: return, return-object''')
  write_line('''     */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    bl      MterpThreadFenceForConstructor''')
  write_line('''    ldr     lr, [rSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    ands    lr, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    blne    MterpSuspendCheck                       @ (self)''')
  write_line('''    mov     r2, rINST, lsr #8           @ r2<- AA''')
  write_line('''    GET_VREG r0, r2                     @ r0<- vAA''')
  write_line('''    mov     r1, #0''')
  write_line('''    b       MterpReturn''')

def op_return_object():
  op_return()

def op_return_void():
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    bl      MterpThreadFenceForConstructor''')
  write_line('''    ldr     lr, [rSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    ands    lr, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    blne    MterpSuspendCheck                       @ (self)''')
  write_line('''    mov    r0, #0''')
  write_line('''    mov    r1, #0''')
  write_line('''    b      MterpReturn''')

def op_return_void_no_barrier():
  write_line('''    ldr     lr, [rSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    ands    lr, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    blne    MterpSuspendCheck                       @ (self)''')
  write_line('''    mov    r0, #0''')
  write_line('''    mov    r1, #0''')
  write_line('''    b      MterpReturn''')

def op_return_wide():
  write_line('''    /*''')
  write_line('''     * Return a 64-bit value.''')
  write_line('''     */''')
  write_line('''    /* return-wide vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    bl      MterpThreadFenceForConstructor''')
  write_line('''    ldr     lr, [rSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     r0, rSELF''')
  write_line('''    ands    lr, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    blne    MterpSuspendCheck                       @ (self)''')
  write_line('''    mov     r2, rINST, lsr #8           @ r2<- AA''')
  write_line('''    VREG_INDEX_TO_ADDR r2, r2           @ r2<- &fp[AA]''')
  write_line('''    ldmia   r2, {r0-r1}                 @ r0/r1 <- vAA/vAA+1''')
  write_line('''    b       MterpReturn''')

def op_rsub_int():
  write_line('''/* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */''')
  binopLit16(instr="rsb     r0, r0, r1")

def op_rsub_int_lit8():
  binopLit8(extract="", instr="rsb     r0, r0, r3, asr #8")

def op_sget(is_object="0", helper="MterpSGetU32"):
  field(helper=helper)

def op_sget_boolean():
  op_sget(helper="MterpSGetU8")

def op_sget_byte():
  op_sget(helper="MterpSGetI8")

def op_sget_char():
  op_sget(helper="MterpSGetU16")

def op_sget_object():
  op_sget(is_object="1", helper="MterpSGetObj")

def op_sget_short():
  op_sget(helper="MterpSGetI16")

def op_sget_wide():
  op_sget(helper="MterpSGetU64")

def op_shl_int():
  binop(preinstr="and     r1, r1, #31", instr="mov     r0, r0, asl r1")

def op_shl_int_2addr():
  binop2addr(preinstr="and     r1, r1, #31", instr="mov     r0, r0, asl r1")

def op_shl_int_lit8():
  binopLit8(extract="ubfx    r1, r3, #8, #5", instr="mov     r0, r0, asl r1")

def op_shl_long():
  write_line('''    /*''')
  write_line('''     * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line('''     * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line('''     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line('''     * 6 bits of the shift distance.''')
  write_line('''     */''')
  write_line('''    /* shl-long vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r3, r0, #255                @ r3<- BB''')
  write_line('''    mov     r0, r0, lsr #8              @ r0<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[BB]''')
  write_line('''    GET_VREG r2, r0                     @ r2<- vCC''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1''')
  write_line('''    CLEAR_SHADOW_PAIR r9, lr, ip        @ Zero out the shadow regs''')
  write_line('''    and     r2, r2, #63                 @ r2<- r2 & 0x3f''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[AA]''')
  write_line('''    mov     r1, r1, asl r2              @ r1<- r1 << r2''')
  write_line('''    rsb     r3, r2, #32                 @ r3<- 32 - r2''')
  write_line('''    orr     r1, r1, r0, lsr r3          @ r1<- r1 | (r0 << (32-r2))''')
  write_line('''    subs    ip, r2, #32                 @ ip<- r2 - 32''')
  write_line('''    movpl   r1, r0, asl ip              @ if r2 >= 32, r1<- r0 << (r2-32)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    mov     r0, r0, asl r2              @ r0<- r0 << r2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_shl_long_2addr():
  write_line('''    /*''')
  write_line('''     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line('''     * 32-bit shift distance.''')
  write_line('''     */''')
  write_line('''    /* shl-long/2addr vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r2, r3                     @ r2<- vB''')
  write_line('''    CLEAR_SHADOW_PAIR r9, lr, ip        @ Zero out the shadow regs''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[A]''')
  write_line('''    and     r2, r2, #63                 @ r2<- r2 & 0x3f''')
  write_line('''    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1''')
  write_line('''    mov     r1, r1, asl r2              @ r1<- r1 << r2''')
  write_line('''    rsb     r3, r2, #32                 @ r3<- 32 - r2''')
  write_line('''    orr     r1, r1, r0, lsr r3          @ r1<- r1 | (r0 << (32-r2))''')
  write_line('''    subs    ip, r2, #32                 @ ip<- r2 - 32''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    movpl   r1, r0, asl ip              @ if r2 >= 32, r1<- r0 << (r2-32)''')
  write_line('''    mov     r0, r0, asl r2              @ r0<- r0 << r2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_shr_int():
  binop(preinstr="and     r1, r1, #31", instr="mov     r0, r0, asr r1")

def op_shr_int_2addr():
  binop2addr(preinstr="and     r1, r1, #31", instr="mov     r0, r0, asr r1")

def op_shr_int_lit8():
  binopLit8(extract="ubfx    r1, r3, #8, #5", instr="mov     r0, r0, asr r1")

def op_shr_long():
  write_line('''    /*''')
  write_line('''     * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line('''     * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line('''     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line('''     * 6 bits of the shift distance.''')
  write_line('''     */''')
  write_line('''    /* shr-long vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r3, r0, #255                @ r3<- BB''')
  write_line('''    mov     r0, r0, lsr #8              @ r0<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[BB]''')
  write_line('''    GET_VREG r2, r0                     @ r2<- vCC''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1''')
  write_line('''    CLEAR_SHADOW_PAIR r9, lr, ip        @ Zero out the shadow regs''')
  write_line('''    and     r2, r2, #63                 @ r0<- r0 & 0x3f''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[AA]''')
  write_line('''    mov     r0, r0, lsr r2              @ r0<- r2 >> r2''')
  write_line('''    rsb     r3, r2, #32                 @ r3<- 32 - r2''')
  write_line('''    orr     r0, r0, r1, asl r3          @ r0<- r0 | (r1 << (32-r2))''')
  write_line('''    subs    ip, r2, #32                 @ ip<- r2 - 32''')
  write_line('''    movpl   r0, r1, asr ip              @ if r2 >= 32, r0<-r1 >> (r2-32)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    mov     r1, r1, asr r2              @ r1<- r1 >> r2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_shr_long_2addr():
  write_line('''    /*''')
  write_line('''     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line('''     * 32-bit shift distance.''')
  write_line('''     */''')
  write_line('''    /* shr-long/2addr vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r2, r3                     @ r2<- vB''')
  write_line('''    CLEAR_SHADOW_PAIR r9, lr, ip        @ Zero out the shadow regs''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[A]''')
  write_line('''    and     r2, r2, #63                 @ r2<- r2 & 0x3f''')
  write_line('''    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1''')
  write_line('''    mov     r0, r0, lsr r2              @ r0<- r2 >> r2''')
  write_line('''    rsb     r3, r2, #32                 @ r3<- 32 - r2''')
  write_line('''    orr     r0, r0, r1, asl r3          @ r0<- r0 | (r1 << (32-r2))''')
  write_line('''    subs    ip, r2, #32                 @ ip<- r2 - 32''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    movpl   r0, r1, asr ip              @ if r2 >= 32, r0<-r1 >> (r2-32)''')
  write_line('''    mov     r1, r1, asr r2              @ r1<- r1 >> r2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_sparse_switch():
  op_packed_switch(func="MterpDoSparseSwitch")

def op_sput(is_object="0", helper="MterpSPutU32"):
  field(helper=helper)

def op_sput_boolean():
  op_sput(helper="MterpSPutU8")

def op_sput_byte():
  op_sput(helper="MterpSPutI8")

def op_sput_char():
  op_sput(helper="MterpSPutU16")

def op_sput_object():
  op_sput(is_object="1", helper="MterpSPutObj")

def op_sput_short():
  op_sput(helper="MterpSPutI16")

def op_sput_wide():
  op_sput(helper="MterpSPutU64")

def op_sub_double():
  fbinopWide(instr="fsubd   d2, d0, d1")

def op_sub_double_2addr():
  fbinopWide2addr(instr="fsubd   d2, d0, d1")

def op_sub_float():
  fbinop(instr="fsubs   s2, s0, s1")

def op_sub_float_2addr():
  fbinop2addr(instr="fsubs   s2, s0, s1")

def op_sub_int():
  binop(instr="sub     r0, r0, r1")

def op_sub_int_2addr():
  binop2addr(instr="sub     r0, r0, r1")

def op_sub_long():
  binopWide(preinstr="subs    r0, r0, r2", instr="sbc     r1, r1, r3")

def op_sub_long_2addr():
  binopWide2addr(preinstr="subs    r0, r0, r2", instr="sbc     r1, r1, r3")

def op_throw():
  write_line('''    /*''')
  write_line('''     * Throw an exception object in the current thread.''')
  write_line('''     */''')
  write_line('''    /* throw vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov      r2, rINST, lsr #8           @ r2<- AA''')
  write_line('''    GET_VREG r1, r2                      @ r1<- vAA (exception object)''')
  write_line('''    cmp      r1, #0                      @ null object?''')
  write_line('''    beq      common_errNullObject        @ yes, throw an NPE instead''')
  write_line('''    str      r1, [rSELF, #THREAD_EXCEPTION_OFFSET]  @ thread->exception<- obj''')
  write_line('''    b        MterpException''')

def op_unused_3e():
  unused()

def op_unused_3f():
  unused()

def op_unused_40():
  unused()

def op_unused_41():
  unused()

def op_unused_42():
  unused()

def op_unused_43():
  unused()

def op_unused_73():
  unused()

def op_unused_79():
  unused()

def op_unused_7a():
  unused()

def op_unused_f3():
  unused()

def op_unused_f4():
  unused()

def op_unused_f5():
  unused()

def op_unused_f6():
  unused()

def op_unused_f7():
  unused()

def op_unused_f8():
  unused()

def op_unused_f9():
  unused()

def op_unused_fc():
  unused()

def op_unused_fd():
  unused()

def op_ushr_int():
  binop(preinstr="and     r1, r1, #31", instr="mov     r0, r0, lsr r1")

def op_ushr_int_2addr():
  binop2addr(preinstr="and     r1, r1, #31", instr="mov     r0, r0, lsr r1")

def op_ushr_int_lit8():
  binopLit8(extract="ubfx    r1, r3, #8, #5", instr="mov     r0, r0, lsr r1")

def op_ushr_long():
  write_line('''    /*''')
  write_line('''     * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line('''     * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line('''     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line('''     * 6 bits of the shift distance.''')
  write_line('''     */''')
  write_line('''    /* ushr-long vAA, vBB, vCC */''')
  write_line('''    FETCH r0, 1                         @ r0<- CCBB''')
  write_line('''    mov     r9, rINST, lsr #8           @ r9<- AA''')
  write_line('''    and     r3, r0, #255                @ r3<- BB''')
  write_line('''    mov     r0, r0, lsr #8              @ r0<- CC''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[BB]''')
  write_line('''    GET_VREG r2, r0                     @ r2<- vCC''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1''')
  write_line('''    CLEAR_SHADOW_PAIR r9, lr, ip        @ Zero out the shadow regs''')
  write_line('''    and     r2, r2, #63                 @ r0<- r0 & 0x3f''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[AA]''')
  write_line('''    mov     r0, r0, lsr r2              @ r0<- r2 >> r2''')
  write_line('''    rsb     r3, r2, #32                 @ r3<- 32 - r2''')
  write_line('''    orr     r0, r0, r1, asl r3          @ r0<- r0 | (r1 << (32-r2))''')
  write_line('''    subs    ip, r2, #32                 @ ip<- r2 - 32''')
  write_line('''    movpl   r0, r1, lsr ip              @ if r2 >= 32, r0<-r1 >>> (r2-32)''')
  write_line('''    FETCH_ADVANCE_INST 2                @ advance rPC, load rINST''')
  write_line('''    mov     r1, r1, lsr r2              @ r1<- r1 >>> r2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_ushr_long_2addr():
  write_line('''    /*''')
  write_line('''     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line('''     * 32-bit shift distance.''')
  write_line('''     */''')
  write_line('''    /* ushr-long/2addr vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r2, r3                     @ r2<- vB''')
  write_line('''    CLEAR_SHADOW_PAIR r9, lr, ip        @ Zero out the shadow regs''')
  write_line('''    VREG_INDEX_TO_ADDR r9, r9           @ r9<- &fp[A]''')
  write_line('''    and     r2, r2, #63                 @ r2<- r2 & 0x3f''')
  write_line('''    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1''')
  write_line('''    mov     r0, r0, lsr r2              @ r0<- r2 >> r2''')
  write_line('''    rsb     r3, r2, #32                 @ r3<- 32 - r2''')
  write_line('''    orr     r0, r0, r1, asl r3          @ r0<- r0 | (r1 << (32-r2))''')
  write_line('''    subs    ip, r2, #32                 @ ip<- r2 - 32''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    movpl   r0, r1, lsr ip              @ if r2 >= 32, r0<-r1 >>> (r2-32)''')
  write_line('''    mov     r1, r1, lsr r2              @ r1<- r1 >>> r2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

def op_xor_int():
  binop(instr="eor     r0, r0, r1")

def op_xor_int_2addr():
  binop2addr(instr="eor     r0, r0, r1")

def op_xor_int_lit16():
  binopLit16(instr="eor     r0, r0, r1")

def op_xor_int_lit8():
  binopLit8(extract="", instr="eor     r0, r0, r3, asr #8")

def op_xor_long():
  binopWide(preinstr="eor     r0, r0, r2", instr="eor     r1, r1, r3")

def op_xor_long_2addr():
  binopWide2addr(preinstr="eor     r0, r0, r2", instr="eor     r1, r1, r3")

def unop(preinstr="", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = op r0".''')
  write_line('''     * This could be an ARM instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * for: neg-int, not-int, neg-float, int-to-float, float-to-int,''')
  write_line('''     *      int-to-byte, int-to-char, int-to-short''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    GET_VREG r0, r3                     @ r0<- vB''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              @ r0<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r0, r9                     @ vAA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 8-9 instructions */''')

def unopNarrower(preinstr="", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64bit-to-32bit unary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = op r0/r1", where''')
  write_line('''     * "result" is a 32-bit quantity in r0.''')
  write_line('''     *''')
  write_line('''     * For: long-to-float, double-to-int, double-to-float''')
  write_line('''     *''')
  write_line('''     * (This would work for long-to-int, but that instruction is actually''')
  write_line('''     * an exact match for op_move.)''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    r9, rINST, #8, #4           @ r9<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[B]''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- vB/vB+1''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              @ r0<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    SET_VREG r0, r9                     @ vA<- r0''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 9-10 instructions */''')

def unopWide(preinstr="", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = op r0/r1".''')
  write_line('''     * This could be an ARM instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * For: neg-long, not-long, neg-double, long-to-double, double-to-long''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    rINST, rINST, #8, #4        @ rINST<- A''')
  write_line('''    VREG_INDEX_TO_ADDR r3, r3           @ r3<- &fp[B]''')
  write_line('''    VREG_INDEX_TO_ADDR r9, rINST        @ r9<- &fp[A]''')
  write_line('''    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA''')
  write_line('''    CLEAR_SHADOW_PAIR rINST, ip, lr     @ Zero shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              @ r0/r1<- op, r2-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vAA<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 10-11 instructions */''')

def unopWider(preinstr="", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32bit-to-64bit unary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = op r0", where''')
  write_line('''     * "result" is a 64-bit quantity in r0/r1.''')
  write_line('''     *''')
  write_line('''     * For: int-to-long, int-to-double, float-to-long, float-to-double''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    mov     r3, rINST, lsr #12          @ r3<- B''')
  write_line('''    ubfx    rINST, rINST, #8, #4        @ rINST<- A''')
  write_line('''    GET_VREG r0, r3                     @ r0<- vB''')
  write_line('''    VREG_INDEX_TO_ADDR r9, rINST        @ r9<- &fp[A]''')
  write_line('''    ''' + preinstr + '''                           @ optional op; may set condition codes''')
  write_line('''    CLEAR_SHADOW_PAIR rINST, ip, lr     @ Zero shadow regs''')
  write_line('''    FETCH_ADVANCE_INST 1                @ advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              @ r0<- op, r0-r3 changed''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')
  write_line('''    /* 9-10 instructions */''')

def unused():
  write_line('''/*''')
  write_line(''' * Bail to reference interpreter to throw.''')
  write_line(''' */''')
  write_line('''  b MterpFallback''')

def zcmp(condition=""):
  write_line('''    /*''')
  write_line('''     * Generic one-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform.''')
  write_line('''     *''')
  write_line('''     * for: if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez''')
  write_line('''     */''')
  write_line('''    /* if-cmp vAA, +BBBB */''')
  write_line('''    mov     r0, rINST, lsr #8           @ r0<- AA''')
  write_line('''    GET_VREG r0, r0                     @ r0<- vAA''')
  write_line('''    FETCH_S rINST, 1                    @ rINST<- branch offset, in code units''')
  write_line('''    cmp     r0, #0                      @ compare (vA, 0)''')
  write_line('''    b''' + condition + ''' MterpCommonTakenBranchNoFlags''')
  write_line('''    cmp     rPROFILE, #JIT_CHECK_OSR    @ possible OSR re-entry?''')
  write_line('''    beq     .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST 2''')
  write_line('''    GET_INST_OPCODE ip                  @ extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      @ jump to next instruction''')

