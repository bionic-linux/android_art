# DO NOT EDIT: This file was generated by gen-mterp.py.
arch = "mips64"

import sys

out = sys.stdout
handler_size_bytes = "128"
handler_size_bits = "7"
opcode = ""
opnum = ""

def write_line(line):
  out.write(line + "\n")

def balign():
  write_line("    .balign {}".format(handler_size_bytes))

def write_opcode(num, name, write_method, is_alt):
  global opnum, opcode
  opnum, opcode = str(num), name
  if is_alt:
    name = "ALT_" + name
  write_line("/* ------------------------------ */")
  balign()
  write_line(".L_{1}: /* {0:#04x} */".format(num, name))
  if is_alt:
    alt_stub()
  else:
    write_method()
  write_line("")
  opnum, opcode = None, None

def generate(output_file):
  global out
  out = output_file
  write_line("/* DO NOT EDIT: This file was generated by gen-mterp.py. */")
  header()
  entry()

  instruction_start()
  opcodes(is_alt = False)
  balign()
  instruction_end()

  instruction_start_sister()
  write_sister()
  instruction_end_sister()

  # We need to footer sooner so that branch instruction can reach it.
  # TODO: Clean up.
  if arch == "arm64":
    footer()

  instruction_start_alt()
  opcodes(is_alt = True)
  balign()
  instruction_end_alt()

  if arch == "arm64":
    close_cfi()
  else:
    footer()

  out.truncate()

def opcodes(is_alt):
  write_opcode(0, "op_nop", op_nop, is_alt)
  write_opcode(1, "op_move", op_move, is_alt)
  write_opcode(2, "op_move_from16", op_move_from16, is_alt)
  write_opcode(3, "op_move_16", op_move_16, is_alt)
  write_opcode(4, "op_move_wide", op_move_wide, is_alt)
  write_opcode(5, "op_move_wide_from16", op_move_wide_from16, is_alt)
  write_opcode(6, "op_move_wide_16", op_move_wide_16, is_alt)
  write_opcode(7, "op_move_object", op_move_object, is_alt)
  write_opcode(8, "op_move_object_from16", op_move_object_from16, is_alt)
  write_opcode(9, "op_move_object_16", op_move_object_16, is_alt)
  write_opcode(10, "op_move_result", op_move_result, is_alt)
  write_opcode(11, "op_move_result_wide", op_move_result_wide, is_alt)
  write_opcode(12, "op_move_result_object", op_move_result_object, is_alt)
  write_opcode(13, "op_move_exception", op_move_exception, is_alt)
  write_opcode(14, "op_return_void", op_return_void, is_alt)
  write_opcode(15, "op_return", op_return, is_alt)
  write_opcode(16, "op_return_wide", op_return_wide, is_alt)
  write_opcode(17, "op_return_object", op_return_object, is_alt)
  write_opcode(18, "op_const_4", op_const_4, is_alt)
  write_opcode(19, "op_const_16", op_const_16, is_alt)
  write_opcode(20, "op_const", op_const, is_alt)
  write_opcode(21, "op_const_high16", op_const_high16, is_alt)
  write_opcode(22, "op_const_wide_16", op_const_wide_16, is_alt)
  write_opcode(23, "op_const_wide_32", op_const_wide_32, is_alt)
  write_opcode(24, "op_const_wide", op_const_wide, is_alt)
  write_opcode(25, "op_const_wide_high16", op_const_wide_high16, is_alt)
  write_opcode(26, "op_const_string", op_const_string, is_alt)
  write_opcode(27, "op_const_string_jumbo", op_const_string_jumbo, is_alt)
  write_opcode(28, "op_const_class", op_const_class, is_alt)
  write_opcode(29, "op_monitor_enter", op_monitor_enter, is_alt)
  write_opcode(30, "op_monitor_exit", op_monitor_exit, is_alt)
  write_opcode(31, "op_check_cast", op_check_cast, is_alt)
  write_opcode(32, "op_instance_of", op_instance_of, is_alt)
  write_opcode(33, "op_array_length", op_array_length, is_alt)
  write_opcode(34, "op_new_instance", op_new_instance, is_alt)
  write_opcode(35, "op_new_array", op_new_array, is_alt)
  write_opcode(36, "op_filled_new_array", op_filled_new_array, is_alt)
  write_opcode(37, "op_filled_new_array_range", op_filled_new_array_range, is_alt)
  write_opcode(38, "op_fill_array_data", op_fill_array_data, is_alt)
  write_opcode(39, "op_throw", op_throw, is_alt)
  write_opcode(40, "op_goto", op_goto, is_alt)
  write_opcode(41, "op_goto_16", op_goto_16, is_alt)
  write_opcode(42, "op_goto_32", op_goto_32, is_alt)
  write_opcode(43, "op_packed_switch", op_packed_switch, is_alt)
  write_opcode(44, "op_sparse_switch", op_sparse_switch, is_alt)
  write_opcode(45, "op_cmpl_float", op_cmpl_float, is_alt)
  write_opcode(46, "op_cmpg_float", op_cmpg_float, is_alt)
  write_opcode(47, "op_cmpl_double", op_cmpl_double, is_alt)
  write_opcode(48, "op_cmpg_double", op_cmpg_double, is_alt)
  write_opcode(49, "op_cmp_long", op_cmp_long, is_alt)
  write_opcode(50, "op_if_eq", op_if_eq, is_alt)
  write_opcode(51, "op_if_ne", op_if_ne, is_alt)
  write_opcode(52, "op_if_lt", op_if_lt, is_alt)
  write_opcode(53, "op_if_ge", op_if_ge, is_alt)
  write_opcode(54, "op_if_gt", op_if_gt, is_alt)
  write_opcode(55, "op_if_le", op_if_le, is_alt)
  write_opcode(56, "op_if_eqz", op_if_eqz, is_alt)
  write_opcode(57, "op_if_nez", op_if_nez, is_alt)
  write_opcode(58, "op_if_ltz", op_if_ltz, is_alt)
  write_opcode(59, "op_if_gez", op_if_gez, is_alt)
  write_opcode(60, "op_if_gtz", op_if_gtz, is_alt)
  write_opcode(61, "op_if_lez", op_if_lez, is_alt)
  write_opcode(62, "op_unused_3e", op_unused_3e, is_alt)
  write_opcode(63, "op_unused_3f", op_unused_3f, is_alt)
  write_opcode(64, "op_unused_40", op_unused_40, is_alt)
  write_opcode(65, "op_unused_41", op_unused_41, is_alt)
  write_opcode(66, "op_unused_42", op_unused_42, is_alt)
  write_opcode(67, "op_unused_43", op_unused_43, is_alt)
  write_opcode(68, "op_aget", op_aget, is_alt)
  write_opcode(69, "op_aget_wide", op_aget_wide, is_alt)
  write_opcode(70, "op_aget_object", op_aget_object, is_alt)
  write_opcode(71, "op_aget_boolean", op_aget_boolean, is_alt)
  write_opcode(72, "op_aget_byte", op_aget_byte, is_alt)
  write_opcode(73, "op_aget_char", op_aget_char, is_alt)
  write_opcode(74, "op_aget_short", op_aget_short, is_alt)
  write_opcode(75, "op_aput", op_aput, is_alt)
  write_opcode(76, "op_aput_wide", op_aput_wide, is_alt)
  write_opcode(77, "op_aput_object", op_aput_object, is_alt)
  write_opcode(78, "op_aput_boolean", op_aput_boolean, is_alt)
  write_opcode(79, "op_aput_byte", op_aput_byte, is_alt)
  write_opcode(80, "op_aput_char", op_aput_char, is_alt)
  write_opcode(81, "op_aput_short", op_aput_short, is_alt)
  write_opcode(82, "op_iget", op_iget, is_alt)
  write_opcode(83, "op_iget_wide", op_iget_wide, is_alt)
  write_opcode(84, "op_iget_object", op_iget_object, is_alt)
  write_opcode(85, "op_iget_boolean", op_iget_boolean, is_alt)
  write_opcode(86, "op_iget_byte", op_iget_byte, is_alt)
  write_opcode(87, "op_iget_char", op_iget_char, is_alt)
  write_opcode(88, "op_iget_short", op_iget_short, is_alt)
  write_opcode(89, "op_iput", op_iput, is_alt)
  write_opcode(90, "op_iput_wide", op_iput_wide, is_alt)
  write_opcode(91, "op_iput_object", op_iput_object, is_alt)
  write_opcode(92, "op_iput_boolean", op_iput_boolean, is_alt)
  write_opcode(93, "op_iput_byte", op_iput_byte, is_alt)
  write_opcode(94, "op_iput_char", op_iput_char, is_alt)
  write_opcode(95, "op_iput_short", op_iput_short, is_alt)
  write_opcode(96, "op_sget", op_sget, is_alt)
  write_opcode(97, "op_sget_wide", op_sget_wide, is_alt)
  write_opcode(98, "op_sget_object", op_sget_object, is_alt)
  write_opcode(99, "op_sget_boolean", op_sget_boolean, is_alt)
  write_opcode(100, "op_sget_byte", op_sget_byte, is_alt)
  write_opcode(101, "op_sget_char", op_sget_char, is_alt)
  write_opcode(102, "op_sget_short", op_sget_short, is_alt)
  write_opcode(103, "op_sput", op_sput, is_alt)
  write_opcode(104, "op_sput_wide", op_sput_wide, is_alt)
  write_opcode(105, "op_sput_object", op_sput_object, is_alt)
  write_opcode(106, "op_sput_boolean", op_sput_boolean, is_alt)
  write_opcode(107, "op_sput_byte", op_sput_byte, is_alt)
  write_opcode(108, "op_sput_char", op_sput_char, is_alt)
  write_opcode(109, "op_sput_short", op_sput_short, is_alt)
  write_opcode(110, "op_invoke_virtual", op_invoke_virtual, is_alt)
  write_opcode(111, "op_invoke_super", op_invoke_super, is_alt)
  write_opcode(112, "op_invoke_direct", op_invoke_direct, is_alt)
  write_opcode(113, "op_invoke_static", op_invoke_static, is_alt)
  write_opcode(114, "op_invoke_interface", op_invoke_interface, is_alt)
  write_opcode(115, "op_return_void_no_barrier", op_return_void_no_barrier, is_alt)
  write_opcode(116, "op_invoke_virtual_range", op_invoke_virtual_range, is_alt)
  write_opcode(117, "op_invoke_super_range", op_invoke_super_range, is_alt)
  write_opcode(118, "op_invoke_direct_range", op_invoke_direct_range, is_alt)
  write_opcode(119, "op_invoke_static_range", op_invoke_static_range, is_alt)
  write_opcode(120, "op_invoke_interface_range", op_invoke_interface_range, is_alt)
  write_opcode(121, "op_unused_79", op_unused_79, is_alt)
  write_opcode(122, "op_unused_7a", op_unused_7a, is_alt)
  write_opcode(123, "op_neg_int", op_neg_int, is_alt)
  write_opcode(124, "op_not_int", op_not_int, is_alt)
  write_opcode(125, "op_neg_long", op_neg_long, is_alt)
  write_opcode(126, "op_not_long", op_not_long, is_alt)
  write_opcode(127, "op_neg_float", op_neg_float, is_alt)
  write_opcode(128, "op_neg_double", op_neg_double, is_alt)
  write_opcode(129, "op_int_to_long", op_int_to_long, is_alt)
  write_opcode(130, "op_int_to_float", op_int_to_float, is_alt)
  write_opcode(131, "op_int_to_double", op_int_to_double, is_alt)
  write_opcode(132, "op_long_to_int", op_long_to_int, is_alt)
  write_opcode(133, "op_long_to_float", op_long_to_float, is_alt)
  write_opcode(134, "op_long_to_double", op_long_to_double, is_alt)
  write_opcode(135, "op_float_to_int", op_float_to_int, is_alt)
  write_opcode(136, "op_float_to_long", op_float_to_long, is_alt)
  write_opcode(137, "op_float_to_double", op_float_to_double, is_alt)
  write_opcode(138, "op_double_to_int", op_double_to_int, is_alt)
  write_opcode(139, "op_double_to_long", op_double_to_long, is_alt)
  write_opcode(140, "op_double_to_float", op_double_to_float, is_alt)
  write_opcode(141, "op_int_to_byte", op_int_to_byte, is_alt)
  write_opcode(142, "op_int_to_char", op_int_to_char, is_alt)
  write_opcode(143, "op_int_to_short", op_int_to_short, is_alt)
  write_opcode(144, "op_add_int", op_add_int, is_alt)
  write_opcode(145, "op_sub_int", op_sub_int, is_alt)
  write_opcode(146, "op_mul_int", op_mul_int, is_alt)
  write_opcode(147, "op_div_int", op_div_int, is_alt)
  write_opcode(148, "op_rem_int", op_rem_int, is_alt)
  write_opcode(149, "op_and_int", op_and_int, is_alt)
  write_opcode(150, "op_or_int", op_or_int, is_alt)
  write_opcode(151, "op_xor_int", op_xor_int, is_alt)
  write_opcode(152, "op_shl_int", op_shl_int, is_alt)
  write_opcode(153, "op_shr_int", op_shr_int, is_alt)
  write_opcode(154, "op_ushr_int", op_ushr_int, is_alt)
  write_opcode(155, "op_add_long", op_add_long, is_alt)
  write_opcode(156, "op_sub_long", op_sub_long, is_alt)
  write_opcode(157, "op_mul_long", op_mul_long, is_alt)
  write_opcode(158, "op_div_long", op_div_long, is_alt)
  write_opcode(159, "op_rem_long", op_rem_long, is_alt)
  write_opcode(160, "op_and_long", op_and_long, is_alt)
  write_opcode(161, "op_or_long", op_or_long, is_alt)
  write_opcode(162, "op_xor_long", op_xor_long, is_alt)
  write_opcode(163, "op_shl_long", op_shl_long, is_alt)
  write_opcode(164, "op_shr_long", op_shr_long, is_alt)
  write_opcode(165, "op_ushr_long", op_ushr_long, is_alt)
  write_opcode(166, "op_add_float", op_add_float, is_alt)
  write_opcode(167, "op_sub_float", op_sub_float, is_alt)
  write_opcode(168, "op_mul_float", op_mul_float, is_alt)
  write_opcode(169, "op_div_float", op_div_float, is_alt)
  write_opcode(170, "op_rem_float", op_rem_float, is_alt)
  write_opcode(171, "op_add_double", op_add_double, is_alt)
  write_opcode(172, "op_sub_double", op_sub_double, is_alt)
  write_opcode(173, "op_mul_double", op_mul_double, is_alt)
  write_opcode(174, "op_div_double", op_div_double, is_alt)
  write_opcode(175, "op_rem_double", op_rem_double, is_alt)
  write_opcode(176, "op_add_int_2addr", op_add_int_2addr, is_alt)
  write_opcode(177, "op_sub_int_2addr", op_sub_int_2addr, is_alt)
  write_opcode(178, "op_mul_int_2addr", op_mul_int_2addr, is_alt)
  write_opcode(179, "op_div_int_2addr", op_div_int_2addr, is_alt)
  write_opcode(180, "op_rem_int_2addr", op_rem_int_2addr, is_alt)
  write_opcode(181, "op_and_int_2addr", op_and_int_2addr, is_alt)
  write_opcode(182, "op_or_int_2addr", op_or_int_2addr, is_alt)
  write_opcode(183, "op_xor_int_2addr", op_xor_int_2addr, is_alt)
  write_opcode(184, "op_shl_int_2addr", op_shl_int_2addr, is_alt)
  write_opcode(185, "op_shr_int_2addr", op_shr_int_2addr, is_alt)
  write_opcode(186, "op_ushr_int_2addr", op_ushr_int_2addr, is_alt)
  write_opcode(187, "op_add_long_2addr", op_add_long_2addr, is_alt)
  write_opcode(188, "op_sub_long_2addr", op_sub_long_2addr, is_alt)
  write_opcode(189, "op_mul_long_2addr", op_mul_long_2addr, is_alt)
  write_opcode(190, "op_div_long_2addr", op_div_long_2addr, is_alt)
  write_opcode(191, "op_rem_long_2addr", op_rem_long_2addr, is_alt)
  write_opcode(192, "op_and_long_2addr", op_and_long_2addr, is_alt)
  write_opcode(193, "op_or_long_2addr", op_or_long_2addr, is_alt)
  write_opcode(194, "op_xor_long_2addr", op_xor_long_2addr, is_alt)
  write_opcode(195, "op_shl_long_2addr", op_shl_long_2addr, is_alt)
  write_opcode(196, "op_shr_long_2addr", op_shr_long_2addr, is_alt)
  write_opcode(197, "op_ushr_long_2addr", op_ushr_long_2addr, is_alt)
  write_opcode(198, "op_add_float_2addr", op_add_float_2addr, is_alt)
  write_opcode(199, "op_sub_float_2addr", op_sub_float_2addr, is_alt)
  write_opcode(200, "op_mul_float_2addr", op_mul_float_2addr, is_alt)
  write_opcode(201, "op_div_float_2addr", op_div_float_2addr, is_alt)
  write_opcode(202, "op_rem_float_2addr", op_rem_float_2addr, is_alt)
  write_opcode(203, "op_add_double_2addr", op_add_double_2addr, is_alt)
  write_opcode(204, "op_sub_double_2addr", op_sub_double_2addr, is_alt)
  write_opcode(205, "op_mul_double_2addr", op_mul_double_2addr, is_alt)
  write_opcode(206, "op_div_double_2addr", op_div_double_2addr, is_alt)
  write_opcode(207, "op_rem_double_2addr", op_rem_double_2addr, is_alt)
  write_opcode(208, "op_add_int_lit16", op_add_int_lit16, is_alt)
  write_opcode(209, "op_rsub_int", op_rsub_int, is_alt)
  write_opcode(210, "op_mul_int_lit16", op_mul_int_lit16, is_alt)
  write_opcode(211, "op_div_int_lit16", op_div_int_lit16, is_alt)
  write_opcode(212, "op_rem_int_lit16", op_rem_int_lit16, is_alt)
  write_opcode(213, "op_and_int_lit16", op_and_int_lit16, is_alt)
  write_opcode(214, "op_or_int_lit16", op_or_int_lit16, is_alt)
  write_opcode(215, "op_xor_int_lit16", op_xor_int_lit16, is_alt)
  write_opcode(216, "op_add_int_lit8", op_add_int_lit8, is_alt)
  write_opcode(217, "op_rsub_int_lit8", op_rsub_int_lit8, is_alt)
  write_opcode(218, "op_mul_int_lit8", op_mul_int_lit8, is_alt)
  write_opcode(219, "op_div_int_lit8", op_div_int_lit8, is_alt)
  write_opcode(220, "op_rem_int_lit8", op_rem_int_lit8, is_alt)
  write_opcode(221, "op_and_int_lit8", op_and_int_lit8, is_alt)
  write_opcode(222, "op_or_int_lit8", op_or_int_lit8, is_alt)
  write_opcode(223, "op_xor_int_lit8", op_xor_int_lit8, is_alt)
  write_opcode(224, "op_shl_int_lit8", op_shl_int_lit8, is_alt)
  write_opcode(225, "op_shr_int_lit8", op_shr_int_lit8, is_alt)
  write_opcode(226, "op_ushr_int_lit8", op_ushr_int_lit8, is_alt)
  write_opcode(227, "op_iget_quick", op_iget_quick, is_alt)
  write_opcode(228, "op_iget_wide_quick", op_iget_wide_quick, is_alt)
  write_opcode(229, "op_iget_object_quick", op_iget_object_quick, is_alt)
  write_opcode(230, "op_iput_quick", op_iput_quick, is_alt)
  write_opcode(231, "op_iput_wide_quick", op_iput_wide_quick, is_alt)
  write_opcode(232, "op_iput_object_quick", op_iput_object_quick, is_alt)
  write_opcode(233, "op_invoke_virtual_quick", op_invoke_virtual_quick, is_alt)
  write_opcode(234, "op_invoke_virtual_range_quick", op_invoke_virtual_range_quick, is_alt)
  write_opcode(235, "op_iput_boolean_quick", op_iput_boolean_quick, is_alt)
  write_opcode(236, "op_iput_byte_quick", op_iput_byte_quick, is_alt)
  write_opcode(237, "op_iput_char_quick", op_iput_char_quick, is_alt)
  write_opcode(238, "op_iput_short_quick", op_iput_short_quick, is_alt)
  write_opcode(239, "op_iget_boolean_quick", op_iget_boolean_quick, is_alt)
  write_opcode(240, "op_iget_byte_quick", op_iget_byte_quick, is_alt)
  write_opcode(241, "op_iget_char_quick", op_iget_char_quick, is_alt)
  write_opcode(242, "op_iget_short_quick", op_iget_short_quick, is_alt)
  write_opcode(243, "op_unused_f3", op_unused_f3, is_alt)
  write_opcode(244, "op_unused_f4", op_unused_f4, is_alt)
  write_opcode(245, "op_unused_f5", op_unused_f5, is_alt)
  write_opcode(246, "op_unused_f6", op_unused_f6, is_alt)
  write_opcode(247, "op_unused_f7", op_unused_f7, is_alt)
  write_opcode(248, "op_unused_f8", op_unused_f8, is_alt)
  write_opcode(249, "op_unused_f9", op_unused_f9, is_alt)
  write_opcode(250, "op_invoke_polymorphic", op_invoke_polymorphic, is_alt)
  write_opcode(251, "op_invoke_polymorphic_range", op_invoke_polymorphic_range, is_alt)
  write_opcode(252, "op_invoke_custom", op_invoke_custom, is_alt)
  write_opcode(253, "op_invoke_custom_range", op_invoke_custom_range, is_alt)
  write_opcode(254, "op_const_method_handle", op_const_method_handle, is_alt)
  write_opcode(255, "op_const_method_type", op_const_method_type, is_alt)
def write_sister():
  global opnum, opcode
  pass
def alt_stub():
  write_line('''/*''')
  write_line(''' * Inter-instruction transfer stub.  Call out to MterpCheckBefore to handle''')
  write_line(''' * any interesting requests and then jump to the real instruction''')
  write_line(''' * handler.  Note that the call to MterpCheckBefore is done as a tail call.''')
  write_line(''' */''')
  write_line('''    .extern MterpCheckBefore''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    dla     ra, artMterpAsmInstructionStart''')
  write_line('''    dla     t9, MterpCheckBefore''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rPC''')
  write_line('''    daddu   ra, ra, (''' + opnum + ''' * 128)            # Addr of primary handler.''')
  write_line('''    jalr    zero, t9                            # (self, shadow_frame, dex_pc_ptr) Note: tail call.''')

def bincmp(condition=""):
  write_line('''    /*''')
  write_line('''     * Generic two-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform, e.g. for''')
  write_line('''     * "if-le" you would use "le".''')
  write_line('''     *''')
  write_line('''     * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le''')
  write_line('''     */''')
  write_line('''    /* if-cmp vA, vB, +CCCC */''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    lh      rINST, 2(rPC)               # rINST <- offset (sign-extended CCCC)''')
  write_line('''    GET_VREG a0, a2                     # a0 <- vA''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vB''')
  write_line('''    b''' + condition + '''c a0, a1, MterpCommonTakenBranchNoFlags''')
  write_line('''    li      v0, JIT_CHECK_OSR           # possible OSR re-entry?''')
  write_line('''    beqc    rPROFILE, v0, .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def binop(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be a MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (a1).  Useful for integer division and modulus.  Note that we''')
  write_line('''     * *don't* check for (INT_MIN / -1) here, because the CPU handles it''')
  write_line('''     * correctly.''')
  write_line('''     *''')
  write_line('''     * For: add-int, sub-int, mul-int, div-int, rem-int, and-int, or-int,''')
  write_line('''     *      xor-int, shl-int, shr-int, ushr-int''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG a0, a2                     # a0 <- vBB''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vCC''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    beqz    a1, common_errDivideByZero  # is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    ''' + instr + '''                              # ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', a4                # vAA <- ''' + result + '''''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def binop2addr(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be a MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vB (a1).  Useful for integer division and modulus.  Note that we''')
  write_line('''     * *don't* check for (INT_MIN / -1) here, because the CPU handles it''')
  write_line('''     * correctly.''')
  write_line('''     *''')
  write_line('''     * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,''')
  write_line('''     *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,''')
  write_line('''     *      shl-int/2addr, shr-int/2addr, ushr-int/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG a0, a2                     # a0 <- vA''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    beqz    a1, common_errDivideByZero  # is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    ''' + instr + '''                              # ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', a2                # vA <- ''' + result + '''''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def binopLit16(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit16" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be an MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * CCCC (a1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit16, rsub-int, mul-int/lit16, div-int/lit16,''')
  write_line('''     *      rem-int/lit16, and-int/lit16, or-int/lit16, xor-int/lit16''')
  write_line('''     */''')
  write_line('''    /* binop/lit16 vA, vB, #+CCCC */''')
  write_line('''    lh      a1, 2(rPC)                  # a1 <- sign-extended CCCC''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG a0, a3                     # a0 <- vB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    beqz    a1, common_errDivideByZero  # is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    ''' + instr + '''                              # ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', a2                # vA <- ''' + result + '''''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')
  write_line('''''')

def binopLit8(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit8" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be an MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * CC (a1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit8, rsub-int/lit8, mul-int/lit8, div-int/lit8,''')
  write_line('''     *      rem-int/lit8, and-int/lit8, or-int/lit8, xor-int/lit8,''')
  write_line('''     *      shl-int/lit8, shr-int/lit8, ushr-int/lit8''')
  write_line('''     */''')
  write_line('''    /* binop/lit8 vAA, vBB, #+CC */''')
  write_line('''    lbu     a3, 2(rPC)                  # a3 <- BB''')
  write_line('''    lb      a1, 3(rPC)                  # a1 <- sign-extended CC''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    GET_VREG a0, a3                     # a0 <- vBB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    beqz    a1, common_errDivideByZero  # is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    ''' + instr + '''                              # ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', a2                # vAA <- ''' + result + '''''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')
  write_line('''''')

def binopWide(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be a MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (a1).  Useful for integer division and modulus.  Note that we''')
  write_line('''     * *don't* check for (LONG_MIN / -1) here, because the CPU handles it''')
  write_line('''     * correctly.''')
  write_line('''     *''')
  write_line('''     * For: add-long, sub-long, mul-long, div-long, rem-long, and-long, or-long,''')
  write_line('''     *      xor-long, shl-long, shr-long, ushr-long''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG_WIDE a0, a2                # a0 <- vBB''')
  write_line('''    GET_VREG_WIDE a1, a3                # a1 <- vCC''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    beqz    a1, common_errDivideByZero  # is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    ''' + instr + '''                              # ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE ''' + result + ''', a4           # vAA <- ''' + result + '''''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def binopWide2addr(preinstr="", result="a0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = a0 op a1".''')
  write_line('''     * This could be a MIPS instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than a0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vB (a1).  Useful for integer division and modulus.  Note that we''')
  write_line('''     * *don't* check for (LONG_MIN / -1) here, because the CPU handles it''')
  write_line('''     * correctly.''')
  write_line('''     *''')
  write_line('''     * For: add-long/2addr, sub-long/2addr, mul-long/2addr, div-long/2addr,''')
  write_line('''     *      rem-long/2addr, and-long/2addr, or-long/2addr, xor-long/2addr,''')
  write_line('''     *      shl-long/2addr, shr-long/2addr, ushr-long/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG_WIDE a0, a2                # a0 <- vA''')
  write_line('''    GET_VREG_WIDE a1, a3                # a1 <- vB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    beqz    a1, common_errDivideByZero  # is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    ''' + instr + '''                              # ''' + result + ''' <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE ''' + result + ''', a2           # vA <- ''' + result + '''''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def const(helper="UndefinedConstHandler"):
  write_line('''    /* const/class vAA, type@BBBB */''')
  write_line('''    /* const/method-handle vAA, method_handle@BBBB */''')
  write_line('''    /* const/method-type vAA, proto@BBBB */''')
  write_line('''    /* const/string vAA, string@@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    lhu     a0, 2(rPC)                  # a0 <- BBBB''')
  write_line('''    srl     a1, rINST, 8                # a1 <- AA''')
  write_line('''    daddu   a2, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a3, rSELF''')
  write_line('''    jal     ''' + helper + '''                     # (index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST 2                     # load rINST''')
  write_line('''    bnez    v0, MterpPossibleException  # let reference interpreter deal with it.''')
  write_line('''    ADVANCE 2                           # advance rPC''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def entry():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Interpreter entry point.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .set    reorder''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    .global ExecuteMterpImpl''')
  write_line('''    .type   ExecuteMterpImpl, %function''')
  write_line('''    .balign 16''')
  write_line('''/*''')
  write_line(''' * On entry:''')
  write_line(''' *  a0  Thread* self''')
  write_line(''' *  a1  dex_instructions''')
  write_line(''' *  a2  ShadowFrame''')
  write_line(''' *  a3  JValue* result_register''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''ExecuteMterpImpl:''')
  write_line('''    .cfi_startproc''')
  write_line('''    .cpsetup t9, t8, ExecuteMterpImpl''')
  write_line('''''')
  write_line('''    .cfi_def_cfa sp, 0''')
  write_line('''    daddu   sp, sp, -STACK_SIZE''')
  write_line('''    .cfi_adjust_cfa_offset STACK_SIZE''')
  write_line('''''')
  write_line('''    sd      t8, STACK_OFFSET_GP(sp)''')
  write_line('''    .cfi_rel_offset 28, STACK_OFFSET_GP''')
  write_line('''    sd      ra, STACK_OFFSET_RA(sp)''')
  write_line('''    .cfi_rel_offset 31, STACK_OFFSET_RA''')
  write_line('''''')
  write_line('''    sd      s0, STACK_OFFSET_S0(sp)''')
  write_line('''    .cfi_rel_offset 16, STACK_OFFSET_S0''')
  write_line('''    sd      s1, STACK_OFFSET_S1(sp)''')
  write_line('''    .cfi_rel_offset 17, STACK_OFFSET_S1''')
  write_line('''    sd      s2, STACK_OFFSET_S2(sp)''')
  write_line('''    .cfi_rel_offset 18, STACK_OFFSET_S2''')
  write_line('''    sd      s3, STACK_OFFSET_S3(sp)''')
  write_line('''    .cfi_rel_offset 19, STACK_OFFSET_S3''')
  write_line('''    sd      s4, STACK_OFFSET_S4(sp)''')
  write_line('''    .cfi_rel_offset 20, STACK_OFFSET_S4''')
  write_line('''    sd      s5, STACK_OFFSET_S5(sp)''')
  write_line('''    .cfi_rel_offset 21, STACK_OFFSET_S5''')
  write_line('''    sd      s6, STACK_OFFSET_S6(sp)''')
  write_line('''    .cfi_rel_offset 22, STACK_OFFSET_S6''')
  write_line('''''')
  write_line('''    /* Remember the return register */''')
  write_line('''    sd      a3, SHADOWFRAME_RESULT_REGISTER_OFFSET(a2)''')
  write_line('''''')
  write_line('''    /* Remember the dex instruction pointer */''')
  write_line('''    sd      a1, SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET(a2)''')
  write_line('''''')
  write_line('''    /* set up "named" registers */''')
  write_line('''    move    rSELF, a0''')
  write_line('''    daddu   rFP, a2, SHADOWFRAME_VREGS_OFFSET''')
  write_line('''    lw      v0, SHADOWFRAME_NUMBER_OF_VREGS_OFFSET(a2)''')
  write_line('''    dlsa    rREFS, v0, rFP, 2''')
  write_line('''    lw      v0, SHADOWFRAME_DEX_PC_OFFSET(a2)''')
  write_line('''    dlsa    rPC, v0, a1, 1''')
  write_line('''    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)''')
  write_line('''    EXPORT_PC''')
  write_line('''''')
  write_line('''    /* Starting ibase */''')
  write_line('''    REFRESH_IBASE''')
  write_line('''''')
  write_line('''    /* Set up for backwards branches & osr profiling */''')
  write_line('''    ld      a0, OFF_FP_METHOD(rFP)''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rSELF''')
  write_line('''    jal     MterpSetUpHotnessCountdown''')
  write_line('''    move    rPROFILE, v0                # Starting hotness countdown to rPROFILE''')
  write_line('''''')
  write_line('''    /* start executing the instruction at rPC */''')
  write_line('''    FETCH_INST''')
  write_line('''    GET_INST_OPCODE v0''')
  write_line('''    GOTO_OPCODE v0''')
  write_line('''''')
  write_line('''    /* NOTE: no fallthrough */''')

def fallback():
  write_line('''/* Transfer stub to alternate interpreter */''')
  write_line('''    b       MterpFallback''')

def fbinop(instr=""):
  write_line('''    /*:''')
  write_line('''     * Generic 32-bit floating-point operation.''')
  write_line('''     *''')
  write_line('''     * For: add-float, sub-float, mul-float, div-float.''')
  write_line('''     * form: <op> f0, f0, f1''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG_FLOAT f0, a2               # f0 <- vBB''')
  write_line('''    GET_VREG_FLOAT f1, a3               # f1 <- vCC''')
  write_line('''    ''' + instr + '''                              # f0 <- f0 op f1''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_FLOAT f0, a4               # vAA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def fbinop2addr(instr=""):
  write_line('''    /*:''')
  write_line('''     * Generic 32-bit "/2addr" floating-point operation.''')
  write_line('''     *''')
  write_line('''     * For: add-float/2addr, sub-float/2addr, mul-float/2addr, div-float/2addr.''')
  write_line('''     * form: <op> f0, f0, f1''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG_FLOAT f0, a2               # f0 <- vA''')
  write_line('''    GET_VREG_FLOAT f1, a3               # f1 <- vB''')
  write_line('''    ''' + instr + '''                              # f0 <- f0 op f1''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_FLOAT f0, a2               # vA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def fbinopWide(instr=""):
  write_line('''    /*:''')
  write_line('''     * Generic 64-bit floating-point operation.''')
  write_line('''     *''')
  write_line('''     * For: add-double, sub-double, mul-double, div-double.''')
  write_line('''     * form: <op> f0, f0, f1''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG_DOUBLE f0, a2              # f0 <- vBB''')
  write_line('''    GET_VREG_DOUBLE f1, a3              # f1 <- vCC''')
  write_line('''    ''' + instr + '''                              # f0 <- f0 op f1''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_DOUBLE f0, a4              # vAA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def fbinopWide2addr(instr=""):
  write_line('''    /*:''')
  write_line('''     * Generic 64-bit "/2addr" floating-point operation.''')
  write_line('''     *''')
  write_line('''     * For: add-double/2addr, sub-double/2addr, mul-double/2addr, div-double/2addr.''')
  write_line('''     * form: <op> f0, f0, f1''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG_DOUBLE f0, a2              # f0 <- vA''')
  write_line('''    GET_VREG_DOUBLE f1, a3              # f1 <- vB''')
  write_line('''    ''' + instr + '''                              # f0 <- f0 op f1''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_DOUBLE f0, a2              # vA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def fcmp(gt_bias=""):
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line('''     * destination register based on the results of the comparison.''')
  write_line('''     *''')
  write_line('''     * For: cmpl-float, cmpg-float''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG_FLOAT f0, a2               # f0 <- vBB''')
  write_line('''    GET_VREG_FLOAT f1, a3               # f1 <- vCC''')
  write_line('''    cmp.eq.s f2, f0, f1''')
  write_line('''    li      a0, 0''')
  write_line('''    bc1nez  f2, 1f                      # done if vBB == vCC (ordered)''')
  write_line('''    .if ''' + gt_bias + '''''')
  write_line('''    cmp.lt.s f2, f0, f1''')
  write_line('''    li      a0, -1''')
  write_line('''    bc1nez  f2, 1f                      # done if vBB < vCC (ordered)''')
  write_line('''    li      a0, 1                       # vBB > vCC or unordered''')
  write_line('''    .else''')
  write_line('''    cmp.lt.s f2, f1, f0''')
  write_line('''    li      a0, 1''')
  write_line('''    bc1nez  f2, 1f                      # done if vBB > vCC (ordered)''')
  write_line('''    li      a0, -1                      # vBB < vCC or unordered''')
  write_line('''    .endif''')
  write_line('''1:''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a4                     # vAA <- a0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def fcmpWide(gt_bias=""):
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line('''     * destination register based on the results of the comparison.''')
  write_line('''     *''')
  write_line('''     * For: cmpl-double, cmpg-double''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG_DOUBLE f0, a2              # f0 <- vBB''')
  write_line('''    GET_VREG_DOUBLE f1, a3              # f1 <- vCC''')
  write_line('''    cmp.eq.d f2, f0, f1''')
  write_line('''    li      a0, 0''')
  write_line('''    bc1nez  f2, 1f                      # done if vBB == vCC (ordered)''')
  write_line('''    .if ''' + gt_bias + '''''')
  write_line('''    cmp.lt.d f2, f0, f1''')
  write_line('''    li      a0, -1''')
  write_line('''    bc1nez  f2, 1f                      # done if vBB < vCC (ordered)''')
  write_line('''    li      a0, 1                       # vBB > vCC or unordered''')
  write_line('''    .else''')
  write_line('''    cmp.lt.d f2, f1, f0''')
  write_line('''    li      a0, 1''')
  write_line('''    bc1nez  f2, 1f                      # done if vBB > vCC (ordered)''')
  write_line('''    li      a0, -1                      # vBB < vCC or unordered''')
  write_line('''    .endif''')
  write_line('''1:''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a4                     # vAA <- a0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def fcvtFooter(suffix="", valreg=""):
  write_line('''    /*''')
  write_line('''     * Stores a specified register containing the result of conversion''')
  write_line('''     * from or to a floating-point type and jumps to the next instruction.''')
  write_line('''     *''')
  write_line('''     * Expects a1 to contain the destination Dalvik register number.''')
  write_line('''     * a1 is set up by fcvtHeader.S.''')
  write_line('''     *''')
  write_line('''     * For: int-to-float, int-to-double, long-to-float, long-to-double,''')
  write_line('''     *      float-to-int, float-to-long, float-to-double, double-to-int,''')
  write_line('''     *      double-to-long, double-to-float, neg-float, neg-double.''')
  write_line('''     *''')
  write_line('''     * Note that this file can't be included after a break in other files''')
  write_line('''     * and in those files its contents appear as a copy.''')
  write_line('''     * See: float-to-int, float-to-long, double-to-int, double-to-long.''')
  write_line('''     */''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG''' + suffix + ''' ''' + valreg + ''', a1''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def fcvtHeader(suffix="", valreg=""):
  write_line('''    /*''')
  write_line('''     * Loads a specified register from vB. Used primarily for conversions''')
  write_line('''     * from or to a floating-point type.''')
  write_line('''     *''')
  write_line('''     * Sets up a1 = A and a2 = B. a2 is later used by fcvtFooter.S to''')
  write_line('''     * store the result in vA and jump to the next instruction.''')
  write_line('''     *''')
  write_line('''     * For: int-to-float, int-to-double, long-to-float, long-to-double,''')
  write_line('''     *      float-to-int, float-to-long, float-to-double, double-to-int,''')
  write_line('''     *      double-to-long, double-to-float, neg-float, neg-double.''')
  write_line('''     */''')
  write_line('''    ext     a1, rINST, 8, 4             # a1 <- A''')
  write_line('''    srl     a2, rINST, 12               # a2 <- B''')
  write_line('''    GET_VREG''' + suffix + ''' ''' + valreg + ''', a2''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')

def field(helper=""):
  write_line('''TODO''')

def footer():
  write_line('''/*''')
  write_line(''' * We've detected a condition that will result in an exception, but the exception''')
  write_line(''' * has not yet been thrown.  Just bail out to the reference interpreter to deal with it.''')
  write_line(''' * TUNING: for consistency, we may want to just go ahead and handle these here.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .extern MterpLogDivideByZeroException''')
  write_line('''common_errDivideByZero:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    jal     MterpLogDivideByZeroException''')
  write_line('''#endif''')
  write_line('''    b       MterpCommonFallback''')
  write_line('''''')
  write_line('''    .extern MterpLogArrayIndexException''')
  write_line('''common_errArrayIndex:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    jal     MterpLogArrayIndexException''')
  write_line('''#endif''')
  write_line('''    b       MterpCommonFallback''')
  write_line('''''')
  write_line('''    .extern MterpLogNullObjectException''')
  write_line('''common_errNullObject:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    jal     MterpLogNullObjectException''')
  write_line('''#endif''')
  write_line('''    b       MterpCommonFallback''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * If we're here, something is out of the ordinary.  If there is a pending''')
  write_line(''' * exception, handle it.  Otherwise, roll back and retry with the reference''')
  write_line(''' * interpreter.''')
  write_line(''' */''')
  write_line('''MterpPossibleException:''')
  write_line('''    ld      a0, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    beqzc   a0, MterpFallback                       # If not, fall back to reference interpreter.''')
  write_line('''    /* intentional fallthrough - handle pending exception. */''')
  write_line('''/*''')
  write_line(''' * On return from a runtime helper routine, we've found a pending exception.''')
  write_line(''' * Can we handle it here - or need to bail out to caller?''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''    .extern MterpHandleException''')
  write_line('''    .extern MterpShouldSwitchInterpreters''')
  write_line('''MterpException:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    jal     MterpHandleException                    # (self, shadow_frame)''')
  write_line('''    beqzc   v0, MterpExceptionReturn                # no local catch, back to caller.''')
  write_line('''    ld      a0, OFF_FP_DEX_INSTRUCTIONS(rFP)''')
  write_line('''    lwu     a1, OFF_FP_DEX_PC(rFP)''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    dlsa    rPC, a1, a0, 1                          # generate new dex_pc_ptr''')
  write_line('''    /* Do we need to switch interpreters? */''')
  write_line('''    jal     MterpShouldSwitchInterpreters''')
  write_line('''    bnezc   v0, MterpFallback''')
  write_line('''    /* resume execution at catch block */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH_INST''')
  write_line('''    GET_INST_OPCODE v0''')
  write_line('''    GOTO_OPCODE v0''')
  write_line('''    /* NOTE: no fallthrough */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Common handling for branches with support for Jit profiling.''')
  write_line(''' * On entry:''')
  write_line(''' *    rINST          <= signed offset''')
  write_line(''' *    rPROFILE       <= signed hotness countdown (expanded to 64 bits)''')
  write_line(''' *''')
  write_line(''' * We have quite a few different cases for branch profiling, OSR detection and''')
  write_line(''' * suspend check support here.''')
  write_line(''' *''')
  write_line(''' * Taken backward branches:''')
  write_line(''' *    If profiling active, do hotness countdown and report if we hit zero.''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *    Is there a pending suspend request?  If so, suspend.''')
  write_line(''' *''')
  write_line(''' * Taken forward branches and not-taken backward branches:''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *''')
  write_line(''' * Our most common case is expected to be a taken backward branch with active jit profiling,''')
  write_line(''' * but no full OSR check and no pending suspend request.''')
  write_line(''' * Next most common case is not-taken branch with no full OSR check.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpCommonTakenBranchNoFlags:''')
  write_line('''    bgtzc   rINST, .L_forward_branch    # don't add forward branches to hotness''')
  write_line('''/*''')
  write_line(''' * We need to subtract 1 from positive values and we should not see 0 here,''')
  write_line(''' * so we may use the result of the comparison with -1.''')
  write_line(''' */''')
  write_line('''    li      v0, JIT_CHECK_OSR''')
  write_line('''    beqc    rPROFILE, v0, .L_osr_check''')
  write_line('''    bltc    rPROFILE, v0, .L_resume_backward_branch''')
  write_line('''    dsubu   rPROFILE, 1''')
  write_line('''    beqzc   rPROFILE, .L_add_batch      # counted down to zero - report''')
  write_line('''.L_resume_backward_branch:''')
  write_line('''    lw      ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    daddu   a2, rINST, rINST            # a2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB a2            # update rPC, load rINST''')
  write_line('''    and     ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    bnezc   ra, .L_suspend_request_pending''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')
  write_line('''''')
  write_line('''.L_suspend_request_pending:''')
  write_line('''    EXPORT_PC''')
  write_line('''    move    a0, rSELF''')
  write_line('''    jal     MterpSuspendCheck           # (self)''')
  write_line('''    bnezc   v0, MterpFallback''')
  write_line('''    REFRESH_IBASE                       # might have changed during suspend''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')
  write_line('''''')
  write_line('''.L_no_count_backwards:''')
  write_line('''    li      v0, JIT_CHECK_OSR           # check for possible OSR re-entry''')
  write_line('''    bnec    rPROFILE, v0, .L_resume_backward_branch''')
  write_line('''.L_osr_check:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rINST''')
  write_line('''    EXPORT_PC''')
  write_line('''    jal MterpMaybeDoOnStackReplacement  # (self, shadow_frame, offset)''')
  write_line('''    bnezc   v0, MterpOnStackReplacement''')
  write_line('''    b       .L_resume_backward_branch''')
  write_line('''''')
  write_line('''.L_forward_branch:''')
  write_line('''    li      v0, JIT_CHECK_OSR           # check for possible OSR re-entry''')
  write_line('''    beqc    rPROFILE, v0, .L_check_osr_forward''')
  write_line('''.L_resume_forward_branch:''')
  write_line('''    daddu   a2, rINST, rINST            # a2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB a2            # update rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')
  write_line('''''')
  write_line('''.L_check_osr_forward:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rINST''')
  write_line('''    EXPORT_PC''')
  write_line('''    jal     MterpMaybeDoOnStackReplacement # (self, shadow_frame, offset)''')
  write_line('''    bnezc   v0, MterpOnStackReplacement''')
  write_line('''    b       .L_resume_forward_branch''')
  write_line('''''')
  write_line('''.L_add_batch:''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    sh      rPROFILE, SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET(a1)''')
  write_line('''    ld      a0, OFF_FP_METHOD(rFP)''')
  write_line('''    move    a2, rSELF''')
  write_line('''    jal     MterpAddHotnessBatch        # (method, shadow_frame, self)''')
  write_line('''    move    rPROFILE, v0                # restore new hotness countdown to rPROFILE''')
  write_line('''    b       .L_no_count_backwards''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Entered from the conditional branch handlers when OSR check request active on''')
  write_line(''' * not-taken path.  All Dalvik not-taken conditional branch offsets are 2.''')
  write_line(''' */''')
  write_line('''.L_check_not_taken_osr:''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    li      a2, 2''')
  write_line('''    EXPORT_PC''')
  write_line('''    jal     MterpMaybeDoOnStackReplacement # (self, shadow_frame, offset)''')
  write_line('''    bnezc   v0, MterpOnStackReplacement''')
  write_line('''    FETCH_ADVANCE_INST 2 ''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On-stack replacement has happened, and now we've returned from the compiled method.''')
  write_line(''' */''')
  write_line('''MterpOnStackReplacement:''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rINST                               # rINST contains offset''')
  write_line('''    jal     MterpLogOSR''')
  write_line('''#endif''')
  write_line('''    li      v0, 1                                   # Signal normal return''')
  write_line('''    b       MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Bail out to reference interpreter.''')
  write_line(''' */''')
  write_line('''    .extern MterpLogFallback''')
  write_line('''MterpFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    jal     MterpLogFallback''')
  write_line('''#endif''')
  write_line('''MterpCommonFallback:''')
  write_line('''    li      v0, 0                                   # signal retry with reference interpreter.''')
  write_line('''    b       MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We pushed some registers on the stack in ExecuteMterpImpl, then saved''')
  write_line(''' * SP and RA.  Here we restore SP, restore the registers, and then restore''')
  write_line(''' * RA to PC.''')
  write_line(''' *''')
  write_line(''' * On entry:''')
  write_line(''' *  uint32_t* rFP  (should still be live, pointer to base of vregs)''')
  write_line(''' */''')
  write_line('''MterpExceptionReturn:''')
  write_line('''    li      v0, 1                                   # signal return to caller.''')
  write_line('''    b       MterpDone''')
  write_line('''/*''')
  write_line(''' * Returned value is expected in a0 and if it's not 64-bit, the 32 most''')
  write_line(''' * significant bits of a0 must be zero-extended or sign-extended''')
  write_line(''' * depending on the return type.''')
  write_line(''' */''')
  write_line('''MterpReturn:''')
  write_line('''    ld      a2, OFF_FP_RESULT_REGISTER(rFP)''')
  write_line('''    sd      a0, 0(a2)''')
  write_line('''    li      v0, 1                                   # signal return to caller.''')
  write_line('''MterpDone:''')
  write_line('''/*''')
  write_line(''' * At this point, we expect rPROFILE to be non-zero.  If negative, hotness is disabled or we're''')
  write_line(''' * checking for OSR.  If greater than zero, we might have unreported hotness to register''')
  write_line(''' * (the difference between the ending rPROFILE and the cached hotness counter).  rPROFILE''')
  write_line(''' * should only reach zero immediately after a hotness decrement, and is then reset to either''')
  write_line(''' * a negative special state or the new non-zero countdown value.''')
  write_line(''' */''')
  write_line('''    blez    rPROFILE, .L_pop_and_return # if > 0, we may have some counts to report.''')
  write_line('''''')
  write_line('''MterpProfileActive:''')
  write_line('''    move    rINST, v0                   # stash return value''')
  write_line('''    /* Report cached hotness counts */''')
  write_line('''    ld      a0, OFF_FP_METHOD(rFP)''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rSELF''')
  write_line('''    sh      rPROFILE, SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET(a1)''')
  write_line('''    jal     MterpAddHotnessBatch        # (method, shadow_frame, self)''')
  write_line('''    move    v0, rINST                   # restore return value''')
  write_line('''''')
  write_line('''.L_pop_and_return:''')
  write_line('''    ld      s6, STACK_OFFSET_S6(sp)''')
  write_line('''    .cfi_restore 22''')
  write_line('''    ld      s5, STACK_OFFSET_S5(sp)''')
  write_line('''    .cfi_restore 21''')
  write_line('''    ld      s4, STACK_OFFSET_S4(sp)''')
  write_line('''    .cfi_restore 20''')
  write_line('''    ld      s3, STACK_OFFSET_S3(sp)''')
  write_line('''    .cfi_restore 19''')
  write_line('''    ld      s2, STACK_OFFSET_S2(sp)''')
  write_line('''    .cfi_restore 18''')
  write_line('''    ld      s1, STACK_OFFSET_S1(sp)''')
  write_line('''    .cfi_restore 17''')
  write_line('''    ld      s0, STACK_OFFSET_S0(sp)''')
  write_line('''    .cfi_restore 16''')
  write_line('''''')
  write_line('''    ld      ra, STACK_OFFSET_RA(sp)''')
  write_line('''    .cfi_restore 31''')
  write_line('''''')
  write_line('''    ld      t8, STACK_OFFSET_GP(sp)''')
  write_line('''    .cpreturn''')
  write_line('''    .cfi_restore 28''')
  write_line('''''')
  write_line('''    .set    noreorder''')
  write_line('''    jr      ra''')
  write_line('''    daddu   sp, sp, STACK_SIZE''')
  write_line('''    .cfi_adjust_cfa_offset -STACK_SIZE''')
  write_line('''''')
  write_line('''    .cfi_endproc''')
  write_line('''    .set    reorder''')
  write_line('''    .size ExecuteMterpImpl, .-ExecuteMterpImpl''')

def header():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''#define zero $0  /* always zero */''')
  write_line('''#define AT   $at /* assembler temp */''')
  write_line('''#define v0   $2  /* return value */''')
  write_line('''#define v1   $3''')
  write_line('''#define a0   $4  /* argument registers */''')
  write_line('''#define a1   $5''')
  write_line('''#define a2   $6''')
  write_line('''#define a3   $7''')
  write_line('''#define a4   $8  /* expanded register arguments */''')
  write_line('''#define a5   $9''')
  write_line('''#define a6   $10''')
  write_line('''#define a7   $11''')
  write_line('''#define ta0  $8  /* alias */''')
  write_line('''#define ta1  $9''')
  write_line('''#define ta2  $10''')
  write_line('''#define ta3  $11''')
  write_line('''#define t0   $12 /* temp registers (not saved across subroutine calls) */''')
  write_line('''#define t1   $13''')
  write_line('''#define t2   $14''')
  write_line('''#define t3   $15''')
  write_line('''''')
  write_line('''#define s0   $16 /* saved across subroutine calls (callee saved) */''')
  write_line('''#define s1   $17''')
  write_line('''#define s2   $18''')
  write_line('''#define s3   $19''')
  write_line('''#define s4   $20''')
  write_line('''#define s5   $21''')
  write_line('''#define s6   $22''')
  write_line('''#define s7   $23''')
  write_line('''#define t8   $24 /* two more temp registers */''')
  write_line('''#define t9   $25''')
  write_line('''#define k0   $26 /* kernel temporary */''')
  write_line('''#define k1   $27''')
  write_line('''#define gp   $28 /* global pointer */''')
  write_line('''#define sp   $29 /* stack pointer */''')
  write_line('''#define s8   $30 /* one more callee saved */''')
  write_line('''#define ra   $31 /* return address */''')
  write_line('''''')
  write_line('''#define f0   $f0''')
  write_line('''#define f1   $f1''')
  write_line('''#define f2   $f2''')
  write_line('''#define f3   $f3''')
  write_line('''#define f12  $f12''')
  write_line('''#define f13  $f13''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * It looks like the GNU assembler currently does not support the blec and bgtc''')
  write_line(''' * idioms, which should translate into bgec and bltc respectively with swapped''')
  write_line(''' * left and right register operands.''')
  write_line(''' * TODO: remove these macros when the assembler is fixed.''')
  write_line(''' */''')
  write_line('''.macro blec lreg, rreg, target''')
  write_line('''    bgec    \\rreg, \\lreg, \\target''')
  write_line('''.endm''')
  write_line('''.macro bgtc lreg, rreg, target''')
  write_line('''    bltc    \\rreg, \\lreg, \\target''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line('''Mterp and MIPS64 notes:''')
  write_line('''''')
  write_line('''The following registers have fixed assignments:''')
  write_line('''''')
  write_line('''  reg nick      purpose''')
  write_line('''  s0  rPC       interpreted program counter, used for fetching instructions''')
  write_line('''  s1  rFP       interpreted frame pointer, used for accessing locals and args''')
  write_line('''  s2  rSELF     self (Thread) pointer''')
  write_line('''  s3  rINST     first 16-bit code unit of current instruction''')
  write_line('''  s4  rIBASE    interpreted instruction base pointer, used for computed goto''')
  write_line('''  s5  rREFS     base of object references in shadow frame  (ideally, we'll get rid of this later).''')
  write_line('''  s6  rPROFILE  jit profile hotness countdown''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/* During bringup, we'll use the shadow frame model instead of rFP */''')
  write_line('''/* single-purpose registers, given names for clarity */''')
  write_line('''#define rPC      s0''')
  write_line('''#define CFI_DEX  16  // DWARF register number of the register holding dex-pc (s0).''')
  write_line('''#define CFI_TMP  4   // DWARF register number of the first argument register (a0).''')
  write_line('''#define rFP      s1''')
  write_line('''#define rSELF    s2''')
  write_line('''#define rINST    s3''')
  write_line('''#define rIBASE   s4''')
  write_line('''#define rREFS    s5''')
  write_line('''#define rPROFILE s6''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * This is a #include, not a %include, because we want the C pre-processor''')
  write_line(''' * to expand the macros into assembler assignment statements.''')
  write_line(''' */''')
  write_line('''#include "asm_support.h"''')
  write_line('''#include "interpreter/cfi_asm_support.h"''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Instead of holding a pointer to the shadow frame, we keep rFP at the base of the vregs.  So,''')
  write_line(''' * to access other shadow frame fields, we need to use a backwards offset.  Define those here.''')
  write_line(''' */''')
  write_line('''#define OFF_FP(a) (a - SHADOWFRAME_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_NUMBER_OF_VREGS OFF_FP(SHADOWFRAME_NUMBER_OF_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC OFF_FP(SHADOWFRAME_DEX_PC_OFFSET)''')
  write_line('''#define OFF_FP_LINK OFF_FP(SHADOWFRAME_LINK_OFFSET)''')
  write_line('''#define OFF_FP_METHOD OFF_FP(SHADOWFRAME_METHOD_OFFSET)''')
  write_line('''#define OFF_FP_RESULT_REGISTER OFF_FP(SHADOWFRAME_RESULT_REGISTER_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC_PTR OFF_FP(SHADOWFRAME_DEX_PC_PTR_OFFSET)''')
  write_line('''#define OFF_FP_DEX_INSTRUCTIONS OFF_FP(SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET)''')
  write_line('''#define OFF_FP_SHADOWFRAME OFF_FP(0)''')
  write_line('''''')
  write_line('''#define MTERP_PROFILE_BRANCHES 1''')
  write_line('''#define MTERP_LOGGING 0''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * "export" the PC to dex_pc field in the shadow frame, f/b/o future exception objects.  Must''')
  write_line(''' * be done *before* something throws.''')
  write_line(''' *''')
  write_line(''' * It's okay to do this more than once.''')
  write_line(''' *''')
  write_line(''' * NOTE: the fast interpreter keeps track of dex pc as a direct pointer to the mapped''')
  write_line(''' * dex byte codes.  However, the rest of the runtime expects dex pc to be an instruction''')
  write_line(''' * offset into the code_items_[] array.  For effiency, we will "export" the''')
  write_line(''' * current dex pc as a direct pointer using the EXPORT_PC macro, and rely on GetDexPC''')
  write_line(''' * to convert to a dex pc when needed.''')
  write_line(''' */''')
  write_line('''.macro EXPORT_PC''')
  write_line('''    sd      rPC, OFF_FP_DEX_PC_PTR(rFP)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh handler table.''')
  write_line(''' */''')
  write_line('''.macro REFRESH_IBASE''')
  write_line('''    ld      rIBASE, THREAD_CURRENT_IBASE_OFFSET(rSELF)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from rPC into rINST.  Does not advance rPC.''')
  write_line(''' */''')
  write_line('''.macro FETCH_INST''')
  write_line('''    lhu     rINST, 0(rPC)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/* Advance rPC by some number of code units. */''')
  write_line('''.macro ADVANCE count''')
  write_line('''    daddu   rPC, rPC, (\\count) * 2''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from an offset specified by _reg and advance xPC.''')
  write_line(''' * xPC to point to the next instruction.  "_reg" must specify the distance''')
  write_line(''' * in bytes, *not* 16-bit code units, and may be a signed value.  Must not set flags.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''.macro FETCH_ADVANCE_INST_RB reg''')
  write_line('''    daddu   rPC, rPC, \\reg''')
  write_line('''    FETCH_INST''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from the specified offset.  Advances rPC''')
  write_line(''' * to point to the next instruction.''')
  write_line(''' *''')
  write_line(''' * This must come AFTER anything that can throw an exception, or the''')
  write_line(''' * exception catch may miss.  (This also implies that it must come after''')
  write_line(''' * EXPORT_PC.)''')
  write_line(''' */''')
  write_line('''.macro FETCH_ADVANCE_INST count''')
  write_line('''    ADVANCE \\count''')
  write_line('''    FETCH_INST''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Similar to FETCH_ADVANCE_INST, but does not update rPC.  Used to load''')
  write_line(''' * rINST ahead of possible exception point.  Be sure to manually advance rPC''')
  write_line(''' * later.''')
  write_line(''' */''')
  write_line('''.macro PREFETCH_INST count''')
  write_line('''    lhu     rINST, ((\\count) * 2)(rPC)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Put the instruction's opcode field into the specified register.''')
  write_line(''' */''')
  write_line('''.macro GET_INST_OPCODE reg''')
  write_line('''    and     \\reg, rINST, 255''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Begin executing the opcode in _reg.''')
  write_line(''' */''')
  write_line('''.macro GOTO_OPCODE reg''')
  write_line('''    .set noat''')
  write_line('''    sll     AT, \\reg, 7''')
  write_line('''    daddu   AT, rIBASE, AT''')
  write_line('''    jic     AT, 0''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 32-bit value from a Dalvik register.''')
  write_line(''' * Note, GET_VREG does sign extension to 64 bits while''')
  write_line(''' * GET_VREG_U does zero extension to 64 bits.''')
  write_line(''' * One is useful for arithmetic while the other is''')
  write_line(''' * useful for storing the result value as 64-bit.''')
  write_line(''' */''')
  write_line('''.macro GET_VREG reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    lw      \\reg, 0(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro GET_VREG_U reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    lwu     \\reg, 0(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro GET_VREG_FLOAT reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    lwc1    \\reg, 0(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    sw      \\reg, 0(AT)''')
  write_line('''    dlsa    AT, \\vreg, rREFS, 2''')
  write_line('''    sw      zero, 0(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_OBJECT reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    sw      \\reg, 0(AT)''')
  write_line('''    dlsa    AT, \\vreg, rREFS, 2''')
  write_line('''    sw      \\reg, 0(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_FLOAT reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    swc1    \\reg, 0(AT)''')
  write_line('''    dlsa    AT, \\vreg, rREFS, 2''')
  write_line('''    sw      zero, 0(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 64-bit value from a Dalvik register.''')
  write_line(''' * Avoid unaligned memory accesses.''')
  write_line(''' * Note, SET_VREG_WIDE clobbers the register containing the value being stored.''')
  write_line(''' * Note, SET_VREG_DOUBLE clobbers the register containing the Dalvik register number.''')
  write_line(''' */''')
  write_line('''.macro GET_VREG_WIDE reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    lw      \\reg, 0(AT)''')
  write_line('''    lw      AT, 4(AT)''')
  write_line('''    dinsu   \\reg, AT, 32, 32''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro GET_VREG_DOUBLE reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    lwc1    \\reg, 0(AT)''')
  write_line('''    lw      AT, 4(AT)''')
  write_line('''    mthc1   AT, \\reg''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_WIDE reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    sw      \\reg, 0(AT)''')
  write_line('''    drotr32 \\reg, \\reg, 0''')
  write_line('''    sw      \\reg, 4(AT)''')
  write_line('''    dlsa    AT, \\vreg, rREFS, 2''')
  write_line('''    sw      zero, 0(AT)''')
  write_line('''    sw      zero, 4(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_DOUBLE reg, vreg''')
  write_line('''    .set noat''')
  write_line('''    dlsa    AT, \\vreg, rREFS, 2''')
  write_line('''    sw      zero, 0(AT)''')
  write_line('''    sw      zero, 4(AT)''')
  write_line('''    dlsa    AT, \\vreg, rFP, 2''')
  write_line('''    swc1    \\reg, 0(AT)''')
  write_line('''    mfhc1   \\vreg, \\reg''')
  write_line('''    sw      \\vreg, 4(AT)''')
  write_line('''    .set at''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On-stack offsets for spilling/unspilling callee-saved registers''')
  write_line(''' * and the frame size.''')
  write_line(''' */''')
  write_line('''#define STACK_OFFSET_RA 0''')
  write_line('''#define STACK_OFFSET_GP 8''')
  write_line('''#define STACK_OFFSET_S0 16''')
  write_line('''#define STACK_OFFSET_S1 24''')
  write_line('''#define STACK_OFFSET_S2 32''')
  write_line('''#define STACK_OFFSET_S3 40''')
  write_line('''#define STACK_OFFSET_S4 48''')
  write_line('''#define STACK_OFFSET_S5 56''')
  write_line('''#define STACK_OFFSET_S6 64''')
  write_line('''#define STACK_SIZE      80    /* needs 16 byte alignment */''')
  write_line('''''')
  write_line('''/* Constants for float/double_to_int/long conversions */''')
  write_line('''#define INT_MIN             0x80000000''')
  write_line('''#define INT_MIN_AS_FLOAT    0xCF000000''')
  write_line('''#define INT_MIN_AS_DOUBLE   0xC1E0000000000000''')
  write_line('''#define LONG_MIN            0x8000000000000000''')
  write_line('''#define LONG_MIN_AS_FLOAT   0xDF000000''')
  write_line('''#define LONG_MIN_AS_DOUBLE  0xC3E0000000000000''')

def instruction_end():
  write_line('''''')
  write_line('''    .global artMterpAsmInstructionEnd''')
  write_line('''artMterpAsmInstructionEnd:''')

def instruction_end_alt():
  write_line('''''')
  write_line('''    .global artMterpAsmAltInstructionEnd''')
  write_line('''artMterpAsmAltInstructionEnd:''')

def instruction_end_sister():
  write_line('''''')
  write_line('''    .global artMterpAsmSisterEnd''')
  write_line('''artMterpAsmSisterEnd:''')

def instruction_start():
  write_line('''''')
  write_line('''    .global artMterpAsmInstructionStart''')
  write_line('''artMterpAsmInstructionStart = .L_op_nop''')
  write_line('''    .text''')

def instruction_start_alt():
  write_line('''''')
  write_line('''    .global artMterpAsmAltInstructionStart''')
  write_line('''artMterpAsmAltInstructionStart = .L_ALT_op_nop''')
  write_line('''    .text''')

def instruction_start_sister():
  write_line('''''')
  write_line('''    .global artMterpAsmSisterStart''')
  write_line('''    .text''')
  write_line('''    .balign 4''')
  write_line('''artMterpAsmSisterStart:''')

def invoke(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * Generic invoke handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    .extern MterpShouldSwitchInterpreters''')
  write_line('''    EXPORT_PC''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rPC''')
  write_line('''    move    a3, rINST''')
  write_line('''    jal     ''' + helper + '''''')
  write_line('''    beqzc   v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 3''')
  write_line('''    jal     MterpShouldSwitchInterpreters''')
  write_line('''    bnezc   v0, MterpFallback''')
  write_line('''    GET_INST_OPCODE v0''')
  write_line('''    GOTO_OPCODE v0''')

def invoke_polymorphic(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * invoke-polymorphic handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB, proto@HHHH */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    .extern MterpShouldSwitchInterpreters''')
  write_line('''    EXPORT_PC''')
  write_line('''    move    a0, rSELF''')
  write_line('''    daddu   a1, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a2, rPC''')
  write_line('''    move    a3, rINST''')
  write_line('''    jal     ''' + helper + '''''')
  write_line('''    beqzc   v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 4''')
  write_line('''    jal     MterpShouldSwitchInterpreters''')
  write_line('''    bnezc   v0, MterpFallback''')
  write_line('''    GET_INST_OPCODE v0''')
  write_line('''    GOTO_OPCODE v0''')

def op_add_double():
  fbinopWide(instr="add.d f0, f0, f1")

def op_add_double_2addr():
  fbinopWide2addr(instr="add.d f0, f0, f1")

def op_add_float():
  fbinop(instr="add.s f0, f0, f1")

def op_add_float_2addr():
  fbinop2addr(instr="add.s f0, f0, f1")

def op_add_int():
  binop(instr="addu a0, a0, a1")

def op_add_int_2addr():
  binop2addr(instr="addu a0, a0, a1")

def op_add_int_lit16():
  binopLit16(instr="addu a0, a0, a1")

def op_add_int_lit8():
  binopLit8(instr="addu a0, a0, a1")

def op_add_long():
  binopWide(instr="daddu a0, a0, a1")

def op_add_long_2addr():
  binopWide2addr(instr="daddu a0, a0, a1")

def op_aget(load="lw", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''    /*''')
  write_line('''     * Array get, 32 bits or less.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * for: aget, aget-boolean, aget-byte, aget-char, aget-short''')
  write_line('''     *''')
  write_line('''     * NOTE: assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vBB (array object)''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vCC (requested index)''')
  write_line('''    beqz    a0, common_errNullObject    # bail if null array object''')
  write_line('''    lw      a3, MIRROR_ARRAY_LENGTH_OFFSET(a0)  # a3 <- arrayObj->length''')
  write_line('''    .if ''' + shift + '''''')
  write_line('''    # [d]lsa does not support shift count of 0.''')
  write_line('''    dlsa    a0, a1, a0, ''' + shift + '''          # a0 <- arrayObj + index*width''')
  write_line('''    .else''')
  write_line('''    daddu   a0, a1, a0                  # a0 <- arrayObj + index*width''')
  write_line('''    .endif''')
  write_line('''    bgeu    a1, a3, common_errArrayIndex  # unsigned compare: index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    ''' + load + '''   a2, ''' + data_offset + '''(a0)        # a2 <- vBB[vCC]''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a2, a4                     # vAA <- a2''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_aget_boolean():
  op_aget(load="lbu", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aget_byte():
  op_aget(load="lb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aget_char():
  op_aget(load="lhu", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aget_object():
  write_line('''    /*''')
  write_line('''     * Array object get.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * for: aget-object''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    .extern artAGetObjectFromMterp''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vBB (array object)''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vCC (requested index)''')
  write_line('''    jal     artAGetObjectFromMterp      # (array, index)''')
  write_line('''    ld      a1, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    bnez    a1, MterpException''')
  write_line('''    SET_VREG_OBJECT v0, a4              # vAA <- v0''')
  write_line('''    ADVANCE 2''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_aget_short():
  op_aget(load="lh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aget_wide():
  write_line('''    /*''')
  write_line('''     * Array get, 64 bits.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    /* aget-wide vAA, vBB, vCC */''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vBB (array object)''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vCC (requested index)''')
  write_line('''    beqz    a0, common_errNullObject    # bail if null array object''')
  write_line('''    lw      a3, MIRROR_ARRAY_LENGTH_OFFSET(a0)  # a3 <- arrayObj->length''')
  write_line('''    dlsa    a0, a1, a0, 3               # a0 <- arrayObj + index*width''')
  write_line('''    bgeu    a1, a3, common_errArrayIndex  # unsigned compare: index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    lw      a2, MIRROR_WIDE_ARRAY_DATA_OFFSET(a0)''')
  write_line('''    lw      a3, (MIRROR_WIDE_ARRAY_DATA_OFFSET+4)(a0)''')
  write_line('''    dinsu   a2, a3, 32, 32              # a2 <- vBB[vCC]''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a2, a4                # vAA <- a2''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_and_int():
  binop(instr="and a0, a0, a1")

def op_and_int_2addr():
  binop2addr(instr="and a0, a0, a1")

def op_and_int_lit16():
  binopLit16(instr="and a0, a0, a1")

def op_and_int_lit8():
  binopLit8(instr="and a0, a0, a1")

def op_and_long():
  binopWide(instr="and a0, a0, a1")

def op_and_long_2addr():
  binopWide2addr(instr="and a0, a0, a1")

def op_aput(store="sw", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''    /*''')
  write_line('''     * Array put, 32 bits or less.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     * for: aput, aput-boolean, aput-byte, aput-char, aput-short''')
  write_line('''     *''')
  write_line('''     * NOTE: this assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vBB (array object)''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vCC (requested index)''')
  write_line('''    beqz    a0, common_errNullObject    # bail if null array object''')
  write_line('''    lw      a3, MIRROR_ARRAY_LENGTH_OFFSET(a0)  # a3 <- arrayObj->length''')
  write_line('''    .if ''' + shift + '''''')
  write_line('''    # [d]lsa does not support shift count of 0.''')
  write_line('''    dlsa    a0, a1, a0, ''' + shift + '''          # a0 <- arrayObj + index*width''')
  write_line('''    .else''')
  write_line('''    daddu   a0, a1, a0                  # a0 <- arrayObj + index*width''')
  write_line('''    .endif''')
  write_line('''    bgeu    a1, a3, common_errArrayIndex  # unsigned compare: index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_VREG a2, a4                     # a2 <- vAA''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    ''' + store + '''  a2, ''' + data_offset + '''(a0)        # vBB[vCC] <- a2''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_aput_boolean():
  op_aput(store="sb", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aput_byte():
  op_aput(store="sb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aput_char():
  op_aput(store="sh", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aput_object():
  write_line('''    /*''')
  write_line('''     * Store an object into an array.  vBB[vCC] <- vAA.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    .extern MterpAputObject''')
  write_line('''    EXPORT_PC''')
  write_line('''    daddu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a1, rPC''')
  write_line('''    move    a2, rINST''')
  write_line('''    jal     MterpAputObject''')
  write_line('''    beqzc   v0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_aput_short():
  op_aput(store="sh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aput_wide():
  write_line('''    /*''')
  write_line('''     * Array put, 64 bits.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    /* aput-wide vAA, vBB, vCC */''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vBB (array object)''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vCC (requested index)''')
  write_line('''    beqz    a0, common_errNullObject    # bail if null array object''')
  write_line('''    lw      a3, MIRROR_ARRAY_LENGTH_OFFSET(a0)  # a3 <- arrayObj->length''')
  write_line('''    dlsa    a0, a1, a0, 3               # a0 <- arrayObj + index*width''')
  write_line('''    bgeu    a1, a3, common_errArrayIndex  # unsigned compare: index >= length, bail''')
  write_line('''    GET_VREG_WIDE a2, a4                # a2 <- vAA''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    sw      a2, MIRROR_WIDE_ARRAY_DATA_OFFSET(a0)''')
  write_line('''    dsrl32  a2, a2, 0''')
  write_line('''    sw      a2, (MIRROR_WIDE_ARRAY_DATA_OFFSET+4)(a0)  # vBB[vCC] <- a2''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_array_length():
  write_line('''    /*''')
  write_line('''     * Return the length of an array.''')
  write_line('''     */''')
  write_line('''    srl     a1, rINST, 12               # a1 <- B''')
  write_line('''    GET_VREG_U a0, a1                   # a0 <- vB (object ref)''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    beqz    a0, common_errNullObject    # yup, fail''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    lw      a3, MIRROR_ARRAY_LENGTH_OFFSET(a0)  # a3 <- array length''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a3, a2                     # vB <- length''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_check_cast():
  write_line('''    /*''')
  write_line('''     * Check to see if a cast from one class to another is allowed.''')
  write_line('''     */''')
  write_line('''    /* check-cast vAA, class//BBBB */''')
  write_line('''    .extern MterpCheckCast''')
  write_line('''    EXPORT_PC''')
  write_line('''    lhu     a0, 2(rPC)                  # a0 <- BBBB''')
  write_line('''    srl     a1, rINST, 8                # a1 <- AA''')
  write_line('''    dlsa    a1, a1, rFP, 2              # a1 <- &object''')
  write_line('''    ld      a2, OFF_FP_METHOD(rFP)      # a2 <- method''')
  write_line('''    move    a3, rSELF                   # a3 <- self''')
  write_line('''    jal     MterpCheckCast              # (index, &obj, method, self)''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    bnez    v0, MterpPossibleException''')
  write_line('''    ADVANCE 2''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_cmp_long():
  write_line('''    /* cmp-long vAA, vBB, vCC */''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    GET_VREG_WIDE a0, a2                # a0 <- vBB''')
  write_line('''    GET_VREG_WIDE a1, a3                # a1 <- vCC''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    slt     a2, a0, a1''')
  write_line('''    slt     a0, a1, a0''')
  write_line('''    subu    a0, a0, a2''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a4                     # vAA <- result''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_cmpg_double():
  fcmpWide(gt_bias="1")

def op_cmpg_float():
  fcmp(gt_bias="1")

def op_cmpl_double():
  fcmpWide(gt_bias="0")

def op_cmpl_float():
  fcmp(gt_bias="0")

def op_const():
  write_line('''    /* const vAA, #+BBBBbbbb */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- bbbb (low)''')
  write_line('''    lh      a1, 4(rPC)                  # a1 <- BBBB (high)''')
  write_line('''    FETCH_ADVANCE_INST 3                # advance rPC, load rINST''')
  write_line('''    ins     a0, a1, 16, 16              # a0 = BBBBbbbb''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a2                     # vAA <- +BBBBbbbb''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_16():
  write_line('''    /* const/16 vAA, #+BBBB */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- sign-extended BBBB''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a2                     # vAA <- +BBBB''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_4():
  write_line('''    /* const/4 vA, #+B */''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    seh     a0, rINST                   # sign extend B in rINST''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    sra     a0, a0, 12                  # shift B into its final position''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a2                     # vA <- +B''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_class():
  const(helper="MterpConstClass")

def op_const_high16():
  write_line('''    /* const/high16 vAA, #+BBBB0000 */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- BBBB''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    sll     a0, a0, 16                  # a0 <- BBBB0000''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a2                     # vAA <- +BBBB0000''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_method_handle():
  const(helper="MterpConstMethodHandle")

def op_const_method_type():
  const(helper="MterpConstMethodType")

def op_const_string():
  const(helper="MterpConstString")

def op_const_string_jumbo():
  write_line('''    /* const/string vAA, String//BBBBBBBB */''')
  write_line('''    .extern MterpConstString''')
  write_line('''    EXPORT_PC''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- bbbb (low)''')
  write_line('''    lh      a4, 4(rPC)                  # a4 <- BBBB (high)''')
  write_line('''    srl     a1, rINST, 8                # a1 <- AA''')
  write_line('''    ins     a0, a4, 16, 16              # a0 <- BBBBbbbb''')
  write_line('''    daddu   a2, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a3, rSELF''')
  write_line('''    jal     MterpConstString            # (index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST 3                     # load rINST''')
  write_line('''    bnez    v0, MterpPossibleException  # let reference interpreter deal with it.''')
  write_line('''    ADVANCE 3                           # advance rPC''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_wide():
  write_line('''    /* const-wide vAA, #+HHHHhhhhBBBBbbbb */''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- bbbb (low)''')
  write_line('''    lh      a1, 4(rPC)                  # a1 <- BBBB (low middle)''')
  write_line('''    lh      a2, 6(rPC)                  # a2 <- hhhh (high middle)''')
  write_line('''    lh      a3, 8(rPC)                  # a3 <- HHHH (high)''')
  write_line('''    FETCH_ADVANCE_INST 5                # advance rPC, load rINST''')
  write_line('''    ins     a0, a1, 16, 16              # a0 = BBBBbbbb''')
  write_line('''    ins     a2, a3, 16, 16              # a2 = HHHHhhhh''')
  write_line('''    dinsu   a0, a2, 32, 32              # a0 = HHHHhhhhBBBBbbbb''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a4                # vAA <- +HHHHhhhhBBBBbbbb''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_wide_16():
  write_line('''    /* const-wide/16 vAA, #+BBBB */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- sign-extended BBBB''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vAA <- +BBBB''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_wide_32():
  write_line('''    /* const-wide/32 vAA, #+BBBBbbbb */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- bbbb (low)''')
  write_line('''    lh      a1, 4(rPC)                  # a1 <- BBBB (high)''')
  write_line('''    FETCH_ADVANCE_INST 3                # advance rPC, load rINST''')
  write_line('''    ins     a0, a1, 16, 16              # a0 = BBBBbbbb''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vAA <- +BBBBbbbb''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_const_wide_high16():
  write_line('''    /* const-wide/high16 vAA, #+BBBB000000000000 */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- BBBB''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    dsll32  a0, a0, 16                  # a0 <- BBBB000000000000''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vAA <- +BBBB000000000000''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_div_double():
  fbinopWide(instr="div.d f0, f0, f1")

def op_div_double_2addr():
  fbinopWide2addr(instr="div.d f0, f0, f1")

def op_div_float():
  fbinop(instr="div.s f0, f0, f1")

def op_div_float_2addr():
  fbinop2addr(instr="div.s f0, f0, f1")

def op_div_int():
  binop(instr="div a0, a0, a1", chkzero="1")

def op_div_int_2addr():
  binop2addr(instr="div a0, a0, a1", chkzero="1")

def op_div_int_lit16():
  binopLit16(instr="div a0, a0, a1", chkzero="1")

def op_div_int_lit8():
  binopLit8(instr="div a0, a0, a1", chkzero="1")

def op_div_long():
  binopWide(instr="ddiv a0, a0, a1", chkzero="1")

def op_div_long_2addr():
  binopWide2addr(instr="ddiv a0, a0, a1", chkzero="1")

def op_double_to_float():
  write_line('''    /*''')
  write_line('''     * Conversion from or to floating-point happens in a floating-point register.''')
  write_line('''     * Therefore we load the input and store the output into or from a''')
  write_line('''     * floating-point register irrespective of the type.''')
  write_line('''     */''')
  fcvtHeader(suffix="_DOUBLE", valreg="f0")
  write_line('''    cvt.s.d f0, f0''')
  fcvtFooter(suffix="_FLOAT", valreg="f0")

def op_double_to_int():
  fcvtHeader(suffix="_DOUBLE", valreg="f0")
  write_line('''    trunc.w.d f0, f0''')
  fcvtFooter(suffix="_FLOAT", valreg="f0")

def op_double_to_long():
  fcvtHeader(suffix="_DOUBLE", valreg="f0")
  write_line('''    trunc.l.d f0, f0''')
  fcvtFooter(suffix="_DOUBLE", valreg="f0")

def op_fill_array_data():
  write_line('''    /* fill-array-data vAA, +BBBBBBBB */''')
  write_line('''    .extern MterpFillArrayData''')
  write_line('''    EXPORT_PC''')
  write_line('''    lh      a1, 2(rPC)                  # a1 <- bbbb (lo)''')
  write_line('''    lh      a0, 4(rPC)                  # a0 <- BBBB (hi)''')
  write_line('''    srl     a3, rINST, 8                # a3 <- AA''')
  write_line('''    ins     a1, a0, 16, 16              # a1 <- BBBBbbbb''')
  write_line('''    GET_VREG_U a0, a3                   # a0 <- vAA (array object)''')
  write_line('''    dlsa    a1, a1, rPC, 1              # a1 <- PC + BBBBbbbb*2 (array data off.)''')
  write_line('''    jal     MterpFillArrayData          # (obj, payload)''')
  write_line('''    beqzc   v0, MterpPossibleException  # exception?''')
  write_line('''    FETCH_ADVANCE_INST 3                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_filled_new_array(helper="MterpFilledNewArray"):
  write_line('''    /*''')
  write_line('''     * Create a new array with elements filled from registers.''')
  write_line('''     *''')
  write_line('''     * for: filled-new-array, filled-new-array/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class//CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, type//BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    daddu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a1, rPC''')
  write_line('''    move    a2, rSELF''')
  write_line('''    jal     ''' + helper + '''''')
  write_line('''    beqzc   v0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 3                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_filled_new_array_range():
  op_filled_new_array(helper="MterpFilledNewArrayRange")

def op_float_to_double():
  write_line('''    /*''')
  write_line('''     * Conversion from or to floating-point happens in a floating-point register.''')
  write_line('''     * Therefore we load the input and store the output into or from a''')
  write_line('''     * floating-point register irrespective of the type.''')
  write_line('''     */''')
  fcvtHeader(suffix="_FLOAT", valreg="f0")
  write_line('''    cvt.d.s f0, f0''')
  fcvtFooter(suffix="_DOUBLE", valreg="f0")

def op_float_to_int():
  fcvtHeader(suffix="_FLOAT", valreg="f0")
  write_line('''    trunc.w.s f0, f0''')
  fcvtFooter(suffix="_FLOAT", valreg="f0")

def op_float_to_long():
  fcvtHeader(suffix="_FLOAT", valreg="f0")
  write_line('''    trunc.l.s f0, f0''')
  fcvtFooter(suffix="_DOUBLE", valreg="f0")

def op_goto():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 8-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto +AA */''')
  write_line('''    srl     rINST, rINST, 8''')
  write_line('''    seb     rINST, rINST                # rINST <- offset (sign-extended AA)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_16():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 16-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto/16 +AAAA */''')
  write_line('''    lh      rINST, 2(rPC)               # rINST <- offset (sign-extended AAAA)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_32():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 32-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     *''')
  write_line('''     * Unlike most opcodes, this one is allowed to branch to itself, so''')
  write_line('''     * our "backward branch" test must be "<=0" instead of "<0".''')
  write_line('''     */''')
  write_line('''    /* goto/32 +AAAAAAAA */''')
  write_line('''    lh      rINST, 2(rPC)               # rINST <- aaaa (low)''')
  write_line('''    lh      a1, 4(rPC)                  # a1 <- AAAA (high)''')
  write_line('''    ins     rINST, a1, 16, 16           # rINST <- offset (sign-extended AAAAaaaa)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_if_eq():
  bincmp(condition="eq")

def op_if_eqz():
  zcmp(condition="eq")

def op_if_ge():
  bincmp(condition="ge")

def op_if_gez():
  zcmp(condition="ge")

def op_if_gt():
  bincmp(condition="gt")

def op_if_gtz():
  zcmp(condition="gt")

def op_if_le():
  bincmp(condition="le")

def op_if_lez():
  zcmp(condition="le")

def op_if_lt():
  bincmp(condition="lt")

def op_if_ltz():
  zcmp(condition="lt")

def op_if_ne():
  bincmp(condition="ne")

def op_if_nez():
  zcmp(condition="ne")

def op_iget(is_object="0", helper="MterpIGetU32"):
  field(helper=helper)

def op_iget_boolean():
  op_iget(helper="MterpIGetU8")

def op_iget_boolean_quick():
  op_iget_quick(load="lbu")

def op_iget_byte():
  op_iget(helper="MterpIGetI8")

def op_iget_byte_quick():
  op_iget_quick(load="lb")

def op_iget_char():
  op_iget(helper="MterpIGetU16")

def op_iget_char_quick():
  op_iget_quick(load="lhu")

def op_iget_object():
  op_iget(is_object="1", helper="MterpIGetObj")

def op_iget_object_quick():
  write_line('''    /* For: iget-object-quick */''')
  write_line('''    /* op vA, vB, offset//CCCC */''')
  write_line('''    .extern artIGetObjectFromMterp''')
  write_line('''    srl     a2, rINST, 12               # a2 <- B''')
  write_line('''    lhu     a1, 2(rPC)                  # a1 <- field byte offset''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- object we're operating on''')
  write_line('''    jal     artIGetObjectFromMterp      # (obj, offset)''')
  write_line('''    ld      a3, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    bnez    a3, MterpPossibleException  # bail out''')
  write_line('''    SET_VREG_OBJECT v0, a2              # fp[A] <- v0''')
  write_line('''    ADVANCE 2                           # advance rPC''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_iget_quick(load="lw"):
  write_line('''    /* For: iget-quick, iget-boolean-quick, iget-byte-quick, iget-char-quick, iget-short-quick */''')
  write_line('''    /* op vA, vB, offset//CCCC */''')
  write_line('''    srl     a2, rINST, 12               # a2 <- B''')
  write_line('''    lhu     a1, 2(rPC)                  # a1 <- field byte offset''')
  write_line('''    GET_VREG_U a3, a2                   # a3 <- object we're operating on''')
  write_line('''    ext     a4, rINST, 8, 4             # a4 <- A''')
  write_line('''    daddu   a1, a1, a3''')
  write_line('''    beqz    a3, common_errNullObject    # object was null''')
  write_line('''    ''' + load + '''   a0, 0(a1)                   # a0 <- obj.field''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    SET_VREG a0, a4                     # fp[A] <- a0''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_iget_short():
  op_iget(helper="MterpIGetI16")

def op_iget_short_quick():
  op_iget_quick(load="lh")

def op_iget_wide():
  op_iget(helper="MterpIGetU64")

def op_iget_wide_quick():
  write_line('''    /* iget-wide-quick vA, vB, offset//CCCC */''')
  write_line('''    srl     a2, rINST, 12               # a2 <- B''')
  write_line('''    lhu     a4, 2(rPC)                  # a4 <- field byte offset''')
  write_line('''    GET_VREG_U a3, a2                   # a3 <- object we're operating on''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    beqz    a3, common_errNullObject    # object was null''')
  write_line('''    daddu   a4, a3, a4                  # create direct pointer''')
  write_line('''    lw      a0, 0(a4)''')
  write_line('''    lw      a1, 4(a4)''')
  write_line('''    dinsu   a0, a1, 32, 32''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    SET_VREG_WIDE a0, a2''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_instance_of():
  write_line('''    /*''')
  write_line('''     * Check to see if an object reference is an instance of a class.''')
  write_line('''     *''')
  write_line('''     * Most common situation is a non-null object, being compared against''')
  write_line('''     * an already-resolved class.''')
  write_line('''     */''')
  write_line('''    /* instance-of vA, vB, class//CCCC */''')
  write_line('''    .extern MterpInstanceOf''')
  write_line('''    EXPORT_PC''')
  write_line('''    lhu     a0, 2(rPC)                  # a0 <- CCCC''')
  write_line('''    srl     a1, rINST, 12               # a1 <- B''')
  write_line('''    dlsa    a1, a1, rFP, 2              # a1 <- &object''')
  write_line('''    ld      a2, OFF_FP_METHOD(rFP)      # a2 <- method''')
  write_line('''    move    a3, rSELF                   # a3 <- self''')
  write_line('''    jal     MterpInstanceOf             # (index, &obj, method, self)''')
  write_line('''    ld      a1, THREAD_EXCEPTION_OFFSET(rSELF)''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    bnez    a1, MterpException''')
  write_line('''    ADVANCE 2                           # advance rPC''')
  write_line('''    SET_VREG v0, a2                     # vA <- v0''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_int_to_byte():
  unop(instr="seb     a0, a0")

def op_int_to_char():
  unop(instr="and     a0, a0, 0xffff")

def op_int_to_double():
  write_line('''    /*''')
  write_line('''     * Conversion from or to floating-point happens in a floating-point register.''')
  write_line('''     * Therefore we load the input and store the output into or from a''')
  write_line('''     * floating-point register irrespective of the type.''')
  write_line('''     */''')
  fcvtHeader(suffix="_FLOAT", valreg="f0")
  write_line('''    cvt.d.w f0, f0''')
  fcvtFooter(suffix="_DOUBLE", valreg="f0")

def op_int_to_float():
  write_line('''    /*''')
  write_line('''     * Conversion from or to floating-point happens in a floating-point register.''')
  write_line('''     * Therefore we load the input and store the output into or from a''')
  write_line('''     * floating-point register irrespective of the type.''')
  write_line('''     */''')
  fcvtHeader(suffix="_FLOAT", valreg="f0")
  write_line('''    cvt.s.w f0, f0''')
  fcvtFooter(suffix="_FLOAT", valreg="f0")

def op_int_to_long():
  write_line('''    /* int-to-long vA, vB */''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG a0, a3                     # a0 <- vB (sign-extended to 64 bits)''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vA <- vB''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_int_to_short():
  unop(instr="seh     a0, a0")

def op_invoke_custom():
  invoke(helper="MterpInvokeCustom")

def op_invoke_custom_range():
  invoke(helper="MterpInvokeCustomRange")

def op_invoke_direct():
  invoke(helper="MterpInvokeDirect")

def op_invoke_direct_range():
  invoke(helper="MterpInvokeDirectRange")

def op_invoke_interface():
  invoke(helper="MterpInvokeInterface")
  write_line('''    /*''')
  write_line('''     * Handle an interface method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-interface, invoke-interface/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_interface_range():
  invoke(helper="MterpInvokeInterfaceRange")

def op_invoke_polymorphic():
  invoke_polymorphic(helper="MterpInvokePolymorphic")

def op_invoke_polymorphic_range():
  invoke_polymorphic(helper="MterpInvokePolymorphicRange")

def op_invoke_static():
  invoke(helper="MterpInvokeStatic")

def op_invoke_static_range():
  invoke(helper="MterpInvokeStaticRange")

def op_invoke_super():
  invoke(helper="MterpInvokeSuper")
  write_line('''    /*''')
  write_line('''     * Handle a "super" method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-super, invoke-super/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_super_range():
  invoke(helper="MterpInvokeSuperRange")

def op_invoke_virtual():
  invoke(helper="MterpInvokeVirtual")
  write_line('''    /*''')
  write_line('''     * Handle a virtual method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-virtual, invoke-virtual/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_virtual_quick():
  invoke(helper="MterpInvokeVirtualQuick")

def op_invoke_virtual_range():
  invoke(helper="MterpInvokeVirtualRange")

def op_invoke_virtual_range_quick():
  invoke(helper="MterpInvokeVirtualQuickRange")

def op_iput(is_object="0", helper="MterpIPutU32"):
  field(helper=helper)

def op_iput_boolean():
  op_iput(helper="MterpIPutU8")

def op_iput_boolean_quick():
  op_iput_quick(store="sb")

def op_iput_byte():
  op_iput(helper="MterpIPutI8")

def op_iput_byte_quick():
  op_iput_quick(store="sb")

def op_iput_char():
  op_iput(helper="MterpIPutU16")

def op_iput_char_quick():
  op_iput_quick(store="sh")

def op_iput_object():
  op_iput(is_object="1", helper="MterpIPutObj")

def op_iput_object_quick():
  write_line('''    .extern MterpIputObjectQuick''')
  write_line('''    EXPORT_PC''')
  write_line('''    daddu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a1, rPC''')
  write_line('''    move    a2, rINST''')
  write_line('''    jal     MterpIputObjectQuick''')
  write_line('''    beqzc   v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_iput_quick(store="sw"):
  write_line('''    /* For: iput-quick, iput-boolean-quick, iput-byte-quick, iput-char-quick, iput-short-quick */''')
  write_line('''    /* op vA, vB, offset//CCCC */''')
  write_line('''    srl     a2, rINST, 12               # a2 <- B''')
  write_line('''    lhu     a1, 2(rPC)                  # a1 <- field byte offset''')
  write_line('''    GET_VREG_U a3, a2                   # a3 <- fp[B], the object pointer''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    beqz    a3, common_errNullObject    # object was null''')
  write_line('''    GET_VREG a0, a2                     # a0 <- fp[A]''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    daddu   a1, a1, a3''')
  write_line('''    ''' + store + '''  a0, 0(a1)                   # obj.field <- a0''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_iput_short():
  op_iput(helper="MterpIPutI16")

def op_iput_short_quick():
  op_iput_quick(store="sh")

def op_iput_wide():
  op_iput(helper="MterpIPutU64")

def op_iput_wide_quick():
  write_line('''    /* iput-wide-quick vA, vB, offset//CCCC */''')
  write_line('''    srl     a2, rINST, 12               # a2 <- B''')
  write_line('''    lhu     a3, 2(rPC)                  # a3 <- field byte offset''')
  write_line('''    GET_VREG_U a2, a2                   # a2 <- fp[B], the object pointer''')
  write_line('''    ext     a0, rINST, 8, 4             # a0 <- A''')
  write_line('''    beqz    a2, common_errNullObject    # object was null''')
  write_line('''    GET_VREG_WIDE a0, a0                # a0 <- fp[A]''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    daddu   a1, a2, a3                  # create a direct pointer''')
  write_line('''    sw      a0, 0(a1)''')
  write_line('''    dsrl32  a0, a0, 0''')
  write_line('''    sw      a0, 4(a1)''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_long_to_double():
  write_line('''    /*''')
  write_line('''     * Conversion from or to floating-point happens in a floating-point register.''')
  write_line('''     * Therefore we load the input and store the output into or from a''')
  write_line('''     * floating-point register irrespective of the type.''')
  write_line('''     */''')
  fcvtHeader(suffix="_DOUBLE", valreg="f0")
  write_line('''    cvt.d.l f0, f0''')
  fcvtFooter(suffix="_DOUBLE", valreg="f0")

def op_long_to_float():
  write_line('''    /*''')
  write_line('''     * Conversion from or to floating-point happens in a floating-point register.''')
  write_line('''     * Therefore we load the input and store the output into or from a''')
  write_line('''     * floating-point register irrespective of the type.''')
  write_line('''     */''')
  fcvtHeader(suffix="_DOUBLE", valreg="f0")
  write_line('''    cvt.s.l f0, f0''')
  fcvtFooter(suffix="_FLOAT", valreg="f0")

def op_long_to_int():
  write_line('''/* we ignore the high word, making this equivalent to a 32-bit reg move */''')
  op_move()

def op_monitor_enter():
  write_line('''    /*''')
  write_line('''     * Synchronize on an object.''')
  write_line('''     */''')
  write_line('''    /* monitor-enter vAA */''')
  write_line('''    .extern artLockObjectFromCode''')
  write_line('''    EXPORT_PC''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vAA (object)''')
  write_line('''    move    a1, rSELF                   # a1 <- self''')
  write_line('''    jal     artLockObjectFromCode''')
  write_line('''    bnezc   v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 1''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_monitor_exit():
  write_line('''    /*''')
  write_line('''     * Unlock an object.''')
  write_line('''     *''')
  write_line('''     * Exceptions that occur when unlocking a monitor need to appear as''')
  write_line('''     * if they happened at the following instruction.  See the Dalvik''')
  write_line('''     * instruction spec.''')
  write_line('''     */''')
  write_line('''    /* monitor-exit vAA */''')
  write_line('''    .extern artUnlockObjectFromCode''')
  write_line('''    EXPORT_PC''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vAA (object)''')
  write_line('''    move    a1, rSELF                   # a1 <- self''')
  write_line('''    jal     artUnlockObjectFromCode     # v0 <- success for unlock(self, obj)''')
  write_line('''    bnezc   v0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 1                # before throw: advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move(is_object="0"):
  write_line('''    /* for move, move-object, long-to-int */''')
  write_line('''    /* op vA, vB */''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_VREG a0, a3                     # a0 <- vB''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT a0, a2              # vA <- vB''')
  write_line('''    .else''')
  write_line('''    SET_VREG a0, a2                     # vA <- vB''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_16(is_object="0"):
  write_line('''    /* for: move/16, move-object/16 */''')
  write_line('''    /* op vAAAA, vBBBB */''')
  write_line('''    lhu     a3, 4(rPC)                  # a3 <- BBBB''')
  write_line('''    lhu     a2, 2(rPC)                  # a2 <- AAAA''')
  write_line('''    FETCH_ADVANCE_INST 3                # advance rPC, load rINST''')
  write_line('''    GET_VREG a0, a3                     # a0 <- vBBBB''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT a0, a2              # vAAAA <- vBBBB''')
  write_line('''    .else''')
  write_line('''    SET_VREG a0, a2                     # vAAAA <- vBBBB''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_exception():
  write_line('''    /* move-exception vAA */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    ld      a0, THREAD_EXCEPTION_OFFSET(rSELF)  # load exception obj''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    SET_VREG_OBJECT a0, a2              # vAA <- exception obj''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    sd      zero, THREAD_EXCEPTION_OFFSET(rSELF)  # clear exception''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_from16(is_object="0"):
  write_line('''    /* for: move/from16, move-object/from16 */''')
  write_line('''    /* op vAA, vBBBB */''')
  write_line('''    lhu     a3, 2(rPC)                  # a3 <- BBBB''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_VREG a0, a3                     # a0 <- vBBBB''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT a0, a2              # vAA <- vBBBB''')
  write_line('''    .else''')
  write_line('''    SET_VREG a0, a2                     # vAA <- vBBBB''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_object():
  op_move(is_object="1")

def op_move_object_16():
  op_move_16(is_object="1")

def op_move_object_from16():
  op_move_from16(is_object="1")

def op_move_result(is_object="0"):
  write_line('''    /* for: move-result, move-result-object */''')
  write_line('''    /* op vAA */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    ld      a0, OFF_FP_RESULT_REGISTER(rFP)  # get pointer to result JType''')
  write_line('''    lw      a0, 0(a0)                   # a0 <- result.i''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT a0, a2              # vAA <- result''')
  write_line('''    .else''')
  write_line('''    SET_VREG a0, a2                     # vAA <- result''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_result_object():
  op_move_result(is_object="1")

def op_move_result_wide():
  write_line('''    /* for: move-result-wide */''')
  write_line('''    /* op vAA */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    ld      a0, OFF_FP_RESULT_REGISTER(rFP)  # get pointer to result JType''')
  write_line('''    ld      a0, 0(a0)                   # a0 <- result.j''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vAA <- result''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_wide():
  write_line('''    /* move-wide vA, vB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    GET_VREG_WIDE a0, a3                # a0 <- vB''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vA <- vB''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_wide_16():
  write_line('''    /* move-wide/16 vAAAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    lhu     a3, 4(rPC)                  # a3 <- BBBB''')
  write_line('''    lhu     a2, 2(rPC)                  # a2 <- AAAA''')
  write_line('''    GET_VREG_WIDE a0, a3                # a0 <- vBBBB''')
  write_line('''    FETCH_ADVANCE_INST 3                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vAAAA <- vBBBB''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_move_wide_from16():
  write_line('''    /* move-wide/from16 vAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    lhu     a3, 2(rPC)                  # a3 <- BBBB''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    GET_VREG_WIDE a0, a3                # a0 <- vBBBB''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vAA <- vBBBB''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_mul_double():
  fbinopWide(instr="mul.d f0, f0, f1")

def op_mul_double_2addr():
  fbinopWide2addr(instr="mul.d f0, f0, f1")

def op_mul_float():
  fbinop(instr="mul.s f0, f0, f1")

def op_mul_float_2addr():
  fbinop2addr(instr="mul.s f0, f0, f1")

def op_mul_int():
  binop(instr="mul a0, a0, a1")

def op_mul_int_2addr():
  binop2addr(instr="mul a0, a0, a1")

def op_mul_int_lit16():
  binopLit16(instr="mul a0, a0, a1")

def op_mul_int_lit8():
  binopLit8(instr="mul a0, a0, a1")

def op_mul_long():
  binopWide(instr="dmul a0, a0, a1")

def op_mul_long_2addr():
  binopWide2addr(instr="dmul a0, a0, a1")

def op_neg_double():
  fcvtHeader(suffix="_DOUBLE", valreg="f0")
  write_line('''    neg.d   f0, f0''')
  fcvtFooter(suffix="_DOUBLE", valreg="f0")

def op_neg_float():
  fcvtHeader(suffix="_FLOAT", valreg="f0")
  write_line('''    neg.s   f0, f0''')
  fcvtFooter(suffix="_FLOAT", valreg="f0")

def op_neg_int():
  unop(instr="subu    a0, zero, a0")

def op_neg_long():
  unopWide(instr="dsubu   a0, zero, a0")

def op_new_array():
  write_line('''    /*''')
  write_line('''     * Allocate an array of objects, specified with the array class''')
  write_line('''     * and a count.''')
  write_line('''     *''')
  write_line('''     * The verifier guarantees that this is an array class, so we don't''')
  write_line('''     * check for it here.''')
  write_line('''     */''')
  write_line('''    /* new-array vA, vB, class//CCCC */''')
  write_line('''    .extern MterpNewArray''')
  write_line('''    EXPORT_PC''')
  write_line('''    daddu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a1, rPC''')
  write_line('''    move    a2, rINST''')
  write_line('''    move    a3, rSELF''')
  write_line('''    jal     MterpNewArray''')
  write_line('''    beqzc   v0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_new_instance():
  write_line('''    /*''')
  write_line('''     * Create a new instance of a class.''')
  write_line('''     */''')
  write_line('''    /* new-instance vAA, class//BBBB */''')
  write_line('''    .extern MterpNewInstance''')
  write_line('''    EXPORT_PC''')
  write_line('''    daddu   a0, rFP, OFF_FP_SHADOWFRAME''')
  write_line('''    move    a1, rSELF''')
  write_line('''    move    a2, rINST''')
  write_line('''    jal     MterpNewInstance            # (shadow_frame, self, inst_data)''')
  write_line('''    beqzc   v0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_nop():
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_not_int():
  unop(instr="nor     a0, zero, a0")

def op_not_long():
  unopWide(instr="nor     a0, zero, a0")

def op_or_int():
  binop(instr="or a0, a0, a1")

def op_or_int_2addr():
  binop2addr(instr="or a0, a0, a1")

def op_or_int_lit16():
  binopLit16(instr="or a0, a0, a1")

def op_or_int_lit8():
  binopLit8(instr="or a0, a0, a1")

def op_or_long():
  binopWide(instr="or a0, a0, a1")

def op_or_long_2addr():
  binopWide2addr(instr="or a0, a0, a1")

def op_packed_switch(func="MterpDoPackedSwitch"):
  write_line('''    /*''')
  write_line('''     * Handle a packed-switch or sparse-switch instruction.  In both cases''')
  write_line('''     * we decode it and hand it off to a helper function.''')
  write_line('''     *''')
  write_line('''     * We don't really expect backward branches in a switch statement, but''')
  write_line('''     * they're perfectly legal, so we check for them here.''')
  write_line('''     *''')
  write_line('''     * for: packed-switch, sparse-switch''')
  write_line('''     */''')
  write_line('''    /* op vAA, +BBBBBBBB */''')
  write_line('''    .extern ''' + func + '''''')
  write_line('''    lh      a0, 2(rPC)                  # a0 <- bbbb (lo)''')
  write_line('''    lh      a1, 4(rPC)                  # a1 <- BBBB (hi)''')
  write_line('''    srl     a3, rINST, 8                # a3 <- AA''')
  write_line('''    ins     a0, a1, 16, 16              # a0 <- BBBBbbbb''')
  write_line('''    GET_VREG a1, a3                     # a1 <- vAA''')
  write_line('''    dlsa    a0, a0, rPC, 1              # a0 <- PC + BBBBbbbb*2''')
  write_line('''    jal     ''' + func + '''                       # v0 <- code-unit branch offset''')
  write_line('''    move    rINST, v0''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_rem_double():
  write_line('''    /* rem-double vAA, vBB, vCC */''')
  write_line('''    .extern fmod''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG_DOUBLE f12, a2             # f12 <- vBB''')
  write_line('''    GET_VREG_DOUBLE f13, a3             # f13 <- vCC''')
  write_line('''    jal     fmod                        # f0 <- f12 op f13''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_DOUBLE f0, a4              # vAA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_rem_double_2addr():
  write_line('''    /* rem-double/2addr vA, vB */''')
  write_line('''    .extern fmod''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG_DOUBLE f12, a2             # f12 <- vA''')
  write_line('''    GET_VREG_DOUBLE f13, a3             # f13 <- vB''')
  write_line('''    jal     fmod                        # f0 <- f12 op f13''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_DOUBLE f0, a2              # vA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_rem_float():
  write_line('''    /* rem-float vAA, vBB, vCC */''')
  write_line('''    .extern fmodf''')
  write_line('''    lbu     a2, 2(rPC)                  # a2 <- BB''')
  write_line('''    lbu     a3, 3(rPC)                  # a3 <- CC''')
  write_line('''    GET_VREG_FLOAT f12, a2              # f12 <- vBB''')
  write_line('''    GET_VREG_FLOAT f13, a3              # f13 <- vCC''')
  write_line('''    jal     fmodf                       # f0 <- f12 op f13''')
  write_line('''    srl     a4, rINST, 8                # a4 <- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_FLOAT f0, a4               # vAA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_rem_float_2addr():
  write_line('''    /* rem-float/2addr vA, vB */''')
  write_line('''    .extern fmodf''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG_FLOAT f12, a2              # f12 <- vA''')
  write_line('''    GET_VREG_FLOAT f13, a3              # f13 <- vB''')
  write_line('''    jal     fmodf                       # f0 <- f12 op f13''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_FLOAT f0, a2               # vA <- f0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def op_rem_int():
  binop(instr="mod a0, a0, a1", chkzero="1")

def op_rem_int_2addr():
  binop2addr(instr="mod a0, a0, a1", chkzero="1")

def op_rem_int_lit16():
  binopLit16(instr="mod a0, a0, a1", chkzero="1")

def op_rem_int_lit8():
  binopLit8(instr="mod a0, a0, a1", chkzero="1")

def op_rem_long():
  binopWide(instr="dmod a0, a0, a1", chkzero="1")

def op_rem_long_2addr():
  binopWide2addr(instr="dmod a0, a0, a1", chkzero="1")

def op_return(instr="GET_VREG"):
  write_line('''    /*''')
  write_line('''     * Return a 32-bit value.''')
  write_line('''     *''')
  write_line('''     * for: return (sign-extend), return-object (zero-extend)''')
  write_line('''     */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    .extern MterpSuspendCheck''')
  write_line('''    jal     MterpThreadFenceForConstructor''')
  write_line('''    lw      ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move    a0, rSELF''')
  write_line('''    and     ra, ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqzc   ra, 1f''')
  write_line('''    jal     MterpSuspendCheck           # (self)''')
  write_line('''1:''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    ''' + instr + '''  a0, a2                      # a0 <- vAA''')
  write_line('''    b       MterpReturn''')

def op_return_object():
  op_return(instr="GET_VREG_U")

def op_return_void():
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    .extern MterpSuspendCheck''')
  write_line('''    jal     MterpThreadFenceForConstructor''')
  write_line('''    lw      ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move    a0, rSELF''')
  write_line('''    and     ra, ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqzc   ra, 1f''')
  write_line('''    jal     MterpSuspendCheck           # (self)''')
  write_line('''1:''')
  write_line('''    li      a0, 0''')
  write_line('''    b       MterpReturn''')

def op_return_void_no_barrier():
  write_line('''    .extern MterpSuspendCheck''')
  write_line('''    lw      ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move    a0, rSELF''')
  write_line('''    and     ra, ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqzc   ra, 1f''')
  write_line('''    jal     MterpSuspendCheck           # (self)''')
  write_line('''1:''')
  write_line('''    li      a0, 0''')
  write_line('''    b       MterpReturn''')

def op_return_wide():
  write_line('''    /*''')
  write_line('''     * Return a 64-bit value.''')
  write_line('''     */''')
  write_line('''    /* return-wide vAA */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    .extern MterpSuspendCheck''')
  write_line('''    jal     MterpThreadFenceForConstructor''')
  write_line('''    lw      ra, THREAD_FLAGS_OFFSET(rSELF)''')
  write_line('''    move    a0, rSELF''')
  write_line('''    and     ra, ra, THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    beqzc   ra, 1f''')
  write_line('''    jal     MterpSuspendCheck           # (self)''')
  write_line('''1:''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    GET_VREG_WIDE a0, a2                # a0 <- vAA''')
  write_line('''    b       MterpReturn''')

def op_rsub_int():
  binopLit16(instr="subu a0, a1, a0")

def op_rsub_int_lit8():
  binopLit8(instr="subu a0, a1, a0")

def op_sget(is_object="0", helper="MterpSGetU32"):
  field(helper=helper)

def op_sget_boolean():
  op_sget(helper="MterpSGetU8")

def op_sget_byte():
  op_sget(helper="MterpSGetI8")

def op_sget_char():
  op_sget(helper="MterpSGetU16")

def op_sget_object():
  op_sget(is_object="1", helper="MterpSGetObj")

def op_sget_short():
  op_sget(helper="MterpSGetI16")

def op_sget_wide():
  op_sget(helper="MterpSGetU64")

def op_shl_int():
  binop(instr="sll a0, a0, a1")

def op_shl_int_2addr():
  binop2addr(instr="sll a0, a0, a1")

def op_shl_int_lit8():
  binopLit8(instr="sll a0, a0, a1")

def op_shl_long():
  binopWide(instr="dsll a0, a0, a1")

def op_shl_long_2addr():
  binopWide2addr(instr="dsll a0, a0, a1")

def op_shr_int():
  binop(instr="sra a0, a0, a1")

def op_shr_int_2addr():
  binop2addr(instr="sra a0, a0, a1")

def op_shr_int_lit8():
  binopLit8(instr="sra a0, a0, a1")

def op_shr_long():
  binopWide(instr="dsra a0, a0, a1")

def op_shr_long_2addr():
  binopWide2addr(instr="dsra a0, a0, a1")

def op_sparse_switch():
  op_packed_switch(func="MterpDoSparseSwitch")

def op_sput(is_object="0", helper="MterpSPutU32"):
  field(helper=helper)

def op_sput_boolean():
  op_sput(helper="MterpSPutU8")

def op_sput_byte():
  op_sput(helper="MterpSPutI8")

def op_sput_char():
  op_sput(helper="MterpSPutU16")

def op_sput_object():
  op_sput(is_object="1", helper="MterpSPutObj")

def op_sput_short():
  op_sput(helper="MterpSPutI16")

def op_sput_wide():
  op_sput(helper="MterpSPutU64")

def op_sub_double():
  fbinopWide(instr="sub.d f0, f0, f1")

def op_sub_double_2addr():
  fbinopWide2addr(instr="sub.d f0, f0, f1")

def op_sub_float():
  fbinop(instr="sub.s f0, f0, f1")

def op_sub_float_2addr():
  fbinop2addr(instr="sub.s f0, f0, f1")

def op_sub_int():
  binop(instr="subu a0, a0, a1")

def op_sub_int_2addr():
  binop2addr(instr="subu a0, a0, a1")

def op_sub_long():
  binopWide(instr="dsubu a0, a0, a1")

def op_sub_long_2addr():
  binopWide2addr(instr="dsubu a0, a0, a1")

def op_throw():
  write_line('''    /*''')
  write_line('''     * Throw an exception object in the current thread.''')
  write_line('''     */''')
  write_line('''    /* throw vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    GET_VREG_U a0, a2                   # a0 <- vAA (exception object)''')
  write_line('''    beqzc   a0, common_errNullObject''')
  write_line('''    sd      a0, THREAD_EXCEPTION_OFFSET(rSELF)  # thread->exception <- obj''')
  write_line('''    b       MterpException''')

def op_unused_3e():
  unused()

def op_unused_3f():
  unused()

def op_unused_40():
  unused()

def op_unused_41():
  unused()

def op_unused_42():
  unused()

def op_unused_43():
  unused()

def op_unused_79():
  unused()

def op_unused_7a():
  unused()

def op_unused_f3():
  unused()

def op_unused_f4():
  unused()

def op_unused_f5():
  unused()

def op_unused_f6():
  unused()

def op_unused_f7():
  unused()

def op_unused_f8():
  unused()

def op_unused_f9():
  unused()

def op_unused_fc():
  unused()

def op_unused_fd():
  unused()

def op_ushr_int():
  binop(instr="srl a0, a0, a1")

def op_ushr_int_2addr():
  binop2addr(instr="srl a0, a0, a1")

def op_ushr_int_lit8():
  binopLit8(instr="srl a0, a0, a1")

def op_ushr_long():
  binopWide(instr="dsrl a0, a0, a1")

def op_ushr_long_2addr():
  binopWide2addr(instr="dsrl a0, a0, a1")

def op_xor_int():
  binop(instr="xor a0, a0, a1")

def op_xor_int_2addr():
  binop2addr(instr="xor a0, a0, a1")

def op_xor_int_lit16():
  binopLit16(instr="xor a0, a0, a1")

def op_xor_int_lit8():
  binopLit8(instr="xor a0, a0, a1")

def op_xor_long():
  binopWide(instr="xor a0, a0, a1")

def op_xor_long_2addr():
  binopWide2addr(instr="xor a0, a0, a1")

def unop(preinstr="", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "a0 = op a0".''')
  write_line('''     *''')
  write_line('''     * for: int-to-byte, int-to-char, int-to-short,''')
  write_line('''     *      not-int, neg-int''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG a0, a3                     # a0 <- vB''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              # a0 <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG a0, a2                     # vA <- a0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def unopWide(preinstr="", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "a0 = op a0".''')
  write_line('''     *''')
  write_line('''     * For: not-long, neg-long''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    ext     a3, rINST, 12, 4            # a3 <- B''')
  write_line('''    GET_VREG_WIDE a0, a3                # a0 <- vB''')
  write_line('''    ext     a2, rINST, 8, 4             # a2 <- A''')
  write_line('''    ''' + preinstr + '''                           # optional op''')
  write_line('''    FETCH_ADVANCE_INST 1                # advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              # a0 <- op, a0-a3 changed''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE a0, a2                # vA <- a0''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

def unused():
  write_line('''/*''')
  write_line(''' * Bail to reference interpreter to throw.''')
  write_line(''' */''')
  write_line('''    b       MterpFallback''')

def zcmp(condition=""):
  write_line('''    /*''')
  write_line('''     * Generic one-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform, e.g. for''')
  write_line('''     * "if-lez" you would use "le".''')
  write_line('''     *''')
  write_line('''     * For: if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez''')
  write_line('''     */''')
  write_line('''    /* if-cmp vAA, +BBBB */''')
  write_line('''    srl     a2, rINST, 8                # a2 <- AA''')
  write_line('''    lh      rINST, 2(rPC)               # rINST <- offset (sign-extended BBBB)''')
  write_line('''    GET_VREG a0, a2                     # a0 <- vAA''')
  write_line('''    b''' + condition + '''zc a0, MterpCommonTakenBranchNoFlags''')
  write_line('''    li      v0, JIT_CHECK_OSR           # possible OSR re-entry?''')
  write_line('''    beqc    rPROFILE, v0, .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST 2                # advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE v0                  # extract opcode from rINST''')
  write_line('''    GOTO_OPCODE v0                      # jump to next instruction''')

