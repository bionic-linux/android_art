# DO NOT EDIT: This file was generated by gen-mterp.py.
arch = "x86_64"

import sys

out = sys.stdout
handler_size_bytes = "128"
handler_size_bits = "7"
opcode = ""
opnum = ""

def write_line(line):
  out.write(line + "\n")

def balign():
  write_line("    .balign {}".format(handler_size_bytes))

def write_opcode(num, name, write_method, is_alt):
  global opnum, opcode
  opnum, opcode = str(num), name
  if is_alt:
    name = "ALT_" + name
  write_line("/* ------------------------------ */")
  balign()
  write_line(".L_{1}: /* {0:#04x} */".format(num, name))
  if is_alt:
    alt_stub()
  else:
    write_method()
  write_line("")
  opnum, opcode = None, None

def generate(output_file):
  global out
  out = output_file
  write_line("/* DO NOT EDIT: This file was generated by gen-mterp.py. */")
  header()
  entry()

  instruction_start()
  opcodes(is_alt = False)
  balign()
  instruction_end()

  instruction_start_sister()
  write_sister()
  instruction_end_sister()

  # We need to footer sooner so that branch instruction can reach it.
  # TODO: Clean up.
  if arch == "arm64":
    footer()

  instruction_start_alt()
  opcodes(is_alt = True)
  balign()
  instruction_end_alt()

  if arch == "arm64":
    close_cfi()
  else:
    footer()

  out.truncate()

def opcodes(is_alt):
  write_opcode(0, "op_nop", op_nop, is_alt)
  write_opcode(1, "op_move", op_move, is_alt)
  write_opcode(2, "op_move_from16", op_move_from16, is_alt)
  write_opcode(3, "op_move_16", op_move_16, is_alt)
  write_opcode(4, "op_move_wide", op_move_wide, is_alt)
  write_opcode(5, "op_move_wide_from16", op_move_wide_from16, is_alt)
  write_opcode(6, "op_move_wide_16", op_move_wide_16, is_alt)
  write_opcode(7, "op_move_object", op_move_object, is_alt)
  write_opcode(8, "op_move_object_from16", op_move_object_from16, is_alt)
  write_opcode(9, "op_move_object_16", op_move_object_16, is_alt)
  write_opcode(10, "op_move_result", op_move_result, is_alt)
  write_opcode(11, "op_move_result_wide", op_move_result_wide, is_alt)
  write_opcode(12, "op_move_result_object", op_move_result_object, is_alt)
  write_opcode(13, "op_move_exception", op_move_exception, is_alt)
  write_opcode(14, "op_return_void", op_return_void, is_alt)
  write_opcode(15, "op_return", op_return, is_alt)
  write_opcode(16, "op_return_wide", op_return_wide, is_alt)
  write_opcode(17, "op_return_object", op_return_object, is_alt)
  write_opcode(18, "op_const_4", op_const_4, is_alt)
  write_opcode(19, "op_const_16", op_const_16, is_alt)
  write_opcode(20, "op_const", op_const, is_alt)
  write_opcode(21, "op_const_high16", op_const_high16, is_alt)
  write_opcode(22, "op_const_wide_16", op_const_wide_16, is_alt)
  write_opcode(23, "op_const_wide_32", op_const_wide_32, is_alt)
  write_opcode(24, "op_const_wide", op_const_wide, is_alt)
  write_opcode(25, "op_const_wide_high16", op_const_wide_high16, is_alt)
  write_opcode(26, "op_const_string", op_const_string, is_alt)
  write_opcode(27, "op_const_string_jumbo", op_const_string_jumbo, is_alt)
  write_opcode(28, "op_const_class", op_const_class, is_alt)
  write_opcode(29, "op_monitor_enter", op_monitor_enter, is_alt)
  write_opcode(30, "op_monitor_exit", op_monitor_exit, is_alt)
  write_opcode(31, "op_check_cast", op_check_cast, is_alt)
  write_opcode(32, "op_instance_of", op_instance_of, is_alt)
  write_opcode(33, "op_array_length", op_array_length, is_alt)
  write_opcode(34, "op_new_instance", op_new_instance, is_alt)
  write_opcode(35, "op_new_array", op_new_array, is_alt)
  write_opcode(36, "op_filled_new_array", op_filled_new_array, is_alt)
  write_opcode(37, "op_filled_new_array_range", op_filled_new_array_range, is_alt)
  write_opcode(38, "op_fill_array_data", op_fill_array_data, is_alt)
  write_opcode(39, "op_throw", op_throw, is_alt)
  write_opcode(40, "op_goto", op_goto, is_alt)
  write_opcode(41, "op_goto_16", op_goto_16, is_alt)
  write_opcode(42, "op_goto_32", op_goto_32, is_alt)
  write_opcode(43, "op_packed_switch", op_packed_switch, is_alt)
  write_opcode(44, "op_sparse_switch", op_sparse_switch, is_alt)
  write_opcode(45, "op_cmpl_float", op_cmpl_float, is_alt)
  write_opcode(46, "op_cmpg_float", op_cmpg_float, is_alt)
  write_opcode(47, "op_cmpl_double", op_cmpl_double, is_alt)
  write_opcode(48, "op_cmpg_double", op_cmpg_double, is_alt)
  write_opcode(49, "op_cmp_long", op_cmp_long, is_alt)
  write_opcode(50, "op_if_eq", op_if_eq, is_alt)
  write_opcode(51, "op_if_ne", op_if_ne, is_alt)
  write_opcode(52, "op_if_lt", op_if_lt, is_alt)
  write_opcode(53, "op_if_ge", op_if_ge, is_alt)
  write_opcode(54, "op_if_gt", op_if_gt, is_alt)
  write_opcode(55, "op_if_le", op_if_le, is_alt)
  write_opcode(56, "op_if_eqz", op_if_eqz, is_alt)
  write_opcode(57, "op_if_nez", op_if_nez, is_alt)
  write_opcode(58, "op_if_ltz", op_if_ltz, is_alt)
  write_opcode(59, "op_if_gez", op_if_gez, is_alt)
  write_opcode(60, "op_if_gtz", op_if_gtz, is_alt)
  write_opcode(61, "op_if_lez", op_if_lez, is_alt)
  write_opcode(62, "op_unused_3e", op_unused_3e, is_alt)
  write_opcode(63, "op_unused_3f", op_unused_3f, is_alt)
  write_opcode(64, "op_unused_40", op_unused_40, is_alt)
  write_opcode(65, "op_unused_41", op_unused_41, is_alt)
  write_opcode(66, "op_unused_42", op_unused_42, is_alt)
  write_opcode(67, "op_unused_43", op_unused_43, is_alt)
  write_opcode(68, "op_aget", op_aget, is_alt)
  write_opcode(69, "op_aget_wide", op_aget_wide, is_alt)
  write_opcode(70, "op_aget_object", op_aget_object, is_alt)
  write_opcode(71, "op_aget_boolean", op_aget_boolean, is_alt)
  write_opcode(72, "op_aget_byte", op_aget_byte, is_alt)
  write_opcode(73, "op_aget_char", op_aget_char, is_alt)
  write_opcode(74, "op_aget_short", op_aget_short, is_alt)
  write_opcode(75, "op_aput", op_aput, is_alt)
  write_opcode(76, "op_aput_wide", op_aput_wide, is_alt)
  write_opcode(77, "op_aput_object", op_aput_object, is_alt)
  write_opcode(78, "op_aput_boolean", op_aput_boolean, is_alt)
  write_opcode(79, "op_aput_byte", op_aput_byte, is_alt)
  write_opcode(80, "op_aput_char", op_aput_char, is_alt)
  write_opcode(81, "op_aput_short", op_aput_short, is_alt)
  write_opcode(82, "op_iget", op_iget, is_alt)
  write_opcode(83, "op_iget_wide", op_iget_wide, is_alt)
  write_opcode(84, "op_iget_object", op_iget_object, is_alt)
  write_opcode(85, "op_iget_boolean", op_iget_boolean, is_alt)
  write_opcode(86, "op_iget_byte", op_iget_byte, is_alt)
  write_opcode(87, "op_iget_char", op_iget_char, is_alt)
  write_opcode(88, "op_iget_short", op_iget_short, is_alt)
  write_opcode(89, "op_iput", op_iput, is_alt)
  write_opcode(90, "op_iput_wide", op_iput_wide, is_alt)
  write_opcode(91, "op_iput_object", op_iput_object, is_alt)
  write_opcode(92, "op_iput_boolean", op_iput_boolean, is_alt)
  write_opcode(93, "op_iput_byte", op_iput_byte, is_alt)
  write_opcode(94, "op_iput_char", op_iput_char, is_alt)
  write_opcode(95, "op_iput_short", op_iput_short, is_alt)
  write_opcode(96, "op_sget", op_sget, is_alt)
  write_opcode(97, "op_sget_wide", op_sget_wide, is_alt)
  write_opcode(98, "op_sget_object", op_sget_object, is_alt)
  write_opcode(99, "op_sget_boolean", op_sget_boolean, is_alt)
  write_opcode(100, "op_sget_byte", op_sget_byte, is_alt)
  write_opcode(101, "op_sget_char", op_sget_char, is_alt)
  write_opcode(102, "op_sget_short", op_sget_short, is_alt)
  write_opcode(103, "op_sput", op_sput, is_alt)
  write_opcode(104, "op_sput_wide", op_sput_wide, is_alt)
  write_opcode(105, "op_sput_object", op_sput_object, is_alt)
  write_opcode(106, "op_sput_boolean", op_sput_boolean, is_alt)
  write_opcode(107, "op_sput_byte", op_sput_byte, is_alt)
  write_opcode(108, "op_sput_char", op_sput_char, is_alt)
  write_opcode(109, "op_sput_short", op_sput_short, is_alt)
  write_opcode(110, "op_invoke_virtual", op_invoke_virtual, is_alt)
  write_opcode(111, "op_invoke_super", op_invoke_super, is_alt)
  write_opcode(112, "op_invoke_direct", op_invoke_direct, is_alt)
  write_opcode(113, "op_invoke_static", op_invoke_static, is_alt)
  write_opcode(114, "op_invoke_interface", op_invoke_interface, is_alt)
  write_opcode(115, "op_return_void_no_barrier", op_return_void_no_barrier, is_alt)
  write_opcode(116, "op_invoke_virtual_range", op_invoke_virtual_range, is_alt)
  write_opcode(117, "op_invoke_super_range", op_invoke_super_range, is_alt)
  write_opcode(118, "op_invoke_direct_range", op_invoke_direct_range, is_alt)
  write_opcode(119, "op_invoke_static_range", op_invoke_static_range, is_alt)
  write_opcode(120, "op_invoke_interface_range", op_invoke_interface_range, is_alt)
  write_opcode(121, "op_unused_79", op_unused_79, is_alt)
  write_opcode(122, "op_unused_7a", op_unused_7a, is_alt)
  write_opcode(123, "op_neg_int", op_neg_int, is_alt)
  write_opcode(124, "op_not_int", op_not_int, is_alt)
  write_opcode(125, "op_neg_long", op_neg_long, is_alt)
  write_opcode(126, "op_not_long", op_not_long, is_alt)
  write_opcode(127, "op_neg_float", op_neg_float, is_alt)
  write_opcode(128, "op_neg_double", op_neg_double, is_alt)
  write_opcode(129, "op_int_to_long", op_int_to_long, is_alt)
  write_opcode(130, "op_int_to_float", op_int_to_float, is_alt)
  write_opcode(131, "op_int_to_double", op_int_to_double, is_alt)
  write_opcode(132, "op_long_to_int", op_long_to_int, is_alt)
  write_opcode(133, "op_long_to_float", op_long_to_float, is_alt)
  write_opcode(134, "op_long_to_double", op_long_to_double, is_alt)
  write_opcode(135, "op_float_to_int", op_float_to_int, is_alt)
  write_opcode(136, "op_float_to_long", op_float_to_long, is_alt)
  write_opcode(137, "op_float_to_double", op_float_to_double, is_alt)
  write_opcode(138, "op_double_to_int", op_double_to_int, is_alt)
  write_opcode(139, "op_double_to_long", op_double_to_long, is_alt)
  write_opcode(140, "op_double_to_float", op_double_to_float, is_alt)
  write_opcode(141, "op_int_to_byte", op_int_to_byte, is_alt)
  write_opcode(142, "op_int_to_char", op_int_to_char, is_alt)
  write_opcode(143, "op_int_to_short", op_int_to_short, is_alt)
  write_opcode(144, "op_add_int", op_add_int, is_alt)
  write_opcode(145, "op_sub_int", op_sub_int, is_alt)
  write_opcode(146, "op_mul_int", op_mul_int, is_alt)
  write_opcode(147, "op_div_int", op_div_int, is_alt)
  write_opcode(148, "op_rem_int", op_rem_int, is_alt)
  write_opcode(149, "op_and_int", op_and_int, is_alt)
  write_opcode(150, "op_or_int", op_or_int, is_alt)
  write_opcode(151, "op_xor_int", op_xor_int, is_alt)
  write_opcode(152, "op_shl_int", op_shl_int, is_alt)
  write_opcode(153, "op_shr_int", op_shr_int, is_alt)
  write_opcode(154, "op_ushr_int", op_ushr_int, is_alt)
  write_opcode(155, "op_add_long", op_add_long, is_alt)
  write_opcode(156, "op_sub_long", op_sub_long, is_alt)
  write_opcode(157, "op_mul_long", op_mul_long, is_alt)
  write_opcode(158, "op_div_long", op_div_long, is_alt)
  write_opcode(159, "op_rem_long", op_rem_long, is_alt)
  write_opcode(160, "op_and_long", op_and_long, is_alt)
  write_opcode(161, "op_or_long", op_or_long, is_alt)
  write_opcode(162, "op_xor_long", op_xor_long, is_alt)
  write_opcode(163, "op_shl_long", op_shl_long, is_alt)
  write_opcode(164, "op_shr_long", op_shr_long, is_alt)
  write_opcode(165, "op_ushr_long", op_ushr_long, is_alt)
  write_opcode(166, "op_add_float", op_add_float, is_alt)
  write_opcode(167, "op_sub_float", op_sub_float, is_alt)
  write_opcode(168, "op_mul_float", op_mul_float, is_alt)
  write_opcode(169, "op_div_float", op_div_float, is_alt)
  write_opcode(170, "op_rem_float", op_rem_float, is_alt)
  write_opcode(171, "op_add_double", op_add_double, is_alt)
  write_opcode(172, "op_sub_double", op_sub_double, is_alt)
  write_opcode(173, "op_mul_double", op_mul_double, is_alt)
  write_opcode(174, "op_div_double", op_div_double, is_alt)
  write_opcode(175, "op_rem_double", op_rem_double, is_alt)
  write_opcode(176, "op_add_int_2addr", op_add_int_2addr, is_alt)
  write_opcode(177, "op_sub_int_2addr", op_sub_int_2addr, is_alt)
  write_opcode(178, "op_mul_int_2addr", op_mul_int_2addr, is_alt)
  write_opcode(179, "op_div_int_2addr", op_div_int_2addr, is_alt)
  write_opcode(180, "op_rem_int_2addr", op_rem_int_2addr, is_alt)
  write_opcode(181, "op_and_int_2addr", op_and_int_2addr, is_alt)
  write_opcode(182, "op_or_int_2addr", op_or_int_2addr, is_alt)
  write_opcode(183, "op_xor_int_2addr", op_xor_int_2addr, is_alt)
  write_opcode(184, "op_shl_int_2addr", op_shl_int_2addr, is_alt)
  write_opcode(185, "op_shr_int_2addr", op_shr_int_2addr, is_alt)
  write_opcode(186, "op_ushr_int_2addr", op_ushr_int_2addr, is_alt)
  write_opcode(187, "op_add_long_2addr", op_add_long_2addr, is_alt)
  write_opcode(188, "op_sub_long_2addr", op_sub_long_2addr, is_alt)
  write_opcode(189, "op_mul_long_2addr", op_mul_long_2addr, is_alt)
  write_opcode(190, "op_div_long_2addr", op_div_long_2addr, is_alt)
  write_opcode(191, "op_rem_long_2addr", op_rem_long_2addr, is_alt)
  write_opcode(192, "op_and_long_2addr", op_and_long_2addr, is_alt)
  write_opcode(193, "op_or_long_2addr", op_or_long_2addr, is_alt)
  write_opcode(194, "op_xor_long_2addr", op_xor_long_2addr, is_alt)
  write_opcode(195, "op_shl_long_2addr", op_shl_long_2addr, is_alt)
  write_opcode(196, "op_shr_long_2addr", op_shr_long_2addr, is_alt)
  write_opcode(197, "op_ushr_long_2addr", op_ushr_long_2addr, is_alt)
  write_opcode(198, "op_add_float_2addr", op_add_float_2addr, is_alt)
  write_opcode(199, "op_sub_float_2addr", op_sub_float_2addr, is_alt)
  write_opcode(200, "op_mul_float_2addr", op_mul_float_2addr, is_alt)
  write_opcode(201, "op_div_float_2addr", op_div_float_2addr, is_alt)
  write_opcode(202, "op_rem_float_2addr", op_rem_float_2addr, is_alt)
  write_opcode(203, "op_add_double_2addr", op_add_double_2addr, is_alt)
  write_opcode(204, "op_sub_double_2addr", op_sub_double_2addr, is_alt)
  write_opcode(205, "op_mul_double_2addr", op_mul_double_2addr, is_alt)
  write_opcode(206, "op_div_double_2addr", op_div_double_2addr, is_alt)
  write_opcode(207, "op_rem_double_2addr", op_rem_double_2addr, is_alt)
  write_opcode(208, "op_add_int_lit16", op_add_int_lit16, is_alt)
  write_opcode(209, "op_rsub_int", op_rsub_int, is_alt)
  write_opcode(210, "op_mul_int_lit16", op_mul_int_lit16, is_alt)
  write_opcode(211, "op_div_int_lit16", op_div_int_lit16, is_alt)
  write_opcode(212, "op_rem_int_lit16", op_rem_int_lit16, is_alt)
  write_opcode(213, "op_and_int_lit16", op_and_int_lit16, is_alt)
  write_opcode(214, "op_or_int_lit16", op_or_int_lit16, is_alt)
  write_opcode(215, "op_xor_int_lit16", op_xor_int_lit16, is_alt)
  write_opcode(216, "op_add_int_lit8", op_add_int_lit8, is_alt)
  write_opcode(217, "op_rsub_int_lit8", op_rsub_int_lit8, is_alt)
  write_opcode(218, "op_mul_int_lit8", op_mul_int_lit8, is_alt)
  write_opcode(219, "op_div_int_lit8", op_div_int_lit8, is_alt)
  write_opcode(220, "op_rem_int_lit8", op_rem_int_lit8, is_alt)
  write_opcode(221, "op_and_int_lit8", op_and_int_lit8, is_alt)
  write_opcode(222, "op_or_int_lit8", op_or_int_lit8, is_alt)
  write_opcode(223, "op_xor_int_lit8", op_xor_int_lit8, is_alt)
  write_opcode(224, "op_shl_int_lit8", op_shl_int_lit8, is_alt)
  write_opcode(225, "op_shr_int_lit8", op_shr_int_lit8, is_alt)
  write_opcode(226, "op_ushr_int_lit8", op_ushr_int_lit8, is_alt)
  write_opcode(227, "op_iget_quick", op_iget_quick, is_alt)
  write_opcode(228, "op_iget_wide_quick", op_iget_wide_quick, is_alt)
  write_opcode(229, "op_iget_object_quick", op_iget_object_quick, is_alt)
  write_opcode(230, "op_iput_quick", op_iput_quick, is_alt)
  write_opcode(231, "op_iput_wide_quick", op_iput_wide_quick, is_alt)
  write_opcode(232, "op_iput_object_quick", op_iput_object_quick, is_alt)
  write_opcode(233, "op_invoke_virtual_quick", op_invoke_virtual_quick, is_alt)
  write_opcode(234, "op_invoke_virtual_range_quick", op_invoke_virtual_range_quick, is_alt)
  write_opcode(235, "op_iput_boolean_quick", op_iput_boolean_quick, is_alt)
  write_opcode(236, "op_iput_byte_quick", op_iput_byte_quick, is_alt)
  write_opcode(237, "op_iput_char_quick", op_iput_char_quick, is_alt)
  write_opcode(238, "op_iput_short_quick", op_iput_short_quick, is_alt)
  write_opcode(239, "op_iget_boolean_quick", op_iget_boolean_quick, is_alt)
  write_opcode(240, "op_iget_byte_quick", op_iget_byte_quick, is_alt)
  write_opcode(241, "op_iget_char_quick", op_iget_char_quick, is_alt)
  write_opcode(242, "op_iget_short_quick", op_iget_short_quick, is_alt)
  write_opcode(243, "op_unused_f3", op_unused_f3, is_alt)
  write_opcode(244, "op_unused_f4", op_unused_f4, is_alt)
  write_opcode(245, "op_unused_f5", op_unused_f5, is_alt)
  write_opcode(246, "op_unused_f6", op_unused_f6, is_alt)
  write_opcode(247, "op_unused_f7", op_unused_f7, is_alt)
  write_opcode(248, "op_unused_f8", op_unused_f8, is_alt)
  write_opcode(249, "op_unused_f9", op_unused_f9, is_alt)
  write_opcode(250, "op_invoke_polymorphic", op_invoke_polymorphic, is_alt)
  write_opcode(251, "op_invoke_polymorphic_range", op_invoke_polymorphic_range, is_alt)
  write_opcode(252, "op_invoke_custom", op_invoke_custom, is_alt)
  write_opcode(253, "op_invoke_custom_range", op_invoke_custom_range, is_alt)
  write_opcode(254, "op_const_method_handle", op_const_method_handle, is_alt)
  write_opcode(255, "op_const_method_type", op_const_method_type, is_alt)
def write_sister():
  global opnum, opcode
  pass
def alt_stub():
  write_line('''/*''')
  write_line(''' * Inter-instruction transfer stub.  Call out to MterpCheckBefore to handle''')
  write_line(''' * any interesting requests and then jump to the real instruction''')
  write_line(''' * handler.  Unlike the Arm handler, we can't do this as a tail call''')
  write_line(''' * because rIBASE is caller save and we need to reload it.''')
  write_line(''' *''')
  write_line(''' * Note that unlike in the Arm implementation, we should never arrive''')
  write_line(''' * here with a zero breakFlag because we always refresh rIBASE on''')
  write_line(''' * return.''')
  write_line(''' */''')
  write_line('''    .extern MterpCheckBefore''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movq    rPC, OUT_ARG2''')
  write_line('''    call    SYMBOL(MterpCheckBefore)        # (self, shadow_frame, dex_pc_ptr)''')
  write_line('''    jmp     .L_op_nop+(''' + opnum + '''*''' + handler_size_bytes + ''')''')

def bincmp(revcmp=""):
  write_line('''/*''')
  write_line(''' * Generic two-operand compare-and-branch operation.  Provide a "revcmp"''')
  write_line(''' * fragment that specifies the *reverse* comparison to perform, e.g.''')
  write_line(''' * for "if-le" you would use "gt".''')
  write_line(''' *''')
  write_line(''' * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le''')
  write_line(''' */''')
  write_line('''    /* if-cmp vA, vB, +CCCC */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # rcx <- A''')
  write_line('''    GET_VREG %eax, %rcx                     # eax <- vA''')
  write_line('''    cmpl    VREG_ADDRESS(rINSTq), %eax      # compare (vA, vB)''')
  write_line('''    j''' + revcmp + '''   1f''')
  write_line('''    movswq  2(rPC), rINSTq                  # Get signed branch offset''')
  write_line('''    testq   rINSTq, rINSTq''')
  write_line('''    jmp     MterpCommonTakenBranch''')
  write_line('''1:''')
  write_line('''    cmpl    $JIT_CHECK_OSR, rPROFILE''')
  write_line('''    je      .L_check_not_taken_osr''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def bindiv(result="", second="", wide="", suffix="", rem="0", ext="cdq"):
  write_line('''/*''')
  write_line(''' * 32-bit binary div/rem operation.  Handles special case of op1=-1.''')
  write_line(''' */''')
  write_line('''    /* div/rem vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rax                    # rax <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # rcx <- CC''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    GET_WIDE_VREG %rax, %rax                # eax <- vBB''')
  write_line('''    GET_WIDE_VREG ''' + second + ''', %rcx             # ecx <- vCC''')
  write_line('''    .else''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- vBB''')
  write_line('''    GET_VREG ''' + second + ''', %rcx                  # ecx <- vCC''')
  write_line('''    .endif''')
  write_line('''    test''' + suffix + '''   ''' + second + ''', ''' + second + '''''')
  write_line('''    jz      common_errDivideByZero''')
  write_line('''    cmp''' + suffix + '''  $-1, ''' + second + '''''')
  write_line('''    je      2f''')
  write_line('''    ''' + ext + '''                                    # rdx:rax <- sign-extended of rax''')
  write_line('''    idiv''' + suffix + '''   ''' + second + '''''')
  write_line('''1:''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    SET_WIDE_VREG ''' + result + ''', rINSTq           # eax <- vBB''')
  write_line('''    .else''')
  write_line('''    SET_VREG ''' + result + ''', rINSTq                # eax <- vBB''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''2:''')
  write_line('''    .if ''' + rem + '''''')
  write_line('''    xor''' + suffix + ''' ''' + result + ''', ''' + result + '''''')
  write_line('''    .else''')
  write_line('''    neg''' + suffix + ''' ''' + result + '''''')
  write_line('''    .endif''')
  write_line('''    jmp     1b''')

def bindiv2addr(result="", second="", wide="", suffix="", rem="0", ext="cdq"):
  write_line('''/*''')
  write_line(''' * 32-bit binary div/rem operation.  Handles special case of op1=-1.''')
  write_line(''' */''')
  write_line('''    /* div/rem/2addr vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- BA''')
  write_line('''    sarl    $4, %ecx                       # rcx <- B''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    GET_WIDE_VREG %rax, rINSTq              # eax <- vA''')
  write_line('''    GET_WIDE_VREG ''' + second + ''', %rcx             # ecx <- vB''')
  write_line('''    .else''')
  write_line('''    GET_VREG %eax, rINSTq                   # eax <- vA''')
  write_line('''    GET_VREG ''' + second + ''', %rcx                  # ecx <- vB''')
  write_line('''    .endif''')
  write_line('''    test''' + suffix + '''   ''' + second + ''', ''' + second + '''''')
  write_line('''    jz      common_errDivideByZero''')
  write_line('''    cmp''' + suffix + '''  $-1, ''' + second + '''''')
  write_line('''    je      2f''')
  write_line('''    ''' + ext + '''                                    # rdx:rax <- sign-extended of rax''')
  write_line('''    idiv''' + suffix + '''   ''' + second + '''''')
  write_line('''1:''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    SET_WIDE_VREG ''' + result + ''', rINSTq           # vA <- result''')
  write_line('''    .else''')
  write_line('''    SET_VREG ''' + result + ''', rINSTq                # vA <- result''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')
  write_line('''2:''')
  write_line('''    .if ''' + rem + '''''')
  write_line('''    xor''' + suffix + ''' ''' + result + ''', ''' + result + '''''')
  write_line('''    .else''')
  write_line('''    neg''' + suffix + ''' ''' + result + '''''')
  write_line('''    .endif''')
  write_line('''    jmp     1b''')

def bindivLit16(result="", rem="0"):
  write_line('''/*''')
  write_line(''' * 32-bit binary div/rem operation.  Handles special case of op1=-1.''')
  write_line(''' */''')
  write_line('''    /* div/rem/lit16 vA, vB, #+CCCC */''')
  write_line('''    /* Need A in rINST, ssssCCCC in ecx, vB in eax */''')
  write_line('''    movl    rINST, %eax                     # rax <- 000000BA''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- vB''')
  write_line('''    movswl  2(rPC), %ecx                    # ecx <- ssssCCCC''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    testl   %ecx, %ecx''')
  write_line('''    jz      common_errDivideByZero''')
  write_line('''    cmpl    $-1, %ecx''')
  write_line('''    je      2f''')
  write_line('''    cdq                                     # rax <- sign-extended of eax''')
  write_line('''    idivl   %ecx''')
  write_line('''1:''')
  write_line('''    SET_VREG ''' + result + ''', rINSTq                # vA <- result''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''2:''')
  write_line('''    .if ''' + rem + '''''')
  write_line('''    xorl    ''' + result + ''', ''' + result + '''''')
  write_line('''    .else''')
  write_line('''    negl    ''' + result + '''''')
  write_line('''    .endif''')
  write_line('''    jmp     1b''')

def bindivLit8(result="", rem="0"):
  write_line('''/*''')
  write_line(''' * 32-bit div/rem "lit8" binary operation.  Handles special case of''')
  write_line(''' * op0=minint & op1=-1''')
  write_line(''' */''')
  write_line('''    /* div/rem/lit8 vAA, vBB, #+CC */''')
  write_line('''    movzbq  2(rPC), %rax                    # eax <- BB''')
  write_line('''    movsbl  3(rPC), %ecx                    # ecx <- ssssssCC''')
  write_line('''    GET_VREG  %eax, %rax                    # eax <- rBB''')
  write_line('''    testl   %ecx, %ecx''')
  write_line('''    je      common_errDivideByZero''')
  write_line('''    cmpl    $-1, %ecx''')
  write_line('''    je      2f''')
  write_line('''    cdq                                     # rax <- sign-extended of eax''')
  write_line('''    idivl   %ecx''')
  write_line('''1:''')
  write_line('''    SET_VREG ''' + result + ''', rINSTq                # vA <- result''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''2:''')
  write_line('''    .if ''' + rem + '''''')
  write_line('''    xorl    ''' + result + ''', ''' + result + '''''')
  write_line('''    .else''')
  write_line('''    negl    ''' + result + '''''')
  write_line('''    .endif''')
  write_line('''    jmp     1b''')

def binop(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit binary operation.  Provide an "instr" line that''')
  write_line(''' * specifies an instruction that performs "result = eax op (rFP,%ecx,4)".''')
  write_line(''' * This could be an x86 instruction or a function call.  (If the result''')
  write_line(''' * comes back in a register other than eax, you can override "result".)''')
  write_line(''' *''')
  write_line(''' * For: add-int, sub-int, and-int, or-int,''')
  write_line(''' *      xor-int, shl-int, shr-int, ushr-int''')
  write_line(''' */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rax                    # rax <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # rcx <- CC''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- vBB''')
  write_line('''    ''' + instr + '''                                  # ex: addl    (rFP,%rcx,4),%eax''')
  write_line('''    SET_VREG ''' + result + ''', rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binop1(wide="0", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit binary operation in which both operands loaded to''')
  write_line(''' * registers (op0 in eax, op1 in ecx).''')
  write_line(''' */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rax                    # eax <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # ecx <- CC''')
  write_line('''    GET_VREG %ecx, %rcx                     # eax <- vCC''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    GET_WIDE_VREG %rax, %rax                # rax <- vBB''')
  write_line('''    ''' + instr + '''                                  # ex: addl    %ecx,%eax''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq''')
  write_line('''    .else''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- vBB''')
  write_line('''    ''' + instr + '''                                  # ex: addl    %ecx,%eax''')
  write_line('''    SET_VREG %eax, rINSTq''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binop2addr(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line(''' * that specifies an instruction that performs "result = r0 op r1".''')
  write_line(''' * This could be an instruction or a function call.''')
  write_line(''' *''')
  write_line(''' * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,''')
  write_line(''' *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,''')
  write_line(''' *      shl-int/2addr, shr-int/2addr, ushr-int/2addr, add-float/2addr,''')
  write_line(''' *      sub-float/2addr, mul-float/2addr, div-float/2addr, rem-float/2addr''')
  write_line(''' */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    GET_VREG %eax, rINSTq                   # eax <- vB''')
  write_line('''    ''' + instr + '''                                  # for ex: addl   %eax,(rFP,%ecx,4)''')
  write_line('''    CLEAR_REF %rcx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def binopLit16(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "lit16" binary operation.  Provide an "instr" line''')
  write_line(''' * that specifies an instruction that performs "result = eax op ecx".''')
  write_line(''' * This could be an x86 instruction or a function call.  (If the result''')
  write_line(''' * comes back in a register other than eax, you can override "result".)''')
  write_line(''' *''')
  write_line(''' * For: add-int/lit16, rsub-int,''')
  write_line(''' *      and-int/lit16, or-int/lit16, xor-int/lit16''')
  write_line(''' */''')
  write_line('''    /* binop/lit16 vA, vB, #+CCCC */''')
  write_line('''    movl    rINST, %eax                     # rax <- 000000BA''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- vB''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    movswl  2(rPC), %ecx                    # ecx <- ssssCCCC''')
  write_line('''    ''' + instr + '''                                  # for example: addl %ecx, %eax''')
  write_line('''    SET_VREG ''' + result + ''', rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binopLit8(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "lit8" binary operation.  Provide an "instr" line''')
  write_line(''' * that specifies an instruction that performs "result = eax op ecx".''')
  write_line(''' * This could be an x86 instruction or a function call.  (If the result''')
  write_line(''' * comes back in a register other than r0, you can override "result".)''')
  write_line(''' *''')
  write_line(''' * For: add-int/lit8, rsub-int/lit8''')
  write_line(''' *      and-int/lit8, or-int/lit8, xor-int/lit8,''')
  write_line(''' *      shl-int/lit8, shr-int/lit8, ushr-int/lit8''')
  write_line(''' */''')
  write_line('''    /* binop/lit8 vAA, vBB, #+CC */''')
  write_line('''    movzbq  2(rPC), %rax                    # rax <- BB''')
  write_line('''    movsbl  3(rPC), %ecx                    # rcx <- ssssssCC''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- rBB''')
  write_line('''    ''' + instr + '''                                  # ex: addl %ecx,%eax''')
  write_line('''    SET_VREG ''' + result + ''', rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binopWide(instr=""):
  write_line('''/*''')
  write_line(''' * Generic 64-bit binary operation.''')
  write_line(''' */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rax                    # eax <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # ecx <- CC''')
  write_line('''    GET_WIDE_VREG %rax, %rax                # rax <- v[BB]''')
  write_line('''    ''' + instr + '''                                  # ex: addq   (rFP,%rcx,4),%rax''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq              # v[AA] <- rax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binopWide2addr(instr=""):
  write_line('''/*''')
  write_line(''' * Generic 64-bit binary operation.''')
  write_line(''' */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    GET_WIDE_VREG %rax, rINSTq              # rax <- vB''')
  write_line('''    ''' + instr + '''                                  # for ex: addq   %rax,(rFP,%rcx,4)''')
  write_line('''    CLEAR_WIDE_REF %rcx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def const(helper="UndefinedConstHandler"):
  write_line('''    /* const/class vAA, type@BBBB */''')
  write_line('''    /* const/method-handle vAA, method_handle@BBBB */''')
  write_line('''    /* const/method-type vAA, proto@BBBB */''')
  write_line('''    /* const/string vAA, string@@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    movzwq  2(rPC), OUT_ARG0                # eax <- OUT_ARG0''')
  write_line('''    movq    rINSTq, OUT_ARG1''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG2''')
  write_line('''    movq    rSELF, OUT_ARG3''')
  write_line('''    call    SYMBOL(''' + helper + ''')                 # (index, tgt_reg, shadow_frame, self)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def cvtfp_int(fp_suffix="", i_suffix="", max_const="", result_reg="", wide=""):
  write_line('''/* On fp to int conversions, Java requires that''')
  write_line(''' * if the result > maxint, it should be clamped to maxint.  If it is less''')
  write_line(''' * than minint, it should be clamped to minint.  If it is a nan, the result''')
  write_line(''' * should be zero.  Further, the rounding mode is to truncate.''')
  write_line(''' */''')
  write_line('''    /* float/double to int/long vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    movs''' + fp_suffix + '''   VREG_ADDRESS(rINSTq), %xmm0''')
  write_line('''    mov''' + i_suffix + '''  ''' + max_const + ''', ''' + result_reg + '''''')
  write_line('''    cvtsi2s''' + fp_suffix + '''''' + i_suffix + ''' ''' + result_reg + ''', %xmm1''')
  write_line('''    comis''' + fp_suffix + '''    %xmm1, %xmm0''')
  write_line('''    jae     1f''')
  write_line('''    jp      2f''')
  write_line('''    cvtts''' + fp_suffix + '''2si''' + i_suffix + '''  %xmm0, ''' + result_reg + '''''')
  write_line('''    jmp     1f''')
  write_line('''2:''')
  write_line('''    xor''' + i_suffix + '''    ''' + result_reg + ''', ''' + result_reg + '''''')
  write_line('''1:''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    SET_WIDE_VREG ''' + result_reg + ''', %rcx''')
  write_line('''    .else''')
  write_line('''    SET_VREG ''' + result_reg + ''', %rcx''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def entry():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''/*''')
  write_line(''' * Interpreter entry point.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    ASM_HIDDEN SYMBOL(ExecuteMterpImpl)''')
  write_line('''    .global SYMBOL(ExecuteMterpImpl)''')
  write_line('''    FUNCTION_TYPE(ExecuteMterpImpl)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On entry:''')
  write_line(''' *  0  Thread* self''')
  write_line(''' *  1  insns_''')
  write_line(''' *  2  ShadowFrame''')
  write_line(''' *  3  JValue* result_register''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''''')
  write_line('''SYMBOL(ExecuteMterpImpl):''')
  write_line('''    .cfi_startproc''')
  write_line('''    .cfi_def_cfa rsp, 8''')
  write_line('''''')
  write_line('''    /* Spill callee save regs */''')
  write_line('''    PUSH %rbx''')
  write_line('''    PUSH %rbp''')
  write_line('''    PUSH %r12''')
  write_line('''    PUSH %r13''')
  write_line('''    PUSH %r14''')
  write_line('''    PUSH %r15''')
  write_line('''''')
  write_line('''    /* Allocate frame */''')
  write_line('''    subq    $FRAME_SIZE, %rsp''')
  write_line('''    .cfi_adjust_cfa_offset FRAME_SIZE''')
  write_line('''''')
  write_line('''    /* Remember the return register */''')
  write_line('''    movq    IN_ARG3, SHADOWFRAME_RESULT_REGISTER_OFFSET(IN_ARG2)''')
  write_line('''''')
  write_line('''    /* Remember the code_item */''')
  write_line('''    movq    IN_ARG1, SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET(IN_ARG2)''')
  write_line('''''')
  write_line('''    /* set up "named" registers */''')
  write_line('''    movl    SHADOWFRAME_NUMBER_OF_VREGS_OFFSET(IN_ARG2), %eax''')
  write_line('''    leaq    SHADOWFRAME_VREGS_OFFSET(IN_ARG2), rFP''')
  write_line('''    leaq    (rFP, %rax, 4), rREFS''')
  write_line('''    movl    SHADOWFRAME_DEX_PC_OFFSET(IN_ARG2), %eax''')
  write_line('''    leaq    (IN_ARG1, %rax, 2), rPC''')
  write_line('''    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)''')
  write_line('''    EXPORT_PC''')
  write_line('''''')
  write_line('''    /* Starting ibase */''')
  write_line('''    movq    IN_ARG0, rSELF''')
  write_line('''    REFRESH_IBASE_REG IN_ARG0''')
  write_line('''''')
  write_line('''    /* Set up for backwards branches & osr profiling */''')
  write_line('''    movq    IN_ARG0, OUT_ARG2  /* Set up OUT_ARG2 before clobbering IN_ARG0 */''')
  write_line('''    movq    OFF_FP_METHOD(rFP), OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpSetUpHotnessCountdown)''')
  write_line('''    movswl  %ax, rPROFILE''')
  write_line('''''')
  write_line('''    /* start executing the instruction at rPC */''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''    /* NOTE: no fallthrough */''')

def fallback():
  write_line('''/* Transfer stub to alternate interpreter */''')
  write_line('''    jmp     MterpFallback''')
  write_line('''''')

def field(helper=""):
  write_line('''    /*''')
  write_line('''     * General field read / write (iget-* iput-* sget-* sput-*).''')
  write_line('''     */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    REFRESH_INST ''' + opnum + '''                      # fix rINST to include opcode''')
  write_line('''    movq    rPC, OUT_ARG0                      # arg0: Instruction* inst''')
  write_line('''    movl    rINST, OUT_32_ARG1                 # arg1: uint16_t inst_data''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG2  # arg2: ShadowFrame* sf''')
  write_line('''    movq    rSELF, OUT_ARG3                    # arg3: Thread* self''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def footer():
  write_line('''/*''')
  write_line(''' * ===========================================================================''')
  write_line(''' *  Common subroutines and data''')
  write_line(''' * ===========================================================================''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    .align  2''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We've detected a condition that will result in an exception, but the exception''')
  write_line(''' * has not yet been thrown.  Just bail out to the reference interpreter to deal with it.''')
  write_line(''' * TUNING: for consistency, we may want to just go ahead and handle these here.''')
  write_line(''' */''')
  write_line('''common_errDivideByZero:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpLogDivideByZeroException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errArrayIndex:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpLogArrayIndexException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNegativeArraySize:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpLogNegativeArraySizeException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNoSuchMethod:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpLogNoSuchMethodException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNullObject:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpLogNullObjectException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_exceptionThrown:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpLogExceptionThrownException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''MterpSuspendFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movl    THREAD_FLAGS_OFFSET(OUT_ARG0), OUT_32_ARG2''')
  write_line('''    call    SYMBOL(MterpLogSuspendFallback)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * If we're here, something is out of the ordinary.  If there is a pending''')
  write_line(''' * exception, handle it.  Otherwise, roll back and retry with the reference''')
  write_line(''' * interpreter.''')
  write_line(''' */''')
  write_line('''MterpPossibleException:''')
  write_line('''    movq    rSELF, %rcx''')
  write_line('''    cmpq    $0, THREAD_EXCEPTION_OFFSET(%rcx)''')
  write_line('''    jz      MterpFallback''')
  write_line('''    /* intentional fallthrough - handle pending exception. */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On return from a runtime helper routine, we've found a pending exception.''')
  write_line(''' * Can we handle it here - or need to bail out to caller?''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpException:''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpHandleException)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpExceptionReturn''')
  write_line('''    movq    OFF_FP_DEX_INSTRUCTIONS(rFP), %rax''')
  write_line('''    mov     OFF_FP_DEX_PC(rFP), %ecx''')
  write_line('''    leaq    (%rax, %rcx, 2), rPC''')
  write_line('''    movq    rPC, OFF_FP_DEX_PC_PTR(rFP)''')
  write_line('''    /* Do we need to switch interpreters? */''')
  write_line('''    call    SYMBOL(MterpShouldSwitchInterpreters)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    /* resume execution at catch block */''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''    /* NOTE: no fallthrough */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Common handling for branches with support for Jit profiling.''')
  write_line(''' * On entry:''')
  write_line(''' *    rINST          <= signed offset''')
  write_line(''' *    rPROFILE       <= signed hotness countdown (expanded to 32 bits)''')
  write_line(''' *    condition bits <= set to establish sign of offset (use "NoFlags" entry if not)''')
  write_line(''' *''')
  write_line(''' * We have quite a few different cases for branch profiling, OSR detection and''')
  write_line(''' * suspend check support here.''')
  write_line(''' *''')
  write_line(''' * Taken backward branches:''')
  write_line(''' *    If profiling active, do hotness countdown and report if we hit zero.''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *    Is there a pending suspend request?  If so, suspend.''')
  write_line(''' *''')
  write_line(''' * Taken forward branches and not-taken backward branches:''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *''')
  write_line(''' * Our most common case is expected to be a taken backward branch with active jit profiling,''')
  write_line(''' * but no full OSR check and no pending suspend request.''')
  write_line(''' * Next most common case is not-taken branch with no full OSR check.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpCommonTakenBranch:''')
  write_line('''    jg      .L_forward_branch               # don't add forward branches to hotness''')
  write_line('''/*''')
  write_line(''' * We need to subtract 1 from positive values and we should not see 0 here,''')
  write_line(''' * so we may use the result of the comparison with -1.''')
  write_line(''' */''')
  write_line('''#if JIT_CHECK_OSR != -1''')
  write_line('''#  error "JIT_CHECK_OSR must be -1."''')
  write_line('''#endif''')
  write_line('''    cmpl    $JIT_CHECK_OSR, rPROFILE''')
  write_line('''    je      .L_osr_check''')
  write_line('''    decl    rPROFILE''')
  write_line('''    je      .L_add_batch                    # counted down to zero - report''')
  write_line('''.L_resume_backward_branch:''')
  write_line('''    movq    rSELF, %rax''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(%rax)''')
  write_line('''    REFRESH_IBASE_REG %rax''')
  write_line('''    leaq    (rPC, rINSTq, 2), rPC''')
  write_line('''    FETCH_INST''')
  write_line('''    jnz     .L_suspend_request_pending''')
  write_line('''    GOTO_NEXT''')
  write_line('''''')
  write_line('''.L_suspend_request_pending:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)       # (self)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    REFRESH_IBASE                           # might have changed during suspend''')
  write_line('''    GOTO_NEXT''')
  write_line('''''')
  write_line('''.L_no_count_backwards:''')
  write_line('''    cmpl    $JIT_CHECK_OSR, rPROFILE         # possible OSR re-entry?''')
  write_line('''    jne     .L_resume_backward_branch''')
  write_line('''.L_osr_check:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movq    rINSTq, OUT_ARG2''')
  write_line('''    call    SYMBOL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      .L_resume_backward_branch''')
  write_line('''    jmp     MterpOnStackReplacement''')
  write_line('''''')
  write_line('''.L_forward_branch:''')
  write_line('''    cmpl    $JIT_CHECK_OSR, rPROFILE         # possible OSR re-entry?''')
  write_line('''    je      .L_check_osr_forward''')
  write_line('''.L_resume_forward_branch:''')
  write_line('''    leaq    (rPC, rINSTq, 2), rPC''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''''')
  write_line('''.L_check_osr_forward:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movq    rINSTq, OUT_ARG2''')
  write_line('''    call    SYMBOL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      .L_resume_forward_branch''')
  write_line('''    jmp     MterpOnStackReplacement''')
  write_line('''''')
  write_line('''.L_add_batch:''')
  write_line('''    movl    rPROFILE, %eax''')
  write_line('''    movq    OFF_FP_METHOD(rFP), OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movw    %ax, OFF_FP_COUNTDOWN_OFFSET(rFP)''')
  write_line('''    movq    rSELF, OUT_ARG2''')
  write_line('''    call    SYMBOL(MterpAddHotnessBatch)    # (method, shadow_frame, self)''')
  write_line('''    movswl  %ax, rPROFILE''')
  write_line('''    jmp     .L_no_count_backwards''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Entered from the conditional branch handlers when OSR check request active on''')
  write_line(''' * not-taken path.  All Dalvik not-taken conditional branch offsets are 2.''')
  write_line(''' */''')
  write_line('''.L_check_not_taken_osr:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movl    $2, OUT_32_ARG2''')
  write_line('''    call    SYMBOL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpOnStackReplacement''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On-stack replacement has happened, and now we've returned from the compiled method.''')
  write_line(''' */''')
  write_line('''MterpOnStackReplacement:''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movl    rINST, OUT_32_ARG2''')
  write_line('''    call    SYMBOL(MterpLogOSR)''')
  write_line('''#endif''')
  write_line('''    movl    $1, %eax''')
  write_line('''    jmp     MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Bail out to reference interpreter.''')
  write_line(''' */''')
  write_line('''MterpFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    call    SYMBOL(MterpLogFallback)''')
  write_line('''#endif''')
  write_line('''MterpCommonFallback:''')
  write_line('''    xorl    %eax, %eax''')
  write_line('''    jmp     MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On entry:''')
  write_line(''' *  uint32_t* rFP  (should still be live, pointer to base of vregs)''')
  write_line(''' */''')
  write_line('''MterpExceptionReturn:''')
  write_line('''    movl    $1, %eax''')
  write_line('''    jmp     MterpDone''')
  write_line('''MterpReturn:''')
  write_line('''    movq    OFF_FP_RESULT_REGISTER(rFP), %rdx''')
  write_line('''    movq    %rax, (%rdx)''')
  write_line('''    movl    $1, %eax''')
  write_line('''MterpDone:''')
  write_line('''/*''')
  write_line(''' * At this point, we expect rPROFILE to be non-zero.  If negative, hotness is disabled or we're''')
  write_line(''' * checking for OSR.  If greater than zero, we might have unreported hotness to register''')
  write_line(''' * (the difference between the ending rPROFILE and the cached hotness counter).  rPROFILE''')
  write_line(''' * should only reach zero immediately after a hotness decrement, and is then reset to either''')
  write_line(''' * a negative special state or the new non-zero countdown value.''')
  write_line(''' */''')
  write_line('''    testl   rPROFILE, rPROFILE''')
  write_line('''    jle     MRestoreFrame                   # if > 0, we may have some counts to report.''')
  write_line('''''')
  write_line('''    movl    %eax, rINST                     # stash return value''')
  write_line('''    /* Report cached hotness counts */''')
  write_line('''    movl    rPROFILE, %eax''')
  write_line('''    movq    OFF_FP_METHOD(rFP), OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movw    %ax, OFF_FP_COUNTDOWN_OFFSET(rFP)''')
  write_line('''    movq    rSELF, OUT_ARG2''')
  write_line('''    call    SYMBOL(MterpAddHotnessBatch)    # (method, shadow_frame, self)''')
  write_line('''    movl    rINST, %eax                     # restore return value''')
  write_line('''''')
  write_line('''    /* pop up frame */''')
  write_line('''MRestoreFrame:''')
  write_line('''    addq    $FRAME_SIZE, %rsp''')
  write_line('''    .cfi_adjust_cfa_offset -FRAME_SIZE''')
  write_line('''''')
  write_line('''    /* Restore callee save register */''')
  write_line('''    POP %r15''')
  write_line('''    POP %r14''')
  write_line('''    POP %r13''')
  write_line('''    POP %r12''')
  write_line('''    POP %rbp''')
  write_line('''    POP %rbx''')
  write_line('''    ret''')
  write_line('''    .cfi_endproc''')
  write_line('''    SIZE(ExecuteMterpImpl,ExecuteMterpImpl)''')

def fpcmp(suff="d", nanval="pos"):
  write_line('''/*''')
  write_line(''' * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line(''' * destination register based on the results of the comparison.''')
  write_line(''' *''')
  write_line(''' * int compare(x, y) {''')
  write_line(''' *     if (x == y) {''')
  write_line(''' *         return 0;''')
  write_line(''' *     } else if (x < y) {''')
  write_line(''' *         return -1;''')
  write_line(''' *     } else if (x > y) {''')
  write_line(''' *         return 1;''')
  write_line(''' *     } else {''')
  write_line(''' *         return nanval ? 1 : -1;''')
  write_line(''' *     }''')
  write_line(''' * }''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbq  3(rPC), %rcx                    # ecx<- CC''')
  write_line('''    movzbq  2(rPC), %rax                    # eax<- BB''')
  write_line('''    movs''' + suff + ''' VREG_ADDRESS(%rax), %xmm0''')
  write_line('''    xor     %eax, %eax''')
  write_line('''    ucomis''' + suff + ''' VREG_ADDRESS(%rcx), %xmm0''')
  write_line('''    jp      .L''' + opcode + '''_nan_is_''' + nanval + '''''')
  write_line('''    je      .L''' + opcode + '''_finish''')
  write_line('''    jb      .L''' + opcode + '''_less''')
  write_line('''.L''' + opcode + '''_nan_is_pos:''')
  write_line('''    addb    $1, %al''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')
  write_line('''.L''' + opcode + '''_nan_is_neg:''')
  write_line('''.L''' + opcode + '''_less:''')
  write_line('''    movl    $-1, %eax''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG %eax, rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def fpcvt(source_suffix="", dest_suffix="", wide=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit FP conversion operation.''')
  write_line(''' */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    cvts''' + source_suffix + '''2s''' + dest_suffix + '''    VREG_ADDRESS(rINSTq), %xmm0''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    movsd   %xmm0, VREG_ADDRESS(%rcx)''')
  write_line('''    CLEAR_WIDE_REF %rcx''')
  write_line('''    .else''')
  write_line('''    movss   %xmm0, VREG_ADDRESS(%rcx)''')
  write_line('''    CLEAR_REF %rcx''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def header():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''  Art assembly interpreter notes:''')
  write_line('''''')
  write_line('''  First validate assembly code by implementing ExecuteXXXImpl() style body (doesn't''')
  write_line('''  handle invoke, allows higher-level code to create frame & shadow frame.''')
  write_line('''''')
  write_line('''  Once that's working, support direct entry code & eliminate shadow frame (and''')
  write_line('''  excess locals allocation.''')
  write_line('''''')
  write_line('''  Some (hopefully) temporary ugliness.  We'll treat rFP as pointing to the''')
  write_line('''  base of the vreg array within the shadow frame.  Access the other fields,''')
  write_line('''  dex_pc_, method_ and number_of_vregs_ via negative offsets.  For now, we'll continue''')
  write_line('''  the shadow frame mechanism of double-storing object references - via rFP &''')
  write_line('''  number_of_vregs_.''')
  write_line('''''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''x86_64 ABI general notes:''')
  write_line('''''')
  write_line('''Caller save set:''')
  write_line('''   rax, rdx, rcx, rsi, rdi, r8-r11, st(0)-st(7)''')
  write_line('''Callee save set:''')
  write_line('''   rbx, rbp, r12-r15''')
  write_line('''Return regs:''')
  write_line('''   32-bit in eax''')
  write_line('''   64-bit in rax''')
  write_line('''   fp on xmm0''')
  write_line('''''')
  write_line('''First 8 fp parameters came in xmm0-xmm7.''')
  write_line('''First 6 non-fp parameters came in rdi, rsi, rdx, rcx, r8, r9.''')
  write_line('''Other parameters passed on stack, pushed right-to-left.  On entry to target, first''')
  write_line('''param is at 8(%esp).  Traditional entry code is:''')
  write_line('''''')
  write_line('''Stack must be 16-byte aligned to support SSE in native code.''')
  write_line('''''')
  write_line('''If we're not doing variable stack allocation (alloca), the frame pointer can be''')
  write_line('''eliminated and all arg references adjusted to be esp relative.''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/*''')
  write_line('''Mterp and x86_64 notes:''')
  write_line('''''')
  write_line('''Some key interpreter variables will be assigned to registers.''')
  write_line('''''')
  write_line('''  nick     reg   purpose''')
  write_line('''  rPROFILE rbp   countdown register for jit profiling''')
  write_line('''  rPC      r12   interpreted program counter, used for fetching instructions''')
  write_line('''  rFP      r13   interpreted frame pointer, used for accessing locals and args''')
  write_line('''  rINSTw   bx    first 16-bit code of current instruction''')
  write_line('''  rINSTbl  bl    opcode portion of instruction word''')
  write_line('''  rINSTbh  bh    high byte of inst word, usually contains src/tgt reg names''')
  write_line('''  rIBASE   r14   base of instruction handler table''')
  write_line('''  rREFS    r15   base of object references in shadow frame.''')
  write_line('''''')
  write_line('''Notes:''')
  write_line('''   o High order 16 bits of ebx must be zero on entry to handler''')
  write_line('''   o rPC, rFP, rINSTw/rINSTbl valid on handler entry and exit''')
  write_line('''   o eax and ecx are scratch, rINSTw/ebx sometimes scratch''')
  write_line('''''')
  write_line('''Macros are provided for common operations.  Each macro MUST emit only''')
  write_line('''one instruction to make instruction-counting easier.  They MUST NOT alter''')
  write_line('''unspecified registers or condition codes.''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * This is a #include, not a %include, because we want the C pre-processor''')
  write_line(''' * to expand the macros into assembler assignment statements.''')
  write_line(''' */''')
  write_line('''#include "asm_support.h"''')
  write_line('''#include "interpreter/cfi_asm_support.h"''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Handle mac compiler specific''')
  write_line(''' */''')
  write_line('''#if defined(__APPLE__)''')
  write_line('''    #define MACRO_LITERAL(value) $(value)''')
  write_line('''    #define FUNCTION_TYPE(name)''')
  write_line('''    #define OBJECT_TYPE(name)''')
  write_line('''    #define SIZE(start,end)''')
  write_line('''    // Mac OS' symbols have an _ prefix.''')
  write_line('''    #define SYMBOL(name) _ ## name''')
  write_line('''    #define ASM_HIDDEN .private_extern''')
  write_line('''#else''')
  write_line('''    #define MACRO_LITERAL(value) $value''')
  write_line('''    #define FUNCTION_TYPE(name) .type name, @function''')
  write_line('''    #define OBJECT_TYPE(name) .type name, @object''')
  write_line('''    #define SIZE(start,end) .size start, .-end''')
  write_line('''    #define SYMBOL(name) name''')
  write_line('''    #define ASM_HIDDEN .hidden''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''.macro PUSH _reg''')
  write_line('''    pushq \\_reg''')
  write_line('''    .cfi_adjust_cfa_offset 8''')
  write_line('''    .cfi_rel_offset \\_reg, 0''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro POP _reg''')
  write_line('''    popq \\_reg''')
  write_line('''    .cfi_adjust_cfa_offset -8''')
  write_line('''    .cfi_restore \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Instead of holding a pointer to the shadow frame, we keep rFP at the base of the vregs.  So,''')
  write_line(''' * to access other shadow frame fields, we need to use a backwards offset.  Define those here.''')
  write_line(''' */''')
  write_line('''#define OFF_FP(a) (a - SHADOWFRAME_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_NUMBER_OF_VREGS OFF_FP(SHADOWFRAME_NUMBER_OF_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC OFF_FP(SHADOWFRAME_DEX_PC_OFFSET)''')
  write_line('''#define OFF_FP_LINK OFF_FP(SHADOWFRAME_LINK_OFFSET)''')
  write_line('''#define OFF_FP_METHOD OFF_FP(SHADOWFRAME_METHOD_OFFSET)''')
  write_line('''#define OFF_FP_RESULT_REGISTER OFF_FP(SHADOWFRAME_RESULT_REGISTER_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC_PTR OFF_FP(SHADOWFRAME_DEX_PC_PTR_OFFSET)''')
  write_line('''#define OFF_FP_DEX_INSTRUCTIONS OFF_FP(SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET)''')
  write_line('''#define OFF_FP_COUNTDOWN_OFFSET OFF_FP(SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET)''')
  write_line('''#define OFF_FP_SHADOWFRAME (-SHADOWFRAME_VREGS_OFFSET)''')
  write_line('''''')
  write_line('''/* Frame size must be 16-byte aligned.''')
  write_line(''' * Remember about 8 bytes for return address + 6 * 8 for spills.''')
  write_line(''' */''')
  write_line('''#define FRAME_SIZE     8''')
  write_line('''''')
  write_line('''/* Frame diagram while executing ExecuteMterpImpl, high to low addresses */''')
  write_line('''#define IN_ARG3        %rcx''')
  write_line('''#define IN_ARG2        %rdx''')
  write_line('''#define IN_ARG1        %rsi''')
  write_line('''#define IN_ARG0        %rdi''')
  write_line('''/* Spill offsets relative to %esp */''')
  write_line('''#define SELF_SPILL     (FRAME_SIZE -  8)''')
  write_line('''/* Out Args  */''')
  write_line('''#define OUT_ARG3       %rcx''')
  write_line('''#define OUT_ARG2       %rdx''')
  write_line('''#define OUT_ARG1       %rsi''')
  write_line('''#define OUT_ARG0       %rdi''')
  write_line('''#define OUT_32_ARG3    %ecx''')
  write_line('''#define OUT_32_ARG2    %edx''')
  write_line('''#define OUT_32_ARG1    %esi''')
  write_line('''#define OUT_32_ARG0    %edi''')
  write_line('''#define OUT_FP_ARG1    %xmm1''')
  write_line('''#define OUT_FP_ARG0    %xmm0''')
  write_line('''''')
  write_line('''/* During bringup, we'll use the shadow frame model instead of rFP */''')
  write_line('''/* single-purpose registers, given names for clarity */''')
  write_line('''#define rSELF    SELF_SPILL(%rsp)''')
  write_line('''#define rPC      %r12''')
  write_line('''#define CFI_DEX  12 // DWARF register number of the register holding dex-pc (rPC).''')
  write_line('''#define CFI_TMP  5  // DWARF register number of the first argument register (rdi).''')
  write_line('''#define rFP      %r13''')
  write_line('''#define rINST    %ebx''')
  write_line('''#define rINSTq   %rbx''')
  write_line('''#define rINSTw   %bx''')
  write_line('''#define rINSTbh  %bh''')
  write_line('''#define rINSTbl  %bl''')
  write_line('''#define rIBASE   %r14''')
  write_line('''#define rREFS    %r15''')
  write_line('''#define rPROFILE %ebp''')
  write_line('''''')
  write_line('''#define MTERP_LOGGING 0''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * "export" the PC to dex_pc field in the shadow frame, f/b/o future exception objects.  Must''')
  write_line(''' * be done *before* something throws.''')
  write_line(''' *''')
  write_line(''' * It's okay to do this more than once.''')
  write_line(''' *''')
  write_line(''' * NOTE: the fast interpreter keeps track of dex pc as a direct pointer to the mapped''')
  write_line(''' * dex byte codes.  However, the rest of the runtime expects dex pc to be an instruction''')
  write_line(''' * offset into the code_items_[] array.  For effiency, we will "export" the''')
  write_line(''' * current dex pc as a direct pointer using the EXPORT_PC macro, and rely on GetDexPC''')
  write_line(''' * to convert to a dex pc when needed.''')
  write_line(''' */''')
  write_line('''.macro EXPORT_PC''')
  write_line('''    movq    rPC, OFF_FP_DEX_PC_PTR(rFP)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh handler table.''')
  write_line(''' * IBase handles uses the caller save register so we must restore it after each call.''')
  write_line(''' * Also it is used as a result of some 64-bit operations (like imul) and we should''')
  write_line(''' * restore it in such cases also.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''.macro REFRESH_IBASE_REG self_reg''')
  write_line('''    movq    THREAD_CURRENT_IBASE_OFFSET(\\self_reg), rIBASE''')
  write_line('''.endm''')
  write_line('''.macro REFRESH_IBASE''')
  write_line('''    movq    rSELF, rIBASE''')
  write_line('''    REFRESH_IBASE_REG rIBASE''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh rINST.''')
  write_line(''' * At enter to handler rINST does not contain the opcode number.''')
  write_line(''' * However some utilities require the full value, so this macro''')
  write_line(''' * restores the opcode number.''')
  write_line(''' */''')
  write_line('''.macro REFRESH_INST _opnum''')
  write_line('''    movb    rINSTbl, rINSTbh''')
  write_line('''    movb    $\\_opnum, rINSTbl''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from rPC into rINSTw.  Does not advance rPC.''')
  write_line(''' */''')
  write_line('''.macro FETCH_INST''')
  write_line('''    movzwq  (rPC), rINSTq''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Remove opcode from rINST, compute the address of handler and jump to it.''')
  write_line(''' */''')
  write_line('''.macro GOTO_NEXT''')
  write_line('''    movzx   rINSTbl,%eax''')
  write_line('''    movzbl  rINSTbh,rINST''')
  write_line('''    shll    MACRO_LITERAL(''' + handler_size_bits + '''), %eax''')
  write_line('''    addq    rIBASE, %rax''')
  write_line('''    jmp     *%rax''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Advance rPC by instruction count.''')
  write_line(''' */''')
  write_line('''.macro ADVANCE_PC _count''')
  write_line('''    leaq    2*\\_count(rPC), rPC''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Advance rPC by instruction count, fetch instruction and jump to handler.''')
  write_line(''' */''')
  write_line('''.macro ADVANCE_PC_FETCH_AND_GOTO_NEXT _count''')
  write_line('''    ADVANCE_PC \\_count''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 32-bit value from a Dalvik register.''')
  write_line(''' */''')
  write_line('''#define VREG_ADDRESS(_vreg) (rFP,_vreg,4)''')
  write_line('''#define VREG_REF_ADDRESS(_vreg) (rREFS,_vreg,4)''')
  write_line('''''')
  write_line('''.macro GET_VREG _reg _vreg''')
  write_line('''    movl    (rFP,\\_vreg,4), \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/* Read wide value. */''')
  write_line('''.macro GET_WIDE_VREG _reg _vreg''')
  write_line('''    movq    (rFP,\\_vreg,4), \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro SET_VREG _reg _vreg''')
  write_line('''    movl    \\_reg, (rFP,\\_vreg,4)''')
  write_line('''    movl    MACRO_LITERAL(0), (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/* Write wide value. reg is clobbered. */''')
  write_line('''.macro SET_WIDE_VREG _reg _vreg''')
  write_line('''    movq    \\_reg, (rFP,\\_vreg,4)''')
  write_line('''    xorq    \\_reg, \\_reg''')
  write_line('''    movq    \\_reg, (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro SET_VREG_OBJECT _reg _vreg''')
  write_line('''    movl    \\_reg, (rFP,\\_vreg,4)''')
  write_line('''    movl    \\_reg, (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro GET_VREG_HIGH _reg _vreg''')
  write_line('''    movl    4(rFP,\\_vreg,4), \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro SET_VREG_HIGH _reg _vreg''')
  write_line('''    movl    \\_reg, 4(rFP,\\_vreg,4)''')
  write_line('''    movl    MACRO_LITERAL(0), 4(rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro CLEAR_REF _vreg''')
  write_line('''    movl    MACRO_LITERAL(0),  (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro CLEAR_WIDE_REF _vreg''')
  write_line('''    movl    MACRO_LITERAL(0),  (rREFS,\\_vreg,4)''')
  write_line('''    movl    MACRO_LITERAL(0), 4(rREFS,\\_vreg,4)''')
  write_line('''.endm''')

def instruction_end():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmInstructionEnd)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmInstructionEnd)''')
  write_line('''    .global SYMBOL(artMterpAsmInstructionEnd)''')
  write_line('''SYMBOL(artMterpAsmInstructionEnd):''')

def instruction_end_alt():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmAltInstructionEnd)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmAltInstructionEnd)''')
  write_line('''    .global SYMBOL(artMterpAsmAltInstructionEnd)''')
  write_line('''SYMBOL(artMterpAsmAltInstructionEnd):''')

def instruction_end_sister():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmSisterEnd)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmSisterEnd)''')
  write_line('''    .global SYMBOL(artMterpAsmSisterEnd)''')
  write_line('''SYMBOL(artMterpAsmSisterEnd):''')

def instruction_start():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmInstructionStart)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmInstructionStart)''')
  write_line('''    .global SYMBOL(artMterpAsmInstructionStart)''')
  write_line('''SYMBOL(artMterpAsmInstructionStart) = .L_op_nop''')
  write_line('''    .text''')

def instruction_start_alt():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmAltInstructionStart)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmAltInstructionStart)''')
  write_line('''    .global SYMBOL(artMterpAsmAltInstructionStart)''')
  write_line('''    .text''')
  write_line('''SYMBOL(artMterpAsmAltInstructionStart) = .L_ALT_op_nop''')

def instruction_start_sister():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmSisterStart)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmSisterStart)''')
  write_line('''    .global SYMBOL(artMterpAsmSisterStart)''')
  write_line('''    .text''')
  write_line('''    .balign 4''')
  write_line('''SYMBOL(artMterpAsmSisterStart):''')

def invoke(helper="UndefinedInvokeHandler"):
  write_line('''/*''')
  write_line(''' * Generic invoke handler wrapper.''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movq    rPC, OUT_ARG2''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_32_ARG3''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpException''')
  write_line('''    ADVANCE_PC 3''')
  write_line('''    call    SYMBOL(MterpShouldSwitchInterpreters)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')

def invoke_polymorphic(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * invoke-polymorphic handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB, proto@HHHH */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG1''')
  write_line('''    movq    rPC, OUT_ARG2''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_32_ARG3''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpException''')
  write_line('''    ADVANCE_PC 4''')
  write_line('''    call    SYMBOL(MterpShouldSwitchInterpreters)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')

def op_add_double():
  sseBinop(instr="adds", suff="d")

def op_add_double_2addr():
  sseBinop2Addr(instr="adds", suff="d")

def op_add_float():
  sseBinop(instr="adds", suff="s")

def op_add_float_2addr():
  sseBinop2Addr(instr="adds", suff="s")

def op_add_int():
  binop(instr="addl    (rFP,%rcx,4), %eax")

def op_add_int_2addr():
  binop2addr(instr="addl    %eax, (rFP,%rcx,4)")

def op_add_int_lit16():
  binopLit16(instr="addl    %ecx, %eax")

def op_add_int_lit8():
  binopLit8(instr="addl    %ecx, %eax")

def op_add_long():
  binopWide(instr="addq    (rFP,%rcx,4), %rax")

def op_add_long_2addr():
  binopWide2addr(instr="addq    %rax, (rFP,%rcx,4)")

def op_aget(load="movl", shift="4", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET", wide="0"):
  write_line('''/*''')
  write_line(''' * Array get, 32 bits or less.  vAA <- vBB[vCC].''')
  write_line(''' *''')
  write_line(''' * for: aget, aget-boolean, aget-byte, aget-char, aget-short, aget-wide''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rax                    # eax <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- vBB (array object)''')
  write_line('''    GET_VREG %ecx, %rcx                     # ecx <- vCC (requested index)''')
  write_line('''    testl   %eax, %eax                      # null array object?''')
  write_line('''    je      common_errNullObject            # bail if so''')
  write_line('''    cmpl    MIRROR_ARRAY_LENGTH_OFFSET(%eax), %ecx''')
  write_line('''    jae     common_errArrayIndex            # index >= length, bail.''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    movq    ''' + data_offset + '''(%rax,%rcx,8), %rax''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq''')
  write_line('''    .else''')
  write_line('''    ''' + load + '''   ''' + data_offset + '''(%rax,%rcx,''' + shift + '''), %eax''')
  write_line('''    SET_VREG %eax, rINSTq''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aget_boolean():
  op_aget(load="movzbl", shift="1", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aget_byte():
  op_aget(load="movsbl", shift="1", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aget_char():
  op_aget(load="movzwl", shift="2", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aget_object():
  write_line('''/*''')
  write_line(''' * Array object get.  vAA <- vBB[vCC].''')
  write_line(''' *''')
  write_line(''' * for: aget-object''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rax                    # rax <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # rcx <- CC''')
  write_line('''    GET_VREG OUT_32_ARG0, %rax              # eax <- vBB (array object)''')
  write_line('''    GET_VREG OUT_32_ARG1, %rcx              # ecx <- vCC (requested index)''')
  write_line('''    EXPORT_PC''')
  write_line('''    call    SYMBOL(artAGetObjectFromMterp)  # (array, index)''')
  write_line('''    movq    rSELF, %rcx''')
  write_line('''    cmpq    $0, THREAD_EXCEPTION_OFFSET(%rcx)''')
  write_line('''    jnz     MterpException''')
  write_line('''    SET_VREG_OBJECT %eax, rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aget_short():
  op_aget(load="movswl", shift="2", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aget_wide():
  op_aget(load="movq", shift="8", data_offset="MIRROR_WIDE_ARRAY_DATA_OFFSET", wide="1")

def op_and_int():
  binop(instr="andl    (rFP,%rcx,4), %eax")

def op_and_int_2addr():
  binop2addr(instr="andl    %eax, (rFP,%rcx,4)")

def op_and_int_lit16():
  binopLit16(instr="andl    %ecx, %eax")

def op_and_int_lit8():
  binopLit8(instr="andl    %ecx, %eax")

def op_and_long():
  binopWide(instr="andq    (rFP,%rcx,4), %rax")

def op_and_long_2addr():
  binopWide2addr(instr="andq    %rax, (rFP,%rcx,4)")

def op_aput(reg="rINST", store="movl", shift="4", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET", wide="0"):
  write_line('''/*''')
  write_line(''' * Array put, 32 bits or less.  vBB[vCC] <- vAA.''')
  write_line(''' *''')
  write_line(''' * for: aput, aput-boolean, aput-byte, aput-char, aput-short, aput-wide''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rax                    # rax <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # rcx <- CC''')
  write_line('''    GET_VREG %eax, %rax                     # eax <- vBB (array object)''')
  write_line('''    GET_VREG %ecx, %rcx                     # ecx <- vCC (requested index)''')
  write_line('''    testl   %eax, %eax                      # null array object?''')
  write_line('''    je      common_errNullObject            # bail if so''')
  write_line('''    cmpl    MIRROR_ARRAY_LENGTH_OFFSET(%eax), %ecx''')
  write_line('''    jae     common_errArrayIndex            # index >= length, bail.''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    GET_WIDE_VREG rINSTq, rINSTq''')
  write_line('''    .else''')
  write_line('''    GET_VREG rINST, rINSTq''')
  write_line('''    .endif''')
  write_line('''    ''' + store + '''    ''' + reg + ''', ''' + data_offset + '''(%rax,%rcx,''' + shift + ''')''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aput_boolean():
  op_aput(reg="rINSTbl", store="movb", shift="1", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aput_byte():
  op_aput(reg="rINSTbl", store="movb", shift="1", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aput_char():
  op_aput(reg="rINSTw", store="movw", shift="2", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aput_object():
  write_line('''/*''')
  write_line(''' * Store an object into an array.  vBB[vCC] <- vAA.''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG0''')
  write_line('''    movq    rPC, OUT_ARG1''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movq    rINSTq, OUT_ARG2''')
  write_line('''    call    SYMBOL(MterpAputObject)         # (array, index)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aput_short():
  op_aput(reg="rINSTw", store="movw", shift="2", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aput_wide():
  op_aput(reg="rINSTq", store="movq", shift="8", data_offset="MIRROR_WIDE_ARRAY_DATA_OFFSET", wide="1")

def op_array_length():
  write_line('''/*''')
  write_line(''' * Return the length of an array.''')
  write_line(''' */''')
  write_line('''    movl    rINST, %eax                     # eax <- BA''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    GET_VREG %ecx, rINSTq                   # ecx <- vB (object ref)''')
  write_line('''    testl   %ecx, %ecx                      # is null?''')
  write_line('''    je      common_errNullObject''')
  write_line('''    andb    $0xf, %al                      # eax <- A''')
  write_line('''    movl    MIRROR_ARRAY_LENGTH_OFFSET(%rcx), rINST''')
  write_line('''    SET_VREG rINST, %rax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_check_cast():
  write_line('''/*''')
  write_line(''' * Check to see if a cast from one class to another is allowed.''')
  write_line(''' */''')
  write_line('''    /* check-cast vAA, class@BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movzwq  2(rPC), OUT_ARG0                # OUT_ARG0 <- BBBB''')
  write_line('''    leaq    VREG_ADDRESS(rINSTq), OUT_ARG1''')
  write_line('''    movq    OFF_FP_METHOD(rFP), OUT_ARG2''')
  write_line('''    movq    rSELF, OUT_ARG3''')
  write_line('''    call    SYMBOL(MterpCheckCast)          # (index, &obj, method, self)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_cmp_long():
  write_line('''/*''')
  write_line(''' * Compare two 64-bit values.  Puts 0, 1, or -1 into the destination''')
  write_line(''' * register based on the results of the comparison.''')
  write_line(''' */''')
  write_line('''    /* cmp-long vAA, vBB, vCC */''')
  write_line('''    movzbq  2(rPC), %rdx                    # edx <- BB''')
  write_line('''    movzbq  3(rPC), %rcx                    # ecx <- CC''')
  write_line('''    GET_WIDE_VREG %rdx, %rdx                # rdx <- v[BB]''')
  write_line('''    xorl    %eax, %eax''')
  write_line('''    xorl    %edi, %edi''')
  write_line('''    addb    $1, %al''')
  write_line('''    movl    $-1, %esi''')
  write_line('''    cmpq    VREG_ADDRESS(%rcx), %rdx''')
  write_line('''    cmovl   %esi, %edi''')
  write_line('''    cmovg   %eax, %edi''')
  write_line('''    SET_VREG %edi, rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_cmpg_double():
  fpcmp(suff="d", nanval="pos")

def op_cmpg_float():
  fpcmp(suff="s", nanval="pos")

def op_cmpl_double():
  fpcmp(suff="d", nanval="neg")

def op_cmpl_float():
  fpcmp(suff="s", nanval="neg")

def op_const():
  write_line('''    /* const vAA, #+BBBBbbbb */''')
  write_line('''    movl    2(rPC), %eax                    # grab all 32 bits at once''')
  write_line('''    SET_VREG %eax, rINSTq                   # vAA<- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_const_16():
  write_line('''    /* const/16 vAA, #+BBBB */''')
  write_line('''    movswl  2(rPC), %ecx                    # ecx <- ssssBBBB''')
  write_line('''    SET_VREG %ecx, rINSTq                   # vAA <- ssssBBBB''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_const_4():
  write_line('''    /* const/4 vA, #+B */''')
  write_line('''    movsbl  rINSTbl, %eax                   # eax <-ssssssBx''')
  write_line('''    movl    $0xf, rINST''')
  write_line('''    andl    %eax, rINST                     # rINST <- A''')
  write_line('''    sarl    $4, %eax''')
  write_line('''    SET_VREG %eax, rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_const_class():
  const(helper="MterpConstClass")

def op_const_high16():
  write_line('''    /* const/high16 vAA, #+BBBB0000 */''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- 0000BBBB''')
  write_line('''    sall    $16, %eax                      # eax <- BBBB0000''')
  write_line('''    SET_VREG %eax, rINSTq                   # vAA <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_const_method_handle():
  const(helper="MterpConstMethodHandle")

def op_const_method_type():
  const(helper="MterpConstMethodType")

def op_const_string():
  const(helper="MterpConstString")

def op_const_string_jumbo():
  write_line('''    /* const/string vAA, String@BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    2(rPC), OUT_32_ARG0             # OUT_32_ARG0 <- BBBB''')
  write_line('''    movq    rINSTq, OUT_ARG1''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG2''')
  write_line('''    movq    rSELF, OUT_ARG3''')
  write_line('''    call    SYMBOL(MterpConstString)        # (index, tgt_reg, shadow_frame, self)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_const_wide():
  write_line('''    /* const-wide vAA, #+HHHHhhhhBBBBbbbb */''')
  write_line('''    movq    2(rPC), %rax                    # rax <- HHHHhhhhBBBBbbbb''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 5''')

def op_const_wide_16():
  write_line('''    /* const-wide/16 vAA, #+BBBB */''')
  write_line('''    movswq  2(rPC), %rax                    # rax <- ssssBBBB''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq              # store''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_const_wide_32():
  write_line('''    /* const-wide/32 vAA, #+BBBBbbbb */''')
  write_line('''    movslq   2(rPC), %rax                   # eax <- ssssssssBBBBbbbb''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq              # store''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_const_wide_high16():
  write_line('''    /* const-wide/high16 vAA, #+BBBB000000000000 */''')
  write_line('''    movzwq  2(rPC), %rax                    # eax <- 0000BBBB''')
  write_line('''    salq    $48, %rax                      # eax <- BBBB0000''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq              # v[AA+0] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_div_double():
  sseBinop(instr="divs", suff="d")

def op_div_double_2addr():
  sseBinop2Addr(instr="divs", suff="d")

def op_div_float():
  sseBinop(instr="divs", suff="s")

def op_div_float_2addr():
  sseBinop2Addr(instr="divs", suff="s")

def op_div_int():
  bindiv(result="%eax", second="%ecx", wide="0", suffix="l")

def op_div_int_2addr():
  bindiv2addr(result="%eax", second="%ecx", wide="0", suffix="l")

def op_div_int_lit16():
  bindivLit16(result="%eax")

def op_div_int_lit8():
  bindivLit8(result="%eax")

def op_div_long():
  bindiv(result="%rax", second="%rcx", wide="1", suffix="q", ext="cqo")

def op_div_long_2addr():
  bindiv2addr(result="%rax", second="%rcx", wide="1", suffix="q", ext="cqo")

def op_double_to_float():
  fpcvt(source_suffix="d", dest_suffix="s", wide="0")

def op_double_to_int():
  cvtfp_int(fp_suffix="d", i_suffix="l", max_const="$0x7fffffff", result_reg="%eax", wide="0")

def op_double_to_long():
  cvtfp_int(fp_suffix="d", i_suffix="q", max_const="$0x7fffffffffffffff", result_reg="%rax", wide="1")

def op_fill_array_data():
  write_line('''    /* fill-array-data vAA, +BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movslq  2(rPC), %rcx                    # rcx <- ssssssssBBBBbbbb''')
  write_line('''    leaq    (rPC,%rcx,2), OUT_ARG1          # OUT_ARG1 <- PC + ssssssssBBBBbbbb*2''')
  write_line('''    GET_VREG OUT_32_ARG0, rINSTq            # OUT_ARG0 <- vAA (array object)''')
  write_line('''    call    SYMBOL(MterpFillArrayData)      # (obj, payload)''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_filled_new_array(helper="MterpFilledNewArray"):
  write_line('''/*''')
  write_line(''' * Create a new array with elements filled from registers.''')
  write_line(''' *''')
  write_line(''' * for: filled-new-array, filled-new-array/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, type@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG0''')
  write_line('''    movq    rPC, OUT_ARG1''')
  write_line('''    movq    rSELF, OUT_ARG2''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_filled_new_array_range():
  op_filled_new_array(helper="MterpFilledNewArrayRange")

def op_float_to_double():
  fpcvt(source_suffix="s", dest_suffix="d", wide="1")

def op_float_to_int():
  cvtfp_int(fp_suffix="s", i_suffix="l", max_const="$0x7fffffff", result_reg="%eax", wide="0")

def op_float_to_long():
  cvtfp_int(fp_suffix="s", i_suffix="q", max_const="$0x7fffffffffffffff", result_reg="%rax", wide="1")

def op_goto():
  write_line('''/*''')
  write_line(''' * Unconditional branch, 8-bit offset.''')
  write_line(''' *''')
  write_line(''' * The branch distance is a signed code-unit offset, which we need to''')
  write_line(''' * double to get a byte offset.''')
  write_line(''' */''')
  write_line('''    /* goto +AA */''')
  write_line('''    movsbq  rINSTbl, rINSTq                 # rINSTq <- ssssssAA''')
  write_line('''    testq   rINSTq, rINSTq''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_goto_16():
  write_line('''/*''')
  write_line(''' * Unconditional branch, 16-bit offset.''')
  write_line(''' *''')
  write_line(''' * The branch distance is a signed code-unit offset, which we need to''')
  write_line(''' * double to get a byte offset.''')
  write_line(''' */''')
  write_line('''    /* goto/16 +AAAA */''')
  write_line('''    movswq  2(rPC), rINSTq                  # rINSTq <- ssssAAAA''')
  write_line('''    testq   rINSTq, rINSTq''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_goto_32():
  write_line('''/*''')
  write_line(''' * Unconditional branch, 32-bit offset.''')
  write_line(''' *''')
  write_line(''' * The branch distance is a signed code-unit offset, which we need to''')
  write_line(''' * double to get a byte offset.''')
  write_line(''' *''')
  write_line(''' *  Because we need the SF bit set, we'll use an adds''')
  write_line(''' * to convert from Dalvik offset to byte offset.''')
  write_line(''' */''')
  write_line('''    /* goto/32 +AAAAAAAA */''')
  write_line('''    movslq  2(rPC), rINSTq                  # rINSTq <- AAAAAAAA''')
  write_line('''    testq   rINSTq, rINSTq''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_if_eq():
  bincmp(revcmp="ne")

def op_if_eqz():
  zcmp(revcmp="ne")

def op_if_ge():
  bincmp(revcmp="l")

def op_if_gez():
  zcmp(revcmp="l")

def op_if_gt():
  bincmp(revcmp="le")

def op_if_gtz():
  zcmp(revcmp="le")

def op_if_le():
  bincmp(revcmp="g")

def op_if_lez():
  zcmp(revcmp="g")

def op_if_lt():
  bincmp(revcmp="ge")

def op_if_ltz():
  zcmp(revcmp="ge")

def op_if_ne():
  bincmp(revcmp="e")

def op_if_nez():
  zcmp(revcmp="e")

def op_iget(is_object="0", helper="MterpIGetU32"):
  field(helper=helper)

def op_iget_boolean():
  op_iget(helper="MterpIGetU8")

def op_iget_boolean_quick():
  op_iget_quick(load="movsbl")

def op_iget_byte():
  op_iget(helper="MterpIGetI8")

def op_iget_byte_quick():
  op_iget_quick(load="movsbl")

def op_iget_char():
  op_iget(helper="MterpIGetU16")

def op_iget_char_quick():
  op_iget_quick(load="movzwl")

def op_iget_object():
  op_iget(is_object="1", helper="MterpIGetObj")

def op_iget_object_quick():
  write_line('''    /* For: iget-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    .extern artIGetObjectFromMterp''')
  write_line('''    movzbq  rINSTbl, %rcx                   # rcx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG OUT_32_ARG0, %rcx              # vB (object we're operating on)''')
  write_line('''    movzwl  2(rPC), OUT_32_ARG1             # eax <- field byte offset''')
  write_line('''    EXPORT_PC''')
  write_line('''    callq   SYMBOL(artIGetObjectFromMterp)  # (obj, offset)''')
  write_line('''    movq    rSELF, %rcx''')
  write_line('''    cmpq    $0, THREAD_EXCEPTION_OFFSET(%rcx)''')
  write_line('''    jnz     MterpException                  # bail out''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    SET_VREG_OBJECT %eax, rINSTq            # fp[A] <- value''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iget_quick(load="movl", wide="0"):
  write_line('''    /* For: iget-quick, iget-boolean-quick, iget-byte-quick, iget-char-quick, iget-short-quick, iget-wide-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %rcx                     # vB (object we're operating on)''')
  write_line('''    movzwq  2(rPC), %rax                    # eax <- field byte offset''')
  write_line('''    testl   %ecx, %ecx                      # is object null?''')
  write_line('''    je      common_errNullObject''')
  write_line('''    andb    $0xf,rINSTbl                   # rINST <- A''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    movq (%rcx,%rax,1), %rax''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq              # fp[A] <- value''')
  write_line('''    .else''')
  write_line('''    ''' + load + ''' (%rcx,%rax,1), %eax''')
  write_line('''    SET_VREG %eax, rINSTq                   # fp[A] <- value''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iget_short():
  op_iget(helper="MterpIGetI16")

def op_iget_short_quick():
  op_iget_quick(load="movswl")

def op_iget_wide():
  op_iget(helper="MterpIGetU64")

def op_iget_wide_quick():
  op_iget_quick(load="movswl", wide="1")

def op_instance_of():
  write_line('''/*''')
  write_line(''' * Check to see if an object reference is an instance of a class.''')
  write_line(''' *''')
  write_line(''' * Most common situation is a non-null object, being compared against''')
  write_line(''' * an already-resolved class.''')
  write_line(''' */''')
  write_line('''    /* instance-of vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movzwl  2(rPC), OUT_32_ARG0             # OUT_32_ARG0 <- CCCC''')
  write_line('''    movl    rINST, %eax                     # eax <- BA''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    leaq    VREG_ADDRESS(%rax), OUT_ARG1    # Get object address''')
  write_line('''    movq    OFF_FP_METHOD(rFP), OUT_ARG2''')
  write_line('''    movq    rSELF, OUT_ARG3''')
  write_line('''    call    SYMBOL(MterpInstanceOf)         # (index, &obj, method, self)''')
  write_line('''    movsbl  %al, %eax''')
  write_line('''    movq    rSELF, %rcx''')
  write_line('''    cmpq    $0, THREAD_EXCEPTION_OFFSET(%rcx)''')
  write_line('''    jnz     MterpException''')
  write_line('''    andb    $0xf, rINSTbl                  # rINSTbl <- A''')
  write_line('''    SET_VREG %eax, rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_int_to_byte():
  unop(instr="movsbl  %al, %eax")

def op_int_to_char():
  unop(instr="movzwl  %ax,%eax")

def op_int_to_double():
  fpcvt(source_suffix="i", dest_suffix="dl", wide="1")

def op_int_to_float():
  fpcvt(source_suffix="i", dest_suffix="sl", wide="0")

def op_int_to_long():
  write_line('''    /* int to long vA, vB */''')
  write_line('''    movzbq  rINSTbl, %rax                   # rax <- +A''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    movslq  VREG_ADDRESS(%rax), %rax''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq              # v[A] <- %rax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')
  write_line('''''')

def op_int_to_short():
  unop(instr="movswl %ax, %eax")

def op_invoke_custom():
  invoke(helper="MterpInvokeCustom")

def op_invoke_custom_range():
  invoke(helper="MterpInvokeCustomRange")

def op_invoke_direct():
  invoke(helper="MterpInvokeDirect")

def op_invoke_direct_range():
  invoke(helper="MterpInvokeDirectRange")

def op_invoke_interface():
  invoke(helper="MterpInvokeInterface")
  write_line('''/*''')
  write_line(''' * Handle an interface method call.''')
  write_line(''' *''')
  write_line(''' * for: invoke-interface, invoke-interface/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_interface_range():
  invoke(helper="MterpInvokeInterfaceRange")

def op_invoke_polymorphic():
  invoke_polymorphic(helper="MterpInvokePolymorphic")

def op_invoke_polymorphic_range():
  invoke_polymorphic(helper="MterpInvokePolymorphicRange")

def op_invoke_static():
  invoke(helper="MterpInvokeStatic")
  write_line('''''')

def op_invoke_static_range():
  invoke(helper="MterpInvokeStaticRange")

def op_invoke_super():
  invoke(helper="MterpInvokeSuper")
  write_line('''/*''')
  write_line(''' * Handle a "super" method call.''')
  write_line(''' *''')
  write_line(''' * for: invoke-super, invoke-super/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_super_range():
  invoke(helper="MterpInvokeSuperRange")

def op_invoke_virtual():
  invoke(helper="MterpInvokeVirtual")
  write_line('''/*''')
  write_line(''' * Handle a virtual method call.''')
  write_line(''' *''')
  write_line(''' * for: invoke-virtual, invoke-virtual/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_virtual_quick():
  invoke(helper="MterpInvokeVirtualQuick")

def op_invoke_virtual_range():
  invoke(helper="MterpInvokeVirtualRange")

def op_invoke_virtual_range_quick():
  invoke(helper="MterpInvokeVirtualQuickRange")

def op_iput(is_object="0", helper="MterpIPutU32"):
  field(helper=helper)

def op_iput_boolean():
  op_iput(helper="MterpIPutU8")

def op_iput_boolean_quick():
  op_iput_quick(reg="rINSTbl", store="movb")

def op_iput_byte():
  op_iput(helper="MterpIPutI8")

def op_iput_byte_quick():
  op_iput_quick(reg="rINSTbl", store="movb")

def op_iput_char():
  op_iput(helper="MterpIPutU16")

def op_iput_char_quick():
  op_iput_quick(reg="rINSTw", store="movw")

def op_iput_object():
  op_iput(is_object="1", helper="MterpIPutObj")

def op_iput_object_quick():
  write_line('''    EXPORT_PC''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG0''')
  write_line('''    movq    rPC, OUT_ARG1''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_32_ARG2''')
  write_line('''    call    SYMBOL(MterpIputObjectQuick)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iput_quick(reg="rINST", store="movl"):
  write_line('''    /* For: iput-quick, iput-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    movzbq  rINSTbl, %rcx                   # rcx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %rcx                     # vB (object we're operating on)''')
  write_line('''    testl   %ecx, %ecx                      # is object null?''')
  write_line('''    je      common_errNullObject''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG rINST, rINSTq                  # rINST <- v[A]''')
  write_line('''    movzwq  2(rPC), %rax                    # rax <- field byte offset''')
  write_line('''    ''' + store + '''    ''' + reg + ''', (%rcx,%rax,1)''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iput_short():
  op_iput(helper="MterpIPutI16")

def op_iput_short_quick():
  op_iput_quick(reg="rINSTw", store="movw")

def op_iput_wide():
  op_iput(helper="MterpIPutU64")

def op_iput_wide_quick():
  write_line('''    /* iput-wide-quick vA, vB, offset@CCCC */''')
  write_line('''    movzbq    rINSTbl, %rcx                 # rcx<- BA''')
  write_line('''    sarl      $4, %ecx                     # ecx<- B''')
  write_line('''    GET_VREG  %ecx, %rcx                    # vB (object we're operating on)''')
  write_line('''    testl     %ecx, %ecx                    # is object null?''')
  write_line('''    je        common_errNullObject''')
  write_line('''    movzwq    2(rPC), %rax                  # rax<- field byte offset''')
  write_line('''    leaq      (%rcx,%rax,1), %rcx           # ecx<- Address of 64-bit target''')
  write_line('''    andb      $0xf, rINSTbl                # rINST<- A''')
  write_line('''    GET_WIDE_VREG %rax, rINSTq              # rax<- fp[A]/fp[A+1]''')
  write_line('''    movq      %rax, (%rcx)                  # obj.field<- r0/r1''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_long_to_double():
  fpcvt(source_suffix="i", dest_suffix="dq", wide="1")

def op_long_to_float():
  fpcvt(source_suffix="i", dest_suffix="sq", wide="0")

def op_long_to_int():
  write_line('''/* we ignore the high word, making this equivalent to a 32-bit reg move */''')
  op_move()

def op_monitor_enter():
  write_line('''/*''')
  write_line(''' * Synchronize on an object.''')
  write_line(''' */''')
  write_line('''    /* monitor-enter vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG OUT_32_ARG0, rINSTq''')
  write_line('''    movq    rSELF, OUT_ARG1''')
  write_line('''    call    SYMBOL(artLockObjectFromCode)   # (object, self)''')
  write_line('''    testq   %rax, %rax''')
  write_line('''    jnz     MterpException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_monitor_exit():
  write_line('''/*''')
  write_line(''' * Unlock an object.''')
  write_line(''' *''')
  write_line(''' * Exceptions that occur when unlocking a monitor need to appear as''')
  write_line(''' * if they happened at the following instruction.  See the Dalvik''')
  write_line(''' * instruction spec.''')
  write_line(''' */''')
  write_line('''    /* monitor-exit vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG OUT_32_ARG0, rINSTq''')
  write_line('''    movq    rSELF, OUT_ARG1''')
  write_line('''    call    SYMBOL(artUnlockObjectFromCode) # (object, self)''')
  write_line('''    testq   %rax, %rax''')
  write_line('''    jnz     MterpException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move(is_object="0"):
  write_line('''    /* for move, move-object, long-to-int */''')
  write_line('''    /* op vA, vB */''')
  write_line('''    movl    rINST, %eax                     # eax <- BA''')
  write_line('''    andb    $0xf, %al                      # eax <- A''')
  write_line('''    shrl    $4, rINST                      # rINST <- B''')
  write_line('''    GET_VREG %edx, rINSTq''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT %edx, %rax              # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG %edx, %rax                     # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_16(is_object="0"):
  write_line('''    /* for: move/16, move-object/16 */''')
  write_line('''    /* op vAAAA, vBBBB */''')
  write_line('''    movzwq  4(rPC), %rcx                    # ecx <- BBBB''')
  write_line('''    movzwq  2(rPC), %rax                    # eax <- AAAA''')
  write_line('''    GET_VREG %edx, %rcx''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT %edx, %rax              # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG %edx, %rax                     # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_move_exception():
  write_line('''    /* move-exception vAA */''')
  write_line('''    movq    rSELF, %rcx''')
  write_line('''    movl    THREAD_EXCEPTION_OFFSET(%rcx), %eax''')
  write_line('''    SET_VREG_OBJECT %eax, rINSTq            # fp[AA] <- exception object''')
  write_line('''    movl    $0, THREAD_EXCEPTION_OFFSET(%rcx)''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_from16(is_object="0"):
  write_line('''    /* for: move/from16, move-object/from16 */''')
  write_line('''    /* op vAA, vBBBB */''')
  write_line('''    movzwq  2(rPC), %rax                    # eax <- BBBB''')
  write_line('''    GET_VREG %edx, %rax                     # edx <- fp[BBBB]''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT %edx, rINSTq            # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG %edx, rINSTq                   # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_move_object():
  op_move(is_object="1")

def op_move_object_16():
  op_move_16(is_object="1")

def op_move_object_from16():
  op_move_from16(is_object="1")

def op_move_result(is_object="0"):
  write_line('''    /* for: move-result, move-result-object */''')
  write_line('''    /* op vAA */''')
  write_line('''    movq    OFF_FP_RESULT_REGISTER(rFP), %rax    # get pointer to result JType.''')
  write_line('''    movl    (%rax), %eax                    # r0 <- result.i.''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT %eax, rINSTq            # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG %eax, rINSTq                   # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_result_object():
  op_move_result(is_object="1")

def op_move_result_wide():
  write_line('''    /* move-result-wide vAA */''')
  write_line('''    movq    OFF_FP_RESULT_REGISTER(rFP), %rax    # get pointer to result JType.''')
  write_line('''    movq    (%rax), %rdx                         # Get wide''')
  write_line('''    SET_WIDE_VREG %rdx, rINSTq                   # v[AA] <- rdx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_wide():
  write_line('''    /* move-wide vA, vB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    movl    rINST, %ecx                     # ecx <- BA''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    GET_WIDE_VREG %rdx, rINSTq              # rdx <- v[B]''')
  write_line('''    SET_WIDE_VREG %rdx, %rcx                # v[A] <- rdx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_wide_16():
  write_line('''    /* move-wide/16 vAAAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    movzwq  4(rPC), %rcx                    # ecx<- BBBB''')
  write_line('''    movzwq  2(rPC), %rax                    # eax<- AAAA''')
  write_line('''    GET_WIDE_VREG %rdx, %rcx                # rdx <- v[B]''')
  write_line('''    SET_WIDE_VREG %rdx, %rax                # v[A] <- rdx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_move_wide_from16():
  write_line('''    /* move-wide/from16 vAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    movzwl  2(rPC), %ecx                    # ecx <- BBBB''')
  write_line('''    GET_WIDE_VREG %rdx, %rcx                # rdx <- v[B]''')
  write_line('''    SET_WIDE_VREG %rdx, rINSTq              # v[A] <- rdx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_mul_double():
  sseBinop(instr="muls", suff="d")

def op_mul_double_2addr():
  sseBinop2Addr(instr="muls", suff="d")

def op_mul_float():
  sseBinop(instr="muls", suff="s")

def op_mul_float_2addr():
  sseBinop2Addr(instr="muls", suff="s")

def op_mul_int():
  binop(instr="imull   (rFP,%rcx,4), %eax")

def op_mul_int_2addr():
  write_line('''    /* mul vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    GET_VREG %eax, %rcx                     # eax <- vA''')
  write_line('''    imull   (rFP,rINSTq,4), %eax''')
  write_line('''    SET_VREG %eax, %rcx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_mul_int_lit16():
  binopLit16(instr="imull   %ecx, %eax")

def op_mul_int_lit8():
  binopLit8(instr="imull   %ecx, %eax")

def op_mul_long():
  binopWide(instr="imulq   (rFP,%rcx,4), %rax")

def op_mul_long_2addr():
  write_line('''    /* mul vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    GET_WIDE_VREG %rax, %rcx                # rax <- vA''')
  write_line('''    imulq   (rFP,rINSTq,4), %rax''')
  write_line('''    SET_WIDE_VREG %rax, %rcx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_neg_double():
  unop(preinstr="    movq    $0x8000000000000000, %rsi", instr="    xorq    %rsi, %rax", wide="1")

def op_neg_float():
  unop(instr="    xorl    $0x80000000, %eax")

def op_neg_int():
  unop(instr="    negl    %eax")

def op_neg_long():
  unop(instr="    negq    %rax", wide="1")

def op_new_array():
  write_line('''/*''')
  write_line(''' * Allocate an array of objects, specified with the array class''')
  write_line(''' * and a count.''')
  write_line(''' *''')
  write_line(''' * The verifier guarantees that this is an array class, so we don't''')
  write_line(''' * check for it here.''')
  write_line(''' */''')
  write_line('''    /* new-array vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG0''')
  write_line('''    movq    rPC, OUT_ARG1''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movq    rINSTq, OUT_ARG2''')
  write_line('''    movq    rSELF, OUT_ARG3''')
  write_line('''    call    SYMBOL(MterpNewArray)''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_new_instance():
  write_line('''/*''')
  write_line(''' * Create a new instance of a class.''')
  write_line(''' */''')
  write_line('''    /* new-instance vAA, class@BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    leaq    OFF_FP_SHADOWFRAME(rFP), OUT_ARG0''')
  write_line('''    movq    rSELF, OUT_ARG1''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movq    rINSTq, OUT_ARG2''')
  write_line('''    call    SYMBOL(MterpNewInstance)''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_nop():
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_not_int():
  unop(instr="    notl    %eax")

def op_not_long():
  unop(instr="    notq    %rax", wide="1")

def op_or_int():
  binop(instr="orl     (rFP,%rcx,4), %eax")

def op_or_int_2addr():
  binop2addr(instr="orl     %eax, (rFP,%rcx,4)")

def op_or_int_lit16():
  binopLit16(instr="orl     %ecx, %eax")

def op_or_int_lit8():
  binopLit8(instr="orl     %ecx, %eax")

def op_or_long():
  binopWide(instr="orq     (rFP,%rcx,4), %rax")

def op_or_long_2addr():
  binopWide2addr(instr="orq     %rax, (rFP,%rcx,4)")

def op_packed_switch(func="MterpDoPackedSwitch"):
  write_line('''/*''')
  write_line(''' * Handle a packed-switch or sparse-switch instruction.  In both cases''')
  write_line(''' * we decode it and hand it off to a helper function.''')
  write_line(''' *''')
  write_line(''' * We don't really expect backward branches in a switch statement, but''')
  write_line(''' * they're perfectly legal, so we check for them here.''')
  write_line(''' *''')
  write_line(''' * for: packed-switch, sparse-switch''')
  write_line(''' */''')
  write_line('''    /* op vAA, +BBBB */''')
  write_line('''    movslq  2(rPC), OUT_ARG0                # rcx <- ssssssssBBBBbbbb''')
  write_line('''    leaq    (rPC,OUT_ARG0,2), OUT_ARG0      # rcx <- PC + ssssssssBBBBbbbb*2''')
  write_line('''    GET_VREG OUT_32_ARG1, rINSTq            # eax <- vAA''')
  write_line('''    call    SYMBOL(''' + func + ''')''')
  write_line('''    testl   %eax, %eax''')
  write_line('''    movslq  %eax, rINSTq''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_rem_double():
  write_line('''    /* rem_double vAA, vBB, vCC */''')
  write_line('''    movzbq  3(rPC), %rcx                    # ecx <- BB''')
  write_line('''    movzbq  2(rPC), %rax                    # eax <- CC''')
  write_line('''    fldl    VREG_ADDRESS(%rcx)              # %st1 <- fp[vBB]''')
  write_line('''    fldl    VREG_ADDRESS(%rax)              # %st0 <- fp[vCC]''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstpl   VREG_ADDRESS(rINSTq)            # fp[vAA] <- %st''')
  write_line('''    CLEAR_WIDE_REF rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_rem_double_2addr():
  write_line('''    /* rem_double/2addr vA, vB */''')
  write_line('''    movzbq  rINSTbl, %rcx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    fldl    VREG_ADDRESS(rINSTq)            # vB to fp stack''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    fldl    VREG_ADDRESS(%rcx)              # vA to fp stack''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstpl   VREG_ADDRESS(%rcx)              # %st to vA''')
  write_line('''    CLEAR_WIDE_REF %rcx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_rem_float():
  write_line('''    /* rem_float vAA, vBB, vCC */''')
  write_line('''    movzbq  3(rPC), %rcx                    # ecx <- BB''')
  write_line('''    movzbq  2(rPC), %rax                    # eax <- CC''')
  write_line('''    flds    VREG_ADDRESS(%rcx)              # vBB to fp stack''')
  write_line('''    flds    VREG_ADDRESS(%rax)              # vCC to fp stack''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstps   VREG_ADDRESS(rINSTq)            # %st to vAA''')
  write_line('''    CLEAR_REF rINSTq''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_rem_float_2addr():
  write_line('''    /* rem_float/2addr vA, vB */''')
  write_line('''    movzbq  rINSTbl, %rcx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    flds    VREG_ADDRESS(rINSTq)            # vB to fp stack''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    flds    VREG_ADDRESS(%rcx)              # vA to fp stack''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstps   VREG_ADDRESS(%rcx)              # %st to vA''')
  write_line('''    CLEAR_REF %rcx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_rem_int():
  bindiv(result="%edx", second="%ecx", wide="0", suffix="l", rem="1")

def op_rem_int_2addr():
  bindiv2addr(result="%edx", second="%ecx", wide="0", suffix="l", rem="1")

def op_rem_int_lit16():
  bindivLit16(result="%edx", rem="1")

def op_rem_int_lit8():
  bindivLit8(result="%edx", rem="1")

def op_rem_long():
  bindiv(result="%rdx", second="%rcx", wide="1", suffix="q", ext="cqo", rem="1")

def op_rem_long_2addr():
  bindiv2addr(result="%rdx", second="%rcx", wide="1", suffix="q", rem="1", ext="cqo")

def op_return():
  write_line('''/*''')
  write_line(''' * Return a 32-bit value.''')
  write_line(''' *''')
  write_line(''' * for: return, return-object''')
  write_line(''' */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    call    SYMBOL(MterpThreadFenceForConstructor)''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(OUT_ARG0)''')
  write_line('''    jz      1f''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    GET_VREG %eax, rINSTq                   # eax <- vAA''')
  write_line('''    jmp     MterpReturn''')

def op_return_object():
  op_return()

def op_return_void():
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    call    SYMBOL(MterpThreadFenceForConstructor)''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(OUT_ARG0)''')
  write_line('''    jz      1f''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    xorq    %rax, %rax''')
  write_line('''    jmp     MterpReturn''')

def op_return_void_no_barrier():
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(OUT_ARG0)''')
  write_line('''    jz      1f''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    xorq    %rax, %rax''')
  write_line('''    jmp     MterpReturn''')

def op_return_wide():
  write_line('''/*''')
  write_line(''' * Return a 64-bit value.''')
  write_line(''' */''')
  write_line('''    /* return-wide vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    call    SYMBOL(MterpThreadFenceForConstructor)''')
  write_line('''    movq    rSELF, OUT_ARG0''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(OUT_ARG0)''')
  write_line('''    jz      1f''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    GET_WIDE_VREG %rax, rINSTq              # eax <- v[AA]''')
  write_line('''    jmp     MterpReturn''')

def op_rsub_int():
  write_line('''/* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */''')
  binopLit16(instr="subl    %eax, %ecx", result="%ecx")

def op_rsub_int_lit8():
  binopLit8(instr="subl    %eax, %ecx", result="%ecx")

def op_sget(is_object="0", helper="MterpSGetU32"):
  field(helper=helper)

def op_sget_boolean():
  op_sget(helper="MterpSGetU8")

def op_sget_byte():
  op_sget(helper="MterpSGetI8")

def op_sget_char():
  op_sget(helper="MterpSGetU16")

def op_sget_object():
  op_sget(is_object="1", helper="MterpSGetObj")

def op_sget_short():
  op_sget(helper="MterpSGetI16")

def op_sget_wide():
  op_sget(helper="MterpSGetU64")

def op_shl_int():
  binop1(instr="sall    %cl, %eax")

def op_shl_int_2addr():
  shop2addr(instr="sall    %cl, %eax")

def op_shl_int_lit8():
  binopLit8(instr="sall    %cl, %eax")

def op_shl_long():
  binop1(instr="salq    %cl, %rax", wide="1")

def op_shl_long_2addr():
  shop2addr(instr="salq    %cl, %rax", wide="1")

def op_shr_int():
  binop1(instr="sarl    %cl, %eax")

def op_shr_int_2addr():
  shop2addr(instr="sarl    %cl, %eax")

def op_shr_int_lit8():
  binopLit8(instr="sarl    %cl, %eax")

def op_shr_long():
  binop1(instr="sarq    %cl, %rax", wide="1")

def op_shr_long_2addr():
  shop2addr(instr="sarq    %cl, %rax", wide="1")

def op_sparse_switch():
  op_packed_switch(func="MterpDoSparseSwitch")

def op_sput(is_object="0", helper="MterpSPutU32"):
  field(helper=helper)

def op_sput_boolean():
  op_sput(helper="MterpSPutU8")

def op_sput_byte():
  op_sput(helper="MterpSPutI8")

def op_sput_char():
  op_sput(helper="MterpSPutU16")

def op_sput_object():
  op_sput(is_object="1", helper="MterpSPutObj")

def op_sput_short():
  op_sput(helper="MterpSPutI16")

def op_sput_wide():
  op_sput(helper="MterpSPutU64")

def op_sub_double():
  sseBinop(instr="subs", suff="d")

def op_sub_double_2addr():
  sseBinop2Addr(instr="subs", suff="d")

def op_sub_float():
  sseBinop(instr="subs", suff="s")

def op_sub_float_2addr():
  sseBinop2Addr(instr="subs", suff="s")

def op_sub_int():
  binop(instr="subl    (rFP,%rcx,4), %eax")

def op_sub_int_2addr():
  binop2addr(instr="subl    %eax, (rFP,%rcx,4)")

def op_sub_long():
  binopWide(instr="subq    (rFP,%rcx,4), %rax")

def op_sub_long_2addr():
  binopWide2addr(instr="subq    %rax, (rFP,%rcx,4)")

def op_throw():
  write_line('''/*''')
  write_line(''' * Throw an exception object in the current thread.''')
  write_line(''' */''')
  write_line('''    /* throw vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG %eax, rINSTq                   # eax<- vAA (exception object)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      common_errNullObject''')
  write_line('''    movq    rSELF, %rcx''')
  write_line('''    movq    %rax, THREAD_EXCEPTION_OFFSET(%rcx)''')
  write_line('''    jmp     MterpException''')

def op_unused_3e():
  unused()

def op_unused_3f():
  unused()

def op_unused_40():
  unused()

def op_unused_41():
  unused()

def op_unused_42():
  unused()

def op_unused_43():
  unused()

def op_unused_79():
  unused()

def op_unused_7a():
  unused()

def op_unused_f3():
  unused()

def op_unused_f4():
  unused()

def op_unused_f5():
  unused()

def op_unused_f6():
  unused()

def op_unused_f7():
  unused()

def op_unused_f8():
  unused()

def op_unused_f9():
  unused()

def op_unused_fc():
  unused()

def op_unused_fd():
  unused()

def op_ushr_int():
  binop1(instr="shrl    %cl, %eax")

def op_ushr_int_2addr():
  shop2addr(instr="shrl    %cl, %eax")

def op_ushr_int_lit8():
  binopLit8(instr="shrl    %cl, %eax")

def op_ushr_long():
  binop1(instr="shrq    %cl, %rax", wide="1")

def op_ushr_long_2addr():
  shop2addr(instr="shrq    %cl, %rax", wide="1")

def op_xor_int():
  binop(instr="xorl    (rFP,%rcx,4), %eax")

def op_xor_int_2addr():
  binop2addr(instr="xorl    %eax, (rFP,%rcx,4)")

def op_xor_int_lit16():
  binopLit16(instr="xorl    %ecx, %eax")

def op_xor_int_lit8():
  binopLit8(instr="xorl    %ecx, %eax")

def op_xor_long():
  binopWide(instr="xorq    (rFP,%rcx,4), %rax")

def op_xor_long_2addr():
  binopWide2addr(instr="xorq    %rax, (rFP,%rcx,4)")

def shop2addr(wide="0", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "shift/2addr" operation.''')
  write_line(''' */''')
  write_line('''    /* shift/2addr vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # ecx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %rcx                     # ecx <- vBB''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    GET_WIDE_VREG %rax, rINSTq              # rax <- vAA''')
  write_line('''    ''' + instr + '''                                  # ex: sarl %cl, %eax''')
  write_line('''    SET_WIDE_VREG %rax, rINSTq''')
  write_line('''    .else''')
  write_line('''    GET_VREG %eax, rINSTq                   # eax <- vAA''')
  write_line('''    ''' + instr + '''                                  # ex: sarl %cl, %eax''')
  write_line('''    SET_VREG %eax, rINSTq''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def sseBinop(instr="", suff=""):
  write_line('''    movzbq  2(rPC), %rcx                    # ecx <- BB''')
  write_line('''    movzbq  3(rPC), %rax                    # eax <- CC''')
  write_line('''    movs''' + suff + '''   VREG_ADDRESS(%rcx), %xmm0       # %xmm0 <- 1st src''')
  write_line('''    ''' + instr + '''''' + suff + ''' VREG_ADDRESS(%rax), %xmm0''')
  write_line('''    movs''' + suff + '''   %xmm0, VREG_ADDRESS(rINSTq)     # vAA <- %xmm0''')
  write_line('''    pxor    %xmm0, %xmm0''')
  write_line('''    movs''' + suff + '''   %xmm0, VREG_REF_ADDRESS(rINSTq) # clear ref''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def sseBinop2Addr(instr="", suff=""):
  write_line('''    movl    rINST, %ecx                     # ecx <- A+''')
  write_line('''    andl    $0xf, %ecx                     # ecx <- A''')
  write_line('''    movs''' + suff + ''' VREG_ADDRESS(%rcx), %xmm0        # %xmm0 <- 1st src''')
  write_line('''    sarl    $4, rINST                      # rINST<- B''')
  write_line('''    ''' + instr + '''''' + suff + ''' VREG_ADDRESS(rINSTq), %xmm0''')
  write_line('''    movs''' + suff + ''' %xmm0, VREG_ADDRESS(%rcx)   # vAA<- %xmm0''')
  write_line('''    pxor    %xmm0, %xmm0''')
  write_line('''    movs''' + suff + ''' %xmm0, VREG_REF_ADDRESS(rINSTq)  # clear ref''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def unop(preinstr="", instr="", wide="0"):
  write_line('''/*''')
  write_line(''' * Generic 32/64-bit unary operation.  Provide an "instr" line that''')
  write_line(''' * specifies an instruction that performs "result = op eax".''')
  write_line(''' */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    movl    rINST, %ecx                     # rcx <- A+''')
  write_line('''    sarl    $4,rINST                       # rINST <- B''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    GET_WIDE_VREG %rax, rINSTq              # rax <- vB''')
  write_line('''    .else''')
  write_line('''    GET_VREG %eax, rINSTq                   # eax <- vB''')
  write_line('''    .endif''')
  write_line('''    andb    $0xf,%cl                       # ecx <- A''')
  write_line('''''' + preinstr + '''''')
  write_line('''''' + instr + '''''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    SET_WIDE_VREG %rax, %rcx''')
  write_line('''    .else''')
  write_line('''    SET_VREG %eax, %rcx''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def unused():
  write_line('''/*''')
  write_line(''' * Bail to reference interpreter to throw.''')
  write_line(''' */''')
  write_line('''    jmp     MterpFallback''')

def zcmp(revcmp=""):
  write_line('''/*''')
  write_line(''' * Generic one-operand compare-and-branch operation.  Provide a "revcmp"''')
  write_line(''' * fragment that specifies the *reverse* comparison to perform, e.g.''')
  write_line(''' * for "if-le" you would use "gt".''')
  write_line(''' *''')
  write_line(''' * for: if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez''')
  write_line(''' */''')
  write_line('''    /* if-cmp vAA, +BBBB */''')
  write_line('''    cmpl    $0, VREG_ADDRESS(rINSTq)       # compare (vA, 0)''')
  write_line('''    j''' + revcmp + '''   1f''')
  write_line('''    movswq  2(rPC), rINSTq                  # fetch signed displacement''')
  write_line('''    testq   rINSTq, rINSTq''')
  write_line('''    jmp     MterpCommonTakenBranch''')
  write_line('''1:''')
  write_line('''    cmpl    $JIT_CHECK_OSR, rPROFILE''')
  write_line('''    je      .L_check_not_taken_osr''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

