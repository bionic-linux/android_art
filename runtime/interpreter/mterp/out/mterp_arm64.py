# DO NOT EDIT: This file was generated by gen-mterp.py.
arch = "arm64"

import sys

out = sys.stdout
handler_size_bytes = "128"
handler_size_bits = "7"
opcode = ""
opnum = ""

def write_line(line):
  out.write(line + "\n")

def balign():
  write_line("    .balign {}".format(handler_size_bytes))

def write_opcode(num, name, write_method, is_alt):
  global opnum, opcode
  opnum, opcode = str(num), name
  if is_alt:
    name = "ALT_" + name
  write_line("/* ------------------------------ */")
  balign()
  write_line(".L_{1}: /* {0:#04x} */".format(num, name))
  if is_alt:
    alt_stub()
  else:
    write_method()
  write_line("")
  opnum, opcode = None, None

def generate(output_file):
  global out
  out = output_file
  write_line("/* DO NOT EDIT: This file was generated by gen-mterp.py. */")
  header()
  entry()

  instruction_start()
  opcodes(is_alt = False)
  balign()
  instruction_end()

  instruction_start_sister()
  write_sister()
  instruction_end_sister()

  # We need to footer sooner so that branch instruction can reach it.
  # TODO: Clean up.
  if arch == "arm64":
    footer()

  instruction_start_alt()
  opcodes(is_alt = True)
  balign()
  instruction_end_alt()

  if arch == "arm64":
    close_cfi()
  else:
    footer()

  out.truncate()

def opcodes(is_alt):
  write_opcode(0, "op_nop", op_nop, is_alt)
  write_opcode(1, "op_move", op_move, is_alt)
  write_opcode(2, "op_move_from16", op_move_from16, is_alt)
  write_opcode(3, "op_move_16", op_move_16, is_alt)
  write_opcode(4, "op_move_wide", op_move_wide, is_alt)
  write_opcode(5, "op_move_wide_from16", op_move_wide_from16, is_alt)
  write_opcode(6, "op_move_wide_16", op_move_wide_16, is_alt)
  write_opcode(7, "op_move_object", op_move_object, is_alt)
  write_opcode(8, "op_move_object_from16", op_move_object_from16, is_alt)
  write_opcode(9, "op_move_object_16", op_move_object_16, is_alt)
  write_opcode(10, "op_move_result", op_move_result, is_alt)
  write_opcode(11, "op_move_result_wide", op_move_result_wide, is_alt)
  write_opcode(12, "op_move_result_object", op_move_result_object, is_alt)
  write_opcode(13, "op_move_exception", op_move_exception, is_alt)
  write_opcode(14, "op_return_void", op_return_void, is_alt)
  write_opcode(15, "op_return", op_return, is_alt)
  write_opcode(16, "op_return_wide", op_return_wide, is_alt)
  write_opcode(17, "op_return_object", op_return_object, is_alt)
  write_opcode(18, "op_const_4", op_const_4, is_alt)
  write_opcode(19, "op_const_16", op_const_16, is_alt)
  write_opcode(20, "op_const", op_const, is_alt)
  write_opcode(21, "op_const_high16", op_const_high16, is_alt)
  write_opcode(22, "op_const_wide_16", op_const_wide_16, is_alt)
  write_opcode(23, "op_const_wide_32", op_const_wide_32, is_alt)
  write_opcode(24, "op_const_wide", op_const_wide, is_alt)
  write_opcode(25, "op_const_wide_high16", op_const_wide_high16, is_alt)
  write_opcode(26, "op_const_string", op_const_string, is_alt)
  write_opcode(27, "op_const_string_jumbo", op_const_string_jumbo, is_alt)
  write_opcode(28, "op_const_class", op_const_class, is_alt)
  write_opcode(29, "op_monitor_enter", op_monitor_enter, is_alt)
  write_opcode(30, "op_monitor_exit", op_monitor_exit, is_alt)
  write_opcode(31, "op_check_cast", op_check_cast, is_alt)
  write_opcode(32, "op_instance_of", op_instance_of, is_alt)
  write_opcode(33, "op_array_length", op_array_length, is_alt)
  write_opcode(34, "op_new_instance", op_new_instance, is_alt)
  write_opcode(35, "op_new_array", op_new_array, is_alt)
  write_opcode(36, "op_filled_new_array", op_filled_new_array, is_alt)
  write_opcode(37, "op_filled_new_array_range", op_filled_new_array_range, is_alt)
  write_opcode(38, "op_fill_array_data", op_fill_array_data, is_alt)
  write_opcode(39, "op_throw", op_throw, is_alt)
  write_opcode(40, "op_goto", op_goto, is_alt)
  write_opcode(41, "op_goto_16", op_goto_16, is_alt)
  write_opcode(42, "op_goto_32", op_goto_32, is_alt)
  write_opcode(43, "op_packed_switch", op_packed_switch, is_alt)
  write_opcode(44, "op_sparse_switch", op_sparse_switch, is_alt)
  write_opcode(45, "op_cmpl_float", op_cmpl_float, is_alt)
  write_opcode(46, "op_cmpg_float", op_cmpg_float, is_alt)
  write_opcode(47, "op_cmpl_double", op_cmpl_double, is_alt)
  write_opcode(48, "op_cmpg_double", op_cmpg_double, is_alt)
  write_opcode(49, "op_cmp_long", op_cmp_long, is_alt)
  write_opcode(50, "op_if_eq", op_if_eq, is_alt)
  write_opcode(51, "op_if_ne", op_if_ne, is_alt)
  write_opcode(52, "op_if_lt", op_if_lt, is_alt)
  write_opcode(53, "op_if_ge", op_if_ge, is_alt)
  write_opcode(54, "op_if_gt", op_if_gt, is_alt)
  write_opcode(55, "op_if_le", op_if_le, is_alt)
  write_opcode(56, "op_if_eqz", op_if_eqz, is_alt)
  write_opcode(57, "op_if_nez", op_if_nez, is_alt)
  write_opcode(58, "op_if_ltz", op_if_ltz, is_alt)
  write_opcode(59, "op_if_gez", op_if_gez, is_alt)
  write_opcode(60, "op_if_gtz", op_if_gtz, is_alt)
  write_opcode(61, "op_if_lez", op_if_lez, is_alt)
  write_opcode(62, "op_unused_3e", op_unused_3e, is_alt)
  write_opcode(63, "op_unused_3f", op_unused_3f, is_alt)
  write_opcode(64, "op_unused_40", op_unused_40, is_alt)
  write_opcode(65, "op_unused_41", op_unused_41, is_alt)
  write_opcode(66, "op_unused_42", op_unused_42, is_alt)
  write_opcode(67, "op_unused_43", op_unused_43, is_alt)
  write_opcode(68, "op_aget", op_aget, is_alt)
  write_opcode(69, "op_aget_wide", op_aget_wide, is_alt)
  write_opcode(70, "op_aget_object", op_aget_object, is_alt)
  write_opcode(71, "op_aget_boolean", op_aget_boolean, is_alt)
  write_opcode(72, "op_aget_byte", op_aget_byte, is_alt)
  write_opcode(73, "op_aget_char", op_aget_char, is_alt)
  write_opcode(74, "op_aget_short", op_aget_short, is_alt)
  write_opcode(75, "op_aput", op_aput, is_alt)
  write_opcode(76, "op_aput_wide", op_aput_wide, is_alt)
  write_opcode(77, "op_aput_object", op_aput_object, is_alt)
  write_opcode(78, "op_aput_boolean", op_aput_boolean, is_alt)
  write_opcode(79, "op_aput_byte", op_aput_byte, is_alt)
  write_opcode(80, "op_aput_char", op_aput_char, is_alt)
  write_opcode(81, "op_aput_short", op_aput_short, is_alt)
  write_opcode(82, "op_iget", op_iget, is_alt)
  write_opcode(83, "op_iget_wide", op_iget_wide, is_alt)
  write_opcode(84, "op_iget_object", op_iget_object, is_alt)
  write_opcode(85, "op_iget_boolean", op_iget_boolean, is_alt)
  write_opcode(86, "op_iget_byte", op_iget_byte, is_alt)
  write_opcode(87, "op_iget_char", op_iget_char, is_alt)
  write_opcode(88, "op_iget_short", op_iget_short, is_alt)
  write_opcode(89, "op_iput", op_iput, is_alt)
  write_opcode(90, "op_iput_wide", op_iput_wide, is_alt)
  write_opcode(91, "op_iput_object", op_iput_object, is_alt)
  write_opcode(92, "op_iput_boolean", op_iput_boolean, is_alt)
  write_opcode(93, "op_iput_byte", op_iput_byte, is_alt)
  write_opcode(94, "op_iput_char", op_iput_char, is_alt)
  write_opcode(95, "op_iput_short", op_iput_short, is_alt)
  write_opcode(96, "op_sget", op_sget, is_alt)
  write_opcode(97, "op_sget_wide", op_sget_wide, is_alt)
  write_opcode(98, "op_sget_object", op_sget_object, is_alt)
  write_opcode(99, "op_sget_boolean", op_sget_boolean, is_alt)
  write_opcode(100, "op_sget_byte", op_sget_byte, is_alt)
  write_opcode(101, "op_sget_char", op_sget_char, is_alt)
  write_opcode(102, "op_sget_short", op_sget_short, is_alt)
  write_opcode(103, "op_sput", op_sput, is_alt)
  write_opcode(104, "op_sput_wide", op_sput_wide, is_alt)
  write_opcode(105, "op_sput_object", op_sput_object, is_alt)
  write_opcode(106, "op_sput_boolean", op_sput_boolean, is_alt)
  write_opcode(107, "op_sput_byte", op_sput_byte, is_alt)
  write_opcode(108, "op_sput_char", op_sput_char, is_alt)
  write_opcode(109, "op_sput_short", op_sput_short, is_alt)
  write_opcode(110, "op_invoke_virtual", op_invoke_virtual, is_alt)
  write_opcode(111, "op_invoke_super", op_invoke_super, is_alt)
  write_opcode(112, "op_invoke_direct", op_invoke_direct, is_alt)
  write_opcode(113, "op_invoke_static", op_invoke_static, is_alt)
  write_opcode(114, "op_invoke_interface", op_invoke_interface, is_alt)
  write_opcode(115, "op_return_void_no_barrier", op_return_void_no_barrier, is_alt)
  write_opcode(116, "op_invoke_virtual_range", op_invoke_virtual_range, is_alt)
  write_opcode(117, "op_invoke_super_range", op_invoke_super_range, is_alt)
  write_opcode(118, "op_invoke_direct_range", op_invoke_direct_range, is_alt)
  write_opcode(119, "op_invoke_static_range", op_invoke_static_range, is_alt)
  write_opcode(120, "op_invoke_interface_range", op_invoke_interface_range, is_alt)
  write_opcode(121, "op_unused_79", op_unused_79, is_alt)
  write_opcode(122, "op_unused_7a", op_unused_7a, is_alt)
  write_opcode(123, "op_neg_int", op_neg_int, is_alt)
  write_opcode(124, "op_not_int", op_not_int, is_alt)
  write_opcode(125, "op_neg_long", op_neg_long, is_alt)
  write_opcode(126, "op_not_long", op_not_long, is_alt)
  write_opcode(127, "op_neg_float", op_neg_float, is_alt)
  write_opcode(128, "op_neg_double", op_neg_double, is_alt)
  write_opcode(129, "op_int_to_long", op_int_to_long, is_alt)
  write_opcode(130, "op_int_to_float", op_int_to_float, is_alt)
  write_opcode(131, "op_int_to_double", op_int_to_double, is_alt)
  write_opcode(132, "op_long_to_int", op_long_to_int, is_alt)
  write_opcode(133, "op_long_to_float", op_long_to_float, is_alt)
  write_opcode(134, "op_long_to_double", op_long_to_double, is_alt)
  write_opcode(135, "op_float_to_int", op_float_to_int, is_alt)
  write_opcode(136, "op_float_to_long", op_float_to_long, is_alt)
  write_opcode(137, "op_float_to_double", op_float_to_double, is_alt)
  write_opcode(138, "op_double_to_int", op_double_to_int, is_alt)
  write_opcode(139, "op_double_to_long", op_double_to_long, is_alt)
  write_opcode(140, "op_double_to_float", op_double_to_float, is_alt)
  write_opcode(141, "op_int_to_byte", op_int_to_byte, is_alt)
  write_opcode(142, "op_int_to_char", op_int_to_char, is_alt)
  write_opcode(143, "op_int_to_short", op_int_to_short, is_alt)
  write_opcode(144, "op_add_int", op_add_int, is_alt)
  write_opcode(145, "op_sub_int", op_sub_int, is_alt)
  write_opcode(146, "op_mul_int", op_mul_int, is_alt)
  write_opcode(147, "op_div_int", op_div_int, is_alt)
  write_opcode(148, "op_rem_int", op_rem_int, is_alt)
  write_opcode(149, "op_and_int", op_and_int, is_alt)
  write_opcode(150, "op_or_int", op_or_int, is_alt)
  write_opcode(151, "op_xor_int", op_xor_int, is_alt)
  write_opcode(152, "op_shl_int", op_shl_int, is_alt)
  write_opcode(153, "op_shr_int", op_shr_int, is_alt)
  write_opcode(154, "op_ushr_int", op_ushr_int, is_alt)
  write_opcode(155, "op_add_long", op_add_long, is_alt)
  write_opcode(156, "op_sub_long", op_sub_long, is_alt)
  write_opcode(157, "op_mul_long", op_mul_long, is_alt)
  write_opcode(158, "op_div_long", op_div_long, is_alt)
  write_opcode(159, "op_rem_long", op_rem_long, is_alt)
  write_opcode(160, "op_and_long", op_and_long, is_alt)
  write_opcode(161, "op_or_long", op_or_long, is_alt)
  write_opcode(162, "op_xor_long", op_xor_long, is_alt)
  write_opcode(163, "op_shl_long", op_shl_long, is_alt)
  write_opcode(164, "op_shr_long", op_shr_long, is_alt)
  write_opcode(165, "op_ushr_long", op_ushr_long, is_alt)
  write_opcode(166, "op_add_float", op_add_float, is_alt)
  write_opcode(167, "op_sub_float", op_sub_float, is_alt)
  write_opcode(168, "op_mul_float", op_mul_float, is_alt)
  write_opcode(169, "op_div_float", op_div_float, is_alt)
  write_opcode(170, "op_rem_float", op_rem_float, is_alt)
  write_opcode(171, "op_add_double", op_add_double, is_alt)
  write_opcode(172, "op_sub_double", op_sub_double, is_alt)
  write_opcode(173, "op_mul_double", op_mul_double, is_alt)
  write_opcode(174, "op_div_double", op_div_double, is_alt)
  write_opcode(175, "op_rem_double", op_rem_double, is_alt)
  write_opcode(176, "op_add_int_2addr", op_add_int_2addr, is_alt)
  write_opcode(177, "op_sub_int_2addr", op_sub_int_2addr, is_alt)
  write_opcode(178, "op_mul_int_2addr", op_mul_int_2addr, is_alt)
  write_opcode(179, "op_div_int_2addr", op_div_int_2addr, is_alt)
  write_opcode(180, "op_rem_int_2addr", op_rem_int_2addr, is_alt)
  write_opcode(181, "op_and_int_2addr", op_and_int_2addr, is_alt)
  write_opcode(182, "op_or_int_2addr", op_or_int_2addr, is_alt)
  write_opcode(183, "op_xor_int_2addr", op_xor_int_2addr, is_alt)
  write_opcode(184, "op_shl_int_2addr", op_shl_int_2addr, is_alt)
  write_opcode(185, "op_shr_int_2addr", op_shr_int_2addr, is_alt)
  write_opcode(186, "op_ushr_int_2addr", op_ushr_int_2addr, is_alt)
  write_opcode(187, "op_add_long_2addr", op_add_long_2addr, is_alt)
  write_opcode(188, "op_sub_long_2addr", op_sub_long_2addr, is_alt)
  write_opcode(189, "op_mul_long_2addr", op_mul_long_2addr, is_alt)
  write_opcode(190, "op_div_long_2addr", op_div_long_2addr, is_alt)
  write_opcode(191, "op_rem_long_2addr", op_rem_long_2addr, is_alt)
  write_opcode(192, "op_and_long_2addr", op_and_long_2addr, is_alt)
  write_opcode(193, "op_or_long_2addr", op_or_long_2addr, is_alt)
  write_opcode(194, "op_xor_long_2addr", op_xor_long_2addr, is_alt)
  write_opcode(195, "op_shl_long_2addr", op_shl_long_2addr, is_alt)
  write_opcode(196, "op_shr_long_2addr", op_shr_long_2addr, is_alt)
  write_opcode(197, "op_ushr_long_2addr", op_ushr_long_2addr, is_alt)
  write_opcode(198, "op_add_float_2addr", op_add_float_2addr, is_alt)
  write_opcode(199, "op_sub_float_2addr", op_sub_float_2addr, is_alt)
  write_opcode(200, "op_mul_float_2addr", op_mul_float_2addr, is_alt)
  write_opcode(201, "op_div_float_2addr", op_div_float_2addr, is_alt)
  write_opcode(202, "op_rem_float_2addr", op_rem_float_2addr, is_alt)
  write_opcode(203, "op_add_double_2addr", op_add_double_2addr, is_alt)
  write_opcode(204, "op_sub_double_2addr", op_sub_double_2addr, is_alt)
  write_opcode(205, "op_mul_double_2addr", op_mul_double_2addr, is_alt)
  write_opcode(206, "op_div_double_2addr", op_div_double_2addr, is_alt)
  write_opcode(207, "op_rem_double_2addr", op_rem_double_2addr, is_alt)
  write_opcode(208, "op_add_int_lit16", op_add_int_lit16, is_alt)
  write_opcode(209, "op_rsub_int", op_rsub_int, is_alt)
  write_opcode(210, "op_mul_int_lit16", op_mul_int_lit16, is_alt)
  write_opcode(211, "op_div_int_lit16", op_div_int_lit16, is_alt)
  write_opcode(212, "op_rem_int_lit16", op_rem_int_lit16, is_alt)
  write_opcode(213, "op_and_int_lit16", op_and_int_lit16, is_alt)
  write_opcode(214, "op_or_int_lit16", op_or_int_lit16, is_alt)
  write_opcode(215, "op_xor_int_lit16", op_xor_int_lit16, is_alt)
  write_opcode(216, "op_add_int_lit8", op_add_int_lit8, is_alt)
  write_opcode(217, "op_rsub_int_lit8", op_rsub_int_lit8, is_alt)
  write_opcode(218, "op_mul_int_lit8", op_mul_int_lit8, is_alt)
  write_opcode(219, "op_div_int_lit8", op_div_int_lit8, is_alt)
  write_opcode(220, "op_rem_int_lit8", op_rem_int_lit8, is_alt)
  write_opcode(221, "op_and_int_lit8", op_and_int_lit8, is_alt)
  write_opcode(222, "op_or_int_lit8", op_or_int_lit8, is_alt)
  write_opcode(223, "op_xor_int_lit8", op_xor_int_lit8, is_alt)
  write_opcode(224, "op_shl_int_lit8", op_shl_int_lit8, is_alt)
  write_opcode(225, "op_shr_int_lit8", op_shr_int_lit8, is_alt)
  write_opcode(226, "op_ushr_int_lit8", op_ushr_int_lit8, is_alt)
  write_opcode(227, "op_iget_quick", op_iget_quick, is_alt)
  write_opcode(228, "op_iget_wide_quick", op_iget_wide_quick, is_alt)
  write_opcode(229, "op_iget_object_quick", op_iget_object_quick, is_alt)
  write_opcode(230, "op_iput_quick", op_iput_quick, is_alt)
  write_opcode(231, "op_iput_wide_quick", op_iput_wide_quick, is_alt)
  write_opcode(232, "op_iput_object_quick", op_iput_object_quick, is_alt)
  write_opcode(233, "op_invoke_virtual_quick", op_invoke_virtual_quick, is_alt)
  write_opcode(234, "op_invoke_virtual_range_quick", op_invoke_virtual_range_quick, is_alt)
  write_opcode(235, "op_iput_boolean_quick", op_iput_boolean_quick, is_alt)
  write_opcode(236, "op_iput_byte_quick", op_iput_byte_quick, is_alt)
  write_opcode(237, "op_iput_char_quick", op_iput_char_quick, is_alt)
  write_opcode(238, "op_iput_short_quick", op_iput_short_quick, is_alt)
  write_opcode(239, "op_iget_boolean_quick", op_iget_boolean_quick, is_alt)
  write_opcode(240, "op_iget_byte_quick", op_iget_byte_quick, is_alt)
  write_opcode(241, "op_iget_char_quick", op_iget_char_quick, is_alt)
  write_opcode(242, "op_iget_short_quick", op_iget_short_quick, is_alt)
  write_opcode(243, "op_unused_f3", op_unused_f3, is_alt)
  write_opcode(244, "op_unused_f4", op_unused_f4, is_alt)
  write_opcode(245, "op_unused_f5", op_unused_f5, is_alt)
  write_opcode(246, "op_unused_f6", op_unused_f6, is_alt)
  write_opcode(247, "op_unused_f7", op_unused_f7, is_alt)
  write_opcode(248, "op_unused_f8", op_unused_f8, is_alt)
  write_opcode(249, "op_unused_f9", op_unused_f9, is_alt)
  write_opcode(250, "op_invoke_polymorphic", op_invoke_polymorphic, is_alt)
  write_opcode(251, "op_invoke_polymorphic_range", op_invoke_polymorphic_range, is_alt)
  write_opcode(252, "op_invoke_custom", op_invoke_custom, is_alt)
  write_opcode(253, "op_invoke_custom_range", op_invoke_custom_range, is_alt)
  write_opcode(254, "op_const_method_handle", op_const_method_handle, is_alt)
  write_opcode(255, "op_const_method_type", op_const_method_type, is_alt)
def write_sister():
  global opnum, opcode
  pass
def alt_stub():
  write_line('''/*''')
  write_line(''' * Inter-instruction transfer stub.  Call out to MterpCheckBefore to handle''')
  write_line(''' * any interesting requests and then jump to the real instruction''')
  write_line(''' * handler.  Note that the call to MterpCheckBefore is done as a tail call.''')
  write_line(''' */''')
  write_line('''    .extern MterpCheckBefore''')
  write_line('''    ldr    xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]            // refresh IBASE.''')
  write_line('''    adr    lr, artMterpAsmInstructionStart + (''' + opnum + ''' * 128)       // Addr of primary handler.''')
  write_line('''    mov    x0, xSELF''')
  write_line('''    add    x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov    x2, xPC''')
  write_line('''    b      MterpCheckBefore     // (self, shadow_frame, dex_pc_ptr) Note: tail call.''')

def bincmp(condition=""):
  write_line('''    /*''')
  write_line('''     * Generic two-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform.''')
  write_line('''     *''')
  write_line('''     * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le''')
  write_line('''     */''')
  write_line('''    /* if-cmp vA, vB, +CCCC */''')
  write_line('''    lsr     w1, wINST, #12              // w1<- B''')
  write_line('''    ubfx    w0, wINST, #8, #4           // w0<- A''')
  write_line('''    GET_VREG w3, w1                     // w3<- vB''')
  write_line('''    GET_VREG w2, w0                     // w2<- vA''')
  write_line('''    FETCH_S wINST, 1                    // wINST<- branch offset, in code units''')
  write_line('''    cmp     w2, w3                      // compare (vA, vB)''')
  write_line('''    b.''' + condition + ''' MterpCommonTakenBranchNoFlags''')
  write_line('''    cmp     wPROFILE, #JIT_CHECK_OSR    // possible OSR re-entry?''')
  write_line('''    b.eq    .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST 2''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def binop(preinstr="", result="w0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = w0 op w1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than w0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (w1).  Useful for integer division and modulus.  Note that we''')
  write_line('''     * *don't* check for (INT_MIN / -1) here, because the ARM math lib''')
  write_line('''     * handles it correctly.''')
  write_line('''     *''')
  write_line('''     * For: add-int, sub-int, mul-int, div-int, rem-int, and-int, or-int,''')
  write_line('''     *      xor-int, shl-int, shr-int, ushr-int, add-float, sub-float,''')
  write_line('''     *      mul-float, div-float, rem-float''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr     w9, wINST, #8               // w9<- AA''')
  write_line('''    lsr     w3, w0, #8                  // w3<- CC''')
  write_line('''    and     w2, w0, #255                // w2<- BB''')
  write_line('''    GET_VREG w1, w3                     // w1<- vCC''')
  write_line('''    GET_VREG w0, w2                     // w0<- vBB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cbz     w1, common_errDivideByZero  // is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           // optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              // ''' + result + '''<- op, w0-w3 changed''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', w9                // vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 11-14 instructions */''')

def binop2addr(preinstr="", result="w0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = w0 op w1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than w0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (w1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,''')
  write_line('''     *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,''')
  write_line('''     *      shl-int/2addr, shr-int/2addr, ushr-int/2addr, add-float/2addr,''')
  write_line('''     *      sub-float/2addr, mul-float/2addr, div-float/2addr, rem-float/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w9, wINST, #8, #4           // w9<- A''')
  write_line('''    GET_VREG w1, w3                     // w1<- vB''')
  write_line('''    GET_VREG w0, w9                     // w0<- vA''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cbz     w1, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           // optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              // ''' + result + '''<- op, w0-w3 changed''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', w9                // vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def binopLit16(preinstr="", result="w0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit16" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = w0 op w1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than w0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (w1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit16, rsub-int, mul-int/lit16, div-int/lit16,''')
  write_line('''     *      rem-int/lit16, and-int/lit16, or-int/lit16, xor-int/lit16''')
  write_line('''     */''')
  write_line('''    /* binop/lit16 vA, vB, #+CCCC */''')
  write_line('''    FETCH_S w1, 1                       // w1<- ssssCCCC (sign-extended)''')
  write_line('''    lsr     w2, wINST, #12              // w2<- B''')
  write_line('''    ubfx    w9, wINST, #8, #4           // w9<- A''')
  write_line('''    GET_VREG w0, w2                     // w0<- vB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cbz     w1, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''''')
  write_line('''    ''' + instr + '''                              // ''' + result + '''<- op, w0-w3 changed''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', w9                // vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def binopLit8(extract="asr     w1, w3, #8", preinstr="", result="w0", chkzero="0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit "lit8" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "result = w0 op w1".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than w0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * You can override "extract" if the extraction of the literal value''')
  write_line('''     * from w3 to w1 is not the default "asr w1, w3, #8". The extraction''')
  write_line('''     * can be omitted completely if the shift is embedded in "instr".''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (w1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-int/lit8, rsub-int/lit8, mul-int/lit8, div-int/lit8,''')
  write_line('''     *      rem-int/lit8, and-int/lit8, or-int/lit8, xor-int/lit8,''')
  write_line('''     *      shl-int/lit8, shr-int/lit8, ushr-int/lit8''')
  write_line('''     */''')
  write_line('''    /* binop/lit8 vAA, vBB, #+CC */''')
  write_line('''    FETCH_S w3, 1                       // w3<- ssssCCBB (sign-extended for CC)''')
  write_line('''    lsr     w9, wINST, #8               // w9<- AA''')
  write_line('''    and     w2, w3, #255                // w2<- BB''')
  write_line('''    GET_VREG w0, w2                     // w0<- vBB''')
  write_line('''    ''' + extract + '''                            // optional; typically w1<- ssssssCC (sign extended)''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cbz     w1, common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''                           // optional op; may set condition codes''')
  write_line('''    ''' + instr + '''                              // ''' + result + '''<- op, w0-w3 changed''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG ''' + result + ''', w9                // vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 10-12 instructions */''')

def binopWide(preinstr="", instr="add x0, x1, x2", result="x0", r1="x1", r2="x2", chkzero="0"):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit binary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = x1 op x2".''')
  write_line('''     * This could be an ARM instruction or a function call.  (If the result''')
  write_line('''     * comes back in a register other than x0, you can override "result".)''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (w1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-long, sub-long, mul-long, div-long, rem-long, and-long, or-long,''')
  write_line('''     *      xor-long, add-double, sub-double, mul-double, div-double, rem-double''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr     w4, wINST, #8               // w4<- AA''')
  write_line('''    lsr     w2, w0, #8                  // w2<- CC''')
  write_line('''    and     w1, w0, #255                // w1<- BB''')
  write_line('''    GET_VREG_WIDE ''' + r2 + ''', w2               // w2<- vCC''')
  write_line('''    GET_VREG_WIDE ''' + r1 + ''', w1               // w1<- vBB''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cbz     ''' + r2 + ''', common_errDivideByZero  // is second operand zero?''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''''')
  write_line('''    ''' + instr + '''                              // ''' + result + '''<- op, w0-w4 changed''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE ''' + result + ''', w4           // vAA<- ''' + result + '''''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 11-14 instructions */''')

def binopWide2addr(preinstr="", instr="add x0, x0, x1", r0="x0", r1="x1", chkzero="0"):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line('''     * that specifies an instruction that performs "x0 = x0 op x1".''')
  write_line('''     * This must not be a function call, as we keep w2 live across it.''')
  write_line('''     *''')
  write_line('''     * If "chkzero" is set to 1, we perform a divide-by-zero check on''')
  write_line('''     * vCC (w1).  Useful for integer division and modulus.''')
  write_line('''     *''')
  write_line('''     * For: add-long/2addr, sub-long/2addr, mul-long/2addr, div-long/2addr,''')
  write_line('''     *      and-long/2addr, or-long/2addr, xor-long/2addr,''')
  write_line('''     *      shl-long/2addr, shr-long/2addr, ushr-long/2addr, add-double/2addr,''')
  write_line('''     *      sub-double/2addr, mul-double/2addr, div-double/2addr, rem-double/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    lsr     w1, wINST, #12              // w1<- B''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    GET_VREG_WIDE ''' + r1 + ''', w1               // x1<- vB''')
  write_line('''    GET_VREG_WIDE ''' + r0 + ''', w2               // x0<- vA''')
  write_line('''    .if ''' + chkzero + '''''')
  write_line('''    cbz     ''' + r1 + ''', common_errDivideByZero''')
  write_line('''    .endif''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    ''' + preinstr + '''''')
  write_line('''    ''' + instr + '''                              // result<- op''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE ''' + r0 + ''', w2               // vAA<- result''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def close_cfi():
  write_line('''// Close out the cfi info.  We're treating mterp as a single function.''')
  write_line('''''')
  write_line('''END ExecuteMterpImpl''')
  write_line('''''')

def const(helper="UndefinedConstHandler"):
  write_line('''    /* const/class vAA, type@BBBB */''')
  write_line('''    /* const/method-handle vAA, method_handle@BBBB */''')
  write_line('''    /* const/method-type vAA, proto@BBBB */''')
  write_line('''    /* const/string vAA, string@@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH w0, 1                         // w0<- BBBB''')
  write_line('''    lsr     w1, wINST, #8               // w1<- AA''')
  write_line('''    add     x2, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x3, xSELF''')
  write_line('''    bl      ''' + helper + '''                     // (index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST 2                     // load rINST''')
  write_line('''    cbnz    w0, MterpPossibleException  // let reference interpreter deal with it.''')
  write_line('''    ADVANCE 2                           // advance rPC''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def entry():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Interpreter entry point.''')
  write_line(''' * On entry:''')
  write_line(''' *  x0  Thread* self/''')
  write_line(''' *  x1  insns_''')
  write_line(''' *  x2  ShadowFrame''')
  write_line(''' *  x3  JValue* result_register''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''ENTRY ExecuteMterpImpl''')
  write_line('''    SAVE_TWO_REGS_INCREASE_FRAME xPROFILE, x27, 80''')
  write_line('''    SAVE_TWO_REGS                xIBASE, xREFS, 16''')
  write_line('''    SAVE_TWO_REGS                xSELF, xINST, 32''')
  write_line('''    SAVE_TWO_REGS                xPC, xFP, 48''')
  write_line('''    SAVE_TWO_REGS                fp, lr, 64''')
  write_line('''    add     fp, sp, #64''')
  write_line('''''')
  write_line('''    /* Remember the return register */''')
  write_line('''    str     x3, [x2, #SHADOWFRAME_RESULT_REGISTER_OFFSET]''')
  write_line('''''')
  write_line('''    /* Remember the dex instruction pointer */''')
  write_line('''    str     x1, [x2, #SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET]''')
  write_line('''''')
  write_line('''    /* set up "named" registers */''')
  write_line('''    mov     xSELF, x0''')
  write_line('''    ldr     w0, [x2, #SHADOWFRAME_NUMBER_OF_VREGS_OFFSET]''')
  write_line('''    add     xFP, x2, #SHADOWFRAME_VREGS_OFFSET     // point to vregs.''')
  write_line('''    add     xREFS, xFP, w0, lsl #2                 // point to reference array in shadow frame''')
  write_line('''    ldr     w0, [x2, #SHADOWFRAME_DEX_PC_OFFSET]   // Get starting dex_pc.''')
  write_line('''    add     xPC, x1, w0, lsl #1                    // Create direct pointer to 1st dex opcode''')
  write_line('''    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)''')
  write_line('''    EXPORT_PC''')
  write_line('''''')
  write_line('''    /* Starting ibase */''')
  write_line('''    ldr     xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]''')
  write_line('''''')
  write_line('''    /* Set up for backwards branches & osr profiling */''')
  write_line('''    ldr     x0, [xFP, #OFF_FP_METHOD]''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x2, xSELF''')
  write_line('''    bl      MterpSetUpHotnessCountdown''')
  write_line('''    mov     wPROFILE, w0                // Starting hotness countdown to xPROFILE''')
  write_line('''''')
  write_line('''    /* start executing the instruction at rPC */''')
  write_line('''    FETCH_INST                          // load wINST from rPC''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* NOTE: no fallthrough */''')

def fallback():
  write_line('''/* Transfer stub to alternate interpreter */''')
  write_line('''    b    MterpFallback''')
  write_line('''''')

def fbinop(instr=""):
  write_line('''    /*:''')
  write_line('''     * Generic 32-bit floating-point operation.''')
  write_line('''     *''')
  write_line('''     * For: add-float, sub-float, mul-float, div-float''')
  write_line('''     * form: <op> s0, s0, s1''')
  write_line('''     */''')
  write_line('''    /* floatop vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // r0<- CCBB''')
  write_line('''    lsr     w1, w0, #8                  // r2<- CC''')
  write_line('''    and     w0, w0, #255                // r1<- BB''')
  write_line('''    GET_VREG  s1, w1''')
  write_line('''    GET_VREG  s0, w0''')
  write_line('''    ''' + instr + '''                              // s0<- op''')
  write_line('''    lsr     w1, wINST, #8               // r1<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG  s0, w1''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def fbinop2addr(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit floating point "/2addr" binary operation.  Provide''')
  write_line('''     * an "instr" line that specifies an instruction that performs''')
  write_line('''     * "s2 = s0 op s1".''')
  write_line('''     *''')
  write_line('''     * For: add-float/2addr, sub-float/2addr, mul-float/2addr, div-float/2addr''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w9, wINST, #8, #4           // w9<- A''')
  write_line('''    GET_VREG s1, w3''')
  write_line('''    GET_VREG s0, w9''')
  write_line('''    ''' + instr + '''                              // s2<- op''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG s2, w9''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def fcmp(wide="", r1="s1", r2="s2", cond="lt"):
  write_line('''    /*''')
  write_line('''     * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line('''     * destination register based on the results of the comparison.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr     w4, wINST, #8               // w4<- AA''')
  write_line('''    and     w2, w0, #255                // w2<- BB''')
  write_line('''    lsr     w3, w0, #8                  // w3<- CC''')
  write_line('''    GET_VREG''' + wide + ''' ''' + r1 + ''', w2''')
  write_line('''    GET_VREG''' + wide + ''' ''' + r2 + ''', w3''')
  write_line('''    fcmp ''' + r1 + ''', ''' + r2 + '''''')
  write_line('''    cset w0, ne''')
  write_line('''    cneg w0, w0, ''' + cond + '''''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG w0, w4                     // vAA<- w0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def field(helper=""):
  write_line('''    /*''')
  write_line('''     * General field read / write (iget-* iput-* sget-* sput-*).''')
  write_line('''     */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    mov      x0, xPC                       // arg0: Instruction* inst''')
  write_line('''    mov      x1, xINST                     // arg1: uint16_t inst_data''')
  write_line('''    add      x2, xFP, #OFF_FP_SHADOWFRAME  // arg2: ShadowFrame* sf''')
  write_line('''    mov      x3, xSELF                     // arg3: Thread* self''')
  write_line('''    PREFETCH_INST 2                        // prefetch next opcode''')
  write_line('''    bl       ''' + helper + '''''')
  write_line('''    cbz      x0, MterpPossibleException''')
  write_line('''    ADVANCE 2''')
  write_line('''    GET_INST_OPCODE ip                     // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                         // jump to next instruction''')

def footer():
  write_line('''/*''')
  write_line(''' * ===========================================================================''')
  write_line(''' *  Common subroutines and data''')
  write_line(''' * ===========================================================================''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We've detected a condition that will result in an exception, but the exception''')
  write_line(''' * has not yet been thrown.  Just bail out to the reference interpreter to deal with it.''')
  write_line(''' * TUNING: for consistency, we may want to just go ahead and handle these here.''')
  write_line(''' */''')
  write_line('''common_errDivideByZero:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogDivideByZeroException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errArrayIndex:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogArrayIndexException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNegativeArraySize:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogNegativeArraySizeException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNoSuchMethod:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogNoSuchMethodException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNullObject:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogNullObjectException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''common_exceptionThrown:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogExceptionThrownException''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''MterpSuspendFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    ldr  x2, [xSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    bl MterpLogSuspendFallback''')
  write_line('''#endif''')
  write_line('''    b MterpCommonFallback''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * If we're here, something is out of the ordinary.  If there is a pending''')
  write_line(''' * exception, handle it.  Otherwise, roll back and retry with the reference''')
  write_line(''' * interpreter.''')
  write_line(''' */''')
  write_line('''MterpPossibleException:''')
  write_line('''    ldr     x0, [xSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    cbz     x0, MterpFallback                       // If not, fall back to reference interpreter.''')
  write_line('''    /* intentional fallthrough - handle pending exception. */''')
  write_line('''/*''')
  write_line(''' * On return from a runtime helper routine, we've found a pending exception.''')
  write_line(''' * Can we handle it here - or need to bail out to caller?''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpException:''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl      MterpHandleException                    // (self, shadow_frame)''')
  write_line('''    cbz     w0, MterpExceptionReturn                // no local catch, back to caller.''')
  write_line('''    ldr     x0, [xFP, #OFF_FP_DEX_INSTRUCTIONS]''')
  write_line('''    ldr     w1, [xFP, #OFF_FP_DEX_PC]''')
  write_line('''    ldr     xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]''')
  write_line('''    add     xPC, x0, x1, lsl #1                     // generate new dex_pc_ptr''')
  write_line('''    /* Do we need to switch interpreters? */''')
  write_line('''    bl      MterpShouldSwitchInterpreters''')
  write_line('''    cbnz    w0, MterpFallback''')
  write_line('''    /* resume execution at catch block */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH_INST''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip''')
  write_line('''    /* NOTE: no fallthrough */''')
  write_line('''/*''')
  write_line(''' * Common handling for branches with support for Jit profiling.''')
  write_line(''' * On entry:''')
  write_line(''' *    wINST          <= signed offset''')
  write_line(''' *    wPROFILE       <= signed hotness countdown (expanded to 32 bits)''')
  write_line(''' *    condition bits <= set to establish sign of offset (use "NoFlags" entry if not)''')
  write_line(''' *''')
  write_line(''' * We have quite a few different cases for branch profiling, OSR detection and''')
  write_line(''' * suspend check support here.''')
  write_line(''' *''')
  write_line(''' * Taken backward branches:''')
  write_line(''' *    If profiling active, do hotness countdown and report if we hit zero.''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *    Is there a pending suspend request?  If so, suspend.''')
  write_line(''' *''')
  write_line(''' * Taken forward branches and not-taken backward branches:''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *''')
  write_line(''' * Our most common case is expected to be a taken backward branch with active jit profiling,''')
  write_line(''' * but no full OSR check and no pending suspend request.''')
  write_line(''' * Next most common case is not-taken branch with no full OSR check.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpCommonTakenBranchNoFlags:''')
  write_line('''    cmp     wINST, #0''')
  write_line('''    b.gt    .L_forward_branch           // don't add forward branches to hotness''')
  write_line('''    tbnz    wPROFILE, #31, .L_no_count_backwards  // go if negative''')
  write_line('''    subs    wPROFILE, wPROFILE, #1      // countdown''')
  write_line('''    b.eq    .L_add_batch                // counted down to zero - report''')
  write_line('''.L_resume_backward_branch:''')
  write_line('''    ldr     lr, [xSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    add     w2, wINST, wINST            // w2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB w2            // update rPC, load wINST''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    ands    lr, lr, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    b.ne    .L_suspend_request_pending''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''''')
  write_line('''.L_suspend_request_pending:''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    bl      MterpSuspendCheck           // (self)''')
  write_line('''    cbnz    x0, MterpFallback''')
  write_line('''    REFRESH_IBASE                       // might have changed during suspend''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''''')
  write_line('''.L_no_count_backwards:''')
  write_line('''    cmp     wPROFILE, #JIT_CHECK_OSR    // possible OSR re-entry?''')
  write_line('''    b.ne    .L_resume_backward_branch''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x2, xINST''')
  write_line('''    EXPORT_PC''')
  write_line('''    bl      MterpMaybeDoOnStackReplacement  // (self, shadow_frame, offset)''')
  write_line('''    cbnz    x0, MterpOnStackReplacement''')
  write_line('''    b       .L_resume_backward_branch''')
  write_line('''''')
  write_line('''.L_forward_branch:''')
  write_line('''    cmp     wPROFILE, #JIT_CHECK_OSR    // possible OSR re-entry?''')
  write_line('''    b.eq    .L_check_osr_forward''')
  write_line('''.L_resume_forward_branch:''')
  write_line('''    add     w2, wINST, wINST            // w2<- byte offset''')
  write_line('''    FETCH_ADVANCE_INST_RB w2            // update rPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''''')
  write_line('''.L_check_osr_forward:''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x2, xINST''')
  write_line('''    EXPORT_PC''')
  write_line('''    bl      MterpMaybeDoOnStackReplacement  // (self, shadow_frame, offset)''')
  write_line('''    cbnz    x0, MterpOnStackReplacement''')
  write_line('''    b       .L_resume_forward_branch''')
  write_line('''''')
  write_line('''.L_add_batch:''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    strh    wPROFILE, [x1, #SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET]''')
  write_line('''    ldr     x0, [xFP, #OFF_FP_METHOD]''')
  write_line('''    mov     x2, xSELF''')
  write_line('''    bl      MterpAddHotnessBatch        // (method, shadow_frame, self)''')
  write_line('''    mov     wPROFILE, w0                // restore new hotness countdown to wPROFILE''')
  write_line('''    b       .L_no_count_backwards''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Entered from the conditional branch handlers when OSR check request active on''')
  write_line(''' * not-taken path.  All Dalvik not-taken conditional branch offsets are 2.''')
  write_line(''' */''')
  write_line('''.L_check_not_taken_osr:''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x2, #2''')
  write_line('''    EXPORT_PC''')
  write_line('''    bl      MterpMaybeDoOnStackReplacement  // (self, shadow_frame, offset)''')
  write_line('''    cbnz    x0, MterpOnStackReplacement''')
  write_line('''    FETCH_ADVANCE_INST 2''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Check for suspend check request.  Assumes wINST already loaded, xPC advanced and''')
  write_line(''' * still needs to get the opcode and branch to it, and flags are in lr.''')
  write_line(''' */''')
  write_line('''MterpCheckSuspendAndContinue:''')
  write_line('''    ldr     xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]  // refresh xIBASE''')
  write_line('''    ands    w7, w7, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    b.ne    check1''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''check1:''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    bl      MterpSuspendCheck           // (self)''')
  write_line('''    cbnz    x0, MterpFallback           // Something in the environment changed, switch interpreters''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On-stack replacement has happened, and now we've returned from the compiled method.''')
  write_line(''' */''')
  write_line('''MterpOnStackReplacement:''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    sxtw x2, wINST''')
  write_line('''    bl MterpLogOSR''')
  write_line('''#endif''')
  write_line('''    mov  x0, #1                         // Signal normal return''')
  write_line('''    b    MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Bail out to reference interpreter.''')
  write_line(''' */''')
  write_line('''MterpFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    mov  x0, xSELF''')
  write_line('''    add  x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    bl MterpLogFallback''')
  write_line('''#endif''')
  write_line('''MterpCommonFallback:''')
  write_line('''    mov     x0, #0                                  // signal retry with reference interpreter.''')
  write_line('''    b       MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We pushed some registers on the stack in ExecuteMterpImpl, then saved''')
  write_line(''' * SP and LR.  Here we restore SP, restore the registers, and then restore''')
  write_line(''' * LR to PC.''')
  write_line(''' *''')
  write_line(''' * On entry:''')
  write_line(''' *  uint32_t* xFP  (should still be live, pointer to base of vregs)''')
  write_line(''' */''')
  write_line('''MterpExceptionReturn:''')
  write_line('''    mov     x0, #1                                  // signal return to caller.''')
  write_line('''    b MterpDone''')
  write_line('''MterpReturn:''')
  write_line('''    ldr     x2, [xFP, #OFF_FP_RESULT_REGISTER]''')
  write_line('''    str     x0, [x2]''')
  write_line('''    mov     x0, #1                                  // signal return to caller.''')
  write_line('''MterpDone:''')
  write_line('''/*''')
  write_line(''' * At this point, we expect wPROFILE to be non-zero.  If negative, hotness is disabled or we're''')
  write_line(''' * checking for OSR.  If greater than zero, we might have unreported hotness to register''')
  write_line(''' * (the difference between the ending wPROFILE and the cached hotness counter).  wPROFILE''')
  write_line(''' * should only reach zero immediately after a hotness decrement, and is then reset to either''')
  write_line(''' * a negative special state or the new non-zero countdown value.''')
  write_line(''' */''')
  write_line('''    cmp     wPROFILE, #0''')
  write_line('''    bgt     MterpProfileActive                      // if > 0, we may have some counts to report.''')
  write_line('''    .cfi_remember_state''')
  write_line('''    RESTORE_TWO_REGS                fp, lr, 64''')
  write_line('''    RESTORE_TWO_REGS                xPC, xFP, 48''')
  write_line('''    RESTORE_TWO_REGS                xSELF, xINST, 32''')
  write_line('''    RESTORE_TWO_REGS                xIBASE, xREFS, 16''')
  write_line('''    RESTORE_TWO_REGS_DECREASE_FRAME xPROFILE, x27, 80''')
  write_line('''    ret''')
  write_line('''    .cfi_restore_state                              // Reset unwind info so following code unwinds.''')
  write_line('''    .cfi_def_cfa_offset 80                          // workaround for clang bug: 31975598''')
  write_line('''''')
  write_line('''MterpProfileActive:''')
  write_line('''    mov     xINST, x0                               // stash return value''')
  write_line('''    /* Report cached hotness counts */''')
  write_line('''    ldr     x0, [xFP, #OFF_FP_METHOD]''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x2, xSELF''')
  write_line('''    strh    wPROFILE, [x1, #SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET]''')
  write_line('''    bl      MterpAddHotnessBatch                    // (method, shadow_frame, self)''')
  write_line('''    mov     x0, xINST                               // restore return value''')
  write_line('''    RESTORE_TWO_REGS                fp, lr, 64''')
  write_line('''    RESTORE_TWO_REGS                xPC, xFP, 48''')
  write_line('''    RESTORE_TWO_REGS                xSELF, xINST, 32''')
  write_line('''    RESTORE_TWO_REGS                xIBASE, xREFS, 16''')
  write_line('''    RESTORE_TWO_REGS_DECREASE_FRAME xPROFILE, x27, 80''')
  write_line('''    ret''')
  write_line('''''')

def funopNarrow(srcreg="s0", tgtreg="d0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32bit-to-32bit floating point unary operation.  Provide an''')
  write_line('''     * "instr" line that specifies an instruction that performs "''' + tgtreg + ''' = op ''' + srcreg + '''".''')
  write_line('''     *''')
  write_line('''     * For: int-to-float, float-to-int''')
  write_line('''     * TODO: refactor all of the conversions - parameterize width and use same template.''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w4, wINST, #8, #4           // w4<- A''')
  write_line('''    GET_VREG ''' + srcreg + ''', w3''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    ''' + instr + '''                              // d0<- op''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG ''' + tgtreg + ''', w4                // vA<- d0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def funopNarrower(srcreg="s0", tgtreg="d0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64bit-to-32bit floating point unary operation.  Provide an''')
  write_line('''     * "instr" line that specifies an instruction that performs "''' + tgtreg + ''' = op ''' + srcreg + '''".''')
  write_line('''     *''')
  write_line('''     * For: int-to-double, float-to-double, float-to-long''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w4, wINST, #8, #4           // w4<- A''')
  write_line('''    GET_VREG_WIDE ''' + srcreg + ''', w3''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    ''' + instr + '''                              // d0<- op''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG ''' + tgtreg + ''', w4                // vA<- d0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def funopWide(srcreg="s0", tgtreg="d0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 64bit-to-64bit floating point unary operation.  Provide an''')
  write_line('''     * "instr" line that specifies an instruction that performs "''' + tgtreg + ''' = op ''' + srcreg + '''".''')
  write_line('''     *''')
  write_line('''     * For: long-to-double, double-to-long''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w4, wINST, #8, #4           // w4<- A''')
  write_line('''    GET_VREG_WIDE ''' + srcreg + ''', w3''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    ''' + instr + '''                              // d0<- op''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE ''' + tgtreg + ''', w4           // vA<- d0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def funopWider(srcreg="s0", tgtreg="d0", instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32bit-to-64bit floating point unary operation.  Provide an''')
  write_line('''     * "instr" line that specifies an instruction that performs "''' + tgtreg + ''' = op ''' + srcreg + '''".''')
  write_line('''     *''')
  write_line('''     * For: int-to-double, float-to-double, float-to-long''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w4, wINST, #8, #4           // w4<- A''')
  write_line('''    GET_VREG ''' + srcreg + ''', w3''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    ''' + instr + '''                              // d0<- op''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE ''' + tgtreg + ''', w4           // vA<- d0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def header():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''  Art assembly interpreter notes:''')
  write_line('''''')
  write_line('''  First validate assembly code by implementing ExecuteXXXImpl() style body (doesn't''')
  write_line('''  handle invoke, allows higher-level code to create frame & shadow frame.''')
  write_line('''''')
  write_line('''  Once that's working, support direct entry code & eliminate shadow frame (and''')
  write_line('''  excess locals allocation.''')
  write_line('''''')
  write_line('''  Some (hopefully) temporary ugliness.  We'll treat xFP as pointing to the''')
  write_line('''  base of the vreg array within the shadow frame.  Access the other fields,''')
  write_line('''  dex_pc_, method_ and number_of_vregs_ via negative offsets.  For now, we'll continue''')
  write_line('''  the shadow frame mechanism of double-storing object references - via xFP &''')
  write_line('''  number_of_vregs_.''')
  write_line('''''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''ARM64 Runtime register usage conventions.''')
  write_line('''''')
  write_line('''  r0     : w0 is 32-bit return register and x0 is 64-bit.''')
  write_line('''  r0-r7  : Argument registers.''')
  write_line('''  r8-r15 : Caller save registers (used as temporary registers).''')
  write_line('''  r16-r17: Also known as ip0-ip1, respectively. Used as scratch registers by''')
  write_line('''           the linker, by the trampolines and other stubs (the backend uses''')
  write_line('''           these as temporary registers).''')
  write_line('''  r18    : Caller save register (used as temporary register).''')
  write_line('''  r19    : Pointer to thread-local storage.''')
  write_line('''  r20-r29: Callee save registers.''')
  write_line('''  r30    : (lr) is reserved (the link register).''')
  write_line('''  rsp    : (sp) is reserved (the stack pointer).''')
  write_line('''  rzr    : (zr) is reserved (the zero register).''')
  write_line('''''')
  write_line('''  Floating-point registers''')
  write_line('''  v0-v31''')
  write_line('''''')
  write_line('''  v0     : s0 is return register for singles (32-bit) and d0 for doubles (64-bit).''')
  write_line('''           This is analogous to the C/C++ (hard-float) calling convention.''')
  write_line('''  v0-v7  : Floating-point argument registers in both Dalvik and C/C++ conventions.''')
  write_line('''           Also used as temporary and codegen scratch registers.''')
  write_line('''''')
  write_line('''  v0-v7 and v16-v31 : trashed across C calls.''')
  write_line('''  v8-v15 : bottom 64-bits preserved across C calls (d8-d15 are preserved).''')
  write_line('''''')
  write_line('''  v16-v31: Used as codegen temp/scratch.''')
  write_line('''  v8-v15 : Can be used for promotion.''')
  write_line('''''')
  write_line('''  Must maintain 16-byte stack alignment.''')
  write_line('''''')
  write_line('''Mterp notes:''')
  write_line('''''')
  write_line('''The following registers have fixed assignments:''')
  write_line('''''')
  write_line('''  reg nick      purpose''')
  write_line('''  x20  xPC       interpreted program counter, used for fetching instructions''')
  write_line('''  x21  xFP       interpreted frame pointer, used for accessing locals and args''')
  write_line('''  x22  xSELF     self (Thread) pointer''')
  write_line('''  x23  xINST     first 16-bit code unit of current instruction''')
  write_line('''  x24  xIBASE    interpreted instruction base pointer, used for computed goto''')
  write_line('''  x25  xREFS     base of object references in shadow frame  (ideally, we'll get rid of this later).''')
  write_line('''  x26  wPROFILE  jit profile hotness countdown''')
  write_line('''  x16  ip        scratch reg''')
  write_line('''  x17  ip2       scratch reg (used by macros)''')
  write_line('''''')
  write_line('''Macros are provided for common operations.  They MUST NOT alter unspecified registers or condition''')
  write_line('''codes.''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * This is a #include, not a %include, because we want the C pre-processor''')
  write_line(''' * to expand the macros into assembler assignment statements.''')
  write_line(''' */''')
  write_line('''#include "asm_support.h"''')
  write_line('''#include "interpreter/cfi_asm_support.h"''')
  write_line('''''')
  write_line('''#define MTERP_PROFILE_BRANCHES 1''')
  write_line('''#define MTERP_LOGGING 0''')
  write_line('''''')
  write_line('''/* During bringup, we'll use the shadow frame model instead of xFP */''')
  write_line('''/* single-purpose registers, given names for clarity */''')
  write_line('''#define xPC      x20''')
  write_line('''#define CFI_DEX  20 // DWARF register number of the register holding dex-pc (xPC).''')
  write_line('''#define CFI_TMP  0  // DWARF register number of the first argument register (r0).''')
  write_line('''#define xFP      x21''')
  write_line('''#define xSELF    x22''')
  write_line('''#define xINST    x23''')
  write_line('''#define wINST    w23''')
  write_line('''#define xIBASE   x24''')
  write_line('''#define xREFS    x25''')
  write_line('''#define wPROFILE w26''')
  write_line('''#define xPROFILE x26''')
  write_line('''#define ip       x16''')
  write_line('''#define ip2      x17''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Instead of holding a pointer to the shadow frame, we keep xFP at the base of the vregs.  So,''')
  write_line(''' * to access other shadow frame fields, we need to use a backwards offset.  Define those here.''')
  write_line(''' */''')
  write_line('''#define OFF_FP(a) (a - SHADOWFRAME_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_NUMBER_OF_VREGS OFF_FP(SHADOWFRAME_NUMBER_OF_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC OFF_FP(SHADOWFRAME_DEX_PC_OFFSET)''')
  write_line('''#define OFF_FP_LINK OFF_FP(SHADOWFRAME_LINK_OFFSET)''')
  write_line('''#define OFF_FP_METHOD OFF_FP(SHADOWFRAME_METHOD_OFFSET)''')
  write_line('''#define OFF_FP_RESULT_REGISTER OFF_FP(SHADOWFRAME_RESULT_REGISTER_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC_PTR OFF_FP(SHADOWFRAME_DEX_PC_PTR_OFFSET)''')
  write_line('''#define OFF_FP_DEX_INSTRUCTIONS OFF_FP(SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET)''')
  write_line('''#define OFF_FP_SHADOWFRAME OFF_FP(0)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * "export" the PC to dex_pc field in the shadow frame, f/b/o future exception objects.  Must''')
  write_line(''' * be done *before* something throws.''')
  write_line(''' *''')
  write_line(''' * It's okay to do this more than once.''')
  write_line(''' *''')
  write_line(''' * NOTE: the fast interpreter keeps track of dex pc as a direct pointer to the mapped''')
  write_line(''' * dex byte codes.  However, the rest of the runtime expects dex pc to be an instruction''')
  write_line(''' * offset into the code_items_[] array.  For effiency, we will "export" the''')
  write_line(''' * current dex pc as a direct pointer using the EXPORT_PC macro, and rely on GetDexPC''')
  write_line(''' * to convert to a dex pc when needed.''')
  write_line(''' */''')
  write_line('''.macro EXPORT_PC''')
  write_line('''    str  xPC, [xFP, #OFF_FP_DEX_PC_PTR]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from xPC into wINST.  Does not advance xPC.''')
  write_line(''' */''')
  write_line('''.macro FETCH_INST''')
  write_line('''    ldrh    wINST, [xPC]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from the specified offset.  Advances xPC''')
  write_line(''' * to point to the next instruction.  "_count" is in 16-bit code units.''')
  write_line(''' *''')
  write_line(''' * Because of the limited size of immediate constants on ARM, this is only''')
  write_line(''' * suitable for small forward movements (i.e. don't try to implement "goto"''')
  write_line(''' * with this).''')
  write_line(''' *''')
  write_line(''' * This must come AFTER anything that can throw an exception, or the''')
  write_line(''' * exception catch may miss.  (This also implies that it must come after''')
  write_line(''' * EXPORT_PC.)''')
  write_line(''' */''')
  write_line('''.macro FETCH_ADVANCE_INST count''')
  write_line('''    ldrh    wINST, [xPC, #((\\count)*2)]!''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * The operation performed here is similar to FETCH_ADVANCE_INST, except the''')
  write_line(''' * src and dest registers are parameterized (not hard-wired to xPC and xINST).''')
  write_line(''' */''')
  write_line('''.macro PREFETCH_ADVANCE_INST dreg, sreg, count''')
  write_line('''    ldrh    \\dreg, [\\sreg, #((\\count)*2)]!''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Similar to FETCH_ADVANCE_INST, but does not update xPC.  Used to load''')
  write_line(''' * xINST ahead of possible exception point.  Be sure to manually advance xPC''')
  write_line(''' * later.''')
  write_line(''' */''')
  write_line('''.macro PREFETCH_INST count''')
  write_line('''    ldrh    wINST, [xPC, #((\\count)*2)]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/* Advance xPC by some number of code units. */''')
  write_line('''.macro ADVANCE count''')
  write_line('''  add  xPC, xPC, #((\\count)*2)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from an offset specified by _reg and advance xPC.''')
  write_line(''' * xPC to point to the next instruction.  "_reg" must specify the distance''')
  write_line(''' * in bytes, *not* 16-bit code units, and may be a signed value.  Must not set flags.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''.macro FETCH_ADVANCE_INST_RB reg''')
  write_line('''    add     xPC, xPC, \\reg, sxtw''')
  write_line('''    ldrh    wINST, [xPC]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch a half-word code unit from an offset past the current PC.  The''')
  write_line(''' * "_count" value is in 16-bit code units.  Does not advance xPC.''')
  write_line(''' *''')
  write_line(''' * The "_S" variant works the same but treats the value as signed.''')
  write_line(''' */''')
  write_line('''.macro FETCH reg, count''')
  write_line('''    ldrh    \\reg, [xPC, #((\\count)*2)]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro FETCH_S reg, count''')
  write_line('''    ldrsh   \\reg, [xPC, #((\\count)*2)]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch one byte from an offset past the current PC.  Pass in the same''')
  write_line(''' * "_count" as you would for FETCH, and an additional 0/1 indicating which''')
  write_line(''' * byte of the halfword you want (lo/hi).''')
  write_line(''' */''')
  write_line('''.macro FETCH_B reg, count, byte''')
  write_line('''    ldrb     \\reg, [xPC, #((\\count)*2+(\\byte))]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Put the instruction's opcode field into the specified register.''')
  write_line(''' */''')
  write_line('''.macro GET_INST_OPCODE reg''')
  write_line('''    and     \\reg, xINST, #255''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Put the prefetched instruction's opcode field into the specified register.''')
  write_line(''' */''')
  write_line('''.macro GET_PREFETCHED_OPCODE oreg, ireg''')
  write_line('''    and     \\oreg, \\ireg, #255''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Begin executing the opcode in _reg.  Clobbers reg''')
  write_line(''' */''')
  write_line('''''')
  write_line('''.macro GOTO_OPCODE reg''')
  write_line('''    add     \\reg, xIBASE, \\reg, lsl #''' + handler_size_bits + '''''')
  write_line('''    br      \\reg''')
  write_line('''.endm''')
  write_line('''.macro GOTO_OPCODE_BASE base,reg''')
  write_line('''    add     \\reg, \\base, \\reg, lsl #''' + handler_size_bits + '''''')
  write_line('''    br      \\reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 32-bit value from a Dalvik register.''')
  write_line(''' */''')
  write_line('''.macro GET_VREG reg, vreg''')
  write_line('''    ldr     \\reg, [xFP, \\vreg, uxtw #2]''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG reg, vreg''')
  write_line('''    str     \\reg, [xFP, \\vreg, uxtw #2]''')
  write_line('''    str     wzr, [xREFS, \\vreg, uxtw #2]''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_OBJECT reg, vreg, tmpreg''')
  write_line('''    str     \\reg, [xFP, \\vreg, uxtw #2]''')
  write_line('''    str     \\reg, [xREFS, \\vreg, uxtw #2]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 64-bit value from a Dalvik register.''')
  write_line(''' * TUNING: can we do better here?''')
  write_line(''' */''')
  write_line('''.macro GET_VREG_WIDE reg, vreg''')
  write_line('''    add     ip2, xFP, \\vreg, lsl #2''')
  write_line('''    ldr     \\reg, [ip2]''')
  write_line('''.endm''')
  write_line('''.macro SET_VREG_WIDE reg, vreg''')
  write_line('''    add     ip2, xFP, \\vreg, lsl #2''')
  write_line('''    str     \\reg, [ip2]''')
  write_line('''    add     ip2, xREFS, \\vreg, lsl #2''')
  write_line('''    str     xzr, [ip2]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get the 32-bit value from a Dalvik register and sign-extend to 64-bit.''')
  write_line(''' * Used to avoid an extra instruction in int-to-long.''')
  write_line(''' */''')
  write_line('''.macro GET_VREG_S reg, vreg''')
  write_line('''    ldrsw   \\reg, [xFP, \\vreg, uxtw #2]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Convert a virtual register index into an address.''')
  write_line(''' */''')
  write_line('''.macro VREG_INDEX_TO_ADDR reg, vreg''')
  write_line('''    add     \\reg, xFP, \\vreg, lsl #2   /* WARNING: handle shadow frame vreg zero if store */''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh handler table.''')
  write_line(''' */''')
  write_line('''.macro REFRESH_IBASE''')
  write_line('''  ldr     xIBASE, [xSELF, #THREAD_CURRENT_IBASE_OFFSET]''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Save two registers to the stack.''')
  write_line(''' */''')
  write_line('''.macro SAVE_TWO_REGS reg1, reg2, offset''')
  write_line('''    stp \\reg1, \\reg2, [sp, #(\\offset)]''')
  write_line('''    .cfi_rel_offset \\reg1, (\\offset)''')
  write_line('''    .cfi_rel_offset \\reg2, (\\offset) + 8''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Restore two registers from the stack.''')
  write_line(''' */''')
  write_line('''.macro RESTORE_TWO_REGS reg1, reg2, offset''')
  write_line('''    ldp \\reg1, \\reg2, [sp, #(\\offset)]''')
  write_line('''    .cfi_restore \\reg1''')
  write_line('''    .cfi_restore \\reg2''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Increase frame size and save two registers to the bottom of the stack.''')
  write_line(''' */''')
  write_line('''.macro SAVE_TWO_REGS_INCREASE_FRAME reg1, reg2, frame_adjustment''')
  write_line('''    stp \\reg1, \\reg2, [sp, #-(\\frame_adjustment)]!''')
  write_line('''    .cfi_adjust_cfa_offset (\\frame_adjustment)''')
  write_line('''    .cfi_rel_offset \\reg1, 0''')
  write_line('''    .cfi_rel_offset \\reg2, 8''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Restore two registers from the bottom of the stack and decrease frame size.''')
  write_line(''' */''')
  write_line('''.macro RESTORE_TWO_REGS_DECREASE_FRAME reg1, reg2, frame_adjustment''')
  write_line('''    ldp \\reg1, \\reg2, [sp], #(\\frame_adjustment)''')
  write_line('''    .cfi_restore \\reg1''')
  write_line('''    .cfi_restore \\reg2''')
  write_line('''    .cfi_adjust_cfa_offset -(\\frame_adjustment)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * cfi support macros.''')
  write_line(''' */''')
  write_line('''.macro ENTRY name''')
  write_line('''    .type \\name, #function''')
  write_line('''    .hidden \\name  // Hide this as a global symbol, so we do not incur plt calls.''')
  write_line('''    .global \\name''')
  write_line('''    /* Cache alignment for function entry */''')
  write_line('''    .balign 16''')
  write_line('''\\name:''')
  write_line('''    .cfi_startproc''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro END name''')
  write_line('''    .cfi_endproc''')
  write_line('''    .size \\name, .-\\name''')
  write_line('''.endm''')

def instruction_end():
  write_line('''''')
  write_line('''    .type artMterpAsmInstructionEnd, #object''')
  write_line('''    .hidden artMterpAsmInstructionEnd''')
  write_line('''    .global artMterpAsmInstructionEnd''')
  write_line('''artMterpAsmInstructionEnd:''')

def instruction_end_alt():
  write_line('''''')
  write_line('''    .type artMterpAsmAltInstructionEnd, #object''')
  write_line('''    .hidden artMterpAsmAltInstructionEnd''')
  write_line('''    .global artMterpAsmAltInstructionEnd''')
  write_line('''artMterpAsmAltInstructionEnd:''')

def instruction_end_sister():
  write_line('''''')
  write_line('''    .type artMterpAsmSisterEnd, #object''')
  write_line('''    .hidden artMterpAsmSisterEnd''')
  write_line('''    .global artMterpAsmSisterEnd''')
  write_line('''artMterpAsmSisterEnd:''')

def instruction_start():
  write_line('''''')
  write_line('''    .type artMterpAsmInstructionStart, #object''')
  write_line('''    .hidden artMterpAsmInstructionStart''')
  write_line('''    .global artMterpAsmInstructionStart''')
  write_line('''artMterpAsmInstructionStart = .L_op_nop''')
  write_line('''    .text''')

def instruction_start_alt():
  write_line('''''')
  write_line('''    .type artMterpAsmAltInstructionStart, #object''')
  write_line('''    .hidden artMterpAsmAltInstructionStart''')
  write_line('''    .global artMterpAsmAltInstructionStart''')
  write_line('''artMterpAsmAltInstructionStart = .L_ALT_op_nop''')
  write_line('''    .text''')

def instruction_start_sister():
  write_line('''''')
  write_line('''    .type artMterpAsmSisterStart, #object''')
  write_line('''    .hidden artMterpAsmSisterStart''')
  write_line('''    .global artMterpAsmSisterStart''')
  write_line('''    .text''')
  write_line('''    .balign 4''')
  write_line('''artMterpAsmSisterStart:''')

def invoke(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * Generic invoke handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x2, xPC''')
  write_line('''    mov     x3, xINST''')
  write_line('''    bl      ''' + helper + '''''')
  write_line('''    cbz     w0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 3''')
  write_line('''    bl      MterpShouldSwitchInterpreters''')
  write_line('''    cbnz    w0, MterpFallback''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip''')
  write_line('''''')

def invoke_polymorphic(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * invoke-polymorphic handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB, proto@HHHH */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    add     x1, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x2, xPC''')
  write_line('''    mov     x3, xINST''')
  write_line('''    bl      ''' + helper + '''''')
  write_line('''    cbz     w0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 4''')
  write_line('''    bl      MterpShouldSwitchInterpreters''')
  write_line('''    cbnz    w0, MterpFallback''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip''')

def op_add_double():
  binopWide(instr="fadd d0, d1, d2", result="d0", r1="d1", r2="d2")

def op_add_double_2addr():
  binopWide2addr(instr="fadd     d0, d0, d1", r0="d0", r1="d1")

def op_add_float():
  fbinop(instr="fadd   s0, s0, s1")

def op_add_float_2addr():
  fbinop2addr(instr="fadd   s2, s0, s1")

def op_add_int():
  binop(instr="add     w0, w0, w1")

def op_add_int_2addr():
  binop2addr(instr="add     w0, w0, w1")

def op_add_int_lit16():
  binopLit16(instr="add     w0, w0, w1")

def op_add_int_lit8():
  binopLit8(extract="", instr="add     w0, w0, w3, asr #8")

def op_add_long():
  binopWide(instr="add x0, x1, x2")

def op_add_long_2addr():
  binopWide2addr(instr="add     x0, x0, x1")

def op_aget(load="ldr", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''    /*''')
  write_line('''     * Array get, 32 bits or less.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17''')
  write_line('''     * instructions.  We use a pair of FETCH_Bs instead.''')
  write_line('''     *''')
  write_line('''     * for: aget, aget-boolean, aget-byte, aget-char, aget-short''')
  write_line('''     *''')
  write_line('''     * NOTE: assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B w2, 1, 0                    // w2<- BB''')
  write_line('''    lsr     w9, wINST, #8               // w9<- AA''')
  write_line('''    FETCH_B w3, 1, 1                    // w3<- CC''')
  write_line('''    GET_VREG w0, w2                     // w0<- vBB (array object)''')
  write_line('''    GET_VREG w1, w3                     // w1<- vCC (requested index)''')
  write_line('''    cbz     x0, common_errNullObject    // bail if null array object.''')
  write_line('''    ldr     w3, [x0, #MIRROR_ARRAY_LENGTH_OFFSET]    // w3<- arrayObj->length''')
  write_line('''    add     x0, x0, w1, uxtw #''' + shift + '''    // w0<- arrayObj + index*width''')
  write_line('''    cmp     w1, w3                      // compare unsigned index, length''')
  write_line('''    bcs     common_errArrayIndex        // index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + load + '''   w2, [x0, #''' + data_offset + ''']     // w2<- vBB[vCC]''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG w2, w9                     // vAA<- w2''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_aget_boolean():
  op_aget(load="ldrb", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aget_byte():
  op_aget(load="ldrsb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aget_char():
  op_aget(load="ldrh", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aget_object():
  write_line('''    /*''')
  write_line('''     * Array object get.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     * for: aget-object''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B w2, 1, 0                    // w2<- BB''')
  write_line('''    FETCH_B w3, 1, 1                    // w3<- CC''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG w0, w2                     // w0<- vBB (array object)''')
  write_line('''    GET_VREG w1, w3                     // w1<- vCC (requested index)''')
  write_line('''    bl       artAGetObjectFromMterp     // (array, index)''')
  write_line('''    ldr      x1, [xSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    lsr      w2, wINST, #8               // w9<- AA''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cbnz     w1, MterpException''')
  write_line('''    SET_VREG_OBJECT w0, w2''')
  write_line('''    ADVANCE 2''')
  write_line('''    GET_INST_OPCODE ip''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_aget_short():
  op_aget(load="ldrsh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aget_wide():
  write_line('''    /*''')
  write_line('''     * Array get, 64 bits.  vAA <- vBB[vCC].''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    /* aget-wide vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr     w4, wINST, #8               // w4<- AA''')
  write_line('''    and     w2, w0, #255                // w2<- BB''')
  write_line('''    lsr     w3, w0, #8                  // w3<- CC''')
  write_line('''    GET_VREG w0, w2                     // w0<- vBB (array object)''')
  write_line('''    GET_VREG w1, w3                     // w1<- vCC (requested index)''')
  write_line('''    cbz     w0, common_errNullObject        // yes, bail''')
  write_line('''    ldr     w3, [x0, #MIRROR_ARRAY_LENGTH_OFFSET]    // w3<- arrayObj->length''')
  write_line('''    add     x0, x0, w1, lsl #3          // w0<- arrayObj + index*width''')
  write_line('''    cmp     w1, w3                      // compare unsigned index, length''')
  write_line('''    bcs     common_errArrayIndex        // index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    ldr     x2, [x0, #MIRROR_WIDE_ARRAY_DATA_OFFSET]  // x2<- vBB[vCC]''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE x2, w4''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_and_int():
  binop(instr="and     w0, w0, w1")

def op_and_int_2addr():
  binop2addr(instr="and     w0, w0, w1")

def op_and_int_lit16():
  binopLit16(instr="and     w0, w0, w1")

def op_and_int_lit8():
  binopLit8(extract="", instr="and     w0, w0, w3, asr #8")

def op_and_long():
  binopWide(instr="and x0, x1, x2")

def op_and_long_2addr():
  binopWide2addr(instr="and     x0, x0, x1")

def op_aput(store="str", shift="2", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''    /*''')
  write_line('''     * Array put, 32 bits or less.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17''')
  write_line('''     * instructions.  We use a pair of FETCH_Bs instead.''')
  write_line('''     *''')
  write_line('''     * for: aput, aput-boolean, aput-byte, aput-char, aput-short''')
  write_line('''     *''')
  write_line('''     * NOTE: this assumes data offset for arrays is the same for all non-wide types.''')
  write_line('''     * If this changes, specialize.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    FETCH_B w2, 1, 0                    // w2<- BB''')
  write_line('''    lsr     w9, wINST, #8               // w9<- AA''')
  write_line('''    FETCH_B w3, 1, 1                    // w3<- CC''')
  write_line('''    GET_VREG w0, w2                     // w0<- vBB (array object)''')
  write_line('''    GET_VREG w1, w3                     // w1<- vCC (requested index)''')
  write_line('''    cbz     w0, common_errNullObject    // bail if null''')
  write_line('''    ldr     w3, [x0, #MIRROR_ARRAY_LENGTH_OFFSET]     // w3<- arrayObj->length''')
  write_line('''    add     x0, x0, w1, lsl #''' + shift + '''     // w0<- arrayObj + index*width''')
  write_line('''    cmp     w1, w3                      // compare unsigned index, length''')
  write_line('''    bcs     common_errArrayIndex        // index >= length, bail''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_VREG w2, w9                     // w2<- vAA''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    ''' + store + '''  w2, [x0, #''' + data_offset + ''']     // vBB[vCC]<- w2''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_aput_boolean():
  op_aput(store="strb", shift="0", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aput_byte():
  op_aput(store="strb", shift="0", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aput_char():
  op_aput(store="strh", shift="1", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aput_object():
  write_line('''    /*''')
  write_line('''     * Store an object into an array.  vBB[vCC] <- vAA.''')
  write_line('''     */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     x0, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x1, xPC''')
  write_line('''    mov     w2, wINST''')
  write_line('''    bl      MterpAputObject''')
  write_line('''    cbz     w0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_aput_short():
  op_aput(store="strh", shift="1", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aput_wide():
  write_line('''    /*''')
  write_line('''     * Array put, 64 bits.  vBB[vCC] <- vAA.''')
  write_line('''     *''')
  write_line('''     */''')
  write_line('''    /* aput-wide vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr     w4, wINST, #8               // w4<- AA''')
  write_line('''    and     w2, w0, #255                // w2<- BB''')
  write_line('''    lsr     w3, w0, #8                  // w3<- CC''')
  write_line('''    GET_VREG w0, w2                     // w0<- vBB (array object)''')
  write_line('''    GET_VREG w1, w3                     // w1<- vCC (requested index)''')
  write_line('''    cbz     w0, common_errNullObject    // bail if null''')
  write_line('''    ldr     w3, [x0, #MIRROR_ARRAY_LENGTH_OFFSET]    // w3<- arrayObj->length''')
  write_line('''    add     x0, x0, w1, lsl #3          // w0<- arrayObj + index*width''')
  write_line('''    cmp     w1, w3                      // compare unsigned index, length''')
  write_line('''    bcs     common_errArrayIndex        // index >= length, bail''')
  write_line('''    GET_VREG_WIDE x1, w4''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    str     x1, [x0, #MIRROR_WIDE_ARRAY_DATA_OFFSET]''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_array_length():
  write_line('''    /*''')
  write_line('''     * Return the length of an array.''')
  write_line('''     */''')
  write_line('''    lsr     w1, wINST, #12              // w1<- B''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    GET_VREG w0, w1                     // w0<- vB (object ref)''')
  write_line('''    cbz     w0, common_errNullObject    // yup, fail''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    ldr     w3, [x0, #MIRROR_ARRAY_LENGTH_OFFSET]    // w3<- array length''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG w3, w2                     // vB<- length''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_check_cast():
  write_line('''    /*''')
  write_line('''     * Check to see if a cast from one class to another is allowed.''')
  write_line('''     */''')
  write_line('''    /* check-cast vAA, class//BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH    w0, 1                      // w0<- BBBB''')
  write_line('''    lsr      w1, wINST, #8              // w1<- AA''')
  write_line('''    VREG_INDEX_TO_ADDR x1, w1           // w1<- &object''')
  write_line('''    ldr      x2, [xFP, #OFF_FP_METHOD]  // w2<- method''')
  write_line('''    mov      x3, xSELF                  // w3<- self''')
  write_line('''    bl       MterpCheckCast             // (index, &obj, method, self)''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cbnz     w0, MterpPossibleException''')
  write_line('''    ADVANCE  2''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_cmp_long():
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr     w4, wINST, #8               // w4<- AA''')
  write_line('''    and     w2, w0, #255                // w2<- BB''')
  write_line('''    lsr     w3, w0, #8                  // w3<- CC''')
  write_line('''    GET_VREG_WIDE x1, w2''')
  write_line('''    GET_VREG_WIDE x2, w3''')
  write_line('''    cmp     x1, x2''')
  write_line('''    cset    w0, ne''')
  write_line('''    cneg    w0, w0, lt''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    SET_VREG w0, w4''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_cmpg_double():
  fcmp(wide="_WIDE", r1="d1", r2="d2", cond="cc")

def op_cmpg_float():
  fcmp(wide="", r1="s1", r2="s2", cond="cc")

def op_cmpl_double():
  fcmp(wide="_WIDE", r1="d1", r2="d2", cond="lt")

def op_cmpl_float():
  fcmp(wide="", r1="s1", r2="s2", cond="lt")

def op_const():
  write_line('''    /* const vAA, #+BBBBbbbb */''')
  write_line('''    lsr     w3, wINST, #8               // w3<- AA''')
  write_line('''    FETCH w0, 1                         // w0<- bbbb (low''')
  write_line('''    FETCH w1, 2                         // w1<- BBBB (high''')
  write_line('''    FETCH_ADVANCE_INST 3                // advance rPC, load wINST''')
  write_line('''    orr     w0, w0, w1, lsl #16         // w0<- BBBBbbbb''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG w0, w3                     // vAA<- w0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_const_16():
  write_line('''    /* const/16 vAA, #+BBBB */''')
  write_line('''    FETCH_S w0, 1                       // w0<- ssssBBBB (sign-extended)''')
  write_line('''    lsr     w3, wINST, #8               // w3<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance xPC, load wINST''')
  write_line('''    SET_VREG w0, w3                     // vAA<- w0''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_const_4():
  write_line('''    /* const/4 vA, #+B */''')
  write_line('''    sbfx    w1, wINST, #12, #4          // w1<- sssssssB''')
  write_line('''    ubfx    w0, wINST, #8, #4           // w0<- A''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance xPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // ip<- opcode from xINST''')
  write_line('''    SET_VREG w1, w0                     // fp[A]<- w1''')
  write_line('''    GOTO_OPCODE ip                      // execute next instruction''')

def op_const_class():
  const(helper="MterpConstClass")

def op_const_high16():
  write_line('''    /* const/high16 vAA, #+BBBB0000 */''')
  write_line('''    FETCH   w0, 1                       // r0<- 0000BBBB (zero-extended)''')
  write_line('''    lsr     w3, wINST, #8               // r3<- AA''')
  write_line('''    lsl     w0, w0, #16                 // r0<- BBBB0000''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    SET_VREG w0, w3                     // vAA<- r0''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_const_method_handle():
  const(helper="MterpConstMethodHandle")

def op_const_method_type():
  const(helper="MterpConstMethodType")

def op_const_string():
  const(helper="MterpConstString")

def op_const_string_jumbo():
  write_line('''    /* const/string vAA, String//BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH w0, 1                         // w0<- bbbb (low''')
  write_line('''    FETCH w2, 2                         // w2<- BBBB (high''')
  write_line('''    lsr     w1, wINST, #8               // w1<- AA''')
  write_line('''    orr     w0, w0, w2, lsl #16         // w1<- BBBBbbbb''')
  write_line('''    add     x2, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x3, xSELF''')
  write_line('''    bl      MterpConstString            // (index, tgt_reg, shadow_frame, self)''')
  write_line('''    PREFETCH_INST 3                     // advance rPC''')
  write_line('''    cbnz    w0, MterpPossibleException      // let reference interpreter deal with it.''')
  write_line('''    ADVANCE 3                           // advance rPC''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_const_wide():
  write_line('''    /* const-wide vAA, #+HHHHhhhhBBBBbbbb */''')
  write_line('''    FETCH w0, 1                         // w0<- bbbb (low)''')
  write_line('''    FETCH w1, 2                         // w1<- BBBB (low middle)''')
  write_line('''    FETCH w2, 3                         // w2<- hhhh (high middle)''')
  write_line('''    FETCH w3, 4                         // w3<- HHHH (high)''')
  write_line('''    lsr     w4, wINST, #8               // r4<- AA''')
  write_line('''    FETCH_ADVANCE_INST 5                // advance rPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    orr     w0, w0, w1, lsl #16         // w0<-         BBBBbbbb''')
  write_line('''    orr     x0, x0, x2, lsl #32         // w0<-     hhhhBBBBbbbb''')
  write_line('''    orr     x0, x0, x3, lsl #48         // w0<- HHHHhhhhBBBBbbbb''')
  write_line('''    SET_VREG_WIDE x0, w4''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_const_wide_16():
  write_line('''    /* const-wide/16 vAA, #+BBBB */''')
  write_line('''    FETCH_S x0, 1                       // x0<- ssssssssssssBBBB (sign-extended)''')
  write_line('''    lsr     w3, wINST, #8               // w3<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE x0, w3''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_const_wide_32():
  write_line('''    /* const-wide/32 vAA, #+BBBBbbbb */''')
  write_line('''    FETCH   w0, 1                       // x0<- 000000000000bbbb (low)''')
  write_line('''    lsr     w3, wINST, #8               // w3<- AA''')
  write_line('''    FETCH_S x2, 2                       // x2<- ssssssssssssBBBB (high)''')
  write_line('''    FETCH_ADVANCE_INST 3                // advance rPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    orr     x0, x0, x2, lsl #16         // x0<- ssssssssBBBBbbbb''')
  write_line('''    SET_VREG_WIDE x0, w3''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_const_wide_high16():
  write_line('''    /* const-wide/high16 vAA, #+BBBB000000000000 */''')
  write_line('''    FETCH w0, 1                         // w0<- 0000BBBB (zero-extended)''')
  write_line('''    lsr     w1, wINST, #8               // w1<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    lsl     x0, x0, #48''')
  write_line('''    SET_VREG_WIDE x0, w1''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_div_double():
  binopWide(instr="fdiv d0, d1, d2", result="d0", r1="d1", r2="d2")

def op_div_double_2addr():
  binopWide2addr(instr="fdiv     d0, d0, d1", r0="d0", r1="d1")

def op_div_float():
  fbinop(instr="fdiv   s0, s0, s1")

def op_div_float_2addr():
  fbinop2addr(instr="fdiv   s2, s0, s1")

def op_div_int():
  binop(instr="sdiv     w0, w0, w1", chkzero="1")

def op_div_int_2addr():
  binop2addr(instr="sdiv     w0, w0, w1", chkzero="1")

def op_div_int_lit16():
  binopLit16(instr="sdiv w0, w0, w1", chkzero="1")

def op_div_int_lit8():
  binopLit8(instr="sdiv     w0, w0, w1", chkzero="1")

def op_div_long():
  binopWide(instr="sdiv x0, x1, x2", chkzero="1")

def op_div_long_2addr():
  binopWide2addr(instr="sdiv     x0, x0, x1", chkzero="1")

def op_double_to_float():
  funopNarrower(instr="fcvt s0, d0", srcreg="d0", tgtreg="s0")

def op_double_to_int():
  funopNarrower(instr="fcvtzs w0, d0", srcreg="d0", tgtreg="w0")

def op_double_to_long():
  funopWide(instr="fcvtzs x0, d0", srcreg="d0", tgtreg="x0")

def op_fill_array_data():
  write_line('''    /* fill-array-data vAA, +BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH   w0, 1                       // x0<- 000000000000bbbb (lo)''')
  write_line('''    FETCH_S x1, 2                       // x1<- ssssssssssssBBBB (hi)''')
  write_line('''    lsr     w3, wINST, #8               // w3<- AA''')
  write_line('''    orr     x1, x0, x1, lsl #16         // x1<- ssssssssBBBBbbbb''')
  write_line('''    GET_VREG w0, w3                     // w0<- vAA (array object)''')
  write_line('''    add     x1, xPC, x1, lsl #1         // x1<- PC + ssssssssBBBBbbbb*2 (array data off.)''')
  write_line('''    bl      MterpFillArrayData          // (obj, payload)''')
  write_line('''    cbz     w0, MterpPossibleException      // exception?''')
  write_line('''    FETCH_ADVANCE_INST 3                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_filled_new_array(helper="MterpFilledNewArray"):
  write_line('''    /*''')
  write_line('''     * Create a new array with elements filled from registers.''')
  write_line('''     *''')
  write_line('''     * for: filled-new-array, filled-new-array/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class//CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, type//BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     x0, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x1, xPC''')
  write_line('''    mov     x2, xSELF''')
  write_line('''    bl      ''' + helper + '''''')
  write_line('''    cbz     w0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 3                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_filled_new_array_range():
  op_filled_new_array(helper="MterpFilledNewArrayRange")

def op_float_to_double():
  funopWider(instr="fcvt  d0, s0", srcreg="s0", tgtreg="d0")

def op_float_to_int():
  funopNarrow(instr="fcvtzs w0, s0", srcreg="s0", tgtreg="w0")

def op_float_to_long():
  funopWider(instr="fcvtzs x0, s0", srcreg="s0", tgtreg="x0")

def op_goto():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 8-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto +AA */''')
  write_line('''    sbfx    wINST, wINST, #8, #8           // wINST<- ssssssAA (sign-extended)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_16():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 16-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto/16 +AAAA */''')
  write_line('''    FETCH_S wINST, 1                    // wINST<- ssssAAAA (sign-extended)''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_goto_32():
  write_line('''    /*''')
  write_line('''     * Unconditional branch, 32-bit offset.''')
  write_line('''     *''')
  write_line('''     * The branch distance is a signed code-unit offset, which we need to''')
  write_line('''     * double to get a byte offset.''')
  write_line('''     *''')
  write_line('''     * Unlike most opcodes, this one is allowed to branch to itself, so''')
  write_line('''     * our "backward branch" test must be "<=0" instead of "<0".  Because''')
  write_line('''     * we need the V bit set, we'll use an adds to convert from Dalvik''')
  write_line('''     * offset to byte offset.''')
  write_line('''     */''')
  write_line('''    /* goto/32 +AAAAAAAA */''')
  write_line('''    FETCH w0, 1                         // w0<- aaaa (lo)''')
  write_line('''    FETCH w1, 2                         // w1<- AAAA (hi)''')
  write_line('''    orr     wINST, w0, w1, lsl #16      // wINST<- AAAAaaaa''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_if_eq():
  bincmp(condition="eq")

def op_if_eqz():
  zcmp(compare="0", branch="cbz     w2,")

def op_if_ge():
  bincmp(condition="ge")

def op_if_gez():
  zcmp(compare="0", branch="tbz     w2, #31,")

def op_if_gt():
  bincmp(condition="gt")

def op_if_gtz():
  zcmp(branch="b.gt")

def op_if_le():
  bincmp(condition="le")

def op_if_lez():
  zcmp(branch="b.le")

def op_if_lt():
  bincmp(condition="lt")

def op_if_ltz():
  zcmp(compare="0", branch="tbnz    w2, #31,")

def op_if_ne():
  bincmp(condition="ne")

def op_if_nez():
  zcmp(compare="0", branch="cbnz    w2,")

def op_iget(is_object="0", helper="MterpIGetU32"):
  field(helper=helper)

def op_iget_boolean():
  op_iget(helper="MterpIGetU8")

def op_iget_boolean_quick():
  op_iget_quick(load="ldrb")

def op_iget_byte():
  op_iget(helper="MterpIGetI8")

def op_iget_byte_quick():
  op_iget_quick(load="ldrsb")

def op_iget_char():
  op_iget(helper="MterpIGetU16")

def op_iget_char_quick():
  op_iget_quick(load="ldrh")

def op_iget_object():
  op_iget(is_object="1", helper="MterpIGetObj")

def op_iget_object_quick():
  write_line('''    /* For: iget-object-quick */''')
  write_line('''    /* op vA, vB, offset//CCCC */''')
  write_line('''    lsr     w2, wINST, #12              // w2<- B''')
  write_line('''    FETCH w1, 1                         // w1<- field byte offset''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG w0, w2                     // w0<- object we're operating on''')
  write_line('''    bl      artIGetObjectFromMterp      // (obj, offset)''')
  write_line('''    ldr     x3, [xSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cbnz    w3, MterpPossibleException      // bail out''')
  write_line('''    SET_VREG_OBJECT w0, w2              // fp[A]<- w0''')
  write_line('''    ADVANCE 2                           // advance rPC''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_iget_quick(load="ldr", extend=""):
  write_line('''    /* For: iget-quick, iget-boolean-quick, iget-byte-quick, iget-char-quick, iget-short-quick */''')
  write_line('''    /* op vA, vB, offset//CCCC */''')
  write_line('''    lsr     w2, wINST, #12              // w2<- B''')
  write_line('''    FETCH w1, 1                         // w1<- field byte offset''')
  write_line('''    GET_VREG w3, w2                     // w3<- object we're operating on''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    cbz     w3, common_errNullObject    // object was null''')
  write_line('''    ''' + load + '''   w0, [x3, x1]                // w0<- obj.field''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + extend + '''''')
  write_line('''    SET_VREG w0, w2                     // fp[A]<- w0''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_iget_short():
  op_iget(helper="MterpIGetI16")

def op_iget_short_quick():
  op_iget_quick(load="ldrsh")

def op_iget_wide():
  op_iget(helper="MterpIGetU64")

def op_iget_wide_quick():
  write_line('''    /* iget-wide-quick vA, vB, offset//CCCC */''')
  write_line('''    lsr     w2, wINST, #12              // w2<- B''')
  write_line('''    FETCH w4, 1                         // w4<- field byte offset''')
  write_line('''    GET_VREG w3, w2                     // w3<- object we're operating on''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    cbz     w3, common_errNullObject    // object was null''')
  write_line('''    ldr     x0, [x3, x4]                // x0<- obj.field''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    SET_VREG_WIDE x0, w2''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_instance_of():
  write_line('''    /*''')
  write_line('''     * Check to see if an object reference is an instance of a class.''')
  write_line('''     *''')
  write_line('''     * Most common situation is a non-null object, being compared against''')
  write_line('''     * an already-resolved class.''')
  write_line('''     */''')
  write_line('''    /* instance-of vA, vB, class//CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    FETCH     w0, 1                     // w0<- CCCC''')
  write_line('''    lsr       w1, wINST, #12            // w1<- B''')
  write_line('''    VREG_INDEX_TO_ADDR x1, w1           // w1<- &object''')
  write_line('''    ldr       x2, [xFP, #OFF_FP_METHOD] // w2<- method''')
  write_line('''    mov       x3, xSELF                 // w3<- self''')
  write_line('''    bl        MterpInstanceOf           // (index, &obj, method, self)''')
  write_line('''    ldr       x1, [xSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    ubfx      w2, wINST, #8, #4         // w2<- A''')
  write_line('''    PREFETCH_INST 2''')
  write_line('''    cbnz      x1, MterpException''')
  write_line('''    ADVANCE 2                           // advance rPC''')
  write_line('''    SET_VREG w0, w2                     // vA<- w0''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_int_to_byte():
  unop(instr="sxtb    w0, w0")

def op_int_to_char():
  unop(instr="uxth    w0, w0")

def op_int_to_double():
  funopWider(instr="scvtf d0, w0", srcreg="w0", tgtreg="d0")

def op_int_to_float():
  funopNarrow(instr="scvtf s0, w0", srcreg="w0", tgtreg="s0")

def op_int_to_long():
  write_line('''    /* int-to-long vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w4, wINST, #8, #4           // w4<- A''')
  write_line('''    GET_VREG_S x0, w3                   // x0<- sign_extend(fp[B])''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE x0, w4                // fp[A]<- x0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_int_to_short():
  unop(instr="sxth    w0, w0")

def op_invoke_custom():
  invoke(helper="MterpInvokeCustom")

def op_invoke_custom_range():
  invoke(helper="MterpInvokeCustomRange")

def op_invoke_direct():
  invoke(helper="MterpInvokeDirect")

def op_invoke_direct_range():
  invoke(helper="MterpInvokeDirectRange")

def op_invoke_interface():
  invoke(helper="MterpInvokeInterface")
  write_line('''    /*''')
  write_line('''     * Handle an interface method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-interface, invoke-interface/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_interface_range():
  invoke(helper="MterpInvokeInterfaceRange")

def op_invoke_polymorphic():
  invoke_polymorphic(helper="MterpInvokePolymorphic")

def op_invoke_polymorphic_range():
  invoke_polymorphic(helper="MterpInvokePolymorphicRange")

def op_invoke_static():
  invoke(helper="MterpInvokeStatic")
  write_line('''''')

def op_invoke_static_range():
  invoke(helper="MterpInvokeStaticRange")

def op_invoke_super():
  invoke(helper="MterpInvokeSuper")
  write_line('''    /*''')
  write_line('''     * Handle a "super" method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-super, invoke-super/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_super_range():
  invoke(helper="MterpInvokeSuperRange")

def op_invoke_virtual():
  invoke(helper="MterpInvokeVirtual")
  write_line('''    /*''')
  write_line('''     * Handle a virtual method call.''')
  write_line('''     *''')
  write_line('''     * for: invoke-virtual, invoke-virtual/range''')
  write_line('''     */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_virtual_quick():
  invoke(helper="MterpInvokeVirtualQuick")

def op_invoke_virtual_range():
  invoke(helper="MterpInvokeVirtualRange")

def op_invoke_virtual_range_quick():
  invoke(helper="MterpInvokeVirtualQuickRange")

def op_iput(is_object="0", helper="MterpIPutU32"):
  field(helper=helper)

def op_iput_boolean():
  op_iput(helper="MterpIPutU8")

def op_iput_boolean_quick():
  op_iput_quick(store="strb")

def op_iput_byte():
  op_iput(helper="MterpIPutI8")

def op_iput_byte_quick():
  op_iput_quick(store="strb")

def op_iput_char():
  op_iput(helper="MterpIPutU16")

def op_iput_char_quick():
  op_iput_quick(store="strh")

def op_iput_object():
  op_iput(is_object="1", helper="MterpIPutObj")

def op_iput_object_quick():
  write_line('''    EXPORT_PC''')
  write_line('''    add     x0, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x1, xPC''')
  write_line('''    mov     w2, wINST''')
  write_line('''    bl      MterpIputObjectQuick''')
  write_line('''    cbz     w0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_iput_quick(store="str"):
  write_line('''    /* For: iput-quick, iput-object-quick */''')
  write_line('''    /* op vA, vB, offset//CCCC */''')
  write_line('''    lsr     w2, wINST, #12              // w2<- B''')
  write_line('''    FETCH w1, 1                         // w1<- field byte offset''')
  write_line('''    GET_VREG w3, w2                     // w3<- fp[B], the object pointer''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    cbz     w3, common_errNullObject    // object was null''')
  write_line('''    GET_VREG w0, w2                     // w0<- fp[A]''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + store + '''     w0, [x3, x1]             // obj.field<- w0''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_iput_short():
  op_iput(helper="MterpIPutI16")

def op_iput_short_quick():
  op_iput_quick(store="strh")

def op_iput_wide():
  op_iput(helper="MterpIPutU64")

def op_iput_wide_quick():
  write_line('''    /* iput-wide-quick vA, vB, offset//CCCC */''')
  write_line('''    lsr     w2, wINST, #12              // w2<- B''')
  write_line('''    FETCH w3, 1                         // w3<- field byte offset''')
  write_line('''    GET_VREG w2, w2                     // w2<- fp[B], the object pointer''')
  write_line('''    ubfx    w0, wINST, #8, #4           // w0<- A''')
  write_line('''    cbz     w2, common_errNullObject    // object was null''')
  write_line('''    GET_VREG_WIDE x0, w0                // x0<- fp[A]''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    str     x0, [x2, x3]                // obj.field<- x0''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_long_to_double():
  funopWide(instr="scvtf d0, x0", srcreg="x0", tgtreg="d0")

def op_long_to_float():
  funopNarrower(instr="scvtf s0, x0", srcreg="x0", tgtreg="s0")

def op_long_to_int():
  write_line('''/* we ignore the high word, making this equivalent to a 32-bit reg move */''')
  op_move()

def op_monitor_enter():
  write_line('''    /*''')
  write_line('''     * Synchronize on an object.''')
  write_line('''     */''')
  write_line('''    /* monitor-enter vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    lsr      w2, wINST, #8               // w2<- AA''')
  write_line('''    GET_VREG w0, w2                      // w0<- vAA (object)''')
  write_line('''    mov      x1, xSELF                   // w1<- self''')
  write_line('''    bl       artLockObjectFromCode''')
  write_line('''    cbnz     w0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 1''')
  write_line('''    GET_INST_OPCODE ip                   // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                       // jump to next instruction''')

def op_monitor_exit():
  write_line('''    /*''')
  write_line('''     * Unlock an object.''')
  write_line('''     *''')
  write_line('''     * Exceptions that occur when unlocking a monitor need to appear as''')
  write_line('''     * if they happened at the following instruction.  See the Dalvik''')
  write_line('''     * instruction spec.''')
  write_line('''     */''')
  write_line('''    /* monitor-exit vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    lsr      w2, wINST, #8              // w2<- AA''')
  write_line('''    GET_VREG w0, w2                     // w0<- vAA (object)''')
  write_line('''    mov      x1, xSELF                  // w0<- self''')
  write_line('''    bl       artUnlockObjectFromCode    // w0<- success for unlock(self, obj)''')
  write_line('''    cbnz     w0, MterpException''')
  write_line('''    FETCH_ADVANCE_INST 1                // before throw: advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move(is_object="0"):
  write_line('''    /* for move, move-object, long-to-int */''')
  write_line('''    /* op vA, vB */''')
  write_line('''    lsr     w1, wINST, #12              // x1<- B from 15:12''')
  write_line('''    ubfx    w0, wINST, #8, #4           // x0<- A from 11:8''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    GET_VREG w2, w1                     // x2<- fp[B]''')
  write_line('''    GET_INST_OPCODE ip                  // ip<- opcode from wINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT w2, w0              // fp[A]<- x2''')
  write_line('''    .else''')
  write_line('''    SET_VREG w2, w0                     // fp[A]<- x2''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      // execute next instruction''')

def op_move_16(is_object="0"):
  write_line('''    /* for: move/16, move-object/16 */''')
  write_line('''    /* op vAAAA, vBBBB */''')
  write_line('''    FETCH w1, 2                         // w1<- BBBB''')
  write_line('''    FETCH w0, 1                         // w0<- AAAA''')
  write_line('''    FETCH_ADVANCE_INST 3                // advance xPC, load xINST''')
  write_line('''    GET_VREG w2, w1                     // w2<- fp[BBBB]''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from xINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT w2, w0              // fp[AAAA]<- w2''')
  write_line('''    .else''')
  write_line('''    SET_VREG w2, w0                     // fp[AAAA]<- w2''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move_exception():
  write_line('''    /* move-exception vAA */''')
  write_line('''    lsr     w2, wINST, #8               // w2<- AA''')
  write_line('''    ldr     x3, [xSELF, #THREAD_EXCEPTION_OFFSET]''')
  write_line('''    mov     x1, #0                      // w1<- 0''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    SET_VREG_OBJECT w3, w2              // fp[AA]<- exception obj''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    str     x1, [xSELF, #THREAD_EXCEPTION_OFFSET]  // clear exception''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move_from16(is_object="0"):
  write_line('''    /* for: move/from16, move-object/from16 */''')
  write_line('''    /* op vAA, vBBBB */''')
  write_line('''    FETCH w1, 1                         // r1<- BBBB''')
  write_line('''    lsr     w0, wINST, #8               // r0<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    GET_VREG w2, w1                     // r2<- fp[BBBB]''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT w2, w0              // fp[AA]<- r2''')
  write_line('''    .else''')
  write_line('''    SET_VREG w2, w0                     // fp[AA]<- r2''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move_object():
  op_move(is_object="1")

def op_move_object_16():
  op_move_16(is_object="1")

def op_move_object_from16():
  op_move_from16(is_object="1")

def op_move_result(is_object="0"):
  write_line('''    /* for: move-result, move-result-object */''')
  write_line('''    /* op vAA */''')
  write_line('''    lsr     w2, wINST, #8               // r2<- AA''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    ldr     x0, [xFP, #OFF_FP_RESULT_REGISTER]  // get pointer to result JType.''')
  write_line('''    ldr     w0, [x0]                    // r0 <- result.i.''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT w0, w2, w1          // fp[AA]<- r0''')
  write_line('''    .else''')
  write_line('''    SET_VREG w0, w2                     // fp[AA]<- r0''')
  write_line('''    .endif''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move_result_object():
  op_move_result(is_object="1")

def op_move_result_wide():
  write_line('''    /* for: move-result-wide */''')
  write_line('''    /* op vAA */''')
  write_line('''    lsr     w2, wINST, #8               // r2<- AA''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    ldr     x0, [xFP, #OFF_FP_RESULT_REGISTER]  // get pointer to result JType.''')
  write_line('''    ldr     x0, [x0]                    // r0 <- result.i.''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE x0, x2                // fp[AA]<- r0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move_wide():
  write_line('''    /* move-wide vA, vB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    GET_VREG_WIDE  x3, w3''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE  x3, w2''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move_wide_16():
  write_line('''    /* move-wide/16 vAAAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    FETCH w3, 2                         // w3<- BBBB''')
  write_line('''    FETCH w2, 1                         // w2<- AAAA''')
  write_line('''    GET_VREG_WIDE x3, w3''')
  write_line('''    FETCH_ADVANCE_INST 3                // advance rPC, load rINST''')
  write_line('''    SET_VREG_WIDE x3, w2''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_move_wide_from16():
  write_line('''    /* move-wide/from16 vAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    FETCH w3, 1                         // w3<- BBBB''')
  write_line('''    lsr     w2, wINST, #8               // w2<- AA''')
  write_line('''    GET_VREG_WIDE x3, w3''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load wINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE x3, w2''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_mul_double():
  binopWide(instr="fmul d0, d1, d2", result="d0", r1="d1", r2="d2")

def op_mul_double_2addr():
  binopWide2addr(instr="fmul     d0, d0, d1", r0="d0", r1="d1")

def op_mul_float():
  fbinop(instr="fmul   s0, s0, s1")

def op_mul_float_2addr():
  fbinop2addr(instr="fmul   s2, s0, s1")

def op_mul_int():
  write_line('''/* must be "mul w0, w1, w0" -- "w0, w0, w1" is illegal */''')
  binop(instr="mul     w0, w1, w0")

def op_mul_int_2addr():
  write_line('''/* must be "mul w0, w1, w0" -- "w0, w0, w1" is illegal */''')
  binop2addr(instr="mul     w0, w1, w0")

def op_mul_int_lit16():
  write_line('''/* must be "mul w0, w1, w0" -- "w0, w0, w1" is illegal */''')
  binopLit16(instr="mul     w0, w1, w0")

def op_mul_int_lit8():
  write_line('''/* must be "mul w0, w1, w0" -- "w0, w0, w1" is illegal */''')
  binopLit8(instr="mul     w0, w1, w0")

def op_mul_long():
  binopWide(instr="mul x0, x1, x2")

def op_mul_long_2addr():
  binopWide2addr(instr="mul     x0, x0, x1")

def op_neg_double():
  unopWide(instr="eor     x0, x0, #0x8000000000000000")

def op_neg_float():
  unop(instr="eor     w0, w0, #0x80000000")

def op_neg_int():
  unop(instr="sub     w0, wzr, w0")

def op_neg_long():
  unopWide(instr="sub x0, xzr, x0")

def op_new_array():
  write_line('''    /*''')
  write_line('''     * Allocate an array of objects, specified with the array class''')
  write_line('''     * and a count.''')
  write_line('''     *''')
  write_line('''     * The verifier guarantees that this is an array class, so we don't''')
  write_line('''     * check for it here.''')
  write_line('''     */''')
  write_line('''    /* new-array vA, vB, class//CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     x0, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x1, xPC''')
  write_line('''    mov     w2, wINST''')
  write_line('''    mov     x3, xSELF''')
  write_line('''    bl      MterpNewArray''')
  write_line('''    cbz     w0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_new_instance():
  write_line('''    /*''')
  write_line('''     * Create a new instance of a class.''')
  write_line('''     */''')
  write_line('''    /* new-instance vAA, class//BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    add     x0, xFP, #OFF_FP_SHADOWFRAME''')
  write_line('''    mov     x1, xSELF''')
  write_line('''    mov     w2, wINST''')
  write_line('''    bl      MterpNewInstance           // (shadow_frame, self, inst_data)''')
  write_line('''    cbz     w0, MterpPossibleException''')
  write_line('''    FETCH_ADVANCE_INST 2               // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                 // extract opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                     // jump to next instruction''')

def op_nop():
  write_line('''    FETCH_ADVANCE_INST 1                // advance to next instr, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // ip<- opcode from rINST''')
  write_line('''    GOTO_OPCODE ip                      // execute it''')

def op_not_int():
  unop(instr="mvn     w0, w0")

def op_not_long():
  unopWide(instr="mvn     x0, x0")

def op_or_int():
  binop(instr="orr     w0, w0, w1")

def op_or_int_2addr():
  binop2addr(instr="orr     w0, w0, w1")

def op_or_int_lit16():
  binopLit16(instr="orr     w0, w0, w1")

def op_or_int_lit8():
  binopLit8(extract="", instr="orr     w0, w0, w3, asr #8")

def op_or_long():
  binopWide(instr="orr x0, x1, x2")

def op_or_long_2addr():
  binopWide2addr(instr="orr     x0, x0, x1")

def op_packed_switch(func="MterpDoPackedSwitch"):
  write_line('''    /*''')
  write_line('''     * Handle a packed-switch or sparse-switch instruction.  In both cases''')
  write_line('''     * we decode it and hand it off to a helper function.''')
  write_line('''     *''')
  write_line('''     * We don't really expect backward branches in a switch statement, but''')
  write_line('''     * they're perfectly legal, so we check for them here.''')
  write_line('''     *''')
  write_line('''     * for: packed-switch, sparse-switch''')
  write_line('''     */''')
  write_line('''    /* op vAA, +BBBB */''')
  write_line('''    FETCH   w0, 1                       // x0<- 000000000000bbbb (lo)''')
  write_line('''    FETCH_S x1, 2                       // x1<- ssssssssssssBBBB (hi)''')
  write_line('''    lsr     w3, wINST, #8               // w3<- AA''')
  write_line('''    orr     x0, x0, x1, lsl #16         // x0<- ssssssssBBBBbbbb''')
  write_line('''    GET_VREG w1, w3                     // w1<- vAA''')
  write_line('''    add     x0, xPC, x0, lsl #1         // x0<- PC + ssssssssBBBBbbbb*2''')
  write_line('''    bl      ''' + func + '''                       // w0<- code-unit branch offset''')
  write_line('''    sxtw    xINST, w0''')
  write_line('''    b       MterpCommonTakenBranchNoFlags''')

def op_rem_double():
  write_line('''    /* rem vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr     w2, w0, #8                  // w2<- CC''')
  write_line('''    and     w1, w0, #255                // w1<- BB''')
  write_line('''    GET_VREG_WIDE d1, w2                // d1<- vCC''')
  write_line('''    GET_VREG_WIDE d0, w1                // d0<- vBB''')
  write_line('''    bl  fmod''')
  write_line('''    lsr     w4, wINST, #8               // w4<- AA''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE d0, w4                // vAA<- result''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 11-14 instructions */''')

def op_rem_double_2addr():
  write_line('''    /* rem vA, vB */''')
  write_line('''    lsr     w1, wINST, #12              // w1<- B''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    GET_VREG_WIDE d1, w1                // d1<- vB''')
  write_line('''    GET_VREG_WIDE d0, w2                // d0<- vA''')
  write_line('''    bl fmod''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A (need to reload - killed across call)''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE d0, w2                // vAA<- result''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def op_rem_float():
  write_line('''/* EABI doesn't define a float remainder function, but libm does */''')
  fbinop(instr="bl      fmodf")

def op_rem_float_2addr():
  write_line('''    /* rem vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w9, wINST, #8, #4           // w9<- A''')
  write_line('''    GET_VREG s1, w3''')
  write_line('''    GET_VREG s0, w9''')
  write_line('''    bl  fmodf''')
  write_line('''    ubfx    w9, wINST, #8, #4           // w9<- A''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG s0, w9''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

def op_rem_int():
  binop(preinstr="sdiv     w2, w0, w1", instr="msub w0, w2, w1, w0", chkzero="1")

def op_rem_int_2addr():
  binop2addr(preinstr="sdiv     w2, w0, w1", instr="msub w0, w2, w1, w0", chkzero="1")

def op_rem_int_lit16():
  binopLit16(preinstr="sdiv w3, w0, w1", instr="msub w0, w3, w1, w0", chkzero="1")

def op_rem_int_lit8():
  binopLit8(preinstr="sdiv w3, w0, w1", instr="msub w0, w3, w1, w0", chkzero="1")

def op_rem_long():
  binopWide(preinstr="sdiv x3, x1, x2", instr="msub x0, x3, x2, x1", chkzero="1")

def op_rem_long_2addr():
  binopWide2addr(preinstr="sdiv x3, x0, x1", instr="msub x0, x3, x1, x0", chkzero="1")

def op_return():
  write_line('''    /*''')
  write_line('''     * Return a 32-bit value.''')
  write_line('''     *''')
  write_line('''     * for: return, return-object''')
  write_line('''     */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    bl      MterpThreadFenceForConstructor''')
  write_line('''    ldr     w7, [xSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    ands    w7, w7, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    b.ne    .L''' + opcode + '''_check''')
  write_line('''.L''' + opcode + '''_return:''')
  write_line('''    lsr     w2, wINST, #8               // r2<- AA''')
  write_line('''    GET_VREG w0, w2                     // r0<- vAA''')
  write_line('''    b       MterpReturn''')
  write_line('''.L''' + opcode + '''_check:''')
  write_line('''    bl      MterpSuspendCheck           // (self)''')
  write_line('''    b       .L''' + opcode + '''_return''')

def op_return_object():
  op_return()

def op_return_void():
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    bl      MterpThreadFenceForConstructor''')
  write_line('''    ldr     w7, [xSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    ands    w7, w7, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    b.ne    .L''' + opcode + '''_check''')
  write_line('''.L''' + opcode + '''_return:''')
  write_line('''    mov     x0, #0''')
  write_line('''    b       MterpReturn''')
  write_line('''.L''' + opcode + '''_check:''')
  write_line('''    bl      MterpSuspendCheck           // (self)''')
  write_line('''    b       .L''' + opcode + '''_return''')

def op_return_void_no_barrier():
  write_line('''    ldr     w7, [xSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    ands    w7, w7, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    b.ne    .L''' + opcode + '''_check''')
  write_line('''.L''' + opcode + '''_return:''')
  write_line('''    mov     x0, #0''')
  write_line('''    b       MterpReturn''')
  write_line('''.L''' + opcode + '''_check:''')
  write_line('''    bl      MterpSuspendCheck           // (self)''')
  write_line('''    b       .L''' + opcode + '''_return''')

def op_return_wide():
  write_line('''    /*''')
  write_line('''     * Return a 64-bit value.''')
  write_line('''     */''')
  write_line('''    /* return-wide vAA */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    bl      MterpThreadFenceForConstructor''')
  write_line('''    ldr     w7, [xSELF, #THREAD_FLAGS_OFFSET]''')
  write_line('''    mov     x0, xSELF''')
  write_line('''    ands    w7, w7, #THREAD_SUSPEND_OR_CHECKPOINT_REQUEST''')
  write_line('''    b.ne    .L''' + opcode + '''_check''')
  write_line('''.L''' + opcode + '''_return:''')
  write_line('''    lsr     w2, wINST, #8               // w2<- AA''')
  write_line('''    GET_VREG_WIDE x0, w2                // x0<- vAA''')
  write_line('''    b       MterpReturn''')
  write_line('''.L''' + opcode + '''_check:''')
  write_line('''    bl      MterpSuspendCheck           // (self)''')
  write_line('''    b       .L''' + opcode + '''_return''')

def op_rsub_int():
  write_line('''/* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */''')
  binopLit16(instr="sub     w0, w1, w0")

def op_rsub_int_lit8():
  binopLit8(instr="sub     w0, w1, w0")

def op_sget(is_object="0", helper="MterpSGetU32"):
  field(helper=helper)

def op_sget_boolean():
  op_sget(helper="MterpSGetU8")

def op_sget_byte():
  op_sget(helper="MterpSGetI8")

def op_sget_char():
  op_sget(helper="MterpSGetU16")

def op_sget_object():
  op_sget(is_object="1", helper="MterpSGetObj")

def op_sget_short():
  op_sget(helper="MterpSGetI16")

def op_sget_wide():
  op_sget(helper="MterpSGetU64")

def op_shl_int():
  binop(instr="lsl     w0, w0, w1")

def op_shl_int_2addr():
  binop2addr(instr="lsl     w0, w0, w1")

def op_shl_int_lit8():
  binopLit8(extract="ubfx    w1, w3, #8, #5", instr="lsl     w0, w0, w1")

def op_shl_long():
  shiftWide(opcode="lsl")

def op_shl_long_2addr():
  shiftWide2addr(opcode="lsl")

def op_shr_int():
  binop(instr="asr     w0, w0, w1")

def op_shr_int_2addr():
  binop2addr(instr="asr     w0, w0, w1")

def op_shr_int_lit8():
  binopLit8(extract="ubfx    w1, w3, #8, #5", instr="asr     w0, w0, w1")

def op_shr_long():
  shiftWide(opcode="asr")

def op_shr_long_2addr():
  shiftWide2addr(opcode="asr")

def op_sparse_switch():
  op_packed_switch(func="MterpDoSparseSwitch")

def op_sput(is_object="0", helper="MterpSPutU32"):
  field(helper=helper)

def op_sput_boolean():
  op_sput(helper="MterpSPutU8")

def op_sput_byte():
  op_sput(helper="MterpSPutI8")

def op_sput_char():
  op_sput(helper="MterpSPutU16")

def op_sput_object():
  op_sput(is_object="1", helper="MterpSPutObj")

def op_sput_short():
  op_sput(helper="MterpSPutI16")

def op_sput_wide():
  op_sput(helper="MterpSPutU64")

def op_sub_double():
  binopWide(instr="fsub d0, d1, d2", result="d0", r1="d1", r2="d2")

def op_sub_double_2addr():
  binopWide2addr(instr="fsub     d0, d0, d1", r0="d0", r1="d1")

def op_sub_float():
  fbinop(instr="fsub   s0, s0, s1")

def op_sub_float_2addr():
  fbinop2addr(instr="fsub   s2, s0, s1")

def op_sub_int():
  binop(instr="sub     w0, w0, w1")

def op_sub_int_2addr():
  binop2addr(instr="sub     w0, w0, w1")

def op_sub_long():
  binopWide(instr="sub x0, x1, x2")

def op_sub_long_2addr():
  binopWide2addr(instr="sub     x0, x0, x1")

def op_throw():
  write_line('''    /*''')
  write_line('''     * Throw an exception object in the current thread.''')
  write_line('''     */''')
  write_line('''    /* throw vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    lsr      w2, wINST, #8               // r2<- AA''')
  write_line('''    GET_VREG w1, w2                      // r1<- vAA (exception object)''')
  write_line('''    cbz      w1, common_errNullObject''')
  write_line('''    str      x1, [xSELF, #THREAD_EXCEPTION_OFFSET]  // thread->exception<- obj''')
  write_line('''    b        MterpException''')

def op_unused_3e():
  unused()

def op_unused_3f():
  unused()

def op_unused_40():
  unused()

def op_unused_41():
  unused()

def op_unused_42():
  unused()

def op_unused_43():
  unused()

def op_unused_73():
  unused()

def op_unused_79():
  unused()

def op_unused_7a():
  unused()

def op_unused_f3():
  unused()

def op_unused_f4():
  unused()

def op_unused_f5():
  unused()

def op_unused_f6():
  unused()

def op_unused_f7():
  unused()

def op_unused_f8():
  unused()

def op_unused_f9():
  unused()

def op_unused_fc():
  unused()

def op_unused_fd():
  unused()

def op_ushr_int():
  binop(instr="lsr     w0, w0, w1")

def op_ushr_int_2addr():
  binop2addr(instr="lsr     w0, w0, w1")

def op_ushr_int_lit8():
  binopLit8(extract="ubfx    w1, w3, #8, #5", instr="lsr     w0, w0, w1")

def op_ushr_long():
  shiftWide(opcode="lsr")

def op_ushr_long_2addr():
  shiftWide2addr(opcode="lsr")

def op_xor_int():
  binop(instr="eor     w0, w0, w1")

def op_xor_int_2addr():
  binop2addr(instr="eor     w0, w0, w1")

def op_xor_int_lit16():
  binopLit16(instr="eor     w0, w0, w1")

def op_xor_int_lit8():
  binopLit8(extract="", instr="eor     w0, w0, w3, asr #8")

def op_xor_long():
  binopWide(instr="eor x0, x1, x2")

def op_xor_long_2addr():
  binopWide2addr(instr="eor     x0, x0, x1")

def shiftWide(opcode="shl"):
  write_line('''    /*''')
  write_line('''     * 64-bit shift operation.''')
  write_line('''     *''')
  write_line('''     * For: shl-long, shr-long, ushr-long''')
  write_line('''     */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    FETCH w0, 1                         // w0<- CCBB''')
  write_line('''    lsr      w3, wINST, #8               // w3<- AA''')
  write_line('''    lsr      w2, w0, #8                  // w2<- CC''')
  write_line('''    GET_VREG w2, w2                     // w2<- vCC (shift count)''')
  write_line('''    and      w1, w0, #255                // w1<- BB''')
  write_line('''    GET_VREG_WIDE x1, w1                // x1<- vBB''')
  write_line('''    FETCH_ADVANCE_INST 2                // advance rPC, load rINST''')
  write_line('''    ''' + opcode + '''  x0, x1, x2                 // Do the shift. Only low 6 bits of x2 are used.''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE x0, w3                // vAA<- x0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 11-14 instructions */''')

def shiftWide2addr(opcode="lsl"):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit shift operation.''')
  write_line('''     */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    lsr     w1, wINST, #12              // w1<- B''')
  write_line('''    ubfx    w2, wINST, #8, #4           // w2<- A''')
  write_line('''    GET_VREG w1, w1                     // x1<- vB''')
  write_line('''    GET_VREG_WIDE x0, w2                // x0<- vA''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    ''' + opcode + ''' x0, x0, x1                  // Do the shift. Only low 6 bits of x1 are used.''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG_WIDE x0, w2               // vAA<- result''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 10-13 instructions */''')

def unop(instr=""):
  write_line('''    /*''')
  write_line('''     * Generic 32-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = op w0".''')
  write_line('''     * This could be an ARM instruction or a function call.''')
  write_line('''     *''')
  write_line('''     * for: neg-int, not-int, neg-float, int-to-float, float-to-int,''')
  write_line('''     *      int-to-byte, int-to-char, int-to-short''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    GET_VREG w0, w3                     // w0<- vB''')
  write_line('''    ubfx    w9, wINST, #8, #4           // w9<- A''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load rINST''')
  write_line('''    ''' + instr + '''                              // w0<- op, w0-w3 changed''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from rINST''')
  write_line('''    SET_VREG w0, w9                     // vAA<- w0''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 8-9 instructions */''')

def unopWide(instr="sub x0, xzr, x0"):
  write_line('''    /*''')
  write_line('''     * Generic 64-bit unary operation.  Provide an "instr" line that''')
  write_line('''     * specifies an instruction that performs "result = op x0".''')
  write_line('''     *''')
  write_line('''     * For: neg-long, not-long''')
  write_line('''     */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    lsr     w3, wINST, #12              // w3<- B''')
  write_line('''    ubfx    w4, wINST, #8, #4           // w4<- A''')
  write_line('''    GET_VREG_WIDE x0, w3''')
  write_line('''    FETCH_ADVANCE_INST 1                // advance rPC, load wINST''')
  write_line('''    ''' + instr + '''''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    SET_VREG_WIDE x0, w4''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')
  write_line('''    /* 10-11 instructions */''')

def unused():
  write_line('''/*''')
  write_line(''' * Bail to reference interpreter to throw.''')
  write_line(''' */''')
  write_line('''  b MterpFallback''')

def zcmp(compare="1", branch=""):
  write_line('''    /*''')
  write_line('''     * Generic one-operand compare-and-branch operation.  Provide a "condition"''')
  write_line('''     * fragment that specifies the comparison to perform.''')
  write_line('''     *''')
  write_line('''     * for: if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez''')
  write_line('''     */''')
  write_line('''    /* if-cmp vAA, +BBBB */''')
  write_line('''    lsr     w0, wINST, #8               // w0<- AA''')
  write_line('''    GET_VREG w2, w0                     // w2<- vAA''')
  write_line('''    FETCH_S wINST, 1                    // w1<- branch offset, in code units''')
  write_line('''    .if ''' + compare + '''''')
  write_line('''    cmp     w2, #0                      // compare (vA, 0)''')
  write_line('''    .endif''')
  write_line('''    ''' + branch + ''' MterpCommonTakenBranchNoFlags''')
  write_line('''    cmp     wPROFILE, #JIT_CHECK_OSR    // possible OSR re-entry?''')
  write_line('''    b.eq    .L_check_not_taken_osr''')
  write_line('''    FETCH_ADVANCE_INST 2''')
  write_line('''    GET_INST_OPCODE ip                  // extract opcode from wINST''')
  write_line('''    GOTO_OPCODE ip                      // jump to next instruction''')

