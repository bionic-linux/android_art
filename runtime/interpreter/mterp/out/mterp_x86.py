# DO NOT EDIT: This file was generated by gen-mterp.py.
arch = "x86"

import sys

out = sys.stdout
handler_size_bytes = "128"
handler_size_bits = "7"
opcode = ""
opnum = ""

def write_line(line):
  out.write(line + "\n")

def balign():
  write_line("    .balign {}".format(handler_size_bytes))

def write_opcode(num, name, write_method, is_alt):
  global opnum, opcode
  opnum, opcode = str(num), name
  if is_alt:
    name = "ALT_" + name
  write_line("/* ------------------------------ */")
  balign()
  write_line(".L_{1}: /* {0:#04x} */".format(num, name))
  if is_alt:
    alt_stub()
  else:
    write_method()
  write_line("")
  opnum, opcode = None, None

def generate(output_file):
  global out
  out = output_file
  write_line("/* DO NOT EDIT: This file was generated by gen-mterp.py. */")
  header()
  entry()

  instruction_start()
  opcodes(is_alt = False)
  balign()
  instruction_end()

  instruction_start_sister()
  write_sister()
  instruction_end_sister()

  # We need to footer sooner so that branch instruction can reach it.
  # TODO: Clean up.
  if arch == "arm64":
    footer()

  instruction_start_alt()
  opcodes(is_alt = True)
  balign()
  instruction_end_alt()

  if arch == "arm64":
    close_cfi()
  else:
    footer()

  out.truncate()

def opcodes(is_alt):
  write_opcode(0, "op_nop", op_nop, is_alt)
  write_opcode(1, "op_move", op_move, is_alt)
  write_opcode(2, "op_move_from16", op_move_from16, is_alt)
  write_opcode(3, "op_move_16", op_move_16, is_alt)
  write_opcode(4, "op_move_wide", op_move_wide, is_alt)
  write_opcode(5, "op_move_wide_from16", op_move_wide_from16, is_alt)
  write_opcode(6, "op_move_wide_16", op_move_wide_16, is_alt)
  write_opcode(7, "op_move_object", op_move_object, is_alt)
  write_opcode(8, "op_move_object_from16", op_move_object_from16, is_alt)
  write_opcode(9, "op_move_object_16", op_move_object_16, is_alt)
  write_opcode(10, "op_move_result", op_move_result, is_alt)
  write_opcode(11, "op_move_result_wide", op_move_result_wide, is_alt)
  write_opcode(12, "op_move_result_object", op_move_result_object, is_alt)
  write_opcode(13, "op_move_exception", op_move_exception, is_alt)
  write_opcode(14, "op_return_void", op_return_void, is_alt)
  write_opcode(15, "op_return", op_return, is_alt)
  write_opcode(16, "op_return_wide", op_return_wide, is_alt)
  write_opcode(17, "op_return_object", op_return_object, is_alt)
  write_opcode(18, "op_const_4", op_const_4, is_alt)
  write_opcode(19, "op_const_16", op_const_16, is_alt)
  write_opcode(20, "op_const", op_const, is_alt)
  write_opcode(21, "op_const_high16", op_const_high16, is_alt)
  write_opcode(22, "op_const_wide_16", op_const_wide_16, is_alt)
  write_opcode(23, "op_const_wide_32", op_const_wide_32, is_alt)
  write_opcode(24, "op_const_wide", op_const_wide, is_alt)
  write_opcode(25, "op_const_wide_high16", op_const_wide_high16, is_alt)
  write_opcode(26, "op_const_string", op_const_string, is_alt)
  write_opcode(27, "op_const_string_jumbo", op_const_string_jumbo, is_alt)
  write_opcode(28, "op_const_class", op_const_class, is_alt)
  write_opcode(29, "op_monitor_enter", op_monitor_enter, is_alt)
  write_opcode(30, "op_monitor_exit", op_monitor_exit, is_alt)
  write_opcode(31, "op_check_cast", op_check_cast, is_alt)
  write_opcode(32, "op_instance_of", op_instance_of, is_alt)
  write_opcode(33, "op_array_length", op_array_length, is_alt)
  write_opcode(34, "op_new_instance", op_new_instance, is_alt)
  write_opcode(35, "op_new_array", op_new_array, is_alt)
  write_opcode(36, "op_filled_new_array", op_filled_new_array, is_alt)
  write_opcode(37, "op_filled_new_array_range", op_filled_new_array_range, is_alt)
  write_opcode(38, "op_fill_array_data", op_fill_array_data, is_alt)
  write_opcode(39, "op_throw", op_throw, is_alt)
  write_opcode(40, "op_goto", op_goto, is_alt)
  write_opcode(41, "op_goto_16", op_goto_16, is_alt)
  write_opcode(42, "op_goto_32", op_goto_32, is_alt)
  write_opcode(43, "op_packed_switch", op_packed_switch, is_alt)
  write_opcode(44, "op_sparse_switch", op_sparse_switch, is_alt)
  write_opcode(45, "op_cmpl_float", op_cmpl_float, is_alt)
  write_opcode(46, "op_cmpg_float", op_cmpg_float, is_alt)
  write_opcode(47, "op_cmpl_double", op_cmpl_double, is_alt)
  write_opcode(48, "op_cmpg_double", op_cmpg_double, is_alt)
  write_opcode(49, "op_cmp_long", op_cmp_long, is_alt)
  write_opcode(50, "op_if_eq", op_if_eq, is_alt)
  write_opcode(51, "op_if_ne", op_if_ne, is_alt)
  write_opcode(52, "op_if_lt", op_if_lt, is_alt)
  write_opcode(53, "op_if_ge", op_if_ge, is_alt)
  write_opcode(54, "op_if_gt", op_if_gt, is_alt)
  write_opcode(55, "op_if_le", op_if_le, is_alt)
  write_opcode(56, "op_if_eqz", op_if_eqz, is_alt)
  write_opcode(57, "op_if_nez", op_if_nez, is_alt)
  write_opcode(58, "op_if_ltz", op_if_ltz, is_alt)
  write_opcode(59, "op_if_gez", op_if_gez, is_alt)
  write_opcode(60, "op_if_gtz", op_if_gtz, is_alt)
  write_opcode(61, "op_if_lez", op_if_lez, is_alt)
  write_opcode(62, "op_unused_3e", op_unused_3e, is_alt)
  write_opcode(63, "op_unused_3f", op_unused_3f, is_alt)
  write_opcode(64, "op_unused_40", op_unused_40, is_alt)
  write_opcode(65, "op_unused_41", op_unused_41, is_alt)
  write_opcode(66, "op_unused_42", op_unused_42, is_alt)
  write_opcode(67, "op_unused_43", op_unused_43, is_alt)
  write_opcode(68, "op_aget", op_aget, is_alt)
  write_opcode(69, "op_aget_wide", op_aget_wide, is_alt)
  write_opcode(70, "op_aget_object", op_aget_object, is_alt)
  write_opcode(71, "op_aget_boolean", op_aget_boolean, is_alt)
  write_opcode(72, "op_aget_byte", op_aget_byte, is_alt)
  write_opcode(73, "op_aget_char", op_aget_char, is_alt)
  write_opcode(74, "op_aget_short", op_aget_short, is_alt)
  write_opcode(75, "op_aput", op_aput, is_alt)
  write_opcode(76, "op_aput_wide", op_aput_wide, is_alt)
  write_opcode(77, "op_aput_object", op_aput_object, is_alt)
  write_opcode(78, "op_aput_boolean", op_aput_boolean, is_alt)
  write_opcode(79, "op_aput_byte", op_aput_byte, is_alt)
  write_opcode(80, "op_aput_char", op_aput_char, is_alt)
  write_opcode(81, "op_aput_short", op_aput_short, is_alt)
  write_opcode(82, "op_iget", op_iget, is_alt)
  write_opcode(83, "op_iget_wide", op_iget_wide, is_alt)
  write_opcode(84, "op_iget_object", op_iget_object, is_alt)
  write_opcode(85, "op_iget_boolean", op_iget_boolean, is_alt)
  write_opcode(86, "op_iget_byte", op_iget_byte, is_alt)
  write_opcode(87, "op_iget_char", op_iget_char, is_alt)
  write_opcode(88, "op_iget_short", op_iget_short, is_alt)
  write_opcode(89, "op_iput", op_iput, is_alt)
  write_opcode(90, "op_iput_wide", op_iput_wide, is_alt)
  write_opcode(91, "op_iput_object", op_iput_object, is_alt)
  write_opcode(92, "op_iput_boolean", op_iput_boolean, is_alt)
  write_opcode(93, "op_iput_byte", op_iput_byte, is_alt)
  write_opcode(94, "op_iput_char", op_iput_char, is_alt)
  write_opcode(95, "op_iput_short", op_iput_short, is_alt)
  write_opcode(96, "op_sget", op_sget, is_alt)
  write_opcode(97, "op_sget_wide", op_sget_wide, is_alt)
  write_opcode(98, "op_sget_object", op_sget_object, is_alt)
  write_opcode(99, "op_sget_boolean", op_sget_boolean, is_alt)
  write_opcode(100, "op_sget_byte", op_sget_byte, is_alt)
  write_opcode(101, "op_sget_char", op_sget_char, is_alt)
  write_opcode(102, "op_sget_short", op_sget_short, is_alt)
  write_opcode(103, "op_sput", op_sput, is_alt)
  write_opcode(104, "op_sput_wide", op_sput_wide, is_alt)
  write_opcode(105, "op_sput_object", op_sput_object, is_alt)
  write_opcode(106, "op_sput_boolean", op_sput_boolean, is_alt)
  write_opcode(107, "op_sput_byte", op_sput_byte, is_alt)
  write_opcode(108, "op_sput_char", op_sput_char, is_alt)
  write_opcode(109, "op_sput_short", op_sput_short, is_alt)
  write_opcode(110, "op_invoke_virtual", op_invoke_virtual, is_alt)
  write_opcode(111, "op_invoke_super", op_invoke_super, is_alt)
  write_opcode(112, "op_invoke_direct", op_invoke_direct, is_alt)
  write_opcode(113, "op_invoke_static", op_invoke_static, is_alt)
  write_opcode(114, "op_invoke_interface", op_invoke_interface, is_alt)
  write_opcode(115, "op_return_void_no_barrier", op_return_void_no_barrier, is_alt)
  write_opcode(116, "op_invoke_virtual_range", op_invoke_virtual_range, is_alt)
  write_opcode(117, "op_invoke_super_range", op_invoke_super_range, is_alt)
  write_opcode(118, "op_invoke_direct_range", op_invoke_direct_range, is_alt)
  write_opcode(119, "op_invoke_static_range", op_invoke_static_range, is_alt)
  write_opcode(120, "op_invoke_interface_range", op_invoke_interface_range, is_alt)
  write_opcode(121, "op_unused_79", op_unused_79, is_alt)
  write_opcode(122, "op_unused_7a", op_unused_7a, is_alt)
  write_opcode(123, "op_neg_int", op_neg_int, is_alt)
  write_opcode(124, "op_not_int", op_not_int, is_alt)
  write_opcode(125, "op_neg_long", op_neg_long, is_alt)
  write_opcode(126, "op_not_long", op_not_long, is_alt)
  write_opcode(127, "op_neg_float", op_neg_float, is_alt)
  write_opcode(128, "op_neg_double", op_neg_double, is_alt)
  write_opcode(129, "op_int_to_long", op_int_to_long, is_alt)
  write_opcode(130, "op_int_to_float", op_int_to_float, is_alt)
  write_opcode(131, "op_int_to_double", op_int_to_double, is_alt)
  write_opcode(132, "op_long_to_int", op_long_to_int, is_alt)
  write_opcode(133, "op_long_to_float", op_long_to_float, is_alt)
  write_opcode(134, "op_long_to_double", op_long_to_double, is_alt)
  write_opcode(135, "op_float_to_int", op_float_to_int, is_alt)
  write_opcode(136, "op_float_to_long", op_float_to_long, is_alt)
  write_opcode(137, "op_float_to_double", op_float_to_double, is_alt)
  write_opcode(138, "op_double_to_int", op_double_to_int, is_alt)
  write_opcode(139, "op_double_to_long", op_double_to_long, is_alt)
  write_opcode(140, "op_double_to_float", op_double_to_float, is_alt)
  write_opcode(141, "op_int_to_byte", op_int_to_byte, is_alt)
  write_opcode(142, "op_int_to_char", op_int_to_char, is_alt)
  write_opcode(143, "op_int_to_short", op_int_to_short, is_alt)
  write_opcode(144, "op_add_int", op_add_int, is_alt)
  write_opcode(145, "op_sub_int", op_sub_int, is_alt)
  write_opcode(146, "op_mul_int", op_mul_int, is_alt)
  write_opcode(147, "op_div_int", op_div_int, is_alt)
  write_opcode(148, "op_rem_int", op_rem_int, is_alt)
  write_opcode(149, "op_and_int", op_and_int, is_alt)
  write_opcode(150, "op_or_int", op_or_int, is_alt)
  write_opcode(151, "op_xor_int", op_xor_int, is_alt)
  write_opcode(152, "op_shl_int", op_shl_int, is_alt)
  write_opcode(153, "op_shr_int", op_shr_int, is_alt)
  write_opcode(154, "op_ushr_int", op_ushr_int, is_alt)
  write_opcode(155, "op_add_long", op_add_long, is_alt)
  write_opcode(156, "op_sub_long", op_sub_long, is_alt)
  write_opcode(157, "op_mul_long", op_mul_long, is_alt)
  write_opcode(158, "op_div_long", op_div_long, is_alt)
  write_opcode(159, "op_rem_long", op_rem_long, is_alt)
  write_opcode(160, "op_and_long", op_and_long, is_alt)
  write_opcode(161, "op_or_long", op_or_long, is_alt)
  write_opcode(162, "op_xor_long", op_xor_long, is_alt)
  write_opcode(163, "op_shl_long", op_shl_long, is_alt)
  write_opcode(164, "op_shr_long", op_shr_long, is_alt)
  write_opcode(165, "op_ushr_long", op_ushr_long, is_alt)
  write_opcode(166, "op_add_float", op_add_float, is_alt)
  write_opcode(167, "op_sub_float", op_sub_float, is_alt)
  write_opcode(168, "op_mul_float", op_mul_float, is_alt)
  write_opcode(169, "op_div_float", op_div_float, is_alt)
  write_opcode(170, "op_rem_float", op_rem_float, is_alt)
  write_opcode(171, "op_add_double", op_add_double, is_alt)
  write_opcode(172, "op_sub_double", op_sub_double, is_alt)
  write_opcode(173, "op_mul_double", op_mul_double, is_alt)
  write_opcode(174, "op_div_double", op_div_double, is_alt)
  write_opcode(175, "op_rem_double", op_rem_double, is_alt)
  write_opcode(176, "op_add_int_2addr", op_add_int_2addr, is_alt)
  write_opcode(177, "op_sub_int_2addr", op_sub_int_2addr, is_alt)
  write_opcode(178, "op_mul_int_2addr", op_mul_int_2addr, is_alt)
  write_opcode(179, "op_div_int_2addr", op_div_int_2addr, is_alt)
  write_opcode(180, "op_rem_int_2addr", op_rem_int_2addr, is_alt)
  write_opcode(181, "op_and_int_2addr", op_and_int_2addr, is_alt)
  write_opcode(182, "op_or_int_2addr", op_or_int_2addr, is_alt)
  write_opcode(183, "op_xor_int_2addr", op_xor_int_2addr, is_alt)
  write_opcode(184, "op_shl_int_2addr", op_shl_int_2addr, is_alt)
  write_opcode(185, "op_shr_int_2addr", op_shr_int_2addr, is_alt)
  write_opcode(186, "op_ushr_int_2addr", op_ushr_int_2addr, is_alt)
  write_opcode(187, "op_add_long_2addr", op_add_long_2addr, is_alt)
  write_opcode(188, "op_sub_long_2addr", op_sub_long_2addr, is_alt)
  write_opcode(189, "op_mul_long_2addr", op_mul_long_2addr, is_alt)
  write_opcode(190, "op_div_long_2addr", op_div_long_2addr, is_alt)
  write_opcode(191, "op_rem_long_2addr", op_rem_long_2addr, is_alt)
  write_opcode(192, "op_and_long_2addr", op_and_long_2addr, is_alt)
  write_opcode(193, "op_or_long_2addr", op_or_long_2addr, is_alt)
  write_opcode(194, "op_xor_long_2addr", op_xor_long_2addr, is_alt)
  write_opcode(195, "op_shl_long_2addr", op_shl_long_2addr, is_alt)
  write_opcode(196, "op_shr_long_2addr", op_shr_long_2addr, is_alt)
  write_opcode(197, "op_ushr_long_2addr", op_ushr_long_2addr, is_alt)
  write_opcode(198, "op_add_float_2addr", op_add_float_2addr, is_alt)
  write_opcode(199, "op_sub_float_2addr", op_sub_float_2addr, is_alt)
  write_opcode(200, "op_mul_float_2addr", op_mul_float_2addr, is_alt)
  write_opcode(201, "op_div_float_2addr", op_div_float_2addr, is_alt)
  write_opcode(202, "op_rem_float_2addr", op_rem_float_2addr, is_alt)
  write_opcode(203, "op_add_double_2addr", op_add_double_2addr, is_alt)
  write_opcode(204, "op_sub_double_2addr", op_sub_double_2addr, is_alt)
  write_opcode(205, "op_mul_double_2addr", op_mul_double_2addr, is_alt)
  write_opcode(206, "op_div_double_2addr", op_div_double_2addr, is_alt)
  write_opcode(207, "op_rem_double_2addr", op_rem_double_2addr, is_alt)
  write_opcode(208, "op_add_int_lit16", op_add_int_lit16, is_alt)
  write_opcode(209, "op_rsub_int", op_rsub_int, is_alt)
  write_opcode(210, "op_mul_int_lit16", op_mul_int_lit16, is_alt)
  write_opcode(211, "op_div_int_lit16", op_div_int_lit16, is_alt)
  write_opcode(212, "op_rem_int_lit16", op_rem_int_lit16, is_alt)
  write_opcode(213, "op_and_int_lit16", op_and_int_lit16, is_alt)
  write_opcode(214, "op_or_int_lit16", op_or_int_lit16, is_alt)
  write_opcode(215, "op_xor_int_lit16", op_xor_int_lit16, is_alt)
  write_opcode(216, "op_add_int_lit8", op_add_int_lit8, is_alt)
  write_opcode(217, "op_rsub_int_lit8", op_rsub_int_lit8, is_alt)
  write_opcode(218, "op_mul_int_lit8", op_mul_int_lit8, is_alt)
  write_opcode(219, "op_div_int_lit8", op_div_int_lit8, is_alt)
  write_opcode(220, "op_rem_int_lit8", op_rem_int_lit8, is_alt)
  write_opcode(221, "op_and_int_lit8", op_and_int_lit8, is_alt)
  write_opcode(222, "op_or_int_lit8", op_or_int_lit8, is_alt)
  write_opcode(223, "op_xor_int_lit8", op_xor_int_lit8, is_alt)
  write_opcode(224, "op_shl_int_lit8", op_shl_int_lit8, is_alt)
  write_opcode(225, "op_shr_int_lit8", op_shr_int_lit8, is_alt)
  write_opcode(226, "op_ushr_int_lit8", op_ushr_int_lit8, is_alt)
  write_opcode(227, "op_iget_quick", op_iget_quick, is_alt)
  write_opcode(228, "op_iget_wide_quick", op_iget_wide_quick, is_alt)
  write_opcode(229, "op_iget_object_quick", op_iget_object_quick, is_alt)
  write_opcode(230, "op_iput_quick", op_iput_quick, is_alt)
  write_opcode(231, "op_iput_wide_quick", op_iput_wide_quick, is_alt)
  write_opcode(232, "op_iput_object_quick", op_iput_object_quick, is_alt)
  write_opcode(233, "op_invoke_virtual_quick", op_invoke_virtual_quick, is_alt)
  write_opcode(234, "op_invoke_virtual_range_quick", op_invoke_virtual_range_quick, is_alt)
  write_opcode(235, "op_iput_boolean_quick", op_iput_boolean_quick, is_alt)
  write_opcode(236, "op_iput_byte_quick", op_iput_byte_quick, is_alt)
  write_opcode(237, "op_iput_char_quick", op_iput_char_quick, is_alt)
  write_opcode(238, "op_iput_short_quick", op_iput_short_quick, is_alt)
  write_opcode(239, "op_iget_boolean_quick", op_iget_boolean_quick, is_alt)
  write_opcode(240, "op_iget_byte_quick", op_iget_byte_quick, is_alt)
  write_opcode(241, "op_iget_char_quick", op_iget_char_quick, is_alt)
  write_opcode(242, "op_iget_short_quick", op_iget_short_quick, is_alt)
  write_opcode(243, "op_unused_f3", op_unused_f3, is_alt)
  write_opcode(244, "op_unused_f4", op_unused_f4, is_alt)
  write_opcode(245, "op_unused_f5", op_unused_f5, is_alt)
  write_opcode(246, "op_unused_f6", op_unused_f6, is_alt)
  write_opcode(247, "op_unused_f7", op_unused_f7, is_alt)
  write_opcode(248, "op_unused_f8", op_unused_f8, is_alt)
  write_opcode(249, "op_unused_f9", op_unused_f9, is_alt)
  write_opcode(250, "op_invoke_polymorphic", op_invoke_polymorphic, is_alt)
  write_opcode(251, "op_invoke_polymorphic_range", op_invoke_polymorphic_range, is_alt)
  write_opcode(252, "op_invoke_custom", op_invoke_custom, is_alt)
  write_opcode(253, "op_invoke_custom_range", op_invoke_custom_range, is_alt)
  write_opcode(254, "op_const_method_handle", op_const_method_handle, is_alt)
  write_opcode(255, "op_const_method_type", op_const_method_type, is_alt)
def write_sister():
  global opnum, opcode
  pass
def alt_stub():
  write_line('''/*''')
  write_line(''' * Inter-instruction transfer stub.  Call out to MterpCheckBefore to handle''')
  write_line(''' * any interesting requests and then jump to the real instruction''')
  write_line(''' * handler.  Unlike the Arm handler, we can't do this as a tail call''')
  write_line(''' * because rIBASE is caller save and we need to reload it.''')
  write_line(''' *''')
  write_line(''' * Note that unlike in the Arm implementation, we should never arrive''')
  write_line(''' * here with a zero breakFlag because we always refresh rIBASE on''')
  write_line(''' * return.''')
  write_line(''' */''')
  write_line('''    .extern MterpCheckBefore''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG1(%esp)''')
  write_line('''    movl    rPC, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpCheckBefore)        # (self, shadow_frame, dex_pc_ptr)''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    jmp     .L_op_nop+(''' + opnum + '''*''' + handler_size_bytes + ''')''')

def bincmp(revcmp=""):
  write_line('''/*''')
  write_line(''' * Generic two-operand compare-and-branch operation.  Provide a "revcmp"''')
  write_line(''' * fragment that specifies the *reverse* comparison to perform, e.g.''')
  write_line(''' * for "if-le" you would use "gt".''')
  write_line(''' *''')
  write_line(''' * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le''')
  write_line(''' */''')
  write_line('''    /* if-cmp vA, vB, +CCCC */''')
  write_line('''    movzx   rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    GET_VREG %eax, %ecx                     # eax <- vA''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    cmpl    VREG_ADDRESS(rINST), %eax       # compare (vA, vB)''')
  write_line('''    j''' + revcmp + '''   1f''')
  write_line('''    movswl  2(rPC), rINST                   # Get signed branch offset''')
  write_line('''    testl   rINST, rINST''')
  write_line('''    jmp     MterpCommonTakenBranch''')
  write_line('''1:''')
  write_line('''    cmpw    $JIT_CHECK_OSR, rPROFILE''')
  write_line('''    je      .L_check_not_taken_osr''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def bindiv(result="", special="", rem=""):
  write_line('''/*''')
  write_line(''' * 32-bit binary div/rem operation.  Handles special case of op0=minint and''')
  write_line(''' * op1=-1.''')
  write_line(''' */''')
  write_line('''    /* div/rem vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC''')
  write_line('''    mov     rIBASE, LOCAL0(%esp)''')
  write_line('''    testl   %ecx, %ecx''')
  write_line('''    je      common_errDivideByZero''')
  write_line('''    movl    %eax, %edx''')
  write_line('''    orl     %ecx, %edx''')
  write_line('''    testl   $0xFFFFFF00, %edx              # If both arguments are less''')
  write_line('''                                            #   than 8-bit and +ve''')
  write_line('''    jz      .L''' + opcode + '''_8                   # Do 8-bit divide''')
  write_line('''    testl   $0xFFFF0000, %edx              # If both arguments are less''')
  write_line('''                                            #   than 16-bit and +ve''')
  write_line('''    jz      .L''' + opcode + '''_16                  # Do 16-bit divide''')
  write_line('''    cmpl    $-1, %ecx''')
  write_line('''    jne     .L''' + opcode + '''_32''')
  write_line('''    cmpl    $0x80000000, %eax''')
  write_line('''    jne     .L''' + opcode + '''_32''')
  write_line('''    movl    ''' + special + ''', ''' + result + '''''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')
  write_line('''.L''' + opcode + '''_32:''')
  write_line('''    cltd''')
  write_line('''    idivl   %ecx''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')
  write_line('''.L''' + opcode + '''_8:''')
  write_line('''    div     %cl                             # 8-bit divide otherwise.''')
  write_line('''                                            # Remainder in %ah, quotient in %al''')
  write_line('''    .if ''' + rem + '''''')
  write_line('''    movl    %eax, %edx''')
  write_line('''    shr     $8, %edx''')
  write_line('''    .else''')
  write_line('''    andl    $0x000000FF, %eax''')
  write_line('''    .endif''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')
  write_line('''.L''' + opcode + '''_16:''')
  write_line('''    xorl    %edx, %edx                      # Clear %edx before divide''')
  write_line('''    div     %cx''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    mov     LOCAL0(%esp), rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def bindiv2addr(result="", special=""):
  write_line('''/*''')
  write_line(''' * 32-bit binary div/rem operation.  Handles special case of op0=minint and''')
  write_line(''' * op1=-1.''')
  write_line(''' */''')
  write_line('''    /* div/rem/2addr vA, vB */''')
  write_line('''    movzx   rINSTbl, %ecx                   # eax <- BA''')
  write_line('''    mov     rIBASE, LOCAL0(%esp)''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %ecx                     # eax <- vBB''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vBB''')
  write_line('''    testl   %ecx, %ecx''')
  write_line('''    je      common_errDivideByZero''')
  write_line('''    cmpl    $-1, %ecx''')
  write_line('''    jne     .L''' + opcode + '''_continue_div2addr''')
  write_line('''    cmpl    $0x80000000, %eax''')
  write_line('''    jne     .L''' + opcode + '''_continue_div2addr''')
  write_line('''    movl    ''' + special + ''', ''' + result + '''''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    mov     LOCAL0(%esp), rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_continue_div2addr:''')
  write_line('''    cltd''')
  write_line('''    idivl   %ecx''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    mov     LOCAL0(%esp), rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def bindivLit16(result="", special=""):
  write_line('''/*''')
  write_line(''' * 32-bit binary div/rem operation.  Handles special case of op0=minint and''')
  write_line(''' * op1=-1.''')
  write_line(''' */''')
  write_line('''    /* div/rem/lit16 vA, vB, #+CCCC */''')
  write_line('''    /* Need A in rINST, ssssCCCC in ecx, vB in eax */''')
  write_line('''    movzbl  rINSTbl, %eax                   # eax <- 000000BA''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vB''')
  write_line('''    movswl  2(rPC), %ecx                    # ecx <- ssssCCCC''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    testl   %ecx, %ecx''')
  write_line('''    je      common_errDivideByZero''')
  write_line('''    cmpl    $-1, %ecx''')
  write_line('''    jne     .L''' + opcode + '''_continue_div''')
  write_line('''    cmpl    $0x80000000, %eax''')
  write_line('''    jne     .L''' + opcode + '''_continue_div''')
  write_line('''    movl    ''' + special + ''', %eax''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_continue_div:''')
  write_line('''    mov     rIBASE, LOCAL0(%esp)''')
  write_line('''    cltd''')
  write_line('''    idivl   %ecx''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    mov     LOCAL0(%esp), rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def bindivLit8(result="", special=""):
  write_line('''/*''')
  write_line(''' * 32-bit div/rem "lit8" binary operation.  Handles special case of''')
  write_line(''' * op0=minint & op1=-1''')
  write_line(''' */''')
  write_line('''    /* div/rem/lit8 vAA, vBB, #+CC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movsbl  3(rPC), %ecx                    # ecx <- ssssssCC''')
  write_line('''    GET_VREG  %eax, %eax                    # eax <- rBB''')
  write_line('''    testl   %ecx, %ecx''')
  write_line('''    je      common_errDivideByZero''')
  write_line('''    cmpl    $0x80000000, %eax''')
  write_line('''    jne     .L''' + opcode + '''_continue_div''')
  write_line('''    cmpl    $-1, %ecx''')
  write_line('''    jne     .L''' + opcode + '''_continue_div''')
  write_line('''    movl    ''' + special + ''', %eax''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_continue_div:''')
  write_line('''    mov     rIBASE, LOCAL0(%esp)''')
  write_line('''    cltd''')
  write_line('''    idivl   %ecx''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    mov     LOCAL0(%esp), rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binop(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit binary operation.  Provide an "instr" line that''')
  write_line(''' * specifies an instruction that performs "result = eax op (rFP,%ecx,4)".''')
  write_line(''' * This could be an x86 instruction or a function call.  (If the result''')
  write_line(''' * comes back in a register other than eax, you can override "result".)''')
  write_line(''' *''')
  write_line(''' * For: add-int, sub-int, and-int, or-int,''')
  write_line(''' *      xor-int, shl-int, shr-int, ushr-int''')
  write_line(''' */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB''')
  write_line('''    ''' + instr + '''                                  # ex: addl    (rFP,%ecx,4),%eax''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binop1(result="%eax", tmp="%ecx", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit binary operation in which both operands loaded to''')
  write_line(''' * registers (op0 in eax, op1 in ecx).''')
  write_line(''' */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC),%eax                     # eax <- BB''')
  write_line('''    movzbl  3(rPC),%ecx                     # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB''')
  write_line('''    GET_VREG %ecx, %ecx                     # eax <- vBB''')
  write_line('''    ''' + instr + '''                                  # ex: addl    %ecx,%eax''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binop2addr(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line''')
  write_line(''' * that specifies an instruction that performs "result = r0 op r1".''')
  write_line(''' * This could be an instruction or a function call.''')
  write_line(''' *''')
  write_line(''' * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,''')
  write_line(''' *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,''')
  write_line(''' *      shl-int/2addr, shr-int/2addr, ushr-int/2addr, add-float/2addr,''')
  write_line(''' *      sub-float/2addr, mul-float/2addr, div-float/2addr, rem-float/2addr''')
  write_line(''' */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    movzx   rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vB''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    ''' + instr + '''                                  # for ex: addl   %eax,(rFP,%ecx,4)''')
  write_line('''    CLEAR_REF %ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def binopLit16(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "lit16" binary operation.  Provide an "instr" line''')
  write_line(''' * that specifies an instruction that performs "result = eax op ecx".''')
  write_line(''' * This could be an x86 instruction or a function call.  (If the result''')
  write_line(''' * comes back in a register other than eax, you can override "result".)''')
  write_line(''' *''')
  write_line(''' * For: add-int/lit16, rsub-int,''')
  write_line(''' *      and-int/lit16, or-int/lit16, xor-int/lit16''')
  write_line(''' */''')
  write_line('''    /* binop/lit16 vA, vB, #+CCCC */''')
  write_line('''    movzbl  rINSTbl, %eax                   # eax <- 000000BA''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vB''')
  write_line('''    movswl  2(rPC), %ecx                    # ecx <- ssssCCCC''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    ''' + instr + '''                                  # for example: addl %ecx, %eax''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binopLit8(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "lit8" binary operation.  Provide an "instr" line''')
  write_line(''' * that specifies an instruction that performs "result = eax op ecx".''')
  write_line(''' * This could be an x86 instruction or a function call.  (If the result''')
  write_line(''' * comes back in a register other than r0, you can override "result".)''')
  write_line(''' *''')
  write_line(''' * For: add-int/lit8, rsub-int/lit8''')
  write_line(''' *      and-int/lit8, or-int/lit8, xor-int/lit8,''')
  write_line(''' *      shl-int/lit8, shr-int/lit8, ushr-int/lit8''')
  write_line(''' */''')
  write_line('''    /* binop/lit8 vAA, vBB, #+CC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movsbl  3(rPC), %ecx                    # ecx <- ssssssCC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- rBB''')
  write_line('''    ''' + instr + '''                                  # ex: addl %ecx,%eax''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binopWide(instr1="", instr2=""):
  write_line('''/*''')
  write_line(''' * Generic 64-bit binary operation.''')
  write_line(''' */''')
  write_line('''    /* binop vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    movl    rIBASE, LOCAL0(%esp)            # save rIBASE''')
  write_line('''    GET_VREG rIBASE, %eax                   # rIBASE <- v[BB+0]''')
  write_line('''    GET_VREG_HIGH %eax, %eax                # eax <- v[BB+1]''')
  write_line('''    ''' + instr1 + '''                                 # ex: addl   (rFP,%ecx,4),rIBASE''')
  write_line('''    ''' + instr2 + '''                                 # ex: adcl   4(rFP,%ecx,4),%eax''')
  write_line('''    SET_VREG rIBASE, rINST                  # v[AA+0] <- rIBASE''')
  write_line('''    movl    LOCAL0(%esp), rIBASE            # restore rIBASE''')
  write_line('''    SET_VREG_HIGH %eax, rINST               # v[AA+1] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def binopWide2addr(instr1="", instr2=""):
  write_line('''/*''')
  write_line(''' * Generic 64-bit binary operation.''')
  write_line(''' */''')
  write_line('''    /* binop/2addr vA, vB */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx<- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx<- B''')
  write_line('''    GET_VREG %eax, %ecx                     # eax<- v[B+0]''')
  write_line('''    GET_VREG_HIGH %ecx, %ecx                # eax<- v[B+1]''')
  write_line('''    andb    $0xF, rINSTbl                  # rINST<- A''')
  write_line('''    ''' + instr1 + '''                                 # ex: addl   %eax,(rFP,rINST,4)''')
  write_line('''    ''' + instr2 + '''                                 # ex: adcl   %ecx,4(rFP,rINST,4)''')
  write_line('''    CLEAR_WIDE_REF rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def const(helper="UndefinedConstHandler"):
  write_line('''    /* const/class vAA, type@BBBB */''')
  write_line('''    /* const/method-handle vAA, method_handle@BBBB */''')
  write_line('''    /* const/method-type vAA, proto@BBBB */''')
  write_line('''    /* const/string vAA, string@@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- BBBB''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rINST, OUT_ARG1(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG3(%esp)''')
  write_line('''    call    SYMBOL(''' + helper + ''')                 # (index, tgt_reg, shadow_frame, self)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def cvtfp_int(srcdouble="1", tgtlong="1"):
  write_line('''/* On fp to int conversions, Java requires that''')
  write_line(''' * if the result > maxint, it should be clamped to maxint.  If it is less''')
  write_line(''' * than minint, it should be clamped to minint.  If it is a nan, the result''')
  write_line(''' * should be zero.  Further, the rounding mode is to truncate.  This model''')
  write_line(''' * differs from what is delivered normally via the x86 fpu, so we have''')
  write_line(''' * to play some games.''')
  write_line(''' */''')
  write_line('''    /* float/double to int/long vA, vB */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    .if ''' + srcdouble + '''''')
  write_line('''    fldl    VREG_ADDRESS(rINST)             # %st0 <- vB''')
  write_line('''    .else''')
  write_line('''    flds    VREG_ADDRESS(rINST)             # %st0 <- vB''')
  write_line('''    .endif''')
  write_line('''    ftst''')
  write_line('''    fnstcw  LOCAL0(%esp)                    # remember original rounding mode''')
  write_line('''    movzwl  LOCAL0(%esp), %eax''')
  write_line('''    movb    $0xc, %ah''')
  write_line('''    movw    %ax, LOCAL0+2(%esp)''')
  write_line('''    fldcw   LOCAL0+2(%esp)                  # set "to zero" rounding mode''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    .if ''' + tgtlong + '''''')
  write_line('''    fistpll VREG_ADDRESS(%ecx)              # convert and store''')
  write_line('''    .else''')
  write_line('''    fistpl  VREG_ADDRESS(%ecx)              # convert and store''')
  write_line('''    .endif''')
  write_line('''    fldcw   LOCAL0(%esp)                    # restore previous rounding mode''')
  write_line('''    .if ''' + tgtlong + '''''')
  write_line('''    movl    $0x80000000, %eax''')
  write_line('''    xorl    VREG_HIGH_ADDRESS(%ecx), %eax''')
  write_line('''    orl     VREG_ADDRESS(%ecx), %eax''')
  write_line('''    .else''')
  write_line('''    cmpl    $0x80000000, VREG_ADDRESS(%ecx)''')
  write_line('''    .endif''')
  write_line('''    je      .L''' + opcode + '''_special_case # fix up result''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    xor     %eax, %eax''')
  write_line('''    mov     %eax, VREG_REF_ADDRESS(%ecx)''')
  write_line('''    .if ''' + tgtlong + '''''')
  write_line('''    mov     %eax, VREG_REF_HIGH_ADDRESS(%ecx)''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_special_case:''')
  write_line('''    fnstsw  %ax''')
  write_line('''    sahf''')
  write_line('''    jp      .L''' + opcode + '''_isNaN''')
  write_line('''    adcl    $-1, VREG_ADDRESS(%ecx)''')
  write_line('''    .if ''' + tgtlong + '''''')
  write_line('''    adcl    $-1, VREG_HIGH_ADDRESS(%ecx)''')
  write_line('''    .endif''')
  write_line('''   jmp      .L''' + opcode + '''_finish''')
  write_line('''.L''' + opcode + '''_isNaN:''')
  write_line('''    movl    $0, VREG_ADDRESS(%ecx)''')
  write_line('''    .if ''' + tgtlong + '''''')
  write_line('''    movl    $0, VREG_HIGH_ADDRESS(%ecx)''')
  write_line('''    .endif''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')

def entry():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''/*''')
  write_line(''' * Interpreter entry point.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    ASM_HIDDEN SYMBOL(ExecuteMterpImpl)''')
  write_line('''    .global SYMBOL(ExecuteMterpImpl)''')
  write_line('''    FUNCTION_TYPE(ExecuteMterpImpl)''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On entry:''')
  write_line(''' *  0  Thread* self''')
  write_line(''' *  1  insns_''')
  write_line(''' *  2  ShadowFrame''')
  write_line(''' *  3  JValue* result_register''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''''')
  write_line('''SYMBOL(ExecuteMterpImpl):''')
  write_line('''    .cfi_startproc''')
  write_line('''    .cfi_def_cfa esp, 4''')
  write_line('''''')
  write_line('''    /* Spill callee save regs */''')
  write_line('''    PUSH    %ebp''')
  write_line('''    PUSH    %edi''')
  write_line('''    PUSH    %esi''')
  write_line('''    PUSH    %ebx''')
  write_line('''''')
  write_line('''    /* Allocate frame */''')
  write_line('''    subl    $FRAME_SIZE, %esp''')
  write_line('''    .cfi_adjust_cfa_offset FRAME_SIZE''')
  write_line('''''')
  write_line('''    /* Load ShadowFrame pointer */''')
  write_line('''    movl    IN_ARG2(%esp), %edx''')
  write_line('''''')
  write_line('''    /* Remember the return register */''')
  write_line('''    movl    IN_ARG3(%esp), %eax''')
  write_line('''    movl    %eax, SHADOWFRAME_RESULT_REGISTER_OFFSET(%edx)''')
  write_line('''''')
  write_line('''    /* Remember the code_item */''')
  write_line('''    movl    IN_ARG1(%esp), %ecx''')
  write_line('''    movl    %ecx, SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET(%edx)''')
  write_line('''''')
  write_line('''    /* set up "named" registers */''')
  write_line('''    movl    SHADOWFRAME_NUMBER_OF_VREGS_OFFSET(%edx), %eax''')
  write_line('''    leal    SHADOWFRAME_VREGS_OFFSET(%edx), rFP''')
  write_line('''    leal    (rFP, %eax, 4), rREFS''')
  write_line('''    movl    SHADOWFRAME_DEX_PC_OFFSET(%edx), %eax''')
  write_line('''    lea     (%ecx, %eax, 2), rPC''')
  write_line('''    CFI_DEFINE_DEX_PC_WITH_OFFSET(CFI_TMP, CFI_DEX, 0)''')
  write_line('''    EXPORT_PC''')
  write_line('''''')
  write_line('''    /* Set up for backwards branches & osr profiling */''')
  write_line('''    movl    OFF_FP_METHOD(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpSetUpHotnessCountdown)''')
  write_line('''''')
  write_line('''    /* Starting ibase */''')
  write_line('''    REFRESH_IBASE''')
  write_line('''''')
  write_line('''    /* start executing the instruction at rPC */''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''    /* NOTE: no fallthrough */''')

def fallback():
  write_line('''/* Transfer stub to alternate interpreter */''')
  write_line('''    jmp     MterpFallback''')
  write_line('''''')

def field(helper=""):
  write_line('''    /*''')
  write_line('''     * General field read / write (iget-* iput-* sget-* sput-*).''')
  write_line('''     */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    REFRESH_INST ''' + opnum + '''                   # fix rINST to include opcode''')
  write_line('''    movl    rPC, OUT_ARG0(%esp)             # arg0: Instruction* inst''')
  write_line('''    movl    rINST, OUT_ARG1(%esp)           # arg1: uint16_t inst_data''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)            # arg2: ShadowFrame* sf''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG3(%esp)            # arg3: Thread* self''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def footer():
  write_line('''/*''')
  write_line(''' * ===========================================================================''')
  write_line(''' *  Common subroutines and data''')
  write_line(''' * ===========================================================================''')
  write_line(''' */''')
  write_line('''''')
  write_line('''    .text''')
  write_line('''    .align  2''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * We've detected a condition that will result in an exception, but the exception''')
  write_line(''' * has not yet been thrown.  Just bail out to the reference interpreter to deal with it.''')
  write_line(''' * TUNING: for consistency, we may want to just go ahead and handle these here.''')
  write_line(''' */''')
  write_line('''common_errDivideByZero:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpLogDivideByZeroException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errArrayIndex:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpLogArrayIndexException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNegativeArraySize:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpLogNegativeArraySizeException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNoSuchMethod:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpLogNoSuchMethodException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_errNullObject:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpLogNullObjectException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''common_exceptionThrown:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    call    SYMBOL(MterpLogExceptionThrownException)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''MterpSuspendFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    movl    THREAD_FLAGS_OFFSET(%eax), %eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpLogSuspendFallback)''')
  write_line('''#endif''')
  write_line('''    jmp     MterpCommonFallback''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * If we're here, something is out of the ordinary.  If there is a pending''')
  write_line(''' * exception, handle it.  Otherwise, roll back and retry with the reference''')
  write_line(''' * interpreter.''')
  write_line(''' */''')
  write_line('''MterpPossibleException:''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    testl   $-1, THREAD_EXCEPTION_OFFSET(%eax)''')
  write_line('''    jz      MterpFallback''')
  write_line('''    /* intentional fallthrough - handle pending exception. */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On return from a runtime helper routine, we've found a pending exception.''')
  write_line(''' * Can we handle it here - or need to bail out to caller?''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpException:''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpHandleException)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpExceptionReturn''')
  write_line('''    movl    OFF_FP_DEX_INSTRUCTIONS(rFP), %eax''')
  write_line('''    movl    OFF_FP_DEX_PC(rFP), %ecx''')
  write_line('''    lea     (%eax, %ecx, 2), rPC''')
  write_line('''    movl    rPC, OFF_FP_DEX_PC_PTR(rFP)''')
  write_line('''    /* Do we need to switch interpreters? */''')
  write_line('''    call    SYMBOL(MterpShouldSwitchInterpreters)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    /* resume execution at catch block */''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''    /* NOTE: no fallthrough */''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Common handling for branches with support for Jit profiling.''')
  write_line(''' * On entry:''')
  write_line(''' *    rINST          <= signed offset''')
  write_line(''' *    condition bits <= set to establish sign of offset (use "NoFlags" entry if not)''')
  write_line(''' *''')
  write_line(''' * We have quite a few different cases for branch profiling, OSR detection and''')
  write_line(''' * suspend check support here.''')
  write_line(''' *''')
  write_line(''' * Taken backward branches:''')
  write_line(''' *    If profiling active, do hotness countdown and report if we hit zero.''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *    Is there a pending suspend request?  If so, suspend.''')
  write_line(''' *''')
  write_line(''' * Taken forward branches and not-taken backward branches:''')
  write_line(''' *    If in osr check mode, see if our target is a compiled loop header entry and do OSR if so.''')
  write_line(''' *''')
  write_line(''' * Our most common case is expected to be a taken backward branch with active jit profiling,''')
  write_line(''' * but no full OSR check and no pending suspend request.''')
  write_line(''' * Next most common case is not-taken branch with no full OSR check.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''MterpCommonTakenBranch:''')
  write_line('''    jg      .L_forward_branch               # don't add forward branches to hotness''')
  write_line('''/*''')
  write_line(''' * We need to subtract 1 from positive values and we should not see 0 here,''')
  write_line(''' * so we may use the result of the comparison with -1.''')
  write_line(''' */''')
  write_line('''#if JIT_CHECK_OSR != -1''')
  write_line('''#  error "JIT_CHECK_OSR must be -1."''')
  write_line('''#endif''')
  write_line('''    cmpw    $JIT_CHECK_OSR, rPROFILE''')
  write_line('''    je      .L_osr_check''')
  write_line('''    decw    rPROFILE''')
  write_line('''    je      .L_add_batch                    # counted down to zero - report''')
  write_line('''.L_resume_backward_branch:''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(%eax)''')
  write_line('''    leal    (rPC, rINST, 2), rPC''')
  write_line('''    FETCH_INST''')
  write_line('''    jnz     .L_suspend_request_pending''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    GOTO_NEXT''')
  write_line('''''')
  write_line('''.L_suspend_request_pending:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)            # rSELF in eax''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)       # (self)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    REFRESH_IBASE                           # might have changed during suspend''')
  write_line('''    GOTO_NEXT''')
  write_line('''''')
  write_line('''.L_no_count_backwards:''')
  write_line('''    cmpw    $JIT_CHECK_OSR, rPROFILE         # possible OSR re-entry?''')
  write_line('''    jne     .L_resume_backward_branch''')
  write_line('''.L_osr_check:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    rINST, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      .L_resume_backward_branch''')
  write_line('''    jmp     MterpOnStackReplacement''')
  write_line('''''')
  write_line('''.L_forward_branch:''')
  write_line('''    cmpw    $JIT_CHECK_OSR, rPROFILE         # possible OSR re-entry?''')
  write_line('''    je      .L_check_osr_forward''')
  write_line('''.L_resume_forward_branch:''')
  write_line('''    leal    (rPC, rINST, 2), rPC''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''''')
  write_line('''.L_check_osr_forward:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    rINST, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    testb   %al, %al''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    jz      .L_resume_forward_branch''')
  write_line('''    jmp     MterpOnStackReplacement''')
  write_line('''''')
  write_line('''.L_add_batch:''')
  write_line('''    movl    OFF_FP_METHOD(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpAddHotnessBatch)    # (method, shadow_frame, self)''')
  write_line('''    jmp     .L_no_count_backwards''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Entered from the conditional branch handlers when OSR check request active on''')
  write_line(''' * not-taken path.  All Dalvik not-taken conditional branch offsets are 2.''')
  write_line(''' */''')
  write_line('''.L_check_not_taken_osr:''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    $2, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpMaybeDoOnStackReplacement) # (self, shadow_frame, offset)''')
  write_line('''    testb   %al, %al''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    jnz     MterpOnStackReplacement''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On-stack replacement has happened, and now we've returned from the compiled method.''')
  write_line(''' */''')
  write_line('''MterpOnStackReplacement:''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    rINST, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpLogOSR)''')
  write_line('''#endif''')
  write_line('''    movl    $1, %eax''')
  write_line('''    jmp     MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Bail out to reference interpreter.''')
  write_line(''' */''')
  write_line('''MterpFallback:''')
  write_line('''    EXPORT_PC''')
  write_line('''#if MTERP_LOGGING''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    lea     OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpLogFallback)''')
  write_line('''#endif''')
  write_line('''MterpCommonFallback:''')
  write_line('''    xor     %eax, %eax''')
  write_line('''    jmp     MterpDone''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * On entry:''')
  write_line(''' *  uint32_t* rFP  (should still be live, pointer to base of vregs)''')
  write_line(''' */''')
  write_line('''MterpExceptionReturn:''')
  write_line('''    movl    $1, %eax''')
  write_line('''    jmp     MterpDone''')
  write_line('''MterpReturn:''')
  write_line('''    movl    OFF_FP_RESULT_REGISTER(rFP), %edx''')
  write_line('''    movl    %eax, (%edx)''')
  write_line('''    movl    %ecx, 4(%edx)''')
  write_line('''    mov     $1, %eax''')
  write_line('''MterpDone:''')
  write_line('''/*''')
  write_line(''' * At this point, we expect rPROFILE to be non-zero.  If negative, hotness is disabled or we're''')
  write_line(''' * checking for OSR.  If greater than zero, we might have unreported hotness to register''')
  write_line(''' * (the difference between the ending rPROFILE and the cached hotness counter).  rPROFILE''')
  write_line(''' * should only reach zero immediately after a hotness decrement, and is then reset to either''')
  write_line(''' * a negative special state or the new non-zero countdown value.''')
  write_line(''' */''')
  write_line('''    cmpw    $0, rPROFILE''')
  write_line('''    jle     MRestoreFrame                   # if > 0, we may have some counts to report.''')
  write_line('''''')
  write_line('''    movl    %eax, rINST                     # stash return value''')
  write_line('''    /* Report cached hotness counts */''')
  write_line('''    movl    OFF_FP_METHOD(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpAddHotnessBatch)    # (method, shadow_frame, self)''')
  write_line('''    movl    rINST, %eax                     # restore return value''')
  write_line('''''')
  write_line('''    /* pop up frame */''')
  write_line('''MRestoreFrame:''')
  write_line('''    addl    $FRAME_SIZE, %esp''')
  write_line('''    .cfi_adjust_cfa_offset -FRAME_SIZE''')
  write_line('''''')
  write_line('''    /* Restore callee save register */''')
  write_line('''    POP     %ebx''')
  write_line('''    POP     %esi''')
  write_line('''    POP     %edi''')
  write_line('''    POP     %ebp''')
  write_line('''    ret''')
  write_line('''    .cfi_endproc''')
  write_line('''    SIZE(ExecuteMterpImpl,ExecuteMterpImpl)''')

def fpcmp(suff="d", nanval="pos"):
  write_line('''/*''')
  write_line(''' * Compare two floating-point values.  Puts 0, 1, or -1 into the''')
  write_line(''' * destination register based on the results of the comparison.''')
  write_line(''' *''')
  write_line(''' * int compare(x, y) {''')
  write_line(''' *     if (x == y) {''')
  write_line(''' *         return 0;''')
  write_line(''' *     } else if (x < y) {''')
  write_line(''' *         return -1;''')
  write_line(''' *     } else if (x > y) {''')
  write_line(''' *         return 1;''')
  write_line(''' *     } else {''')
  write_line(''' *         return nanval ? 1 : -1;''')
  write_line(''' *     }''')
  write_line(''' * }''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx<- CC''')
  write_line('''    movzbl  2(rPC), %eax                    # eax<- BB''')
  write_line('''    movs''' + suff + ''' VREG_ADDRESS(%eax), %xmm0''')
  write_line('''    xor     %eax, %eax''')
  write_line('''    ucomis''' + suff + ''' VREG_ADDRESS(%ecx), %xmm0''')
  write_line('''    jp      .L''' + opcode + '''_nan_is_''' + nanval + '''''')
  write_line('''    je      .L''' + opcode + '''_finish''')
  write_line('''    jb      .L''' + opcode + '''_less''')
  write_line('''.L''' + opcode + '''_nan_is_pos:''')
  write_line('''    incl    %eax''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')
  write_line('''.L''' + opcode + '''_nan_is_neg:''')
  write_line('''.L''' + opcode + '''_less:''')
  write_line('''    decl    %eax''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def fpcvt(instr="", load="", store="", wide="0"):
  write_line('''/*''')
  write_line(''' * Generic 32-bit FP conversion operation.''')
  write_line(''' */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    ''' + load + '''   VREG_ADDRESS(rINST)             # %st0 <- vB''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    ''' + instr + '''''')
  write_line('''    ''' + store + '''  VREG_ADDRESS(%ecx)              # vA <- %st0''')
  write_line('''    .if ''' + wide + '''''')
  write_line('''    CLEAR_WIDE_REF %ecx''')
  write_line('''    .else''')
  write_line('''    CLEAR_REF %ecx''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def header():
  write_line('''/*''')
  write_line(''' * Copyright (C) 2016 The Android Open Source Project''')
  write_line(''' *''')
  write_line(''' * Licensed under the Apache License, Version 2.0 (the "License");''')
  write_line(''' * you may not use this file except in compliance with the License.''')
  write_line(''' * You may obtain a copy of the License at''')
  write_line(''' *''')
  write_line(''' *      http://www.apache.org/licenses/LICENSE-2.0''')
  write_line(''' *''')
  write_line(''' * Unless required by applicable law or agreed to in writing, software''')
  write_line(''' * distributed under the License is distributed on an "AS IS" BASIS,''')
  write_line(''' * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.''')
  write_line(''' * See the License for the specific language governing permissions and''')
  write_line(''' * limitations under the License.''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''  Art assembly interpreter notes:''')
  write_line('''''')
  write_line('''  First validate assembly code by implementing ExecuteXXXImpl() style body (doesn't''')
  write_line('''  handle invoke, allows higher-level code to create frame & shadow frame.''')
  write_line('''''')
  write_line('''  Once that's working, support direct entry code & eliminate shadow frame (and''')
  write_line('''  excess locals allocation.''')
  write_line('''''')
  write_line('''  Some (hopefully) temporary ugliness.  We'll treat rFP as pointing to the''')
  write_line('''  base of the vreg array within the shadow frame.  Access the other fields,''')
  write_line('''  dex_pc_, method_ and number_of_vregs_ via negative offsets.  For now, we'll continue''')
  write_line('''  the shadow frame mechanism of double-storing object references - via rFP &''')
  write_line('''  number_of_vregs_.''')
  write_line('''''')
  write_line(''' */''')
  write_line('''''')
  write_line('''/*''')
  write_line('''x86 ABI general notes:''')
  write_line('''''')
  write_line('''Caller save set:''')
  write_line('''   eax, edx, ecx, st(0)-st(7)''')
  write_line('''Callee save set:''')
  write_line('''   ebx, esi, edi, ebp''')
  write_line('''Return regs:''')
  write_line('''   32-bit in eax''')
  write_line('''   64-bit in edx:eax (low-order 32 in eax)''')
  write_line('''   fp on top of fp stack st(0)''')
  write_line('''''')
  write_line('''Parameters passed on stack, pushed right-to-left.  On entry to target, first''')
  write_line('''parm is at 4(%esp).  Traditional entry code is:''')
  write_line('''''')
  write_line('''functEntry:''')
  write_line('''    push    %ebp             # save old frame pointer''')
  write_line('''    mov     %ebp,%esp        # establish new frame pointer''')
  write_line('''    sub     FrameSize,%esp   # Allocate storage for spill, locals & outs''')
  write_line('''''')
  write_line('''Once past the prologue, arguments are referenced at ((argno + 2)*4)(%ebp)''')
  write_line('''''')
  write_line('''Stack must be 16-byte aligned to support SSE in native code.''')
  write_line('''''')
  write_line('''If we're not doing variable stack allocation (alloca), the frame pointer can be''')
  write_line('''eliminated and all arg references adjusted to be esp relative.''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/*''')
  write_line('''Mterp and x86 notes:''')
  write_line('''''')
  write_line('''Some key interpreter variables will be assigned to registers.''')
  write_line('''''')
  write_line('''  nick     reg   purpose''')
  write_line('''  rPC      esi   interpreted program counter, used for fetching instructions''')
  write_line('''  rFP      edi   interpreted frame pointer, used for accessing locals and args''')
  write_line('''  rINSTw   bx    first 16-bit code of current instruction''')
  write_line('''  rINSTbl  bl    opcode portion of instruction word''')
  write_line('''  rINSTbh  bh    high byte of inst word, usually contains src/tgt reg names''')
  write_line('''  rIBASE   edx   base of instruction handler table''')
  write_line('''  rREFS    ebp   base of object references in shadow frame.''')
  write_line('''''')
  write_line('''Notes:''')
  write_line('''   o High order 16 bits of ebx must be zero on entry to handler''')
  write_line('''   o rPC, rFP, rINSTw/rINSTbl valid on handler entry and exit''')
  write_line('''   o eax and ecx are scratch, rINSTw/ebx sometimes scratch''')
  write_line('''''')
  write_line('''Macros are provided for common operations.  Each macro MUST emit only''')
  write_line('''one instruction to make instruction-counting easier.  They MUST NOT alter''')
  write_line('''unspecified registers or condition codes.''')
  write_line('''*/''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * This is a #include, not a %include, because we want the C pre-processor''')
  write_line(''' * to expand the macros into assembler assignment statements.''')
  write_line(''' */''')
  write_line('''#include "asm_support.h"''')
  write_line('''#include "interpreter/cfi_asm_support.h"''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Handle mac compiler specific''')
  write_line(''' */''')
  write_line('''#if defined(__APPLE__)''')
  write_line('''    #define MACRO_LITERAL(value) $(value)''')
  write_line('''    #define FUNCTION_TYPE(name)''')
  write_line('''    #define OBJECT_TYPE(name)''')
  write_line('''    #define SIZE(start,end)''')
  write_line('''    // Mac OS' symbols have an _ prefix.''')
  write_line('''    #define SYMBOL(name) _ ## name''')
  write_line('''    #define ASM_HIDDEN .private_extern''')
  write_line('''#else''')
  write_line('''    #define MACRO_LITERAL(value) $value''')
  write_line('''    #define FUNCTION_TYPE(name) .type name, @function''')
  write_line('''    #define OBJECT_TYPE(name) .type name, @object''')
  write_line('''    #define SIZE(start,end) .size start, .-end''')
  write_line('''    #define SYMBOL(name) name''')
  write_line('''    #define ASM_HIDDEN .hidden''')
  write_line('''#endif''')
  write_line('''''')
  write_line('''.macro PUSH _reg''')
  write_line('''    pushl \\_reg''')
  write_line('''    .cfi_adjust_cfa_offset 4''')
  write_line('''    .cfi_rel_offset \\_reg, 0''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro POP _reg''')
  write_line('''    popl \\_reg''')
  write_line('''    .cfi_adjust_cfa_offset -4''')
  write_line('''    .cfi_restore \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Instead of holding a pointer to the shadow frame, we keep rFP at the base of the vregs.  So,''')
  write_line(''' * to access other shadow frame fields, we need to use a backwards offset.  Define those here.''')
  write_line(''' */''')
  write_line('''#define OFF_FP(a) (a - SHADOWFRAME_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_NUMBER_OF_VREGS OFF_FP(SHADOWFRAME_NUMBER_OF_VREGS_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC OFF_FP(SHADOWFRAME_DEX_PC_OFFSET)''')
  write_line('''#define OFF_FP_LINK OFF_FP(SHADOWFRAME_LINK_OFFSET)''')
  write_line('''#define OFF_FP_METHOD OFF_FP(SHADOWFRAME_METHOD_OFFSET)''')
  write_line('''#define OFF_FP_RESULT_REGISTER OFF_FP(SHADOWFRAME_RESULT_REGISTER_OFFSET)''')
  write_line('''#define OFF_FP_DEX_PC_PTR OFF_FP(SHADOWFRAME_DEX_PC_PTR_OFFSET)''')
  write_line('''#define OFF_FP_DEX_INSTRUCTIONS OFF_FP(SHADOWFRAME_DEX_INSTRUCTIONS_OFFSET)''')
  write_line('''#define OFF_FP_COUNTDOWN_OFFSET OFF_FP(SHADOWFRAME_HOTNESS_COUNTDOWN_OFFSET)''')
  write_line('''#define OFF_FP_SHADOWFRAME OFF_FP(0)''')
  write_line('''''')
  write_line('''/* Frame size must be 16-byte aligned.''')
  write_line(''' * Remember about 4 bytes for return address + 4 * 4 for spills''')
  write_line(''' */''')
  write_line('''#define FRAME_SIZE     28''')
  write_line('''''')
  write_line('''/* Frame diagram while executing ExecuteMterpImpl, high to low addresses */''')
  write_line('''#define IN_ARG3        (FRAME_SIZE + 16 + 16)''')
  write_line('''#define IN_ARG2        (FRAME_SIZE + 16 + 12)''')
  write_line('''#define IN_ARG1        (FRAME_SIZE + 16 +  8)''')
  write_line('''#define IN_ARG0        (FRAME_SIZE + 16 +  4)''')
  write_line('''/* Spill offsets relative to %esp */''')
  write_line('''#define LOCAL0         (FRAME_SIZE -  4)''')
  write_line('''#define LOCAL1         (FRAME_SIZE -  8)''')
  write_line('''#define LOCAL2         (FRAME_SIZE - 12)''')
  write_line('''/* Out Arg offsets, relative to %esp */''')
  write_line('''#define OUT_ARG3       ( 12)''')
  write_line('''#define OUT_ARG2       (  8)''')
  write_line('''#define OUT_ARG1       (  4)''')
  write_line('''#define OUT_ARG0       (  0)  /* <- ExecuteMterpImpl esp + 0 */''')
  write_line('''''')
  write_line('''/* During bringup, we'll use the shadow frame model instead of rFP */''')
  write_line('''/* single-purpose registers, given names for clarity */''')
  write_line('''#define rSELF    IN_ARG0(%esp)''')
  write_line('''#define rPC      %esi''')
  write_line('''#define CFI_DEX  6  // DWARF register number of the register holding dex-pc (esi).''')
  write_line('''#define CFI_TMP  0  // DWARF register number of the first argument register (eax).''')
  write_line('''#define rFP      %edi''')
  write_line('''#define rINST    %ebx''')
  write_line('''#define rINSTw   %bx''')
  write_line('''#define rINSTbh  %bh''')
  write_line('''#define rINSTbl  %bl''')
  write_line('''#define rIBASE   %edx''')
  write_line('''#define rREFS    %ebp''')
  write_line('''#define rPROFILE OFF_FP_COUNTDOWN_OFFSET(rFP)''')
  write_line('''''')
  write_line('''#define MTERP_LOGGING 0''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * "export" the PC to dex_pc field in the shadow frame, f/b/o future exception objects.  Must''')
  write_line(''' * be done *before* something throws.''')
  write_line(''' *''')
  write_line(''' * It's okay to do this more than once.''')
  write_line(''' *''')
  write_line(''' * NOTE: the fast interpreter keeps track of dex pc as a direct pointer to the mapped''')
  write_line(''' * dex byte codes.  However, the rest of the runtime expects dex pc to be an instruction''')
  write_line(''' * offset into the code_items_[] array.  For effiency, we will "export" the''')
  write_line(''' * current dex pc as a direct pointer using the EXPORT_PC macro, and rely on GetDexPC''')
  write_line(''' * to convert to a dex pc when needed.''')
  write_line(''' */''')
  write_line('''.macro EXPORT_PC''')
  write_line('''    movl    rPC, OFF_FP_DEX_PC_PTR(rFP)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh handler table.''')
  write_line(''' */''')
  write_line('''.macro REFRESH_IBASE''')
  write_line('''    movl    rSELF, rIBASE''')
  write_line('''    movl    THREAD_CURRENT_IBASE_OFFSET(rIBASE), rIBASE''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh handler table.''')
  write_line(''' * IBase handles uses the caller save register so we must restore it after each call.''')
  write_line(''' * Also it is used as a result of some 64-bit operations (like imul) and we should''')
  write_line(''' * restore it in such cases also.''')
  write_line(''' *''')
  write_line(''' * TODO: Consider spilling the IBase instead of restoring it from Thread structure.''')
  write_line(''' */''')
  write_line('''.macro RESTORE_IBASE''')
  write_line('''    movl    rSELF, rIBASE''')
  write_line('''    movl    THREAD_CURRENT_IBASE_OFFSET(rIBASE), rIBASE''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * If rSELF is already loaded then we can use it from known reg.''')
  write_line(''' */''')
  write_line('''.macro RESTORE_IBASE_FROM_SELF _reg''')
  write_line('''    movl    THREAD_CURRENT_IBASE_OFFSET(\\_reg), rIBASE''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Refresh rINST.''')
  write_line(''' * At enter to handler rINST does not contain the opcode number.''')
  write_line(''' * However some utilities require the full value, so this macro''')
  write_line(''' * restores the opcode number.''')
  write_line(''' */''')
  write_line('''.macro REFRESH_INST _opnum''')
  write_line('''    movb    rINSTbl, rINSTbh''')
  write_line('''    movb    MACRO_LITERAL(\\_opnum), rINSTbl''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Fetch the next instruction from rPC into rINSTw.  Does not advance rPC.''')
  write_line(''' */''')
  write_line('''.macro FETCH_INST''')
  write_line('''    movzwl  (rPC), rINST''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Remove opcode from rINST, compute the address of handler and jump to it.''')
  write_line(''' */''')
  write_line('''.macro GOTO_NEXT''')
  write_line('''    movzx   rINSTbl,%eax''')
  write_line('''    movzbl  rINSTbh,rINST''')
  write_line('''    shll    MACRO_LITERAL(''' + handler_size_bits + '''), %eax''')
  write_line('''    addl    rIBASE, %eax''')
  write_line('''    jmp     *%eax''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Advance rPC by instruction count.''')
  write_line(''' */''')
  write_line('''.macro ADVANCE_PC _count''')
  write_line('''    leal    2*\\_count(rPC), rPC''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Advance rPC by instruction count, fetch instruction and jump to handler.''')
  write_line(''' */''')
  write_line('''.macro ADVANCE_PC_FETCH_AND_GOTO_NEXT _count''')
  write_line('''    ADVANCE_PC \\_count''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/*''')
  write_line(''' * Get/set the 32-bit value from a Dalvik register.''')
  write_line(''' */''')
  write_line('''#define VREG_ADDRESS(_vreg) (rFP,_vreg,4)''')
  write_line('''#define VREG_HIGH_ADDRESS(_vreg) 4(rFP,_vreg,4)''')
  write_line('''#define VREG_REF_ADDRESS(_vreg) (rREFS,_vreg,4)''')
  write_line('''#define VREG_REF_HIGH_ADDRESS(_vreg) 4(rREFS,_vreg,4)''')
  write_line('''''')
  write_line('''.macro GET_VREG _reg _vreg''')
  write_line('''    movl    (rFP,\\_vreg,4), \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/* Read wide value to xmm. */''')
  write_line('''.macro GET_WIDE_FP_VREG _reg _vreg''')
  write_line('''    movq    (rFP,\\_vreg,4), \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro SET_VREG _reg _vreg''')
  write_line('''    movl    \\_reg, (rFP,\\_vreg,4)''')
  write_line('''    movl    MACRO_LITERAL(0), (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''/* Write wide value from xmm. xmm is clobbered. */''')
  write_line('''.macro SET_WIDE_FP_VREG _reg _vreg''')
  write_line('''    movq    \\_reg, (rFP,\\_vreg,4)''')
  write_line('''    pxor    \\_reg, \\_reg''')
  write_line('''    movq    \\_reg, (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro SET_VREG_OBJECT _reg _vreg''')
  write_line('''    movl    \\_reg, (rFP,\\_vreg,4)''')
  write_line('''    movl    \\_reg, (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro GET_VREG_HIGH _reg _vreg''')
  write_line('''    movl    4(rFP,\\_vreg,4), \\_reg''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro SET_VREG_HIGH _reg _vreg''')
  write_line('''    movl    \\_reg, 4(rFP,\\_vreg,4)''')
  write_line('''    movl    MACRO_LITERAL(0), 4(rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro CLEAR_REF _vreg''')
  write_line('''    movl    MACRO_LITERAL(0),  (rREFS,\\_vreg,4)''')
  write_line('''.endm''')
  write_line('''''')
  write_line('''.macro CLEAR_WIDE_REF _vreg''')
  write_line('''    movl    MACRO_LITERAL(0),  (rREFS,\\_vreg,4)''')
  write_line('''    movl    MACRO_LITERAL(0), 4(rREFS,\\_vreg,4)''')
  write_line('''.endm''')

def instruction_end():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmInstructionEnd)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmInstructionEnd)''')
  write_line('''    .global SYMBOL(artMterpAsmInstructionEnd)''')
  write_line('''SYMBOL(artMterpAsmInstructionEnd):''')

def instruction_end_alt():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmAltInstructionEnd)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmAltInstructionEnd)''')
  write_line('''    .global SYMBOL(artMterpAsmAltInstructionEnd)''')
  write_line('''SYMBOL(artMterpAsmAltInstructionEnd):''')

def instruction_end_sister():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmSisterEnd)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmSisterEnd)''')
  write_line('''    .global SYMBOL(artMterpAsmSisterEnd)''')
  write_line('''SYMBOL(artMterpAsmSisterEnd):''')

def instruction_start():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmInstructionStart)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmInstructionStart)''')
  write_line('''    .global SYMBOL(artMterpAsmInstructionStart)''')
  write_line('''SYMBOL(artMterpAsmInstructionStart) = .L_op_nop''')
  write_line('''    .text''')

def instruction_start_alt():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmAltInstructionStart)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmAltInstructionStart)''')
  write_line('''    .global SYMBOL(artMterpAsmAltInstructionStart)''')
  write_line('''    .text''')
  write_line('''SYMBOL(artMterpAsmAltInstructionStart) = .L_ALT_op_nop''')

def instruction_start_sister():
  write_line('''''')
  write_line('''    OBJECT_TYPE(artMterpAsmSisterStart)''')
  write_line('''    ASM_HIDDEN SYMBOL(artMterpAsmSisterStart)''')
  write_line('''    .global SYMBOL(artMterpAsmSisterStart)''')
  write_line('''    .text''')
  write_line('''    .balign 4''')
  write_line('''SYMBOL(artMterpAsmSisterStart):''')

def invoke(helper="UndefinedInvokeHandler"):
  write_line('''/*''')
  write_line(''' * Generic invoke handler wrapper.''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG1(%esp)''')
  write_line('''    movl    rPC, OUT_ARG2(%esp)''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_ARG3(%esp)''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpException''')
  write_line('''    ADVANCE_PC 3''')
  write_line('''    call    SYMBOL(MterpShouldSwitchInterpreters)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')

def invoke_polymorphic(helper="UndefinedInvokeHandler"):
  write_line('''    /*''')
  write_line('''     * invoke-polymorphic handler wrapper.''')
  write_line('''     */''')
  write_line('''    /* op {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB, proto@HHHH */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG1(%esp)''')
  write_line('''    movl    rPC, OUT_ARG2(%esp)''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_ARG3(%esp)''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpException''')
  write_line('''    ADVANCE_PC 4''')
  write_line('''    call    SYMBOL(MterpShouldSwitchInterpreters)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpFallback''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    FETCH_INST''')
  write_line('''    GOTO_NEXT''')

def op_add_double():
  sseBinop(instr="adds", suff="d")

def op_add_double_2addr():
  sseBinop2Addr(instr="adds", suff="d")

def op_add_float():
  sseBinop(instr="adds", suff="s")

def op_add_float_2addr():
  sseBinop2Addr(instr="adds", suff="s")

def op_add_int():
  binop(instr="addl    (rFP,%ecx,4), %eax")

def op_add_int_2addr():
  binop2addr(instr="addl    %eax, (rFP,%ecx,4)")

def op_add_int_lit16():
  binopLit16(instr="addl    %ecx, %eax")

def op_add_int_lit8():
  binopLit8(instr="addl    %ecx, %eax")

def op_add_long():
  binopWide(instr1="addl    (rFP,%ecx,4), rIBASE", instr2="adcl    4(rFP,%ecx,4), %eax")

def op_add_long_2addr():
  binopWide2addr(instr1="addl    %eax, (rFP,rINST,4)", instr2="adcl    %ecx, 4(rFP,rINST,4)")

def op_aget(load="movl", shift="4", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''/*''')
  write_line(''' * Array get, 32 bits or less.  vAA <- vBB[vCC].''')
  write_line(''' *''')
  write_line(''' * for: aget, aget-boolean, aget-byte, aget-char, aget-short''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB (array object)''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC (requested index)''')
  write_line('''    testl   %eax, %eax                      # null array object?''')
  write_line('''    je      common_errNullObject            # bail if so''')
  write_line('''    cmpl    MIRROR_ARRAY_LENGTH_OFFSET(%eax), %ecx''')
  write_line('''    jae     common_errArrayIndex            # index >= length, bail.''')
  write_line('''    ''' + load + '''   ''' + data_offset + '''(%eax,%ecx,''' + shift + '''), %eax''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aget_boolean():
  op_aget(load="movzbl", shift="1", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aget_byte():
  op_aget(load="movsbl", shift="1", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aget_char():
  op_aget(load="movzwl", shift="2", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aget_object():
  write_line('''/*''')
  write_line(''' * Array object get.  vAA <- vBB[vCC].''')
  write_line(''' *''')
  write_line(''' * for: aget-object''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB (array object)''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecs <- vCC (requested index)''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(artAGetObjectFromMterp)  # (array, index)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    RESTORE_IBASE_FROM_SELF %ecx''')
  write_line('''    cmpl    $0, THREAD_EXCEPTION_OFFSET(%ecx)''')
  write_line('''    jnz     MterpException''')
  write_line('''    SET_VREG_OBJECT %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aget_short():
  op_aget(load="movswl", shift="2", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aget_wide():
  write_line('''/*''')
  write_line(''' * Array get, 64 bits.  vAA <- vBB[vCC].''')
  write_line(''' */''')
  write_line('''    /* aget-wide vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB (array object)''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC (requested index)''')
  write_line('''    testl   %eax, %eax                      # null array object?''')
  write_line('''    je      common_errNullObject            # bail if so''')
  write_line('''    cmpl    MIRROR_ARRAY_LENGTH_OFFSET(%eax), %ecx''')
  write_line('''    jae     common_errArrayIndex            # index >= length, bail.''')
  write_line('''    leal    MIRROR_WIDE_ARRAY_DATA_OFFSET(%eax,%ecx,8), %eax''')
  write_line('''    movq    (%eax), %xmm0                   # xmm0 <- vBB[vCC]''')
  write_line('''    SET_WIDE_FP_VREG %xmm0, rINST           # vAA <- xmm0''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_and_int():
  binop(instr="andl    (rFP,%ecx,4), %eax")

def op_and_int_2addr():
  binop2addr(instr="andl    %eax, (rFP,%ecx,4)")

def op_and_int_lit16():
  binopLit16(instr="andl    %ecx, %eax")

def op_and_int_lit8():
  binopLit8(instr="andl    %ecx, %eax")

def op_and_long():
  binopWide(instr1="andl    (rFP,%ecx,4), rIBASE", instr2="andl    4(rFP,%ecx,4), %eax")

def op_and_long_2addr():
  binopWide2addr(instr1="andl    %eax, (rFP,rINST,4)", instr2="andl    %ecx, 4(rFP,rINST,4)")

def op_aput(reg="rINST", store="movl", shift="4", data_offset="MIRROR_INT_ARRAY_DATA_OFFSET"):
  write_line('''/*''')
  write_line(''' * Array put, 32 bits or less.  vBB[vCC] <- vAA.''')
  write_line(''' *''')
  write_line(''' * for: aput, aput-boolean, aput-byte, aput-char, aput-short''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB (array object)''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC (requested index)''')
  write_line('''    testl   %eax, %eax                      # null array object?''')
  write_line('''    je      common_errNullObject            # bail if so''')
  write_line('''    cmpl    MIRROR_ARRAY_LENGTH_OFFSET(%eax), %ecx''')
  write_line('''    jae     common_errArrayIndex            # index >= length, bail.''')
  write_line('''    leal    ''' + data_offset + '''(%eax,%ecx,''' + shift + '''), %eax''')
  write_line('''    GET_VREG rINST, rINST''')
  write_line('''    ''' + store + '''  ''' + reg + ''', (%eax)''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aput_boolean():
  op_aput(reg="rINSTbl", store="movb", shift="1", data_offset="MIRROR_BOOLEAN_ARRAY_DATA_OFFSET")

def op_aput_byte():
  op_aput(reg="rINSTbl", store="movb", shift="1", data_offset="MIRROR_BYTE_ARRAY_DATA_OFFSET")

def op_aput_char():
  op_aput(reg="rINSTw", store="movw", shift="2", data_offset="MIRROR_CHAR_ARRAY_DATA_OFFSET")

def op_aput_object():
  write_line('''/*''')
  write_line(''' * Store an object into an array.  vBB[vCC] <- vAA.''')
  write_line(''' */''')
  write_line('''    /* op vAA, vBB, vCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rPC, OUT_ARG1(%esp)''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpAputObject)         # (array, index)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_aput_short():
  op_aput(reg="rINSTw", store="movw", shift="2", data_offset="MIRROR_SHORT_ARRAY_DATA_OFFSET")

def op_aput_wide():
  write_line('''/*''')
  write_line(''' * Array put, 64 bits.  vBB[vCC] <- vAA.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''    /* aput-wide vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB (array object)''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC (requested index)''')
  write_line('''    testl   %eax, %eax                      # null array object?''')
  write_line('''    je      common_errNullObject            # bail if so''')
  write_line('''    cmpl    MIRROR_ARRAY_LENGTH_OFFSET(%eax), %ecx''')
  write_line('''    jae     common_errArrayIndex            # index >= length, bail.''')
  write_line('''    leal    MIRROR_WIDE_ARRAY_DATA_OFFSET(%eax,%ecx,8), %eax''')
  write_line('''    GET_WIDE_FP_VREG %xmm0, rINST           # xmm0 <- vAA''')
  write_line('''    movq    %xmm0, (%eax)                   # vBB[vCC] <- xmm0''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_array_length():
  write_line('''/*''')
  write_line(''' * Return the length of an array.''')
  write_line(''' */''')
  write_line('''    mov     rINST, %eax                     # eax <- BA''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    GET_VREG %ecx, rINST                    # ecx <- vB (object ref)''')
  write_line('''    testl   %ecx, %ecx                      # is null?''')
  write_line('''    je      common_errNullObject''')
  write_line('''    andb    $0xf, %al                      # eax <- A''')
  write_line('''    movl    MIRROR_ARRAY_LENGTH_OFFSET(%ecx), rINST''')
  write_line('''    SET_VREG rINST, %eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_check_cast():
  write_line('''/*''')
  write_line(''' * Check to see if a cast from one class to another is allowed.''')
  write_line(''' */''')
  write_line('''    /* check-cast vAA, class@BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- BBBB''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    leal    VREG_ADDRESS(rINST), %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    OFF_FP_METHOD(rFP),%eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG3(%esp)''')
  write_line('''    call    SYMBOL(MterpCheckCast)          # (index, &obj, method, self)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_cmp_long():
  write_line('''/*''')
  write_line(''' * Compare two 64-bit values.  Puts 0, 1, or -1 into the destination''')
  write_line(''' * register based on the results of the comparison.''')
  write_line(''' */''')
  write_line('''    /* cmp-long vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG_HIGH %eax, %eax                # eax <- v[BB+1], BB is clobbered''')
  write_line('''    cmpl    VREG_HIGH_ADDRESS(%ecx), %eax''')
  write_line('''    jl      .L''' + opcode + '''_smaller''')
  write_line('''    jg      .L''' + opcode + '''_bigger''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB, restore BB''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- v[BB]''')
  write_line('''    sub     VREG_ADDRESS(%ecx), %eax''')
  write_line('''    ja      .L''' + opcode + '''_bigger''')
  write_line('''    jb      .L''' + opcode + '''_smaller''')
  write_line('''.L''' + opcode + '''_finish:''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_bigger:''')
  write_line('''    movl    $1, %eax''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')
  write_line('''''')
  write_line('''.L''' + opcode + '''_smaller:''')
  write_line('''    movl    $-1, %eax''')
  write_line('''    jmp     .L''' + opcode + '''_finish''')

def op_cmpg_double():
  fpcmp(suff="d", nanval="pos")

def op_cmpg_float():
  fpcmp(suff="s", nanval="pos")

def op_cmpl_double():
  fpcmp(suff="d", nanval="neg")

def op_cmpl_float():
  fpcmp(suff="s", nanval="neg")

def op_const():
  write_line('''    /* const vAA, #+BBBBbbbb */''')
  write_line('''    movl    2(rPC), %eax                    # grab all 32 bits at once''')
  write_line('''    SET_VREG %eax, rINST                    # vAA<- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_const_16():
  write_line('''    /* const/16 vAA, #+BBBB */''')
  write_line('''    movswl  2(rPC), %ecx                    # ecx <- ssssBBBB''')
  write_line('''    SET_VREG %ecx, rINST                    # vAA <- ssssBBBB''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_const_4():
  write_line('''    /* const/4 vA, #+B */''')
  write_line('''    movsx   rINSTbl, %eax                   # eax <-ssssssBx''')
  write_line('''    movl    $0xf, rINST''')
  write_line('''    andl    %eax, rINST                     # rINST <- A''')
  write_line('''    sarl    $4, %eax''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_const_class():
  const(helper="MterpConstClass")

def op_const_high16():
  write_line('''    /* const/high16 vAA, #+BBBB0000 */''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- 0000BBBB''')
  write_line('''    sall    $16, %eax                      # eax <- BBBB0000''')
  write_line('''    SET_VREG %eax, rINST                    # vAA <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_const_method_handle():
  const(helper="MterpConstMethodHandle")

def op_const_method_type():
  const(helper="MterpConstMethodType")

def op_const_string():
  const(helper="MterpConstString")

def op_const_string_jumbo():
  write_line('''    /* const/string vAA, String@BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    2(rPC), %eax                    # eax <- BBBB''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rINST, OUT_ARG1(%esp)''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG3(%esp)''')
  write_line('''    call    SYMBOL(MterpConstString)        # (index, tgt_reg, shadow_frame, self)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_const_wide():
  write_line('''    /* const-wide vAA, #+HHHHhhhhBBBBbbbb */''')
  write_line('''    movl    2(rPC), %eax                    # eax <- lsw''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- AA''')
  write_line('''    movl    6(rPC), rINST                   # rINST <- msw''')
  write_line('''    SET_VREG %eax, %ecx''')
  write_line('''    SET_VREG_HIGH  rINST, %ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 5''')

def op_const_wide_16():
  write_line('''    /* const-wide/16 vAA, #+BBBB */''')
  write_line('''    movswl  2(rPC), %eax                    # eax <- ssssBBBB''')
  write_line('''    movl    rIBASE, %ecx                    # preserve rIBASE (cltd trashes it)''')
  write_line('''    cltd                                    # rIBASE:eax <- ssssssssssssBBBB''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # store msw''')
  write_line('''    SET_VREG %eax, rINST                    # store lsw''')
  write_line('''    movl    %ecx, rIBASE                    # restore rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_const_wide_32():
  write_line('''    /* const-wide/32 vAA, #+BBBBbbbb */''')
  write_line('''    movl    2(rPC), %eax                    # eax <- BBBBbbbb''')
  write_line('''    movl    rIBASE, %ecx                    # preserve rIBASE (cltd trashes it)''')
  write_line('''    cltd                                    # rIBASE:eax <- ssssssssssssBBBB''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # store msw''')
  write_line('''    SET_VREG %eax, rINST                    # store lsw''')
  write_line('''    movl    %ecx, rIBASE                    # restore rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_const_wide_high16():
  write_line('''    /* const-wide/high16 vAA, #+BBBB000000000000 */''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- 0000BBBB''')
  write_line('''    sall    $16, %eax                      # eax <- BBBB0000''')
  write_line('''    SET_VREG_HIGH %eax, rINST               # v[AA+1] <- eax''')
  write_line('''    xorl    %eax, %eax''')
  write_line('''    SET_VREG %eax, rINST                    # v[AA+0] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_div_double():
  sseBinop(instr="divs", suff="d")

def op_div_double_2addr():
  sseBinop2Addr(instr="divs", suff="d")

def op_div_float():
  sseBinop(instr="divs", suff="s")

def op_div_float_2addr():
  sseBinop2Addr(instr="divs", suff="s")

def op_div_int():
  bindiv(result="%eax", special="$0x80000000", rem="0")

def op_div_int_2addr():
  bindiv2addr(result="%eax", special="$0x80000000")

def op_div_int_lit16():
  bindivLit16(result="%eax", special="$0x80000000")

def op_div_int_lit8():
  bindivLit8(result="%eax", special="$0x80000000")

def op_div_long(routine="art_quick_ldiv"):
  write_line('''/* art_quick_* methods has quick abi,''')
  write_line(''' *   so use eax, ecx, edx, ebx for args''')
  write_line(''' */''')
  write_line('''    /* div vAA, vBB, vCC */''')
  write_line('''    .extern ''' + routine + '''''')
  write_line('''    mov     rIBASE, LOCAL0(%esp)            # save rIBASE/%edx''')
  write_line('''    mov     rINST, LOCAL1(%esp)             # save rINST/%ebx''')
  write_line('''    movzbl  3(rPC), %eax                    # eax <- CC''')
  write_line('''    GET_VREG %ecx, %eax''')
  write_line('''    GET_VREG_HIGH %ebx, %eax''')
  write_line('''    movl    %ecx, %edx''')
  write_line('''    orl     %ebx, %ecx''')
  write_line('''    jz      common_errDivideByZero''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    GET_VREG_HIGH %ecx, %eax''')
  write_line('''    GET_VREG %eax, %eax''')
  write_line('''    call    SYMBOL(''' + routine + ''')''')
  write_line('''    mov     LOCAL1(%esp), rINST             # restore rINST/%ebx''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    mov     LOCAL0(%esp), rIBASE            # restore rIBASE/%edx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_div_long_2addr(routine="art_quick_ldiv"):
  write_line('''/* art_quick_* methods has quick abi,''')
  write_line(''' *   so use eax, ecx, edx, ebx for args''')
  write_line(''' */''')
  write_line('''    /* div/2addr vA, vB */''')
  write_line('''    .extern   ''' + routine + '''''')
  write_line('''    mov     rIBASE, LOCAL0(%esp)            # save rIBASE/%edx''')
  write_line('''    movzbl  rINSTbl, %eax''')
  write_line('''    shrl    $4, %eax                       # eax <- B''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    mov     rINST, LOCAL1(%esp)             # save rINST/%ebx''')
  write_line('''    movl    %ebx, %ecx''')
  write_line('''    GET_VREG %edx, %eax''')
  write_line('''    GET_VREG_HIGH %ebx, %eax''')
  write_line('''    movl    %edx, %eax''')
  write_line('''    orl     %ebx, %eax''')
  write_line('''    jz      common_errDivideByZero''')
  write_line('''    GET_VREG %eax, %ecx''')
  write_line('''    GET_VREG_HIGH %ecx, %ecx''')
  write_line('''    call    SYMBOL(''' + routine + ''')''')
  write_line('''    mov     LOCAL1(%esp), rINST             # restore rINST/%ebx''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    mov     LOCAL0(%esp), rIBASE            # restore rIBASE/%edx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_double_to_float():
  fpcvt(load="fldl", store="fstps")

def op_double_to_int():
  cvtfp_int(srcdouble="1", tgtlong="0")

def op_double_to_long():
  cvtfp_int(srcdouble="1", tgtlong="1")

def op_fill_array_data():
  write_line('''    /* fill-array-data vAA, +BBBBBBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movl    2(rPC), %ecx                    # ecx <- BBBBbbbb''')
  write_line('''    leal    (rPC,%ecx,2), %ecx              # ecx <- PC + BBBBbbbb*2''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vAA (array object)''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(MterpFillArrayData)      # (obj, payload)''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_filled_new_array(helper="MterpFilledNewArray"):
  write_line('''/*''')
  write_line(''' * Create a new array with elements filled from registers.''')
  write_line(''' *''')
  write_line(''' * for: filled-new-array, filled-new-array/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, type@BBBB */''')
  write_line('''    .extern ''' + helper + '''''')
  write_line('''    EXPORT_PC''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rPC, OUT_ARG1(%esp)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(''' + helper + ''')''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_filled_new_array_range():
  op_filled_new_array(helper="MterpFilledNewArrayRange")

def op_float_to_double():
  fpcvt(load="flds", store="fstpl", wide="1")

def op_float_to_int():
  cvtfp_int(srcdouble="0", tgtlong="0")

def op_float_to_long():
  cvtfp_int(srcdouble="0", tgtlong="1")

def op_goto():
  write_line('''/*''')
  write_line(''' * Unconditional branch, 8-bit offset.''')
  write_line(''' *''')
  write_line(''' * The branch distance is a signed code-unit offset, which we need to''')
  write_line(''' * double to get a byte offset.''')
  write_line(''' */''')
  write_line('''    /* goto +AA */''')
  write_line('''    movsbl  rINSTbl, rINST                  # rINST <- ssssssAA''')
  write_line('''    testl   rINST, rINST''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_goto_16():
  write_line('''/*''')
  write_line(''' * Unconditional branch, 16-bit offset.''')
  write_line(''' *''')
  write_line(''' * The branch distance is a signed code-unit offset, which we need to''')
  write_line(''' * double to get a byte offset.''')
  write_line(''' */''')
  write_line('''    /* goto/16 +AAAA */''')
  write_line('''    movswl  2(rPC), rINST                   # rINST <- ssssAAAA''')
  write_line('''    testl   rINST, rINST''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_goto_32():
  write_line('''/*''')
  write_line(''' * Unconditional branch, 32-bit offset.''')
  write_line(''' *''')
  write_line(''' * The branch distance is a signed code-unit offset, which we need to''')
  write_line(''' * double to get a byte offset.''')
  write_line(''' *''')
  write_line(''' * Unlike most opcodes, this one is allowed to branch to itself, so''')
  write_line(''' * our "backward branch" test must be "<=0" instead of "<0".  Because''')
  write_line(''' * we need the V bit set, we'll use an adds to convert from Dalvik''')
  write_line(''' * offset to byte offset.''')
  write_line(''' */''')
  write_line('''    /* goto/32 +AAAAAAAA */''')
  write_line('''    movl    2(rPC), rINST                   # rINST <- AAAAAAAA''')
  write_line('''    testl   rINST, rINST''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_if_eq():
  bincmp(revcmp="ne")

def op_if_eqz():
  zcmp(revcmp="ne")

def op_if_ge():
  bincmp(revcmp="l")

def op_if_gez():
  zcmp(revcmp="l")

def op_if_gt():
  bincmp(revcmp="le")

def op_if_gtz():
  zcmp(revcmp="le")

def op_if_le():
  bincmp(revcmp="g")

def op_if_lez():
  zcmp(revcmp="g")

def op_if_lt():
  bincmp(revcmp="ge")

def op_if_ltz():
  zcmp(revcmp="ge")

def op_if_ne():
  bincmp(revcmp="e")

def op_if_nez():
  zcmp(revcmp="e")

def op_iget(is_object="0", helper="MterpIGetU32"):
  field(helper=helper)

def op_iget_boolean():
  op_iget(helper="MterpIGetU8")

def op_iget_boolean_quick():
  op_iget_quick(load="movsbl")

def op_iget_byte():
  op_iget(helper="MterpIGetI8")

def op_iget_byte_quick():
  op_iget_quick(load="movsbl")

def op_iget_char():
  op_iget(helper="MterpIGetU16")

def op_iget_char_quick():
  op_iget_quick(load="movzwl")

def op_iget_object():
  op_iget(is_object="1", helper="MterpIGetObj")

def op_iget_object_quick():
  write_line('''    /* For: iget-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %ecx                     # vB (object we're operating on)''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- field byte offset''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    movl    %eax, OUT_ARG1(%esp)''')
  write_line('''    EXPORT_PC''')
  write_line('''    call    SYMBOL(artIGetObjectFromMterp)  # (obj, offset)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    RESTORE_IBASE_FROM_SELF %ecx''')
  write_line('''    cmpl    $0, THREAD_EXCEPTION_OFFSET(%ecx)''')
  write_line('''    jnz     MterpException                  # bail out''')
  write_line('''    andb    $0xf,rINSTbl                   # rINST <- A''')
  write_line('''    SET_VREG_OBJECT %eax, rINST             # fp[A] <- value''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iget_quick(load="movl"):
  write_line('''    /* For: iget-quick, iget-boolean-quick, iget-byte-quick, iget-char-quick, iget-short-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %ecx                     # vB (object we're operating on)''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- field byte offset''')
  write_line('''    testl   %ecx, %ecx                      # is object null?''')
  write_line('''    je      common_errNullObject''')
  write_line('''    ''' + load + ''' (%ecx,%eax,1), %eax''')
  write_line('''    andb    $0xf,rINSTbl                   # rINST <- A''')
  write_line('''    SET_VREG %eax, rINST                    # fp[A] <- value''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iget_short():
  op_iget(helper="MterpIGetI16")

def op_iget_short_quick():
  op_iget_quick(load="movswl")

def op_iget_wide():
  op_iget(helper="MterpIGetU64")

def op_iget_wide_quick():
  write_line('''    /* iget-wide-quick vA, vB, offset@CCCC */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %ecx                     # vB (object we're operating on)''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- field byte offset''')
  write_line('''    testl   %ecx, %ecx                      # is object null?''')
  write_line('''    je      common_errNullObject''')
  write_line('''    movq    (%ecx,%eax,1), %xmm0''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    SET_WIDE_FP_VREG %xmm0, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_instance_of():
  write_line('''/*''')
  write_line(''' * Check to see if an object reference is an instance of a class.''')
  write_line(''' *''')
  write_line(''' * Most common situation is a non-null object, being compared against''')
  write_line(''' * an already-resolved class.''')
  write_line(''' */''')
  write_line('''    /* instance-of vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- BBBB''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rINST, %eax                     # eax <- BA''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    leal    VREG_ADDRESS(%eax), %ecx        # Get object address''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    movl    OFF_FP_METHOD(rFP),%eax''')
  write_line('''    movl    %eax, OUT_ARG2(%esp)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG3(%esp)''')
  write_line('''    call    SYMBOL(MterpInstanceOf)         # (index, &obj, method, self)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    RESTORE_IBASE_FROM_SELF %ecx''')
  write_line('''    cmpl    $0, THREAD_EXCEPTION_OFFSET(%ecx)''')
  write_line('''    jnz     MterpException''')
  write_line('''    andb    $0xf, rINSTbl                  # rINSTbl <- A''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_int_to_byte():
  unop(instr="movsbl  %al, %eax")

def op_int_to_char():
  unop(instr="movzwl  %ax,%eax")

def op_int_to_double():
  fpcvt(load="fildl", store="fstpl", wide="1")

def op_int_to_float():
  fpcvt(load="fildl", store="fstps")

def op_int_to_long():
  write_line('''    /* int to long vA, vB */''')
  write_line('''    movzbl  rINSTbl, %eax                   # eax <- +A''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vB''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    movl    rIBASE, %ecx                    # cltd trashes rIBASE/edx''')
  write_line('''    cltd                                    # rINST:eax<- sssssssBBBBBBBB''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[A+1] <- rIBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[A+0] <- %eax''')
  write_line('''    movl    %ecx, rIBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')
  write_line('''''')

def op_int_to_short():
  unop(instr="movswl %ax, %eax")

def op_invoke_custom():
  invoke(helper="MterpInvokeCustom")

def op_invoke_custom_range():
  invoke(helper="MterpInvokeCustomRange")

def op_invoke_direct():
  invoke(helper="MterpInvokeDirect")

def op_invoke_direct_range():
  invoke(helper="MterpInvokeDirectRange")

def op_invoke_interface():
  invoke(helper="MterpInvokeInterface")
  write_line('''/*''')
  write_line(''' * Handle an interface method call.''')
  write_line(''' *''')
  write_line(''' * for: invoke-interface, invoke-interface/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_interface_range():
  invoke(helper="MterpInvokeInterfaceRange")

def op_invoke_polymorphic():
  invoke_polymorphic(helper="MterpInvokePolymorphic")

def op_invoke_polymorphic_range():
  invoke_polymorphic(helper="MterpInvokePolymorphicRange")

def op_invoke_static():
  invoke(helper="MterpInvokeStatic")
  write_line('''''')

def op_invoke_static_range():
  invoke(helper="MterpInvokeStaticRange")

def op_invoke_super():
  invoke(helper="MterpInvokeSuper")
  write_line('''/*''')
  write_line(''' * Handle a "super" method call.''')
  write_line(''' *''')
  write_line(''' * for: invoke-super, invoke-super/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_super_range():
  invoke(helper="MterpInvokeSuperRange")

def op_invoke_virtual():
  invoke(helper="MterpInvokeVirtual")
  write_line('''/*''')
  write_line(''' * Handle a virtual method call.''')
  write_line(''' *''')
  write_line(''' * for: invoke-virtual, invoke-virtual/range''')
  write_line(''' */''')
  write_line('''    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */''')
  write_line('''    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */''')

def op_invoke_virtual_quick():
  invoke(helper="MterpInvokeVirtualQuick")

def op_invoke_virtual_range():
  invoke(helper="MterpInvokeVirtualRange")

def op_invoke_virtual_range_quick():
  invoke(helper="MterpInvokeVirtualQuickRange")

def op_iput(is_object="0", helper="MterpIPutU32"):
  field(helper=helper)

def op_iput_boolean():
  op_iput(helper="MterpIPutU8")

def op_iput_boolean_quick():
  op_iput_quick(reg="rINSTbl", store="movb")

def op_iput_byte():
  op_iput(helper="MterpIPutI8")

def op_iput_byte_quick():
  op_iput_quick(reg="rINSTbl", store="movb")

def op_iput_char():
  op_iput(helper="MterpIPutU16")

def op_iput_char_quick():
  op_iput_quick(reg="rINSTw", store="movw")

def op_iput_object():
  op_iput(is_object="1", helper="MterpIPutObj")

def op_iput_object_quick():
  write_line('''    EXPORT_PC''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rPC, OUT_ARG1(%esp)''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpIputObjectQuick)''')
  write_line('''    testb   %al, %al''')
  write_line('''    jz      MterpException''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iput_quick(reg="rINST", store="movl"):
  write_line('''    /* For: iput-quick, iput-object-quick */''')
  write_line('''    /* op vA, vB, offset@CCCC */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %ecx                     # vB (object we're operating on)''')
  write_line('''    testl   %ecx, %ecx                      # is object null?''')
  write_line('''    je      common_errNullObject''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG rINST, rINST                   # rINST <- v[A]''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- field byte offset''')
  write_line('''    ''' + store + '''    ''' + reg + ''', (%ecx,%eax,1)''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_iput_short():
  op_iput(helper="MterpIPutI16")

def op_iput_short_quick():
  op_iput_quick(reg="rINSTw", store="movw")

def op_iput_wide():
  op_iput(helper="MterpIPutU64")

def op_iput_wide_quick():
  write_line('''    /* iput-wide-quick vA, vB, offset@CCCC */''')
  write_line('''    movzbl    rINSTbl, %ecx                 # ecx<- BA''')
  write_line('''    sarl      $4, %ecx                     # ecx<- B''')
  write_line('''    GET_VREG  %ecx, %ecx                    # vB (object we're operating on)''')
  write_line('''    testl     %ecx, %ecx                    # is object null?''')
  write_line('''    je        common_errNullObject''')
  write_line('''    movzwl    2(rPC), %eax                  # eax<- field byte offset''')
  write_line('''    leal      (%ecx,%eax,1), %ecx           # ecx<- Address of 64-bit target''')
  write_line('''    andb      $0xf, rINSTbl                # rINST<- A''')
  write_line('''    GET_WIDE_FP_VREG %xmm0, rINST           # xmm0<- fp[A]/fp[A+1]''')
  write_line('''    movq      %xmm0, (%ecx)                 # obj.field<- r0/r1''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_long_to_double():
  fpcvt(load="fildll", store="fstpl", wide="1")

def op_long_to_float():
  fpcvt(load="fildll", store="fstps")

def op_long_to_int():
  write_line('''/* we ignore the high word, making this equivalent to a 32-bit reg move */''')
  op_move()

def op_monitor_enter():
  write_line('''/*''')
  write_line(''' * Synchronize on an object.''')
  write_line(''' */''')
  write_line('''    /* monitor-enter vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG %ecx, rINST''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(artLockObjectFromCode)   # (object, self)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_monitor_exit():
  write_line('''/*''')
  write_line(''' * Unlock an object.''')
  write_line(''' *''')
  write_line(''' * Exceptions that occur when unlocking a monitor need to appear as''')
  write_line(''' * if they happened at the following instruction.  See the Dalvik''')
  write_line(''' * instruction spec.''')
  write_line(''' */''')
  write_line('''    /* monitor-exit vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG %ecx, rINST''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    movl    %eax, OUT_ARG1(%esp)''')
  write_line('''    call    SYMBOL(artUnlockObjectFromCode) # (object, self)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al''')
  write_line('''    jnz     MterpException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move(is_object="0"):
  write_line('''    /* for move, move-object, long-to-int */''')
  write_line('''    /* op vA, vB */''')
  write_line('''    movzbl  rINSTbl, %eax                   # eax <- BA''')
  write_line('''    andb    $0xf, %al                      # eax <- A''')
  write_line('''    shrl    $4, rINST                      # rINST <- B''')
  write_line('''    GET_VREG rINST, rINST''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT rINST, %eax             # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG rINST, %eax                    # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_16(is_object="0"):
  write_line('''    /* for: move/16, move-object/16 */''')
  write_line('''    /* op vAAAA, vBBBB */''')
  write_line('''    movzwl  4(rPC), %ecx                    # ecx <- BBBB''')
  write_line('''    movzwl  2(rPC), %eax                    # eax <- AAAA''')
  write_line('''    GET_VREG rINST, %ecx''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT rINST, %eax             # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG rINST, %eax                    # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_move_exception():
  write_line('''    /* move-exception vAA */''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    THREAD_EXCEPTION_OFFSET(%ecx), %eax''')
  write_line('''    SET_VREG_OBJECT %eax, rINST             # fp[AA] <- exception object''')
  write_line('''    movl    $0, THREAD_EXCEPTION_OFFSET(%ecx)''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_from16(is_object="0"):
  write_line('''    /* for: move/from16, move-object/from16 */''')
  write_line('''    /* op vAA, vBBBB */''')
  write_line('''    movzx   rINSTbl, %eax                   # eax <- AA''')
  write_line('''    movw    2(rPC), rINSTw                  # rINSTw <- BBBB''')
  write_line('''    GET_VREG rINST, rINST                   # rINST <- fp[BBBB]''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT rINST, %eax             # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG rINST, %eax                    # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_move_object():
  op_move(is_object="1")

def op_move_object_16():
  op_move_16(is_object="1")

def op_move_object_from16():
  op_move_from16(is_object="1")

def op_move_result(is_object="0"):
  write_line('''    /* for: move-result, move-result-object */''')
  write_line('''    /* op vAA */''')
  write_line('''    movl    OFF_FP_RESULT_REGISTER(rFP), %eax    # get pointer to result JType.''')
  write_line('''    movl    (%eax), %eax                    # r0 <- result.i.''')
  write_line('''    .if ''' + is_object + '''''')
  write_line('''    SET_VREG_OBJECT %eax, rINST             # fp[A] <- fp[B]''')
  write_line('''    .else''')
  write_line('''    SET_VREG %eax, rINST                    # fp[A] <- fp[B]''')
  write_line('''    .endif''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_result_object():
  op_move_result(is_object="1")

def op_move_result_wide():
  write_line('''    /* move-result-wide vAA */''')
  write_line('''    movl    OFF_FP_RESULT_REGISTER(rFP), %eax    # get pointer to result JType.''')
  write_line('''    movl    4(%eax), %ecx                   # Get high''')
  write_line('''    movl    (%eax), %eax                    # Get low''')
  write_line('''    SET_VREG %eax, rINST                    # v[AA+0] <- eax''')
  write_line('''    SET_VREG_HIGH %ecx, rINST               # v[AA+1] <- ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_wide():
  write_line('''    /* move-wide vA, vB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    GET_WIDE_FP_VREG %xmm0, rINST           # xmm0 <- v[B]''')
  write_line('''    SET_WIDE_FP_VREG %xmm0, %ecx            # v[A] <- xmm0''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_move_wide_16():
  write_line('''    /* move-wide/16 vAAAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    movzwl  4(rPC), %ecx                    # ecx<- BBBB''')
  write_line('''    movzwl  2(rPC), %eax                    # eax<- AAAA''')
  write_line('''    GET_WIDE_FP_VREG %xmm0, %ecx            # xmm0 <- v[B]''')
  write_line('''    SET_WIDE_FP_VREG %xmm0, %eax            # v[A] <- xmm0''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 3''')

def op_move_wide_from16():
  write_line('''    /* move-wide/from16 vAA, vBBBB */''')
  write_line('''    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */''')
  write_line('''    movzwl  2(rPC), %ecx                    # ecx <- BBBB''')
  write_line('''    movzbl  rINSTbl, %eax                   # eax <- AAAA''')
  write_line('''    GET_WIDE_FP_VREG %xmm0, %ecx            # xmm0 <- v[B]''')
  write_line('''    SET_WIDE_FP_VREG %xmm0, %eax            # v[A] <- xmm0''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_mul_double():
  sseBinop(instr="muls", suff="d")

def op_mul_double_2addr():
  sseBinop2Addr(instr="muls", suff="d")

def op_mul_float():
  sseBinop(instr="muls", suff="s")

def op_mul_float_2addr():
  sseBinop2Addr(instr="muls", suff="s")

def op_mul_int():
  write_line('''    /*''')
  write_line('''     * 32-bit binary multiplication.''')
  write_line('''     */''')
  write_line('''    /* mul vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vBB''')
  write_line('''    mov     rIBASE, LOCAL0(%esp)''')
  write_line('''    imull   (rFP,%ecx,4), %eax              # trashes rIBASE/edx''')
  write_line('''    mov     LOCAL0(%esp), rIBASE''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_mul_int_2addr():
  write_line('''    /* mul vA, vB */''')
  write_line('''    movzx   rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vB''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    movl    rIBASE, rINST''')
  write_line('''    imull   (rFP,%ecx,4), %eax              # trashes rIBASE/edx''')
  write_line('''    movl    rINST, rIBASE''')
  write_line('''    SET_VREG %eax, %ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_mul_int_lit16():
  write_line('''    /* mul/lit16 vA, vB, #+CCCC */''')
  write_line('''    /* Need A in rINST, ssssCCCC in ecx, vB in eax */''')
  write_line('''    movzbl  rINSTbl, %eax                   # eax <- 000000BA''')
  write_line('''    sarl    $4, %eax                       # eax <- B''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- vB''')
  write_line('''    movl    rIBASE, %ecx''')
  write_line('''    movswl  2(rPC), rIBASE                  # rIBASE <- ssssCCCC''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    imull   rIBASE, %eax                    # trashes rIBASE/edx''')
  write_line('''    movl    %ecx, rIBASE''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_mul_int_lit8():
  write_line('''    /* mul/lit8 vAA, vBB, #+CC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movl    rIBASE, %ecx''')
  write_line('''    GET_VREG  %eax, %eax                    # eax <- rBB''')
  write_line('''    movsbl  3(rPC), rIBASE                  # rIBASE <- ssssssCC''')
  write_line('''    imull   rIBASE, %eax                    # trashes rIBASE/edx''')
  write_line('''    movl    %ecx, rIBASE''')
  write_line('''    SET_VREG %eax, rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_mul_long():
  write_line('''/*''')
  write_line(''' * Signed 64-bit integer multiply.''')
  write_line(''' *''')
  write_line(''' * We could definately use more free registers for''')
  write_line(''' * this code.   We spill rINSTw (ebx),''')
  write_line(''' * giving us eax, ebc, ecx and edx as computational''')
  write_line(''' * temps.  On top of that, we'll spill edi (rFP)''')
  write_line(''' * for use as the vB pointer and esi (rPC) for use''')
  write_line(''' * as the vC pointer.  Yuck.''')
  write_line(''' *''')
  write_line(''' */''')
  write_line('''    /* mul-long vAA, vBB, vCC */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- B''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- C''')
  write_line('''    mov     rPC, LOCAL0(%esp)               # save Interpreter PC''')
  write_line('''    mov     rFP, LOCAL1(%esp)               # save FP''')
  write_line('''    mov     rIBASE, LOCAL2(%esp)            # save rIBASE''')
  write_line('''    leal    (rFP,%eax,4), %esi              # esi <- &v[B]''')
  write_line('''    leal    (rFP,%ecx,4), rFP               # rFP <- &v[C]''')
  write_line('''    movl    4(%esi), %ecx                   # ecx <- Bmsw''')
  write_line('''    imull   (rFP), %ecx                     # ecx <- (Bmsw*Clsw)''')
  write_line('''    movl    4(rFP), %eax                    # eax <- Cmsw''')
  write_line('''    imull   (%esi), %eax                    # eax <- (Cmsw*Blsw)''')
  write_line('''    addl    %eax, %ecx                      # ecx <- (Bmsw*Clsw)+(Cmsw*Blsw)''')
  write_line('''    movl    (rFP), %eax                     # eax <- Clsw''')
  write_line('''    mull    (%esi)                          # eax <- (Clsw*Alsw)''')
  write_line('''    mov     LOCAL0(%esp), rPC               # restore Interpreter PC''')
  write_line('''    mov     LOCAL1(%esp), rFP               # restore FP''')
  write_line('''    leal    (%ecx,rIBASE), rIBASE           # full result now in rIBASE:%eax''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[B+1] <- rIBASE''')
  write_line('''    mov     LOCAL2(%esp), rIBASE            # restore IBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[B] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_mul_long_2addr():
  write_line('''/*''')
  write_line(''' * Signed 64-bit integer multiply, 2-addr version''')
  write_line(''' *''')
  write_line(''' * We could definately use more free registers for''')
  write_line(''' * this code.  We must spill %edx (rIBASE) because it''')
  write_line(''' * is used by imul.  We'll also spill rINST (ebx),''')
  write_line(''' * giving us eax, ebc, ecx and rIBASE as computational''')
  write_line(''' * temps.  On top of that, we'll spill %esi (edi)''')
  write_line(''' * for use as the vA pointer and rFP (esi) for use''')
  write_line(''' * as the vB pointer.  Yuck.''')
  write_line(''' */''')
  write_line('''    /* mul-long/2addr vA, vB */''')
  write_line('''    movzbl  rINSTbl, %eax                   # eax <- BA''')
  write_line('''    andb    $0xf, %al                      # eax <- A''')
  write_line('''    CLEAR_WIDE_REF %eax                     # clear refs in advance''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    mov     rPC, LOCAL0(%esp)               # save Interpreter PC''')
  write_line('''    mov     rFP, LOCAL1(%esp)               # save FP''')
  write_line('''    mov     rIBASE, LOCAL2(%esp)            # save rIBASE''')
  write_line('''    leal    (rFP,%eax,4), %esi              # esi <- &v[A]''')
  write_line('''    leal    (rFP,rINST,4), rFP              # rFP <- &v[B]''')
  write_line('''    movl    4(%esi), %ecx                   # ecx <- Amsw''')
  write_line('''    imull   (rFP), %ecx                     # ecx <- (Amsw*Blsw)''')
  write_line('''    movl    4(rFP), %eax                    # eax <- Bmsw''')
  write_line('''    imull   (%esi), %eax                    # eax <- (Bmsw*Alsw)''')
  write_line('''    addl    %eax, %ecx                      # ecx <- (Amsw*Blsw)+(Bmsw*Alsw)''')
  write_line('''    movl    (rFP), %eax                     # eax <- Blsw''')
  write_line('''    mull    (%esi)                          # eax <- (Blsw*Alsw)''')
  write_line('''    leal    (%ecx,rIBASE), rIBASE           # full result now in %edx:%eax''')
  write_line('''    movl    rIBASE, 4(%esi)                 # v[A+1] <- rIBASE''')
  write_line('''    movl    %eax, (%esi)                    # v[A] <- %eax''')
  write_line('''    mov     LOCAL0(%esp), rPC               # restore Interpreter PC''')
  write_line('''    mov     LOCAL2(%esp), rIBASE            # restore IBASE''')
  write_line('''    mov     LOCAL1(%esp), rFP               # restore FP''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_neg_double():
  fpcvt(instr="fchs", load="fldl", store="fstpl", wide="1")

def op_neg_float():
  fpcvt(instr="fchs", load="flds", store="fstps")

def op_neg_int():
  unop(instr="negl    %eax")

def op_neg_long():
  write_line('''    /* unop vA, vB */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG %eax, %ecx                     # eax <- v[B+0]''')
  write_line('''    GET_VREG_HIGH %ecx, %ecx                # ecx <- v[B+1]''')
  write_line('''    negl    %eax''')
  write_line('''    adcl    $0, %ecx''')
  write_line('''    negl    %ecx''')
  write_line('''    SET_VREG %eax, rINST                    # v[A+0] <- eax''')
  write_line('''    SET_VREG_HIGH %ecx, rINST               # v[A+1] <- ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')
  write_line('''''')

def op_new_array():
  write_line('''/*''')
  write_line(''' * Allocate an array of objects, specified with the array class''')
  write_line(''' * and a count.''')
  write_line(''' *''')
  write_line(''' * The verifier guarantees that this is an array class, so we don't''')
  write_line(''' * check for it here.''')
  write_line(''' */''')
  write_line('''    /* new-array vA, vB, class@CCCC */''')
  write_line('''    EXPORT_PC''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rPC, OUT_ARG1(%esp)''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_ARG2(%esp)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG3(%esp)''')
  write_line('''    call    SYMBOL(MterpNewArray)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_new_instance():
  write_line('''/*''')
  write_line(''' * Create a new instance of a class.''')
  write_line(''' */''')
  write_line('''    /* new-instance vAA, class@BBBB */''')
  write_line('''    EXPORT_PC''')
  write_line('''    leal    OFF_FP_SHADOWFRAME(rFP), %eax''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    movl    rSELF, %ecx''')
  write_line('''    movl    %ecx, OUT_ARG1(%esp)''')
  write_line('''    REFRESH_INST ''' + opnum + '''''')
  write_line('''    movl    rINST, OUT_ARG2(%esp)''')
  write_line('''    call    SYMBOL(MterpNewInstance)''')
  write_line('''    RESTORE_IBASE''')
  write_line('''    testb   %al, %al                        # 0 means an exception is thrown''')
  write_line('''    jz      MterpPossibleException''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_nop():
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_not_int():
  unop(instr="notl %eax")

def op_not_long():
  write_line('''    /* unop vA, vB */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG %eax, %ecx                     # eax <- v[B+0]''')
  write_line('''    GET_VREG_HIGH %ecx, %ecx                # ecx <- v[B+1]''')
  write_line('''    notl    %eax''')
  write_line('''    notl    %ecx''')
  write_line('''    SET_VREG %eax, rINST                    # v[A+0] <- eax''')
  write_line('''    SET_VREG_HIGH %ecx, rINST               # v[A+1] <- ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_or_int():
  binop(instr="orl     (rFP,%ecx,4), %eax")

def op_or_int_2addr():
  binop2addr(instr="orl     %eax, (rFP,%ecx,4)")

def op_or_int_lit16():
  binopLit16(instr="orl     %ecx, %eax")

def op_or_int_lit8():
  binopLit8(instr="orl     %ecx, %eax")

def op_or_long():
  binopWide(instr1="orl     (rFP,%ecx,4), rIBASE", instr2="orl     4(rFP,%ecx,4), %eax")

def op_or_long_2addr():
  binopWide2addr(instr1="orl     %eax, (rFP,rINST,4)", instr2="orl     %ecx, 4(rFP,rINST,4)")

def op_packed_switch(func="MterpDoPackedSwitch"):
  write_line('''/*''')
  write_line(''' * Handle a packed-switch or sparse-switch instruction.  In both cases''')
  write_line(''' * we decode it and hand it off to a helper function.''')
  write_line(''' *''')
  write_line(''' * We don't really expect backward branches in a switch statement, but''')
  write_line(''' * they're perfectly legal, so we check for them here.''')
  write_line(''' *''')
  write_line(''' * for: packed-switch, sparse-switch''')
  write_line(''' */''')
  write_line('''    /* op vAA, +BBBB */''')
  write_line('''    movl    2(rPC), %ecx                    # ecx <- BBBBbbbb''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vAA''')
  write_line('''    leal    (rPC,%ecx,2), %ecx              # ecx <- PC + BBBBbbbb*2''')
  write_line('''    movl    %eax, OUT_ARG1(%esp)            # ARG1 <- vAA''')
  write_line('''    movl    %ecx, OUT_ARG0(%esp)            # ARG0 <- switchData''')
  write_line('''    call    SYMBOL(''' + func + ''')''')
  write_line('''    REFRESH_IBASE''')
  write_line('''    testl   %eax, %eax''')
  write_line('''    movl    %eax, rINST''')
  write_line('''    jmp     MterpCommonTakenBranch''')

def op_rem_double():
  write_line('''    /* rem_double vAA, vBB, vCC */''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- BB''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- CC''')
  write_line('''    fldl    VREG_ADDRESS(%ecx)              # %st1 <- fp[vBB]''')
  write_line('''    fldl    VREG_ADDRESS(%eax)              # %st0 <- fp[vCC]''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstpl   VREG_ADDRESS(rINST)             # fp[vAA] <- %st''')
  write_line('''    CLEAR_WIDE_REF rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_rem_double_2addr():
  write_line('''    /* rem_double/2addr vA, vB */''')
  write_line('''    movzx   rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    fldl    VREG_ADDRESS(rINST)             # vB to fp stack''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    fldl    VREG_ADDRESS(%ecx)              # vA to fp stack''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstpl   VREG_ADDRESS(%ecx)              # %st to vA''')
  write_line('''    CLEAR_WIDE_REF %ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_rem_float():
  write_line('''    /* rem_float vAA, vBB, vCC */''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- BB''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- CC''')
  write_line('''    flds    VREG_ADDRESS(%ecx)              # vBB to fp stack''')
  write_line('''    flds    VREG_ADDRESS(%eax)              # vCC to fp stack''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstps   VREG_ADDRESS(rINST)             # %st to vAA''')
  write_line('''    CLEAR_REF rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_rem_float_2addr():
  write_line('''    /* rem_float/2addr vA, vB */''')
  write_line('''    movzx   rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    sarl    $4, rINST                      # rINST <- B''')
  write_line('''    flds    VREG_ADDRESS(rINST)             # vB to fp stack''')
  write_line('''    andb    $0xf, %cl                      # ecx <- A''')
  write_line('''    flds    VREG_ADDRESS(%ecx)              # vA to fp stack''')
  write_line('''1:''')
  write_line('''    fprem''')
  write_line('''    fstsw   %ax''')
  write_line('''    sahf''')
  write_line('''    jp      1b''')
  write_line('''    fstp    %st(1)''')
  write_line('''    fstps   VREG_ADDRESS(%ecx)              # %st to vA''')
  write_line('''    CLEAR_REF %ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_rem_int():
  bindiv(result="rIBASE", special="$0", rem="1")

def op_rem_int_2addr():
  bindiv2addr(result="rIBASE", special="$0")

def op_rem_int_lit16():
  bindivLit16(result="rIBASE", special="$0")

def op_rem_int_lit8():
  bindivLit8(result="rIBASE", special="$0")

def op_rem_long():
  op_div_long(routine="art_quick_lmod")

def op_rem_long_2addr():
  op_div_long_2addr(routine="art_quick_lmod")

def op_return():
  write_line('''/*''')
  write_line(''' * Return a 32-bit value.''')
  write_line(''' *''')
  write_line(''' * for: return, return-object''')
  write_line(''' */''')
  write_line('''    /* op vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    call    SYMBOL(MterpThreadFenceForConstructor)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(%eax)''')
  write_line('''    jz      1f''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vAA''')
  write_line('''    xorl    %ecx, %ecx''')
  write_line('''    jmp     MterpReturn''')

def op_return_object():
  op_return()

def op_return_void():
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    call    SYMBOL(MterpThreadFenceForConstructor)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(%eax)''')
  write_line('''    jz      1f''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    xorl    %eax, %eax''')
  write_line('''    xorl    %ecx, %ecx''')
  write_line('''    jmp     MterpReturn''')

def op_return_void_no_barrier():
  write_line('''    movl    rSELF, %eax''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(%eax)''')
  write_line('''    jz      1f''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    xorl    %eax, %eax''')
  write_line('''    xorl    %ecx, %ecx''')
  write_line('''    jmp     MterpReturn''')

def op_return_wide():
  write_line('''/*''')
  write_line(''' * Return a 64-bit value.''')
  write_line(''' */''')
  write_line('''    /* return-wide vAA */''')
  write_line('''    .extern MterpThreadFenceForConstructor''')
  write_line('''    call    SYMBOL(MterpThreadFenceForConstructor)''')
  write_line('''    movl    rSELF, %eax''')
  write_line('''    testl   $(THREAD_SUSPEND_OR_CHECKPOINT_REQUEST), THREAD_FLAGS_OFFSET(%eax)''')
  write_line('''    jz      1f''')
  write_line('''    movl    %eax, OUT_ARG0(%esp)''')
  write_line('''    call    SYMBOL(MterpSuspendCheck)''')
  write_line('''1:''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- v[AA+0]''')
  write_line('''    GET_VREG_HIGH %ecx, rINST               # ecx <- v[AA+1]''')
  write_line('''    jmp     MterpReturn''')

def op_rsub_int():
  write_line('''/* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */''')
  binopLit16(instr="subl    %eax, %ecx", result="%ecx")

def op_rsub_int_lit8():
  binopLit8(instr="subl    %eax, %ecx", result="%ecx")

def op_sget(is_object="0", helper="MterpSGetU32"):
  field(helper=helper)

def op_sget_boolean():
  op_sget(helper="MterpSGetU8")

def op_sget_byte():
  op_sget(helper="MterpSGetI8")

def op_sget_char():
  op_sget(helper="MterpSGetU16")

def op_sget_object():
  op_sget(is_object="1", helper="MterpSGetObj")

def op_sget_short():
  op_sget(helper="MterpSGetI16")

def op_sget_wide():
  op_sget(helper="MterpSGetU64")

def op_shl_int():
  binop1(instr="sall    %cl, %eax")

def op_shl_int_2addr():
  shop2addr(instr="sall    %cl, %eax")

def op_shl_int_lit8():
  binopLit8(instr="sall    %cl, %eax")

def op_shl_long():
  write_line('''/*''')
  write_line(''' * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line(''' * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line(''' * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line(''' * 6 bits of the shift distance.  x86 shifts automatically mask off''')
  write_line(''' * the low 5 bits of %cl, so have to handle the 64 > shiftcount > 31''')
  write_line(''' * case specially.''')
  write_line(''' */''')
  write_line('''    /* shl-long vAA, vBB, vCC */''')
  write_line('''    /* ecx gets shift count */''')
  write_line('''    /* Need to spill rINST */''')
  write_line('''    /* rINSTw gets AA */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    movl    rIBASE, LOCAL0(%esp)''')
  write_line('''    GET_VREG_HIGH rIBASE, %eax              # ecx <- v[BB+1]''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- v[BB+0]''')
  write_line('''    shldl   %eax,rIBASE''')
  write_line('''    sall    %cl, %eax''')
  write_line('''    testb   $32, %cl''')
  write_line('''    je      2f''')
  write_line('''    movl    %eax, rIBASE''')
  write_line('''    xorl    %eax, %eax''')
  write_line('''2:''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[AA+1] <- rIBASE''')
  write_line('''    movl    LOCAL0(%esp), rIBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[AA+0] <- %eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_shl_long_2addr():
  write_line('''/*''')
  write_line(''' * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line(''' * 32-bit shift distance.''')
  write_line(''' */''')
  write_line('''    /* shl-long/2addr vA, vB */''')
  write_line('''    /* ecx gets shift count */''')
  write_line('''    /* Need to spill rIBASE */''')
  write_line('''    /* rINSTw gets AA */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- v[AA+0]''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    movl    rIBASE, LOCAL0(%esp)''')
  write_line('''    GET_VREG_HIGH rIBASE, rINST             # rIBASE <- v[AA+1]''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vBB''')
  write_line('''    shldl   %eax, rIBASE''')
  write_line('''    sall    %cl, %eax''')
  write_line('''    testb   $32, %cl''')
  write_line('''    je      2f''')
  write_line('''    movl    %eax, rIBASE''')
  write_line('''    xorl    %eax, %eax''')
  write_line('''2:''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[AA+1] <- rIBASE''')
  write_line('''    movl    LOCAL0(%esp), rIBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[AA+0] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_shr_int():
  binop1(instr="sarl    %cl, %eax")

def op_shr_int_2addr():
  shop2addr(instr="sarl    %cl, %eax")

def op_shr_int_lit8():
  binopLit8(instr="sarl    %cl, %eax")

def op_shr_long():
  write_line('''/*''')
  write_line(''' * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line(''' * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line(''' * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line(''' * 6 bits of the shift distance.  x86 shifts automatically mask off''')
  write_line(''' * the low 5 bits of %cl, so have to handle the 64 > shiftcount > 31''')
  write_line(''' * case specially.''')
  write_line(''' */''')
  write_line('''    /* shr-long vAA, vBB, vCC */''')
  write_line('''    /* ecx gets shift count */''')
  write_line('''    /* Need to spill rIBASE */''')
  write_line('''    /* rINSTw gets AA */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    movl    rIBASE, LOCAL0(%esp)''')
  write_line('''    GET_VREG_HIGH rIBASE, %eax              # rIBASE<- v[BB+1]''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- v[BB+0]''')
  write_line('''    shrdl   rIBASE, %eax''')
  write_line('''    sarl    %cl, rIBASE''')
  write_line('''    testb   $32, %cl''')
  write_line('''    je      2f''')
  write_line('''    movl    rIBASE, %eax''')
  write_line('''    sarl    $31, rIBASE''')
  write_line('''2:''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[AA+1] <- rIBASE''')
  write_line('''    movl    LOCAL0(%esp), rIBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[AA+0] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_shr_long_2addr():
  write_line('''/*''')
  write_line(''' * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line(''' * 32-bit shift distance.''')
  write_line(''' */''')
  write_line('''    /* shl-long/2addr vA, vB */''')
  write_line('''    /* ecx gets shift count */''')
  write_line('''    /* Need to spill rIBASE */''')
  write_line('''    /* rINSTw gets AA */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- v[AA+0]''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    movl    rIBASE, LOCAL0(%esp)''')
  write_line('''    GET_VREG_HIGH rIBASE, rINST             # rIBASE <- v[AA+1]''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vBB''')
  write_line('''    shrdl   rIBASE, %eax''')
  write_line('''    sarl    %cl, rIBASE''')
  write_line('''    testb   $32, %cl''')
  write_line('''    je      2f''')
  write_line('''    movl    rIBASE, %eax''')
  write_line('''    sarl    $31, rIBASE''')
  write_line('''2:''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[AA+1] <- rIBASE''')
  write_line('''    movl    LOCAL0(%esp), rIBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[AA+0] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_sparse_switch():
  op_packed_switch(func="MterpDoSparseSwitch")

def op_sput(is_object="0", helper="MterpSPutU32"):
  field(helper=helper)

def op_sput_boolean():
  op_sput(helper="MterpSPutU8")

def op_sput_byte():
  op_sput(helper="MterpSPutI8")

def op_sput_char():
  op_sput(helper="MterpSPutU16")

def op_sput_object():
  op_sput(is_object="1", helper="MterpSPutObj")

def op_sput_short():
  op_sput(helper="MterpSPutI16")

def op_sput_wide():
  op_sput(helper="MterpSPutU64")

def op_sub_double():
  sseBinop(instr="subs", suff="d")

def op_sub_double_2addr():
  sseBinop2Addr(instr="subs", suff="d")

def op_sub_float():
  sseBinop(instr="subs", suff="s")

def op_sub_float_2addr():
  sseBinop2Addr(instr="subs", suff="s")

def op_sub_int():
  binop(instr="subl    (rFP,%ecx,4), %eax")

def op_sub_int_2addr():
  binop2addr(instr="subl    %eax, (rFP,%ecx,4)")

def op_sub_long():
  binopWide(instr1="subl    (rFP,%ecx,4), rIBASE", instr2="sbbl    4(rFP,%ecx,4), %eax")

def op_sub_long_2addr():
  binopWide2addr(instr1="subl    %eax, (rFP,rINST,4)", instr2="sbbl    %ecx, 4(rFP,rINST,4)")

def op_throw():
  write_line('''/*''')
  write_line(''' * Throw an exception object in the current thread.''')
  write_line(''' */''')
  write_line('''    /* throw vAA */''')
  write_line('''    EXPORT_PC''')
  write_line('''    GET_VREG %eax, rINST                    # eax<- vAA (exception object)''')
  write_line('''    testl   %eax, %eax''')
  write_line('''    jz      common_errNullObject''')
  write_line('''    movl    rSELF,%ecx''')
  write_line('''    movl    %eax, THREAD_EXCEPTION_OFFSET(%ecx)''')
  write_line('''    jmp     MterpException''')

def op_unused_3e():
  unused()

def op_unused_3f():
  unused()

def op_unused_40():
  unused()

def op_unused_41():
  unused()

def op_unused_42():
  unused()

def op_unused_43():
  unused()

def op_unused_79():
  unused()

def op_unused_7a():
  unused()

def op_unused_f3():
  unused()

def op_unused_f4():
  unused()

def op_unused_f5():
  unused()

def op_unused_f6():
  unused()

def op_unused_f7():
  unused()

def op_unused_f8():
  unused()

def op_unused_f9():
  unused()

def op_unused_fc():
  unused()

def op_unused_fd():
  unused()

def op_ushr_int():
  binop1(instr="shrl    %cl, %eax")

def op_ushr_int_2addr():
  shop2addr(instr="shrl    %cl, %eax")

def op_ushr_int_lit8():
  binopLit8(instr="shrl    %cl, %eax")

def op_ushr_long():
  write_line('''/*''')
  write_line(''' * Long integer shift.  This is different from the generic 32/64-bit''')
  write_line(''' * binary operations because vAA/vBB are 64-bit but vCC (the shift''')
  write_line(''' * distance) is 32-bit.  Also, Dalvik requires us to mask off the low''')
  write_line(''' * 6 bits of the shift distance.  x86 shifts automatically mask off''')
  write_line(''' * the low 5 bits of %cl, so have to handle the 64 > shiftcount > 31''')
  write_line(''' * case specially.''')
  write_line(''' */''')
  write_line('''    /* shr-long vAA, vBB, vCC */''')
  write_line('''    /* ecx gets shift count */''')
  write_line('''    /* Need to spill rIBASE */''')
  write_line('''    /* rINSTw gets AA */''')
  write_line('''    movzbl  2(rPC), %eax                    # eax <- BB''')
  write_line('''    movzbl  3(rPC), %ecx                    # ecx <- CC''')
  write_line('''    movl    rIBASE, LOCAL0(%esp)''')
  write_line('''    GET_VREG_HIGH rIBASE, %eax              # rIBASE <- v[BB+1]''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vCC''')
  write_line('''    GET_VREG %eax, %eax                     # eax <- v[BB+0]''')
  write_line('''    shrdl   rIBASE, %eax''')
  write_line('''    shrl    %cl, rIBASE''')
  write_line('''    testb   $32, %cl''')
  write_line('''    je      2f''')
  write_line('''    movl    rIBASE, %eax''')
  write_line('''    xorl    rIBASE, rIBASE''')
  write_line('''2:''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[AA+1] <- rIBASE''')
  write_line('''    movl    LOCAL0(%esp), rIBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[BB+0] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def op_ushr_long_2addr():
  write_line('''/*''')
  write_line(''' * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is''')
  write_line(''' * 32-bit shift distance.''')
  write_line(''' */''')
  write_line('''    /* shl-long/2addr vA, vB */''')
  write_line('''    /* ecx gets shift count */''')
  write_line('''    /* Need to spill rIBASE */''')
  write_line('''    /* rINSTw gets AA */''')
  write_line('''    movzbl  rINSTbl, %ecx                   # ecx <- BA''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- v[AA+0]''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    movl    rIBASE, LOCAL0(%esp)''')
  write_line('''    GET_VREG_HIGH rIBASE, rINST             # rIBASE <- v[AA+1]''')
  write_line('''    GET_VREG %ecx, %ecx                     # ecx <- vBB''')
  write_line('''    shrdl   rIBASE, %eax''')
  write_line('''    shrl    %cl, rIBASE''')
  write_line('''    testb   $32, %cl''')
  write_line('''    je      2f''')
  write_line('''    movl    rIBASE, %eax''')
  write_line('''    xorl    rIBASE, rIBASE''')
  write_line('''2:''')
  write_line('''    SET_VREG_HIGH rIBASE, rINST             # v[AA+1] <- rIBASE''')
  write_line('''    movl    LOCAL0(%esp), rIBASE''')
  write_line('''    SET_VREG %eax, rINST                    # v[AA+0] <- eax''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def op_xor_int():
  binop(instr="xorl    (rFP,%ecx,4), %eax")

def op_xor_int_2addr():
  binop2addr(instr="xorl    %eax, (rFP,%ecx,4)")

def op_xor_int_lit16():
  binopLit16(instr="xorl    %ecx, %eax")

def op_xor_int_lit8():
  binopLit8(instr="xorl    %ecx, %eax")

def op_xor_long():
  binopWide(instr1="xorl    (rFP,%ecx,4), rIBASE", instr2="xorl    4(rFP,%ecx,4), %eax")

def op_xor_long_2addr():
  binopWide2addr(instr1="xorl    %eax, (rFP,rINST,4)", instr2="xorl    %ecx, 4(rFP,rINST,4)")

def shop2addr(result="%eax", instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit "shift/2addr" operation.''')
  write_line(''' */''')
  write_line('''    /* shift/2addr vA, vB */''')
  write_line('''    movzx   rINSTbl, %ecx                   # eax <- BA''')
  write_line('''    sarl    $4, %ecx                       # ecx <- B''')
  write_line('''    GET_VREG %ecx, %ecx                     # eax <- vBB''')
  write_line('''    andb    $0xf, rINSTbl                  # rINST <- A''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vAA''')
  write_line('''    ''' + instr + '''                                  # ex: sarl %cl, %eax''')
  write_line('''    SET_VREG ''' + result + ''', rINST''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def sseBinop(instr="", suff=""):
  write_line('''    movzbl  2(rPC), %ecx                    # ecx <- BB''')
  write_line('''    movzbl  3(rPC), %eax                    # eax <- CC''')
  write_line('''    movs''' + suff + '''   VREG_ADDRESS(%ecx), %xmm0  # %xmm0 <- 1st src''')
  write_line('''    ''' + instr + '''''' + suff + ''' VREG_ADDRESS(%eax), %xmm0''')
  write_line('''    movs''' + suff + '''   %xmm0, VREG_ADDRESS(rINST) # vAA <- %xmm0''')
  write_line('''    pxor    %xmm0, %xmm0''')
  write_line('''    movs''' + suff + '''   %xmm0, VREG_REF_ADDRESS(rINST) # clear ref''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

def sseBinop2Addr(instr="", suff=""):
  write_line('''    movzx   rINSTbl, %ecx                   # ecx <- A+''')
  write_line('''    andl    $0xf, %ecx                     # ecx <- A''')
  write_line('''    movs''' + suff + ''' VREG_ADDRESS(%ecx), %xmm0      # %xmm0 <- 1st src''')
  write_line('''    sarl    $4, rINST                      # rINST<- B''')
  write_line('''    ''' + instr + '''''' + suff + ''' VREG_ADDRESS(rINST), %xmm0''')
  write_line('''    movs''' + suff + ''' %xmm0, VREG_ADDRESS(%ecx)   # vAA<- %xmm0''')
  write_line('''    pxor    %xmm0, %xmm0''')
  write_line('''    movs''' + suff + ''' %xmm0, VREG_REF_ADDRESS(rINST)  # clear ref''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def unop(instr=""):
  write_line('''/*''')
  write_line(''' * Generic 32-bit unary operation.  Provide an "instr" line that''')
  write_line(''' * specifies an instruction that performs "result = op eax".''')
  write_line(''' */''')
  write_line('''    /* unop vA, vB */''')
  write_line('''    movzbl  rINSTbl,%ecx                    # ecx <- A+''')
  write_line('''    sarl    $4,rINST                       # rINST <- B''')
  write_line('''    GET_VREG %eax, rINST                    # eax <- vB''')
  write_line('''    andb    $0xf,%cl                       # ecx <- A''')
  write_line('''    ''' + instr + '''''')
  write_line('''    SET_VREG %eax, %ecx''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 1''')

def unused():
  write_line('''/*''')
  write_line(''' * Bail to reference interpreter to throw.''')
  write_line(''' */''')
  write_line('''    jmp     MterpFallback''')

def zcmp(revcmp=""):
  write_line('''/*''')
  write_line(''' * Generic one-operand compare-and-branch operation.  Provide a "revcmp"''')
  write_line(''' * fragment that specifies the *reverse* comparison to perform, e.g.''')
  write_line(''' * for "if-le" you would use "gt".''')
  write_line(''' *''')
  write_line(''' * for: if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez''')
  write_line(''' */''')
  write_line('''    /* if-cmp vAA, +BBBB */''')
  write_line('''    cmpl    $0, VREG_ADDRESS(rINST)        # compare (vA, 0)''')
  write_line('''    j''' + revcmp + '''   1f''')
  write_line('''    movswl  2(rPC), rINST                   # fetch signed displacement''')
  write_line('''    testl   rINST, rINST''')
  write_line('''    jmp     MterpCommonTakenBranch''')
  write_line('''1:''')
  write_line('''    cmpw    $JIT_CHECK_OSR, rPROFILE''')
  write_line('''    je      .L_check_not_taken_osr''')
  write_line('''    ADVANCE_PC_FETCH_AND_GOTO_NEXT 2''')

