{
  "comments": [
    {
      "key": {
        "uuid": "ea77c70c_a69c2605",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1030,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-07-21T14:46:05Z",
      "side": 1,
      "message": "This focuses exclusively on loops. Wouldn\u0027t it be beneficial for other situations as well?",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39b223c6_28c1ab4d",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1030,
      "author": {
        "id": 1055300
      },
      "writtenOn": "2016-08-09T09:07:29Z",
      "side": 1,
      "message": "This make sense for loops only, when we split interval inside the loop, and understand that we\u0027ll never use it from register anymore. We need to return value on register on backbranch. But imagine if we don\u0027t have register uses in a loop while we still think that we should fill register with value. Such situation makes fills on backbranches completely useless.",
      "parentUuid": "ea77c70c_a69c2605",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5c37d20c_603dd2de",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1030,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2016-10-12T13:26:22Z",
      "side": 1,
      "message": "I haven\u0027t checked this recently but won\u0027t the environmental uses of the interval inside the loop (SuspendCheck, BoundsChecks, etc) prevent us from doing this?",
      "parentUuid": "39b223c6_28c1ab4d",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ea77c70c_869f2af9",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-07-21T14:46:05Z",
      "side": 1,
      "message": "ditto",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "990eaf7b_638b226f",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1293,
      "author": {
        "id": 1055300
      },
      "writtenOn": "2016-08-09T09:07:29Z",
      "side": 1,
      "message": "This focuses on loops because it\u0027s critical for loops only",
      "parentUuid": "ea77c70c_869f2af9",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ea77c70c_66ab0e21",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1695,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-07-21T14:46:05Z",
      "side": 1,
      "message": "ConnectSiblings() doesn\u0027t look like the right place to do this kind of work. It would be better to do this by splitting the interval differently during the linear scan.",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39b223c6_08c38760",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1695,
      "author": {
        "id": 1055300
      },
      "writtenOn": "2016-08-09T09:07:29Z",
      "side": 1,
      "message": "The idea behind this place in ConnectSiblings (before the change introduced by patch) is in spilling values right after definition (interval start). However hotness of definition (and as a consequence hotness of spill) is never counted. This caused a situation when we had spills on every iteration instead of having only one right after the loop. \n\nConnectSiblings was changed to avoid extra spilling at definition in a loop body if possible. Change was done here because there is no interval splitting which could move definition (interval start).",
      "parentUuid": "ea77c70c_66ab0e21",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "39b223c6_68cec389",
        "filename": "compiler/optimizing/register_allocator.cc",
        "patchSetId": 3
      },
      "lineNbr": 1695,
      "author": {
        "id": 1055300
      },
      "writtenOn": "2016-08-09T09:07:29Z",
      "side": 1,
      "message": "The idea behind this place in ConnectSiblings (before the change introduced by patch) is in spilling values right after definition (interval start). However hotness of definition (and as a consequence hotness of spill) is never counted. This caused a situation when we had spills on every iteration instead of having only one right after the loop. \n\nConnectSiblings was changed to avoid extra spilling at definition in a loop body if possible. Change was done here because there is no interval splitting which could move definition (interval start).",
      "parentUuid": "ea77c70c_66ab0e21",
      "revId": "f683a5f9d2b21d5eff63c43876f5075f78358288",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}