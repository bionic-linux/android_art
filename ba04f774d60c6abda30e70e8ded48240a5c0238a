{
  "comments": [
    {
      "key": {
        "uuid": "968f39ad_41b11419",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-11-02T08:47:56Z",
      "side": 1,
      "message": "isn\u0027t that \"need_constant_area\"? Also, why not always being true?",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f6195673_fc3138e7",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2015-11-02T15:34:51Z",
      "side": 1,
      "message": "In fact, it is really \u0027has constant area\u0027 available if you need it.  There is a cost for establishing addressability for the constant area (2 instructions per method), and so it isn\u0027t done, except for the cases where the intrinsics need it.  It also isn\u0027t set if we are using the baseline compiler, as the optimization pass to support the constant area isn\u0027t run.",
      "parentUuid": "968f39ad_41b11419",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d685318b_a32ca4d0",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-11-02T15:44:02Z",
      "side": 1,
      "message": "I\u0027m a bit puzzled about the complexity of this change (the need to add a new HInstruction). Why can\u0027t the intrinsic just check whether there is one? Or always create one if an intrinsic actually needs one?",
      "parentUuid": "f6195673_fc3138e7",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "96401a44_ff292b67",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2015-11-02T15:58:48Z",
      "side": 1,
      "message": "The complexity is due to the fact that the Invoke needs to add an extra input holding the result of the HX86ComputeBaseMethodAddress so that it can be correctly register allocated.\n\nOne alternate scheme would be for me to create a new HInvokeStaticOrDirect node, and just add an extra parameter to that, and then check for the existence of the extra parameter during intrinsic code generation.  Would that be work for you?  I was under the impression that you wanted the arch-specific work to use different HInstructions.",
      "parentUuid": "d685318b_a32ca4d0",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "768ac5a0_400cb07e",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-11-02T16:24:52Z",
      "side": 1,
      "message": "Oh, yeah, I forgot about the extra parameter you need to add. Now I understand about the extra instruction. It\u0027s fine if you create an arch-specific one, I think.\n\nBut then why not creating the constant area as soon as an intrinsic requests one?",
      "parentUuid": "96401a44_ff292b67",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "161fca56_11e17bed",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2015-11-02T16:34:53Z",
      "side": 1,
      "message": "The constant area has to be created before register allocation is done, in order to pass the address needed to access the constant area to the instructions that need it.  This is done in constant_area_fixups_x86.cc.  All this boolean flag does is let the intrinsic location generator know that there is a constant area, and it will need to add a RequiresRegister() for the method address input.",
      "parentUuid": "768ac5a0_400cb07e",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "760c86c0_a7156acb",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-11-06T12:01:59Z",
      "side": 1,
      "message": "But wait, why aren\u0027t the constants just replaced with the X86LoadConstant instruction?",
      "parentUuid": "161fca56_11e17bed",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}