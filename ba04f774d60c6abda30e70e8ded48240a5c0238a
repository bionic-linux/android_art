{
  "comments": [
    {
      "key": {
        "uuid": "968f39ad_41b11419",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-11-02T08:47:56Z",
      "side": 1,
      "message": "isn\u0027t that \"need_constant_area\"? Also, why not always being true?",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f6195673_fc3138e7",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2015-11-02T15:34:51Z",
      "side": 1,
      "message": "In fact, it is really \u0027has constant area\u0027 available if you need it.  There is a cost for establishing addressability for the constant area (2 instructions per method), and so it isn\u0027t done, except for the cases where the intrinsics need it.  It also isn\u0027t set if we are using the baseline compiler, as the optimization pass to support the constant area isn\u0027t run.",
      "parentUuid": "968f39ad_41b11419",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d685318b_a32ca4d0",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-11-02T15:44:02Z",
      "side": 1,
      "message": "I\u0027m a bit puzzled about the complexity of this change (the need to add a new HInstruction). Why can\u0027t the intrinsic just check whether there is one? Or always create one if an intrinsic actually needs one?",
      "parentUuid": "f6195673_fc3138e7",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "96401a44_ff292b67",
        "filename": "compiler/optimizing/intrinsics_x86.h",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2015-11-02T15:58:48Z",
      "side": 1,
      "message": "The complexity is due to the fact that the Invoke needs to add an extra input holding the result of the HX86ComputeBaseMethodAddress so that it can be correctly register allocated.\n\nOne alternate scheme would be for me to create a new HInvokeStaticOrDirect node, and just add an extra parameter to that, and then check for the existence of the extra parameter during intrinsic code generation.  Would that be work for you?  I was under the impression that you wanted the arch-specific work to use different HInstructions.",
      "parentUuid": "d685318b_a32ca4d0",
      "range": {
        "startLine": 55,
        "startChar": 7,
        "endLine": 55,
        "endChar": 25
      },
      "revId": "ba04f774d60c6abda30e70e8ded48240a5c0238a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}