{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6c5e48da_a9a9358b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "A few generic parsing-related comments, not python-specific.",
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "587c95f6_a4edefdc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T15:10:01Z",
      "side": 1,
      "message": "Non-python-expert LGTM.",
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6c73b38_268358d2",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "All `re.compile` objects can be global so that the regexps are compiled once (they have static regexp arguments as far as I can see).",
      "range": {
        "startLine": 22,
        "startChar": 15,
        "endLine": 22,
        "endChar": 25
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5e9fe90d_76f19a39",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-01T14:59:52Z",
      "side": 1,
      "message": "Most of the compiles are called just once, and the python documentation suggests that the `re` module also does caching of the compiled expressions.  So I would rather keep is nested for clarity.\n\nPS: The main bottleneck of the whole script is first the LLVM tools dump all the DWARF/assembly, and then the top level re expressions parsing it.  I don\u0027t claim that the script is fast.  I don\u0027t want to run it in the default build config.",
      "parentUuid": "b6c73b38_268358d2",
      "range": {
        "startLine": 22,
        "startChar": 15,
        "endLine": 22,
        "endChar": 25
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c54646e_6a05a3d3",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T15:10:01Z",
      "side": 1,
      "message": "\u003e re  module also does caching of the compiled expressions\n\nGood to know!",
      "parentUuid": "5e9fe90d_76f19a39",
      "range": {
        "startLine": 22,
        "startChar": 15,
        "endLine": 22,
        "endChar": 25
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cfe4393_036cc93a",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 126,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "Looking at this, I\u0027m a bit worried if you may have an instruction that changes stack pointer and should be captured by one of these regexps, and is even listed here, but due to some regexp quirk it doesn\u0027t match (e.g. there is a slightly different form of this instruction not anticipated by your regexp). Perhaps a safer approach would be to tokenize a generic instruction, check the opcode (mnemonics) an do the processing based on that?",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 126,
        "endChar": 75
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2bf347b5_7a9b0e5e",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 126,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-01T14:59:52Z",
      "side": 1,
      "message": "This not exhaustive.  In addition to other forms of the above instructions, there is also dozens of other ways to change the stack pointer.\n\nBut it does not need to be exhaustive.  The motivation is sanity check.\n\nIf the stack pointer is adjusted in new way (and if the DWARF CFI is correct), this script will complain about the discrepancy.\n\nSo general, if the cfa inference heuristic here is insufficient, the script will complain.",
      "parentUuid": "0cfe4393_036cc93a",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 126,
        "endChar": 75
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70534886_ccd67e20",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 143,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "From parsing standpoint this is inefficient: you repeatedly scan the same string, matching different regexps on it. A more efficient approach is to use one joined regexp with named capturing groups, as described here: https://docs.python.org/3.2/library/re.html#writing-a-tokenizer. I\u0027m ok with leaving this as is if it\u0027s not performance-critcal.",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 143,
        "endChar": 27
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1733b17_f6a7fc01",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 143,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-01T14:59:52Z",
      "side": 1,
      "message": "I considered something like that, but I am not convinced it is performance critical.\n\nThis part of the checker is run only on hand-written assembly.  That is, the LLVM tools still dump DWARF/assembly for C++ code, but C++ code is excluded from the stack pointer checks here.",
      "parentUuid": "70534886_ccd67e20",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 143,
        "endChar": 27
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}