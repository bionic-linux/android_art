{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6c5e48da_a9a9358b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "A few generic parsing-related comments, not python-specific.",
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "587c95f6_a4edefdc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T15:10:01Z",
      "side": 1,
      "message": "Non-python-expert LGTM.",
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b06e1562_96dc14c5",
        "filename": "runtime/interpreter/mterp/arm64ng/control_flow.S",
        "patchSetId": 3
      },
      "lineNbr": 170,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-04T15:24:07Z",
      "side": 1,
      "message": "Use `CFI_RESTORE_STATE_AND_DEF_CFA`.",
      "range": {
        "startLine": 170,
        "startChar": 4,
        "endLine": 170,
        "endChar": 22
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8f53a48d_6cfbdb8d",
        "filename": "runtime/interpreter/mterp/arm64ng/control_flow.S",
        "patchSetId": 3
      },
      "lineNbr": 170,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-07T11:45:46Z",
      "side": 1,
      "message": "It needs CFI_DEF_CFA_BREG_PLUS_UCONST\n(the stack size is dynamic)",
      "parentUuid": "b06e1562_96dc14c5",
      "range": {
        "startLine": 170,
        "startChar": 4,
        "endLine": 170,
        "endChar": 22
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "101de123_97add261",
        "filename": "runtime/interpreter/mterp/arm64ng/control_flow.S",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-04T15:24:07Z",
      "side": 1,
      "message": "We could \"un-confuse\" the script by adding expressions for code flow-terminating instructions (including \"ret\"). But we\u0027d need some custom heuristic to tell the script that all nterp opcode handlers are reachable and should have the same SP offset as the last \"BR\" before the NOP handler.\n\nDo we process nterp handlers indiviually? Or do we see the nterp as a single function?",
      "range": {
        "startLine": 173,
        "startChar": 6,
        "endLine": 173,
        "endChar": 96
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53f62b9d_1c0360b1",
        "filename": "runtime/interpreter/mterp/arm64ng/control_flow.S",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-05T10:15:44Z",
      "side": 1,
      "message": "Yes, I know that treating all branches as conditional is questionable.  But, in general, it has not been in issue (and it is not an issue here).  In particular, if I added that support, I should also probably check that \"ret\" in middle of function does not cause the rest of the function to be accidentally skipped.  So I would need to add support for the termination, and then simultaneously add check that no code follows it until the next known-reachable instruction, or the end of the function, which is what the current version effectively does already.  So it would be adding two new features, which together are essentially a no-op anyway.\n\nYes, the we need to find a way to add control-flow edge from the \"calculated handler jump\" to the start of each handler.  That is the issue, and the heuristic would solve it.  I am not quite sure how to do it.  I guess it is easy to identify the jump site by \"end of hard-coded symbol\", but I am not sure how to identify the handlers.\n\nThe nterp is handled as one big function.",
      "parentUuid": "101de123_97add261",
      "range": {
        "startLine": 173,
        "startChar": 6,
        "endLine": 173,
        "endChar": 96
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24e923c0_c6f6b1ce",
        "filename": "runtime/interpreter/mterp/arm64ng/control_flow.S",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-05T10:37:44Z",
      "side": 1,
      "message": "But we do have the names of the handlers somewhere as we can surface them in stack traces, right? They may just need to be retrieved from different data source and found with appropriate regex.\n\nCan you add a TODO to improve the script and remove the dead code?",
      "parentUuid": "53f62b9d_1c0360b1",
      "range": {
        "startLine": 173,
        "startChar": 6,
        "endLine": 173,
        "endChar": 96
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f4e4ab9a_bd9c15ab",
        "filename": "runtime/interpreter/mterp/arm64ng/control_flow.S",
        "patchSetId": 3
      },
      "lineNbr": 173,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-07T11:45:46Z",
      "side": 1,
      "message": "Done.  There is a simple fix actually... just ignore the handlers in the checker.\nThe CFA inside handlers can not be checked anyway as it is dynamic.\nAnd the epilogue is still checked as before.\n\nAt the moment I just excluded them by symbol name.\nMore general solution would have been to stop checking at \"mov sp, ?\" and restart at \"mov ?, sp\".",
      "parentUuid": "24e923c0_c6f6b1ce",
      "range": {
        "startLine": 173,
        "startChar": 6,
        "endLine": 173,
        "endChar": 96
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db75efbe_643c20a7",
        "filename": "runtime/interpreter/mterp/arm64ng/main.S",
        "patchSetId": 3
      },
      "lineNbr": 1904,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-04T15:24:07Z",
      "side": 1,
      "message": "double typo",
      "range": {
        "startLine": 1904,
        "startChar": 6,
        "endLine": 1904,
        "endChar": 22
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3729dba_046fddf8",
        "filename": "runtime/interpreter/mterp/arm64ng/main.S",
        "patchSetId": 3
      },
      "lineNbr": 1904,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-07T11:45:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "db75efbe_643c20a7",
      "range": {
        "startLine": 1904,
        "startChar": 6,
        "endLine": 1904,
        "endChar": 22
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a0e1d03_5e4a21d3",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 1,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-04T15:24:07Z",
      "side": 1,
      "message": "Missing copyright header.",
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ca7b50ca_8164af9f",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 1,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-07T11:45:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9a0e1d03_5e4a21d3",
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6c73b38_268358d2",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "All `re.compile` objects can be global so that the regexps are compiled once (they have static regexp arguments as far as I can see).",
      "range": {
        "startLine": 22,
        "startChar": 15,
        "endLine": 22,
        "endChar": 25
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5e9fe90d_76f19a39",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-01T14:59:52Z",
      "side": 1,
      "message": "Most of the compiles are called just once, and the python documentation suggests that the `re` module also does caching of the compiled expressions.  So I would rather keep is nested for clarity.\n\nPS: The main bottleneck of the whole script is first the LLVM tools dump all the DWARF/assembly, and then the top level re expressions parsing it.  I don\u0027t claim that the script is fast.  I don\u0027t want to run it in the default build config.",
      "parentUuid": "b6c73b38_268358d2",
      "range": {
        "startLine": 22,
        "startChar": 15,
        "endLine": 22,
        "endChar": 25
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c54646e_6a05a3d3",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T15:10:01Z",
      "side": 1,
      "message": "\u003e re  module also does caching of the compiled expressions\n\nGood to know!",
      "parentUuid": "5e9fe90d_76f19a39",
      "range": {
        "startLine": 22,
        "startChar": 15,
        "endLine": 22,
        "endChar": 25
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0cfe4393_036cc93a",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 126,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "Looking at this, I\u0027m a bit worried if you may have an instruction that changes stack pointer and should be captured by one of these regexps, and is even listed here, but due to some regexp quirk it doesn\u0027t match (e.g. there is a slightly different form of this instruction not anticipated by your regexp). Perhaps a safer approach would be to tokenize a generic instruction, check the opcode (mnemonics) an do the processing based on that?",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 126,
        "endChar": 75
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2bf347b5_7a9b0e5e",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 126,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-01T14:59:52Z",
      "side": 1,
      "message": "This not exhaustive.  In addition to other forms of the above instructions, there is also dozens of other ways to change the stack pointer.\n\nBut it does not need to be exhaustive.  The motivation is sanity check.\n\nIf the stack pointer is adjusted in new way (and if the DWARF CFI is correct), this script will complain about the discrepancy.\n\nSo general, if the cfa inference heuristic here is insufficient, the script will complain.",
      "parentUuid": "0cfe4393_036cc93a",
      "range": {
        "startLine": 117,
        "startChar": 0,
        "endLine": 126,
        "endChar": 75
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a32c3036_fffc7f41",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 136,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-04T15:24:07Z",
      "side": 1,
      "message": "Is this map retrieval with default result `offset` if the map does not contain a value for key `addr`?",
      "range": {
        "startLine": 136,
        "startChar": 13,
        "endLine": 136,
        "endChar": 44
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7be3c4a7_3082130d",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 136,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-05T10:15:44Z",
      "side": 1,
      "message": "Yes.  Other options are:\n\n`offset \u003d future_offset.get(addr) or offset`\n\n\n  if offset in future_offset:\n     offset \u003d future_offset.get(addr)",
      "parentUuid": "a32c3036_fffc7f41",
      "range": {
        "startLine": 136,
        "startChar": 13,
        "endLine": 136,
        "endChar": 44
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c3b21f4_d6d828a1",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 136,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-05T10:37:44Z",
      "side": 1,
      "message": "I guess all versions are OK for someone familiar with the python APIs but maybe the last one is the best for someone who rarely reads/writes python. (Assuming you meant `if addr in future_offset:`.)",
      "parentUuid": "7be3c4a7_3082130d",
      "range": {
        "startLine": 136,
        "startChar": 13,
        "endLine": 136,
        "endChar": 44
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ab842f4c_c1bf5881",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 136,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-07T11:45:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8c3b21f4_d6d828a1",
      "range": {
        "startLine": 136,
        "startChar": 13,
        "endLine": 136,
        "endChar": 44
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c036e410_d98c947c",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 139,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-04T15:24:07Z",
      "side": 1,
      "message": "Isn\u0027t it an actual error in assembly if the SP offset for an incoming branch does not match SP offset from a fall-through instruction?\n\nHowever, to detect such errors, we would need to detect code flow-terminating instructions, such as \"ret\", \"pop {..., pc}\", \"bx \u003creg\u003e\" and \"br \u003creg\u003e, to avoid too many false positives.",
      "range": {
        "startLine": 138,
        "startChar": 0,
        "endLine": 139,
        "endChar": 44
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a720793_6a43b20c",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 139,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-05T10:15:44Z",
      "side": 1,
      "message": "It would be an error... which this script does not try to find.\n\nThis script tries to check correctness of DWARF CFI.   Trying to check that the SP is consistent within the assembly alone wasn\u0027t a goal I had in mind.\n\nTherefore I took the the \"all branches are considered conditional\" and \"incoming jump takes precedence over fall-through\" approach, which is equivalent assuming the assembly is correct.\n\nAlso note that I only support forward-only branches.  It is single-pass algorithm.  I don\u0027t build control-flow graph.  This was sufficient for our use cases (checking CFI in slow-paths).\n\nI could try to add this assembly control-flow checking feature though.  It is a big beyond the scope of \"check CFI\", but it is reasonable.\n\n---\n\nHaving said all that.  Note that all of above is unrelated to the code line.  The `if` just compresses the output (removes repeated offset entries, as it not necessary to specify the offset didn\u0027t change).",
      "parentUuid": "c036e410_d98c947c",
      "range": {
        "startLine": 138,
        "startChar": 0,
        "endLine": 139,
        "endChar": 44
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5345bddd_8f71ad86",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 139,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-07T12:51:27Z",
      "side": 1,
      "message": "Ack.",
      "parentUuid": "5a720793_6a43b20c",
      "range": {
        "startLine": 138,
        "startChar": 0,
        "endLine": 139,
        "endChar": 44
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70534886_ccd67e20",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 143,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2022-04-01T14:21:27Z",
      "side": 1,
      "message": "From parsing standpoint this is inefficient: you repeatedly scan the same string, matching different regexps on it. A more efficient approach is to use one joined regexp with named capturing groups, as described here: https://docs.python.org/3.2/library/re.html#writing-a-tokenizer. I\u0027m ok with leaving this as is if it\u0027s not performance-critcal.",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 143,
        "endChar": 27
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a1733b17_f6a7fc01",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 143,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-01T14:59:52Z",
      "side": 1,
      "message": "I considered something like that, but I am not convinced it is performance critical.\n\nThis part of the checker is run only on hand-written assembly.  That is, the LLVM tools still dump DWARF/assembly for C++ code, but C++ code is excluded from the stack pointer checks here.",
      "parentUuid": "70534886_ccd67e20",
      "range": {
        "startLine": 142,
        "startChar": 0,
        "endLine": 143,
        "endChar": 27
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "598fb276_f40868a5",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 172,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-04T15:24:07Z",
      "side": 1,
      "message": "typo",
      "range": {
        "startLine": 172,
        "startChar": 85,
        "endLine": 172,
        "endChar": 92
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e7ec914_1ac137ed",
        "filename": "tools/check_cfi.py",
        "patchSetId": 3
      },
      "lineNbr": 172,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2022-04-07T11:45:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "598fb276_f40868a5",
      "range": {
        "startLine": 172,
        "startChar": 85,
        "endLine": 172,
        "endChar": 92
      },
      "revId": "f763fb1dbbdd80b8ed474732b291b4288bf283b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}