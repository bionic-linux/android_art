{
  "comments": [
    {
      "key": {
        "uuid": "34ad251a_a6d15d7e",
        "filename": "compiler/optimizing/code_generator_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 8193,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-03-03T15:56:44Z",
      "side": 1,
      "message": "here you see a sample use of alignment opt in codegen",
      "revId": "114f412127146f3f74e760554f5c78a192755a7c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "506b6a73_cae63bd9",
        "filename": "compiler/optimizing/loop_optimization.cc",
        "patchSetId": 9
      },
      "lineNbr": 567,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-03-03T14:59:05Z",
      "side": 1,
      "message": "General question: how could the design look like for the target dependent features utilization during target independent part (for instance usage of ARM Long, Wide and Narrow variants of instructions)?\n\nI guess some of them could be done via separate simplifier pass by fuzzing some instructions (type_conv + add), but not all of them.",
      "revId": "114f412127146f3f74e760554f5c78a192755a7c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "afbf5ef0_92c93ebb",
        "filename": "compiler/optimizing/loop_optimization.cc",
        "patchSetId": 9
      },
      "lineNbr": 567,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-03-03T15:56:44Z",
      "side": 1,
      "message": "I was thinking along the lines of a combination of attributes in the vector nodes and adding new vector nodes kinds where needed. Do you foresee any issues, since you are more familiar with all features we want to add eventually? If so, we can discuss this perhaps offline and try to design something now already....",
      "parentUuid": "506b6a73_cae63bd9",
      "revId": "114f412127146f3f74e760554f5c78a192755a7c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "21b526e9_fa18d7e4",
        "filename": "compiler/optimizing/loop_optimization.cc",
        "patchSetId": 9
      },
      "lineNbr": 608,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-03-06T17:59:26Z",
      "side": 1,
      "message": "I am right that in the future this can be improved to support the following cases:\n\nvoid foo2(int len, int[] a, short[] b, short[] c) {\n  for(int i \u003d 0; i \u003c 100; i++) {\n    a[i] \u003d (int) (b[i]  + c[i]);\n  }\n}\n\nvoid foo(int len, short[] a, int[] b, int[] c) {\n  for(int i \u003d 0; i \u003c 100; i++) {\n    a[i] \u003d (short) (b[i]  + c[i]);\n  }\n}",
      "revId": "114f412127146f3f74e760554f5c78a192755a7c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "07f6df9d_538c66b7",
        "filename": "compiler/optimizing/nodes_vector.h",
        "patchSetId": 9
      },
      "lineNbr": 128,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-03-03T14:59:05Z",
      "side": 1,
      "message": "Am I right that in the future probably some alignment optimizations could be implemented in a target-independent way (with some queries to targets and possible generation of a few versions of the loop)? For example if we know that the addresses during array strides are VECT_SIZE-aligned (not VECT_ELEM_SIZE-aligned) we could benefit in performance by generating LDR instead of LD1.",
      "revId": "114f412127146f3f74e760554f5c78a192755a7c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f8d41851_59314918",
        "filename": "compiler/optimizing/nodes_vector.h",
        "patchSetId": 9
      },
      "lineNbr": 128,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-03-03T15:52:42Z",
      "side": 1,
      "message": "Yes Sir! You can already see this in the x86 code, where 16 byte alignment is checked to pick the \"better\" instructions for load/store. Currently that path is not taken, but if we add static/dynamic alignment optimizations (which are architectural neutral except for the required boundary), setting this alignment field enables all the other good stuff.",
      "parentUuid": "07f6df9d_538c66b7",
      "revId": "114f412127146f3f74e760554f5c78a192755a7c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}