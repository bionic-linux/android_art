{
  "comments": [
    {
      "key": {
        "uuid": "9833d2f4_efd17d73",
        "filename": "runtime/thread_list.cc",
        "patchSetId": 5
      },
      "lineNbr": 547,
      "author": {
        "id": 1073545
      },
      "writtenOn": "2015-07-09T00:46:03Z",
      "side": 1,
      "message": "I think the failure can only happen if there are no more available slot for active_suspend_barriers[]. This is different from the spurious fail from Thread::RequestCheckpoint(), which could fail because of a CAS.\n\nIf there are no more available slot for active_suspend_barriers[], this while loop would spin wait holding the thread_suspend_count_lock_. Then no other threads can execute PassActiveSuspendBarriers(), because they also need to grab the thread_suspend_count_lock_. Would this be a deadlock? (I think ThreadList::RunCheckpoint() has a similar deadlock problem.)\n\nMaybe this cannot happen because 3 slots for active_suspend_barriers[] are sufficient so that they cannot be full? And why? If this is the case, probably get rid of this while(true) loop and use a CHECK_NE(available_barrier, kMaxSuspendBarriers) in ModifySuspendCount()?",
      "range": {
        "startLine": 547,
        "startChar": 11,
        "endLine": 547,
        "endChar": 35
      },
      "revId": "c767ba25cfb45b0995bc84140f26758413a414a3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "187d22ed_4b10d988",
        "filename": "runtime/thread_list.cc",
        "patchSetId": 5
      },
      "lineNbr": 547,
      "author": {
        "id": 1073545
      },
      "writtenOn": "2015-07-13T23:01:50Z",
      "side": 1,
      "message": "I\u0027ve added logics to handle this case by unlock, sleep and lock, in patch set #7.",
      "parentUuid": "9833d2f4_efd17d73",
      "range": {
        "startLine": 547,
        "startChar": 11,
        "endLine": 547,
        "endChar": 35
      },
      "revId": "c767ba25cfb45b0995bc84140f26758413a414a3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}