{
  "comments": [
    {
      "key": {
        "uuid": "712ad87b_ce86c340",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1597,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-02-01T14:58:49Z",
      "side": 1,
      "message": "Does it fail if we specify r0/r1 as input and output locations? Are we allowed to specify core regs for FP values?",
      "range": {
        "startLine": 1595,
        "startChar": 74,
        "endLine": 1597,
        "endChar": 24
      },
      "revId": "91d297d2a7b2a2591205a8e7664ab92eb3794c44",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f1116843_dda8bf98",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1597,
      "author": {
        "id": 1084448
      },
      "writtenOn": "2016-02-01T15:27:24Z",
      "side": 1,
      "message": "No, we are not. Refer to art::CheckTypeConsistency() (compiler/optimizing/code_generator.cc:99).",
      "parentUuid": "712ad87b_ce86c340",
      "range": {
        "startLine": 1595,
        "startChar": 74,
        "endLine": 1597,
        "endChar": 24
      },
      "revId": "91d297d2a7b2a2591205a8e7664ab92eb3794c44",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d162a4ed_acb5cbee",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1597,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-02-01T16:06:31Z",
      "side": 1,
      "message": "And can we insert kDoubleDoubleToRawLongBits for inputs and kDoubleLongBitsToDouble for the output (in an extra ARM-specific pass)? That would put the burden back on the register allocator and allow elimination of unnecessary kDoubleLongBitsToDouble+kDoubleDoubleToRawLongBits.",
      "parentUuid": "f1116843_dda8bf98",
      "range": {
        "startLine": 1595,
        "startChar": 74,
        "endLine": 1597,
        "endChar": 24
      },
      "revId": "91d297d2a7b2a2591205a8e7664ab92eb3794c44",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f1b5e8da_3aef61dd",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1597,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2016-02-02T14:36:05Z",
      "side": 1,
      "message": "Just don\u0027t do the intrinsic if the graph is debuggable...",
      "range": {
        "startLine": 1597,
        "startChar": 25,
        "endLine": 1597,
        "endChar": 91
      },
      "revId": "91d297d2a7b2a2591205a8e7664ab92eb3794c44",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "51687402_358e701d",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1597,
      "author": {
        "id": 1084448
      },
      "writtenOn": "2016-02-02T14:46:25Z",
      "side": 1,
      "message": "This is still profitable even if the graph is debuggable. However, if the graph is not debuggable, then the input and output constraints can be relaxed to Location::RequiresFpuRegister(). In any case, Vladimir\u0027s suggestion is even better because it avoids this issue and provides a further optimization for code such as Math.cos(Math.sin( ... )) at the same time.",
      "parentUuid": "f1b5e8da_3aef61dd",
      "range": {
        "startLine": 1597,
        "startChar": 25,
        "endLine": 1597,
        "endChar": 91
      },
      "revId": "91d297d2a7b2a2591205a8e7664ab92eb3794c44",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "314ea0ac_fc8b4904",
        "filename": "compiler/optimizing/intrinsics_arm.cc",
        "patchSetId": 1
      },
      "lineNbr": 1597,
      "author": {
        "id": 1072549
      },
      "writtenOn": "2016-02-02T14:59:57Z",
      "side": 1,
      "message": "@Nicolas\n\n1) if the graph is !debuggable we can have:\ncodegen() {\n vmovrrd(r0, r1, AnyFPReg())\n blx \n vmovrrd(AnyFPReg(), r0, r1))\n}\n\n2) if the graph is debuggable we can only have:\ncodegen() {\n vmovrrd(r0, r1, FixedFPReg())\n blx \n vmovrrd(FixedFPReg(), r0, r1))\n}\n\nHowever, none of them are ideal since we would still not generate the best code for something like (extra useless moves between FP-GP regs):\n\nsin(cos(sin(cos(#value))));\n\n(But this would be handled by what Vladimir suggested).\n\nI suggest for now we proceed with the 2nd variant that works fine for both debuggagle and non debuggable graphs, and we work on fixing this properly.",
      "parentUuid": "51687402_358e701d",
      "range": {
        "startLine": 1597,
        "startChar": 25,
        "endLine": 1597,
        "endChar": 91
      },
      "revId": "91d297d2a7b2a2591205a8e7664ab92eb3794c44",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}