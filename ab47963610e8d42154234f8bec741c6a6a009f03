{
  "comments": [
    {
      "key": {
        "uuid": "e7cf4774_e3903c83",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-12-01T10:34:13Z",
      "side": 1,
      "message": "Add bug: 69667779.",
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97b08403_5171b2ed",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-12-01T10:52:33Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e7cf4774_e3903c83",
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4aed1c07_01f1e871",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 154,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-12-01T17:53:02Z",
      "side": 1,
      "message": "Rephrase this as\n\nExtends the scheduling barrier with those ...\n\nso that is is clear that you take the original barrier instructions, and add a few for the arm64 case\n\n(otherwise it reads that this method just deals with vector instr)",
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ddbf65d_7eaf86c5",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-12-01T10:34:13Z",
      "side": 1,
      "message": "Please make this a instr-\u003eIsVecOperation for being extra secure.",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "446c2b06_389f2353",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-12-01T10:52:33Z",
      "side": 1,
      "message": "If we do that, VecInstructions within simd loops won\u0027t be scheduled.\n\nNote, now it\u0027s secure in terms of scheduling as when a new vec instruction is introduced one will have to add it to  FOR_EACH_SCHEDULED_COMMON_INSTRUCTION (in this file) otherwise the whole instruction\u0027s block will not be scheduled.",
      "parentUuid": "6ddbf65d_7eaf86c5",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2affb2b7_0bea95e3",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-12-01T10:58:24Z",
      "side": 1,
      "message": "... and also add it to this list. I\u0027d feel much better if we just make all vec instructions a barrier.\n\nRight now, what kind of vec instructions are safe to schedule?",
      "parentUuid": "446c2b06_389f2353",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5595e08f_7d32918b",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-12-01T11:19:15Z",
      "side": 1,
      "message": "It is safe to schedule those VecInstructions which can\u0027t be live across an invoke or a slowpath other than SuspendCheckSlowPath. It is automatically true for those whose live range doesn\u0027t exceed the SIMD loop boundaries (as we don\u0027t have invokes/other slowpaths in a SIMD loop).\n\n(for SuspendCheck we do:\nlocations-\u003eSetCustomSlowPathCallerSaves(GetGraph()-\u003eHasSIMD() ? RegisterSet::AllFpu() : RegisterSet::Empty()); )\n\nAgain, \"if we just make all vec instructions a barrier\" that will mean that no two VecInstructions be reordered in respect to each other; thus effectively SIMD loops won\u0027t be scheduled.",
      "parentUuid": "2affb2b7_0bea95e3",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "10c84046_834a882a",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-12-01T11:36:10Z",
      "side": 1,
      "message": "I\u0027d still feel much safer for now to just disable any vec operation to be scheduled. Diagnosing the problem wasn\u0027t trivial, and I\u0027d much prefer not opening a chance of hitting it again.\n\nAart, WDYT?",
      "parentUuid": "5595e08f_7d32918b",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c8549d4b_0cda01df",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-12-01T17:53:02Z",
      "side": 1,
      "message": "Artem, what perf do we lose if we just don\u0027t schedule SIMD at all. I am on Nicolas\u0027 conservative side on this one but of course I am also sensitive to performance arguments.\n\nIf we keep a list of individual SIMD instructions, I would like this to be somehow defined in nodes_vector.h so that every time we change SIMD, we think about that again.",
      "parentUuid": "10c84046_834a882a",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d3d9f8bc_a5c213d0",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1096678
      },
      "writtenOn": "2017-12-01T18:13:01Z",
      "side": 1,
      "message": "1. I remember SIMD scheduling brings 4% performance improvement on Linpack, according to CL I5e728b5218fc6640ac583594ba08f69330b01e21.\n2. I also observed performance improvement after scheduling VecLoad/Store instructions in an unrolled SIMD loop on ARM64 backend, assuming we\u0027ve solved the array data alignment issue for ARM64.\n\nAt least we will lose above two performance improvements if we don\u0027t schedule SIMD instructions at all.",
      "parentUuid": "c8549d4b_0cda01df",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b9bfa4af_9ec98764",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-12-01T18:52:23Z",
      "side": 1,
      "message": "I will come back with some perf data.\n\nBut what do you think about inserting a CHECK/DCHECK into register allocator which will make sure there is no SIMD values (defined by a VecOperation) which are live across a call?",
      "parentUuid": "c8549d4b_0cda01df",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6c40f117_9d96a35c",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-12-04T21:59:25Z",
      "side": 1,
      "message": "Are you waiting for my CL to do that or are you suggesting to include that in this CL? In the meanwhile, I would be okay to save perf and use this if needed, provided you make it more visible in the nodes_vector.h somehow",
      "parentUuid": "b9bfa4af_9ec98764",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c51d5de3_6edaa34c",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-12-05T14:39:52Z",
      "side": 1,
      "message": "0. BTW the situation is already a bit fragile even without scheduling as for all newly introduced vector instructions we need to specify CanBeMoved() to return true if we want to have GVN applied. In both cases the default is \"false\" (for both CanBeMoved and IsSchedulable); the only thing is that IsSchedulable resides in scheduler_* not in nodes.h.\n\n1. Would a comment in nodes_vector.h near HVecOperation declaration suffice? Another way would be to change the design of IsSchedulable() and instead of having in scheduler_* introduce yet another function (CanBeMoved, IsClonable) to the HInstruction.\n\n2. CHECK/DCHECK into register allocator - basically my question was whether you want me to implement it in this CL.",
      "parentUuid": "6c40f117_9d96a35c",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2e9a8691_794bc570",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-12-05T17:04:50Z",
      "side": 1,
      "message": "(About CanBeMoved: VecOperations should have side effects that ensure they cannot be moved across call boundaries then. I haven\u0027t checked if that\u0027s the case).",
      "parentUuid": "c51d5de3_6edaa34c",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0f133d1b_2a5cf0fb",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-12-05T17:51:46Z",
      "side": 1,
      "message": "0) As for CanBeMoved(), well, interesting enough I had set that boolean to false for e.g. the replicate exactly for the reason of not moving this too much around. See nodes_vector.h\n\n // A replicate needs to stay in place, since SIMD registers are not\n  // kept alive across vector loop boundaries (yet).\n  bool CanBeMoved() const OVERRIDE { return false; }\n\nSame was done for the others that set values in SIMD registers that remain live into the loop.\n\nThe problem with this and other flags is that the meaning is often subtle in one context and cannot be easily moved to another, despite having a generic name. But it seems that this flag is exactly what you need here, at least as far as scheduling is concerned?\n\n1) Yes, depending on the solution (no new method), a comment would suffice near the abstract SIMD instruction def\n\n2) if you have that already, include it; if you want me to do it, I will send out CL",
      "parentUuid": "c51d5de3_6edaa34c",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "29eaaf02_d8e84a05",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1089808
      },
      "writtenOn": "2017-12-06T20:27:56Z",
      "side": 1,
      "message": "0) Reusing CanBeMoved() for setting IsSchedulingBarrier will only increase that ambiguity. I think that having this sorted in HScheduler${arch} is a good solution because the semantics is arch-specific: not every target has scheduling on; also on arm 32-bit we can perfectly safe schedule those VecOperations as we only use 64-bit registers.\n1) Have added a comment.\n2) I haven\u0027t touched that yet.",
      "parentUuid": "0f133d1b_2a5cf0fb",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "047b1670_23ca054f",
        "filename": "compiler/optimizing/scheduler_arm64.h",
        "patchSetId": 1
      },
      "lineNbr": 165,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2017-12-06T21:09:07Z",
      "side": 1,
      "message": "0) I am okay with this solution, I was just observing that I actually thought about the problem with moving these instructions when designing the SIMD set and thought that CanBeMoved() was the right way to express that; also observing we are getting too many flags that all mean similar but slightly different things :-(\n1) Thanks\n2) Still not clear if you plan to add it, or are waiting for me :-)",
      "parentUuid": "29eaaf02_d8e84a05",
      "range": {
        "startLine": 162,
        "startChar": 0,
        "endLine": 165,
        "endChar": 41
      },
      "revId": "ab47963610e8d42154234f8bec741c6a6a009f03",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}