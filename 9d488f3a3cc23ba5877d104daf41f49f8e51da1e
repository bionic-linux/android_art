{
  "comments": [
    {
      "key": {
        "uuid": "60e03ce1_87b64cae",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2015-12-07T23:57:44Z",
      "side": 1,
      "message": "Would you mind sharing the performance data for this? I would\u0027ve expected (given a good load balance factor) that open addressing has 1 less cache miss on average than with chaining.",
      "range": {
        "startLine": 10,
        "startChar": 12,
        "endLine": 10,
        "endChar": 57
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a02154e4_c8b2ef1e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1085353
      },
      "writtenOn": "2015-12-08T16:40:02Z",
      "side": 1,
      "message": "The performance data for the Google Maps application (if you need I can provide the same data for other applications).\nThe legend:\nTOTAL - total amount of string comparisons for ALL FindIndex() invocations during the application launching.\nAVG - average amount of string comparisons for ONE FindIndex() invocation during the application launching.\nMAX - maximum amount of string comparisons for ONE FindIndex() invocations (the case of looking for a string which are located somewhere in the end of the chain and the chain is too long).\n\nThe results:\nthe Original solution:\nTOTAL \u003d 120683\nAVG \u003d 2.40462\nMAX \u003d 255 - there are several \"very\" long chains.\n\nour solution (with the load_factor \u003d 1):\nTOTAL: 545\nAVG: 0.06058\nmax \u003d 1\n\nHere you can see that there are very long collision chains (up to 255 elements) in the Original solution sometimes and we need to call the string comparison method each time. Meanwhile the longest chain in our table contains less amount of elements and only 1-2 of them are compared using the string comparison operation.\n\nTo measure it I added a counter inside the FindIndex() method initialized by zero and was incrementing it each time we needed to compare strings (each time the control reaches \u0027if (pred_(slot, element))\u0027 statement inside the while loop). Then I was collecting all the counter values for each FindIndex() invocation.",
      "parentUuid": "60e03ce1_87b64cae",
      "range": {
        "startLine": 10,
        "startChar": 12,
        "endLine": 10,
        "endChar": 57
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "80b290f4_2b89d1a0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2015-12-08T17:58:32Z",
      "side": 1,
      "message": "Is that including this CL? The load factors we were using were too high, I adjusted them down and it provided a large reduction in time spent in the hash table:\n\nhttps://android-review.googlesource.com/#/c/176895/",
      "parentUuid": "a02154e4_c8b2ef1e",
      "range": {
        "startLine": 10,
        "startChar": 12,
        "endLine": 10,
        "endChar": 57
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "00430035_eb7031e5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1085353
      },
      "writtenOn": "2015-12-10T11:40:34Z",
      "side": 1,
      "message": "Yes",
      "parentUuid": "80b290f4_2b89d1a0",
      "range": {
        "startLine": 10,
        "startChar": 12,
        "endLine": 10,
        "endChar": 57
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "60c91c79_1c937d7f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2015-12-07T23:57:44Z",
      "side": 1,
      "message": "This would seem to indicate a lot of collisions today. Is there more detailed data?\n\nWhy not just fix the the string hash function to be produce more distributed results, resulting in less collisions?\n\n(or in fact, since this is prezygote strings why not make this into a perfect hash table?)",
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "80be10e1_774dd0bf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1085353
      },
      "writtenOn": "2015-12-08T16:40:02Z",
      "side": 1,
      "message": "Actually as I understand the hash function is good enough: the average amount of string comparisons for the Original version is about 2.4. It means the chains aren\u0027t long in general. But there are several long chains, appearing quite seldom. And the main issue here (in my opinion) is not the has function used, but the approach of collision resolving. I mean there can be (and there are in practice) a lot of already busy slots between the appropriate slot (the slot corresponding the hash) and the slot we are actually placing the element. And during looking up we need to visit all of these slots (because there aren\u0027t empty ones between them). This issue also appears when we are looking for an absent element: we need to pass all slots until we meet an empty one.",
      "parentUuid": "60c91c79_1c937d7f",
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65f20ea9_94980ce6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2015-12-14T22:16:49Z",
      "side": 1,
      "message": "It just seems like there\u0027s plenty of low hanging fruit in the current implementation of hash_set:\n\n1) Resizing should adjust the requested # of slots to the next nearest prime number, this will make it less likely that slot lookup (hashcode%slotindex) will collide for 2 distinct hashcodes.\n\n-- This would potentially help when hash codes are different but the slots end up being the same, should help average case.\n\n2) Linear probing might be inferior to quadratic probing or secondary hash function for giving back different buckets.\n\n-- This would potentially help when the hash codes are the same, it\u0027s less likely to steal slots from another adjacent entry and reduce worst cases.\n\nIt would be interesting to explore these types of enhancements which would have much less complexity and also have a larger impact potential since we actually use the existing hash_set in much more places than just pre_zygote strings.",
      "parentUuid": "80be10e1_774dd0bf",
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c501fa3e_5451820a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 13,
      "author": {
        "id": 1085353
      },
      "writtenOn": "2015-12-15T12:35:51Z",
      "side": 1,
      "message": "Both of the suggestions can help us with reducing the average amount of worst cases (when we are meeting a wrong slot), but probability of considering an element from a wrong chain still exists. Also the first approach increases the table size due to empty slots existence.\n\nAny way, I can check the benefit of the suggestions on practice, if you want.\n\nActually our implementation is based in three ideas:\n1) chains to resolve collisions (we don\u0027t consider elements from other chains);\n2) filling with no collision elements first (allows to make as less as possible wrong placements and also makes the collision chains approach serializable using read-only memory (because our chains are embedded into the table));\n3) comparison of the hash value before the content.\n\nAnd the main item we are promoting is that the table can be faster and less if it\u0027s read only one. The first and the second approaches are applicable for read-only tables only. The third enhancement just uses extra free space of the next slot pointer (index) which isn\u0027t fulfilled in general. Meanwhile your suggestions are about improving the table in general (will influence for all types of hash tables (not read only ones)). I mean your and our ideas don\u0027t correlate with each other.\n\nThe main question here is do you recognise the benefit of read-only tables and their impact to the project?",
      "parentUuid": "65f20ea9_94980ce6",
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a0af948e_e1d1bc20",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2015-12-07T23:57:44Z",
      "side": 1,
      "message": "In total or just the # of components? I see the default load factor is 1.0 which could account for the smaller size.\n\nGiven equivalent load factors I would expect the chained version to be larger given the need to store edge pointer data.",
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "606d9c10_b909db76",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1085353
      },
      "writtenOn": "2015-12-08T16:40:02Z",
      "side": 1,
      "message": "I compared the value returned by the WriteToMemory(nullptr) method. Actually it\u0027s relevant with the num_buckets_ property.\n\nYou\u0027re totally right about the table size: if the load factors are the same the size is bigger. But I investigated that we can increase the load factor of our implementation to 1 without increasing of the average amount of string comparisons. And as the result - the size is less.",
      "parentUuid": "a0af948e_e1d1bc20",
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a0af948e_07016048",
        "filename": "runtime/base/chain_hash_set.h",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2015-12-08T17:58:32Z",
      "side": 1,
      "message": "I wonder if it would be less code duplication to add a kChain template boolean to the normal hash set and just handle the places where the logic differs.",
      "range": {
        "startLine": 43,
        "startChar": 6,
        "endLine": 43,
        "endChar": 18
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a054f4e4_93651eca",
        "filename": "runtime/base/chain_hash_set.h",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1085353
      },
      "writtenOn": "2015-12-10T11:40:34Z",
      "side": 1,
      "message": "I\u0027m also not happy with the code duplication here. It can be several solutions.\n\n1) Add a kChain template. There are two disadvantages here: first, the data structures are different (different class members, different data_ field structure) and second, we need to forbid using of some methods (like Insert()) for the Chain version.\n\n2) To inherit the ChainHashSet (or it\u0027s better to rename it to ReadOnlyHashSet) class from the HashSet, changing some methods logic, deleting unnecessary ones. Also we can hide unnecessary class members under a private modifier.\n\nI think it\u0027s better to implement the second variant.",
      "parentUuid": "a0af948e_07016048",
      "range": {
        "startLine": 43,
        "startChar": 6,
        "endLine": 43,
        "endChar": 18
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "852462f4_aacdefe1",
        "filename": "runtime/base/chain_hash_set.h",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1021471
      },
      "writtenOn": "2015-12-14T22:16:49Z",
      "side": 1,
      "message": "I\u0027m not entirely convinced yet we actually need a chain hash set at all. For that reason alone I wouldn\u0027t necessarily jump into cleaning this up right away.\n\nIf we did however need it, here\u0027s some ways we could clean it up:\n\n----------\n\nTwo interfaces seems like they should be interchangeable (same public member functions), and anywhere the implementation is different it could simply be refactored into 2 separate classes (think of it as the strategy pattern):\n\n  namespace detail {\n   class OpenAddressingHashSetImpl \u003c...\u003e {...};\n   class ChainHashSetImpl \u003c...\u003e { ... };\n  }\n\nPut them into the art::detail namespace (and into a separate detail\\hash_set.h file, 2 files for each impl is also fine as you prefer) as per our convention when a templated class needs to have implementation-specific non-nested classes/functions.\n\nSimply adding a new class that\u0027s a copy or just adding some \u0027if/else\u0027 cases to hash_set.h (to handle chaining) would lead to too much of a mess IMHO.",
      "parentUuid": "a054f4e4_93651eca",
      "range": {
        "startLine": 43,
        "startChar": 6,
        "endLine": 43,
        "endChar": 18
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "658e8e43_d409d40a",
        "filename": "runtime/base/chain_hash_set.h",
        "patchSetId": 1
      },
      "lineNbr": 43,
      "author": {
        "id": 1085353
      },
      "writtenOn": "2015-12-15T12:35:51Z",
      "side": 1,
      "message": "The main idea of our hash set is faster operation and lower memory usage in case of the table is read-only. That\u0027s why I think it\u0027s better to name it ReadOnlyHashSet. Any way, the approach looks nice.\n\nCould you, please, decide do you actually need read-only hash tables support (considering all their benefits) and if you do we will implement and embed it cleanly.",
      "parentUuid": "852462f4_aacdefe1",
      "range": {
        "startLine": 43,
        "startChar": 6,
        "endLine": 43,
        "endChar": 18
      },
      "revId": "9d488f3a3cc23ba5877d104daf41f49f8e51da1e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}