{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c17fea9c_0cc6cb0c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2023-12-04T18:41:34Z",
      "side": 1,
      "message": "The `004-checker-UnsafeTest18` failure looks unrelated to me since it looks like it is failing for interpreter too, but it may be worth it to take a second look since it is related to `Unsafe.getAndSetLong`",
      "revId": "92fdfe65789a776a62590723b01198e8b1087cdb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6cb79a48_8d0d8aa0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2023-12-05T16:21:06Z",
      "side": 1,
      "message": "It is indeed caused by this CL.\n\nI experimented with `--jit-on-first-use` and it was crashing. When I allowed only the second occurrence of GetAndSetLong to be compiled, I managed to hit the following code in gdb:\n\n    \u003d\u003e 0x703bc830:      sub    $0x1c,%esp\n       0x703bc833:      mov    %eax,(%esp)\n       0x703bc836:      mov    %edx,%ebp\n       0x703bc838:      mov    0x2c(%esp),%esi\n       0x703bc83c:      mov    0x30(%esp),%edi\n       0x703bc840:      mov    0x34(%esp),%ebx\n       0x703bc844:      mov    0x38(%esp),%ecx\n       0x703bc848:      mov    0x0(%ebp,%esi,1),%eax\n       0x703bc84c:      mov    0x4(%ebp,%esi,1),%edx\n       0x703bc850:      lock cmpxchg8b 0x0(%ebp,%esi,1)\n       0x703bc856:      jne    0x703bc848\n       0x703bc858:      add    $0x1c,%esp\n       0x703bc85b:      ret\n\nIt seems that the register allocator does not apply explicitly allocated registers to the core spill mask, so the callee-save registers EBP, EDI and EDI are clobbered. I guess I can either fix the register allocator, or disable the 64-bit itrinsics for now.",
      "parentUuid": "c17fea9c_0cc6cb0c",
      "revId": "92fdfe65789a776a62590723b01198e8b1087cdb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f468e752_c610f30d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2023-12-05T16:26:26Z",
      "side": 1,
      "message": "In the build.log from the presubmit I see `(0:00:00.831731)[ 25% 2555/10190 ] test-art-host-run-test-debug-prebuild-interpreter-no-relocate-ntrace-cms-checkjni-picimage-ndebuggable-no-jvmti-cdex-fast-004-checker-UnsafeTest1832 FAIL` Does the `interpreter` tier up? I would have expected to just run on interpreter mode (and thus never hit your CL)\n\n\u003e It seems that the register allocator does not apply explicitly allocated registers to the core spill mask, so the callee-save registers EBP, EDI and EDI are clobbered. I guess I can either fix the register allocator, or disable the 64-bit itrinsics for now.\n\nFixing the register allocator sounds like the best choice, but if you don\u0027t have cycles we can disable the 64bit ones and create a bug to fix it up later.",
      "parentUuid": "6cb79a48_8d0d8aa0",
      "revId": "92fdfe65789a776a62590723b01198e8b1087cdb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a363a6ec_46969177",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2023-12-05T16:51:08Z",
      "side": 1,
      "message": "Even interpreter tests are (oddly) using the boot image with the `Unsafe.getAndSetLong()` compiled like this (this time using `oatdump`):\n\n    CODE: (code_offset\u003d0x0011fc40 size\u003d44)...\n      0x0011fc40:                 83EC1C               sub esp, 28\n      0x0011fc43:                 890424               mov [esp], eax\n      0x0011fc46:                   89D5               mov ebp, edx\n      0x0011fc48:               8B74242C               mov esi, [esp + 44]\n      0x0011fc4c:               8B7C2430               mov edi, [esp + 48]\n      0x0011fc50:               8B5C2434               mov ebx, [esp + 52]\n      0x0011fc54:               8B4C2438               mov ecx, [esp + 56]\n      0x0011fc58:               8B443500               mov eax, [ebp + esi + 0]\n      0x0011fc5c:               8B543504               mov edx, [ebp + esi + 4]\n      0x0011fc60:           F00FC74C3500        lock   cmpxchg8b [ebp + esi + 0]\n      0x0011fc66:                   75F0               jnz/ne -16 (0x0011fc58)\n      0x0011fc68:                 83C41C               add esp, 28\n      0x0011fc6b:                     C3               ret\n\nI was able to set and hit a breakpoint here for `--interpreter`.",
      "parentUuid": "f468e752_c610f30d",
      "revId": "92fdfe65789a776a62590723b01198e8b1087cdb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d9074ed3_eacb48f2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2023-12-06T08:44:53Z",
      "side": 1,
      "message": "The fix is quite simple, see PS2.",
      "parentUuid": "a363a6ec_46969177",
      "revId": "92fdfe65789a776a62590723b01198e8b1087cdb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07da8040_8f9edd8e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2023-12-06T12:08:27Z",
      "side": 1,
      "message": "Nice! Do we need to do the same for other `BlockRegister` calls? namely:\n * RegisterAllocatorLinearScan::BlockRegisters\n * RegisterAllocatorLinearScan::CheckForTempLiveIntervals\n * RegisterAllocatorLinearScan::CheckForFixedOutput\n \nIf so, it might be better to do it in `BlockRegister` itself",
      "parentUuid": "d9074ed3_eacb48f2",
      "revId": "92fdfe65789a776a62590723b01198e8b1087cdb",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}