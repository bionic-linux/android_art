{
  "comments": [
    {
      "key": {
        "uuid": "acefbe0b_8e5eff70",
        "filename": "runtime/gc/space/region_space-inl.h",
        "patchSetId": 14
      },
      "lineNbr": 121,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-04-17T00:18:53Z",
      "side": 1,
      "message": "Isn\u0027t zero_range_end always page_begin when it matters? Get rid of it?",
      "range": {
        "startLine": 121,
        "startChar": 8,
        "endLine": 121,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ed8d509_edbc16b1",
        "filename": "runtime/gc/space/region_space-inl.h",
        "patchSetId": 14
      },
      "lineNbr": 121,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-04-17T02:01:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "acefbe0b_8e5eff70",
      "range": {
        "startLine": 121,
        "startChar": 8,
        "endLine": 121,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e358549a_20b691ab",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 519,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-04-17T00:18:53Z",
      "side": 1,
      "message": "\"Mark only resident pages to recognize cleared pages\"?\n\nWhy is this correct? Is MADV_FREE guaranteed to clear it if it\u0027s paged out? Even then, this seeme brittle if we somehow manage to page it back in before the MADV_FREE? Couldn\u0027t it look cleared if it hasn\u0027t been?\n\nDo we know if any of this matters? Are Java heap pages ever paged out? Or are you only trying to deal with pages that were never touched?\n\nActually mincore() is not very Linux-specific. E.g. https://www.unix.com/man-page/osx/2/mincore/",
      "range": {
        "startLine": 519,
        "startChar": 11,
        "endLine": 519,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ceb4f4c_96534f69",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 519,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-04-17T00:23:32Z",
      "side": 1,
      "message": "I just found the earlier discussion, but I\u0027m still not really convinced. Assuming I\u0027m not overlooking something, I would also be very reluctant to rely on undocumented kernel properties.",
      "parentUuid": "e358549a_20b691ab",
      "range": {
        "startLine": 519,
        "startChar": 11,
        "endLine": 519,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9352117c_deeffc5d",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 519,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-04-17T02:01:10Z",
      "side": 1,
      "message": "May be Minchan can throw some more light.\n\nBTW, it is clarified in a comment in kernel source code (https://elixir.bootlin.com/linux/latest/source/mm/madvise.c#L593) that it immediately releases swap entry. Besides, as the name of the advise suggests, it is intended to free memory. For a page which isn\u0027t in RAM at the time of the call, it doesn\u0027t make sense for the kernel to bring that page back in RAM.\n\nRegarding mincore() not being linux-specific. If there\u0027s a way to test if mincore exist or not, then I\u0027m fine with making this code kernel-generic.",
      "parentUuid": "2ceb4f4c_96534f69",
      "range": {
        "startLine": 519,
        "startChar": 11,
        "endLine": 519,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "14a72505_eaad9dee",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 519,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-04-18T00:18:19Z",
      "side": 1,
      "message": "I\u0027m fine with only using it on Linux. I don\u0027t think performance elsewhere matters much. I would just change the comment to \"Use mincore() only on Linux.\"\n\nI\u0027m hesitant to rely on a kernel code comment for correctness. Somebody may decide to implement this differently next week. I\u0027m also worried about something getting paged in during this as a result of misspeculation of some sort. That may be impossible, but that claim seems to rely on all kinds of subtle hardware, OS, compiler, and runtime properties. Can prefetches ever cause page faults?\n\nWhat does MADV_DONT_NEED do for pages that are not \"in core\"? Is it cheap? Can we just use MADV_DONT_NEED for such pages?",
      "parentUuid": "9352117c_deeffc5d",
      "range": {
        "startLine": 519,
        "startChar": 11,
        "endLine": 519,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "21364080_c2959937",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 519,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-04-19T04:38:48Z",
      "side": 1,
      "message": "I\u0027m not sure if h/w prefetch can cause page fault. Good question! I guess it can. Even if it does, in our case it is guaranteed that the pages in these regions aren\u0027t touched by anyone from this point on.\n\nMADV_DONTNEED \u0027zaps\u0027 all pages in the given range. It is comparatively expensive as it\u0027s blocking. Furthermore, intermixing MADV_FREE and MADV_DONTNEED will make it even more expensive due to invocation of additional syscalls.\n\nHow about this: I\u0027ll perform another mincore after madvise(MADV_FREE). If it shows that any new pages have been brought in core (which were not in core as per first mincore), then will call madvise(MADV_FREE) (after marking them) on them. Any pages that are not in core as per both calls to mincore is guaranteed to be taken care by the first madvise(MADV_FREE).",
      "parentUuid": "14a72505_eaad9dee",
      "range": {
        "startLine": 519,
        "startChar": 11,
        "endLine": 519,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "00193ea6_e6c6ebb7",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 519,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-04-21T01:12:31Z",
      "side": 1,
      "message": "We know that MADV_DONTNEED is slow even for pages that are already paged out? Logically it seems that MADV_FREE and MADV_DONT_NEED should do roughly the same thing in this case, namely discard the page and map it to be zero-filled on access? Or the issue is that MADV_FREE still does this in the background?\n\nDo we ever page out dirty Java heap pages, e.g. to compressed RAM? If not, I guess we should be fine.\n\nIs there a way to test for the kernel property? Is there a way to dirty a page and then force it to be paged out? That, together with the second mincore() call, would give me sufficient confidence, I think. Do you understand empirically which pages are paged out? Just the ones we didn\u0027t actually touch?",
      "parentUuid": "21364080_c2959937",
      "range": {
        "startLine": 519,
        "startChar": 11,
        "endLine": 519,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ca9636ce_8edbe642",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 519,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-04-25T01:00:05Z",
      "side": 1,
      "message": "As per our discussion, I tried the change wherein we simply madv_free the entire range that we want to reclaim, and then memset the entire TLAB, unconditionally. But this seems to be expensive than the current patch-set on this CL. Some of the number are as follows:\n\nMicroAllocBaseline        : 9        8\nMicroAllocOneFinal        : 10       8\nMicroAllocTwoFinal        : 11       8\nMicroAllocThreeFinal      : 13       10\nMicroAllocThreeFinalTwice : 26       20\nMicroAllocThreeFinalThrice: 38       30\nBinaryTrees               : 84       73\n\nThe numbers are in nanoseconds. The first column is for the simple change that we discussed, and the second column is the latest patch-set. Needless to say that without this CL, i.e. with madv_dontneed the numbers are far more worse. So clearly.",
      "parentUuid": "00193ea6_e6c6ebb7",
      "range": {
        "startLine": 519,
        "startChar": 11,
        "endLine": 519,
        "endChar": 36
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2300eb0_239452e7",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 689,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-04-17T00:18:53Z",
      "side": 1,
      "message": "Should this just be a comment? Is this actually informative if it\u0027s repeated many times on the log?",
      "range": {
        "startLine": 689,
        "startChar": 2,
        "endLine": 689,
        "endChar": 60
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "064dc6ac_b8363127",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 689,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2020-04-17T02:01:10Z",
      "side": 1,
      "message": "I took the idea from the definition of MemMap::MadviseDontNeedAndZero(), which handles it this way.\n\nShould I just return for Windows without any comment?",
      "parentUuid": "c2300eb0_239452e7",
      "range": {
        "startLine": 689,
        "startChar": 2,
        "endLine": 689,
        "endChar": 60
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "031e9f3a_0291c2e5",
        "filename": "runtime/gc/space/region_space.cc",
        "patchSetId": 14
      },
      "lineNbr": 689,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-04-18T00:18:19Z",
      "side": 1,
      "message": "I would do that, i.e. change this to\n\n// PurgePages does not madvise on Windows.\n\nI don\u0027t think the log entry is actionable. And it will be repetitive.",
      "parentUuid": "064dc6ac_b8363127",
      "range": {
        "startLine": 689,
        "startChar": 2,
        "endLine": 689,
        "endChar": 60
      },
      "revId": "4a5eba815c4bd7d8995450d915ec15474fd6585d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}