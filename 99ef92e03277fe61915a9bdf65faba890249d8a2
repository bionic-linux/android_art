{
  "comments": [
    {
      "key": {
        "uuid": "64d659dd_17c2bc3b",
        "filename": "compiler/driver/compiler_driver.cc",
        "patchSetId": 2
      },
      "lineNbr": 1896,
      "author": {
        "id": 1000428
      },
      "writtenOn": "2014-06-18T01:07:48Z",
      "side": 1,
      "message": "How do we know at compile time whether a method needs native bridge? The information is not available from the DEX file and can only be known when one tries to load a native library at runtime. From the DEX file, we know a method is native but don\u0027t know it uses a foreign ISA.",
      "range": {
        "startLine": 1896,
        "startChar": 9,
        "endLine": 1896,
        "endChar": 41
      },
      "revId": "99ef92e03277fe61915a9bdf65faba890249d8a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "64d659dd_578844a3",
        "filename": "compiler/driver/compiler_driver.cc",
        "patchSetId": 2
      },
      "lineNbr": 1896,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-06-18T01:38:21Z",
      "side": 1,
      "message": "Good question and something to think about. What should happen now (but I think is not completely implemented), is that the compiled code is thrown away (the entrypoint can be overwritten). In the end, the previous PS was doing a similar thing by hijacking the jni entrypoint.\n\nBTW, I am not sure how your implementation would work with the JNI compiler, either. I did not see any code that changed the signature of a call from the quick method to the native bridge one. Your system kind of worked because of the x86 calling convention placing everything on the stack, but for x86-64 this would have never worked.",
      "parentUuid": "64d659dd_17c2bc3b",
      "range": {
        "startLine": 1896,
        "startChar": 9,
        "endLine": 1896,
        "endChar": 41
      },
      "revId": "99ef92e03277fe61915a9bdf65faba890249d8a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4466b513_e1dadca5",
        "filename": "compiler/driver/compiler_driver.cc",
        "patchSetId": 2
      },
      "lineNbr": 1896,
      "author": {
        "id": 1000428
      },
      "writtenOn": "2014-06-18T19:27:43Z",
      "side": 1,
      "message": "In PS1, all method invocations to foreign JNI methods go through a native bridge wrapper set in entry_point_from_jni_ in ArtMethod. The original fnptr to the foreign JNI method is stored in the newly added field entry_point_from_native_bridge_ in ArtMethod. The native bridge wrapper function is set in RegisterNativeMethods at runtime. See line 2511 of jni_internal.cc in PS1.\n\nThe native bridge wrapper function will interpret the calling convention properly based on the native function shorty and the ISA (x86 vs. x86-64.) It encapsulates the handling of calling convention differences inside the wrapper so it is transparent to ART.\n\nHaving all native bridge JNI calls go thru generic JNI gives up the benefit of optimized code sequence from JNI compiler. It will be better to be able to leverage the JNI compiler for native bridge JNI calls as well.",
      "parentUuid": "64d659dd_578844a3",
      "range": {
        "startLine": 1896,
        "startChar": 9,
        "endLine": 1896,
        "endChar": 41
      },
      "revId": "99ef92e03277fe61915a9bdf65faba890249d8a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4cbf13b_d11204e7",
        "filename": "compiler/driver/compiler_driver.cc",
        "patchSetId": 2
      },
      "lineNbr": 1896,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-06-18T21:36:49Z",
      "side": 1,
      "message": "But your strategy *only* works on x86. On other architectures you do not have the leisure of having all arguments on the stack so that you can easily retrieve the args array. You cannot call an arbitrary native function from a JNI call - the signature has to match.\n\nSo the proper approach for you would have been to override the signature of the Java method. But then you cannot use the JNI compiler, either, because it won\u0027t give you the right things.\n\nDo you see the issue?",
      "parentUuid": "4466b513_e1dadca5",
      "range": {
        "startLine": 1896,
        "startChar": 9,
        "endLine": 1896,
        "endChar": 41
      },
      "revId": "99ef92e03277fe61915a9bdf65faba890249d8a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04975d03_d8d23504",
        "filename": "runtime/mirror/art_method.h",
        "patchSetId": 2
      },
      "lineNbr": 138,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-06-18T01:38:21Z",
      "side": 1,
      "message": "Here is where we should throw away the existing entrypoint, and unconditionally set the generic JNI entrypoint.",
      "range": {
        "startLine": 138,
        "startChar": 4,
        "endLine": 138,
        "endChar": 91
      },
      "revId": "99ef92e03277fe61915a9bdf65faba890249d8a2",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}