{
  "comments": [
    {
      "key": {
        "uuid": "ee86cdd4_991586d4",
        "filename": "runtime/jni_env_ext.cc",
        "patchSetId": 2
      },
      "lineNbr": 123,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-09-29T05:05:54Z",
      "side": 1,
      "message": "Note: I don\u0027t think this actually happens, as the JNI transition frame is a quick frame (even the Generic JNI one looks like one). But just for completeness it\u0027s better to have something here.",
      "range": {
        "startLine": 121,
        "startChar": 4,
        "endLine": 123,
        "endChar": 78
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ae5bf53d_ce9b412f",
        "filename": "runtime/jni_env_ext.cc",
        "patchSetId": 2
      },
      "lineNbr": 137,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-09-29T05:05:54Z",
      "side": 1,
      "message": "Yuck, cruft, will remove tomorrow. Wonder why it didn\u0027t warn me...",
      "range": {
        "startLine": 137,
        "startChar": 2,
        "endLine": 137,
        "endChar": 24
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4ec27958_773baa60",
        "filename": "runtime/jni_env_ext.cc",
        "patchSetId": 2
      },
      "lineNbr": 146,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-09-29T12:13:15Z",
      "side": 1,
      "message": "typo",
      "range": {
        "startLine": 146,
        "startChar": 30,
        "endLine": 146,
        "endChar": 36
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2e2e2591_998116ca",
        "filename": "runtime/jni_env_ext.cc",
        "patchSetId": 2
      },
      "lineNbr": 166,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-09-29T05:05:54Z",
      "side": 1,
      "message": "It\u0027s obviously not a great implementation, but then this is on abort, so I felt this was nicely declarative...",
      "range": {
        "startLine": 164,
        "startChar": 4,
        "endLine": 166,
        "endChar": 66
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6ec3bd5a_d85031f6",
        "filename": "runtime/jni_env_ext.cc",
        "patchSetId": 2
      },
      "lineNbr": 166,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-09-29T12:13:15Z",
      "side": 1,
      "message": "You essentially want\n\n  auto kept_end \u003d std::remove_if(locked_objects-\u003ebegin(),\n                                 locked_objects-\u003eend(),\n                                 [self](const std::pair\u003cuintptr_t, jobject\u003e\u0026 pair) {\n    if (frame \u003d\u003d pair.first) {\n      mirror::Object* o \u003d self-\u003eDecodeJObject(jobj);\n      monitors-\u003eRemove(o);\n      return true;\n    }\n    return false;\n  });\n  locked_objects-\u003eerase(kept_end, locked_objects-\u003eend());\n\nHowever, I\u0027d still prefer the remove_if() loop written explicitly to avoid the lambda.",
      "parentUuid": "2e2e2591_998116ca",
      "range": {
        "startLine": 164,
        "startChar": 4,
        "endLine": 166,
        "endChar": 66
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2e2e2591_19a64629",
        "filename": "runtime/jni_env_ext.cc",
        "patchSetId": 2
      },
      "lineNbr": 166,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-09-29T16:08:00Z",
      "side": 1,
      "message": "Sorry, do I understand you correctly and you really want me to implement remove_if? I disagree with that. Either we should accept the lambda, or we should have a simple implementation. Something that is juggling elements around explicitly (and still needs the erase call to cut off the unused end) is IMHO neither simple nor elegant.",
      "parentUuid": "6ec3bd5a_d85031f6",
      "range": {
        "startLine": 164,
        "startChar": 4,
        "endLine": 166,
        "endChar": 66
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eececd75_44b7e055",
        "filename": "runtime/jni_env_ext.h",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-29T08:32:56Z",
      "side": 1,
      "message": "Won\u0027t it simplify a lot of things if this was thread specific and created at JNI entry? The need to have a uintptr_t from the frame (?) also doesn\u0027t seem right when you know that the calls are scoped.",
      "range": {
        "startLine": 118,
        "startChar": 0,
        "endLine": 118,
        "endChar": 61
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2e2e2591_39b1025f",
        "filename": "runtime/jni_env_ext.h",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-09-29T16:08:00Z",
      "side": 1,
      "message": "This *is* thread-specific, as JNIEnv is. That\u0027s why there\u0027s no lock around this.\n\nMathieu and I derived this encoding to minimize the overhead in non-CheckJNI situations. The only thing you always pay is the CheckJNI-check on exit of a JNI function. And even if CheckJNI is on, only MonitorEnter and Exit operations pay any price. Any stack of vectors to scope things requires entry instrumentation that we wanted to avoid (as bdc really only wanted CheckJNI impacted).",
      "parentUuid": "eececd75_44b7e055",
      "range": {
        "startLine": 118,
        "startChar": 0,
        "endLine": 118,
        "endChar": 61
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e9a4178_3bb20b1e",
        "filename": "runtime/jni_env_ext.h",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-09-29T16:19:20Z",
      "side": 1,
      "message": "Oh, didn\u0027t nee the vector wasn\u0027t locked. My question then is around the \"sessions\" you talk about in the implementation. Why do you need them when calls are scoped? Is that the stack of vectors you wanted to avoid? But if no check-jni, that stack of vector will always be empty.",
      "parentUuid": "2e2e2591_39b1025f",
      "range": {
        "startLine": 118,
        "startChar": 0,
        "endLine": 118,
        "endChar": 61
      },
      "revId": "be20ca0db2aff7c4b076ded6ab3ae5257758d577",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}