{
  "comments": [
    {
      "key": {
        "uuid": "be42e54e_2f9379a9",
        "filename": "compiler/optimizing/inliner.cc",
        "patchSetId": 4
      },
      "lineNbr": 887,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-03-08T11:10:35Z",
      "side": 1,
      "message": "How about:\n\n\"On the other hand, CHA can request inlining of a default non-copied method. If we want to turn the invokeinterface to an invokevirtual, we would need to look up the copied method representing the default method in the receiver\u0027s inferred type\".\n\nShould the second sentence be a TODO? With an extended comment that says the receiver may be of an interface type, and for such case we cannot turn the invokeinterface into an invokevirtual?",
      "range": {
        "startLine": 887,
        "startChar": 0,
        "endLine": 887,
        "endChar": 81
      },
      "revId": "8f301e26943c53485abc2da5ff1907f7c2e0ff0c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "446145ec_33f868ed",
        "filename": "compiler/optimizing/inliner.cc",
        "patchSetId": 4
      },
      "lineNbr": 887,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2017-03-08T22:39:09Z",
      "side": 1,
      "message": "Unfortunately “look up the copied method ...\" doesn\u0027t work since that same default interface method can be copied into multiple classes and have different vtable index. There is also no \"receiver\u0027s inferred type\" since there can be multiple receiver types and it\u0027s just that none of them re-implement the default interface method.\n\nActually it seems to me the right thing to do here is to change invoke-interface into invoke-direct instead of invoke-virtual. We already have the ArtMethod* as a compile time constant, why jump through hoops to change it into an invoke-virtual to look up the same method from vtable? However the work is beyond this revert. We can also do the same thing to invoke-virtual by changing it into an invoke-direct.",
      "parentUuid": "be42e54e_2f9379a9",
      "range": {
        "startLine": 887,
        "startChar": 0,
        "endLine": 887,
        "endChar": 81
      },
      "revId": "8f301e26943c53485abc2da5ff1907f7c2e0ff0c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b1105d2c_05739bf7",
        "filename": "compiler/optimizing/inliner.cc",
        "patchSetId": 4
      },
      "lineNbr": 887,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-03-08T22:48:53Z",
      "side": 1,
      "message": "\u003e Unfortunately “look up the copied method ...\" doesn\u0027t work since\n \u003e that same default interface method can be copied into multiple\n \u003e classes and have different vtable index. There is also no\n \u003e \"receiver\u0027s inferred type\" since there can be multiple receiver\n \u003e types and it\u0027s just that none of them re-implement the default\n \u003e interface method.\n\nWe actually have information on the receiver, thanks to rtp. So if it\u0027s a non-interface type, we could look up the copied method and get its vtable offset.\n\n \u003e \n \u003e Actually it seems to me the right thing to do here is to change\n \u003e invoke-interface into invoke-direct instead of invoke-virtual. We\n \u003e already have the ArtMethod* as a compile time constant, why jump\n \u003e through hoops to change it into an invoke-virtual to look up the\n \u003e same method from vtable? However the work is beyond this revert. We\n \u003e can also do the same thing to invoke-virtual by changing it into an\n \u003e invoke-direct.\n\nRight, see TODO line 880.",
      "parentUuid": "446145ec_33f868ed",
      "range": {
        "startLine": 887,
        "startChar": 0,
        "endLine": 887,
        "endChar": 81
      },
      "revId": "8f301e26943c53485abc2da5ff1907f7c2e0ff0c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2ff34d24_85e7e381",
        "filename": "compiler/optimizing/inliner.cc",
        "patchSetId": 4
      },
      "lineNbr": 887,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2017-03-08T23:12:14Z",
      "side": 1,
      "message": "We know types with rtp/inline-cache. For CHA, there is no type. We devirtualize it only based on observation that the default interface method isn\u0027t re-implemented. So it can be on multiple of classes which can have the copied default method at different vtable index.",
      "parentUuid": "b1105d2c_05739bf7",
      "range": {
        "startLine": 887,
        "startChar": 0,
        "endLine": 887,
        "endChar": 81
      },
      "revId": "8f301e26943c53485abc2da5ff1907f7c2e0ff0c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ab9042e7_d05bb00b",
        "filename": "compiler/optimizing/inliner.cc",
        "patchSetId": 4
      },
      "lineNbr": 887,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-03-09T09:40:30Z",
      "side": 1,
      "message": "I understand that. The message I\u0027m failing to get across is that invoke_instruction-\u003eInputAt(0) has a type inferred by the compiler which you could use to lookup the copied method. Obviously if the inferred type is an interface type, you can\u0027t do anything, but if it\u0027s a non-abstract class, then you can lookup the copied method.",
      "parentUuid": "2ff34d24_85e7e381",
      "range": {
        "startLine": 887,
        "startChar": 0,
        "endLine": 887,
        "endChar": 81
      },
      "revId": "8f301e26943c53485abc2da5ff1907f7c2e0ff0c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "34c6ce2c_c4e089cc",
        "filename": "compiler/optimizing/inliner.cc",
        "patchSetId": 4
      },
      "lineNbr": 887,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2017-03-09T18:53:31Z",
      "side": 1,
      "message": "At this point, method is already a devirtualized method from exact type info of rtp (done in FindVirtualOrInterfaceTarget), inline cache, or CHA. So rtp has been attempted. We don\u0027t need to retry it here.",
      "parentUuid": "ab9042e7_d05bb00b",
      "range": {
        "startLine": 887,
        "startChar": 0,
        "endLine": 887,
        "endChar": 81
      },
      "revId": "8f301e26943c53485abc2da5ff1907f7c2e0ff0c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b8c93b1e_8d0addea",
        "filename": "compiler/optimizing/inliner.cc",
        "patchSetId": 4
      },
      "lineNbr": 887,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2017-03-09T21:39:29Z",
      "side": 1,
      "message": "Ah right, I forgot FindVirtualOrInterfaceTarget was called just before the TryCHAInline.",
      "parentUuid": "34c6ce2c_c4e089cc",
      "range": {
        "startLine": 887,
        "startChar": 0,
        "endLine": 887,
        "endChar": 81
      },
      "revId": "8f301e26943c53485abc2da5ff1907f7c2e0ff0c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}