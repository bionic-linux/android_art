{
  "comments": [
    {
      "key": {
        "uuid": "2358b7c1_c3583bf5",
        "filename": "dex2oat/driver/compiler_driver.cc",
        "patchSetId": 1
      },
      "lineNbr": 2271,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-06-07T08:58:05Z",
      "side": 1,
      "message": "Is that a no-op? Also, it seems line 2485 will cover the transition to visibly initialized.",
      "range": {
        "startLine": 2268,
        "startChar": 0,
        "endLine": 2271,
        "endChar": 5
      },
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d2943148_ec8c6147",
        "filename": "dex2oat/driver/compiler_driver.cc",
        "patchSetId": 1
      },
      "lineNbr": 2271,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-07-02T13:10:05Z",
      "side": 1,
      "message": "This code runs after each individual class initialization. The line 2485 runs only after we\u0027re done initializing classes and it does not call RecordClassStatus().",
      "parentUuid": "2358b7c1_c3583bf5",
      "range": {
        "startLine": 2268,
        "startChar": 0,
        "endLine": 2271,
        "endChar": 5
      },
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f105cb3_698a80f9",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 239,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-06-07T08:58:05Z",
      "side": 1,
      "message": "nit: I\u0027d put high level comment on this class, especially it looks like it applies to both AOT and runtime setups?",
      "range": {
        "startLine": 239,
        "startChar": 0,
        "endLine": 239,
        "endChar": 51
      },
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8615446_8cfeb38d",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 239,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-07-02T13:10:05Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3f105cb3_698a80f9",
      "range": {
        "startLine": 239,
        "startChar": 0,
        "endLine": 239,
        "endChar": 51
      },
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dfb56b6f_e12c042f",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 4402,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-06-07T08:58:05Z",
      "side": 1,
      "message": "I guess this depends on whether array classes carry static state? Which the answer is no?",
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5bc577af_524048a3",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 4402,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-07-02T13:10:05Z",
      "side": 1,
      "message": "I agree but I\u0027d like to know what Hans thinks before I try to finalize an appropriate comment.\n\nIs it OK to fill the Class members, store the status (release operation) and then store the Class* in a memory location that other threads will see? Do we subtly rely on all supported architectures having implicit consume semantics when they read the Class*? Is the implicit consume enough?",
      "parentUuid": "dfb56b6f_e12c042f",
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93e871b3_b0293d93",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 4402,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-07-08T10:18:26Z",
      "side": 1,
      "message": "I may be missing something here, but:\n\nEvery object, including array class objects, needs some kind of fencing at the end of construction to ensure that the fields are visible to any readers of a pointer to that object. We need that for both mutator reads and GC reads. We could possibly do that with release stores of the pointer. That seems tricky if multiple copies can be stored. Do we try that here? Otherwise it seems to me that we need a constructor fence at the end of the class object construction, like we do for other objects. I don\u0027t see that here?\n\nI suspect the release status store doesn\u0027t help, for two reasons:\n\n1. I don\u0027t think all readers read it before accessing the other data?\n\n2. It seems to be getting set before some new_class fields are set?\n\nWe do in general rely on the implied consume ordering, both when pointer-chasing in mutator threads and when tracing in the GC. That\u0027s OK for code we generate. It\u0027s theoretically dubious for C++ runtime code, and I wish we had an alternative. But I don\u0027t think we do (short of generating acquire loads everywhere). I think pretty much all implementations of Java-like languages do this in some way. I can\u0027t think of realistic cases in which it would actually fail in our context, for simple field dereferences. The Linux kernel makes similar, and I think riskier, assumptions all over the place.",
      "parentUuid": "5bc577af_524048a3",
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4df0583f_a09d345c",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 1
      },
      "lineNbr": 5161,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-06-07T08:58:05Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 5161,
        "startChar": 0,
        "endLine": 5161,
        "endChar": 65
      },
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e88f410_74fb5701",
        "filename": "runtime/thread.h",
        "patchSetId": 1
      },
      "lineNbr": 1601,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-06-07T08:58:05Z",
      "side": 1,
      "message": "Nit: add a comment that we need this counter, as the list of classes may be just 1, and we can still hit the kMakeVisiblyInitializedCounterTriggerCount if the thread is looping over the same clinit check.",
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22843713_4d5b6420",
        "filename": "runtime/thread.h",
        "patchSetId": 1
      },
      "lineNbr": 1601,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-06-10T14:50:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0e88f410_74fb5701",
      "revId": "dd2d31977387a644a443c753de4779d1f2d7ece8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}