{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "441e0e43_aec584fb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2023-07-18T13:20:17Z",
      "side": 1,
      "message": "Thank you for the quick fix!",
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91de4b1e_a9d279fb",
        "filename": "runtime/gc/verification.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2023-07-18T14:34:42Z",
      "side": 1,
      "message": "Very interesting trick ðŸ˜Š\n\nUnfortunately, it has the same problem that SafeCopy would have with userfaultfd. Since `write` would read from the `addr` within the kernel, it could potentially result in userfaults in the kernel space, which isn\u0027t allowed.\n\nI think it would be best to use a function parameter (default to do safe access), allowing direct (unsafe) access, if necessary (like with userfaultfd registered memory ranges).",
      "range": {
        "startLine": 43,
        "startChar": 8,
        "endLine": 43,
        "endChar": 13
      },
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "639ff999_c242db69",
        "filename": "runtime/gc/verification.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2023-07-18T14:36:53Z",
      "side": 1,
      "message": "Are you sure it traps? It looks like the kernel looks at the protection before reading the buffer, so we should be good?",
      "parentUuid": "91de4b1e_a9d279fb",
      "range": {
        "startLine": 43,
        "startChar": 8,
        "endLine": 43,
        "endChar": 13
      },
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f135f0a8_c7d21f11",
        "filename": "runtime/gc/verification.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2023-07-18T14:44:07Z",
      "side": 1,
      "message": "Protection isn\u0027t an issue. Userfaultfd kicks in when the page is `missing` and the range is userfaultfd registered. In such a case, the kernel will end up causing userfault in kernel space, which is not allowed.",
      "parentUuid": "639ff999_c242db69",
      "range": {
        "startLine": 43,
        "startChar": 8,
        "endLine": 43,
        "endChar": 13
      },
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "933b4483_00f97e82",
        "filename": "runtime/gc/verification.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2023-07-18T14:49:28Z",
      "side": 1,
      "message": "How not allowed? This could as well be code in some native library looking at arbitrary data. If by not allowed, it means we crash, then this is no different than reading directly?",
      "parentUuid": "f135f0a8_c7d21f11",
      "range": {
        "startLine": 43,
        "startChar": 8,
        "endLine": 43,
        "endChar": 13
      },
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de68f0b0_a5d58e95",
        "filename": "runtime/gc/verification.cc",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2023-07-18T14:57:08Z",
      "side": 1,
      "message": "Not allowed means process crash. If some native library arbitrarily gives our heap\u0027s location to some system call and it ends up triggering userfault (because, say, we were in the middle of doing a GC and hence the accessed page was missing), then it will result in process crash. OTOH, if the library directly accesses it in userspace, then it\u0027s not a problem.\n\nIt\u0027s different from reading directly because if you do a userspace access on a userfaultfd protected missing page, it will be resolved and then access will be allowed.\n\nKernel doesn\u0027t allow userfaults being generated in kernel space for unprivileged processes and in Android all zygote forked processes are unprivileged.",
      "parentUuid": "933b4483_00f97e82",
      "range": {
        "startLine": 43,
        "startChar": 8,
        "endLine": 43,
        "endChar": 13
      },
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fc03035_3faec3cd",
        "filename": "runtime/gc/verification.cc",
        "patchSetId": 3
      },
      "lineNbr": 48,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2023-07-18T13:20:17Z",
      "side": 1,
      "message": "You can use `android::base::Pipe`, which creates `unique_fd` objects that are automatically closed.",
      "range": {
        "startLine": 47,
        "startChar": 4,
        "endLine": 48,
        "endChar": 22
      },
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ccb892f4_0511e50c",
        "filename": "runtime/gc/verification.cc",
        "patchSetId": 3
      },
      "lineNbr": 48,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2023-07-18T14:36:53Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2fc03035_3faec3cd",
      "range": {
        "startLine": 47,
        "startChar": 4,
        "endLine": 48,
        "endChar": 22
      },
      "revId": "79821565238cd81ef99cf462d8083530ecafff1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}