{
  "comments": [
    {
      "key": {
        "uuid": "48631fc4_860fb445",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 220,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2013-12-20T23:52:12Z",
      "side": 1,
      "message": "Add some bitmap scanning logic in here? The logic should be as follows: For each immune space: If have a mod union table, use that, or else assert that the bitmaps are bound and scan the live bitmap of said space. If the immune space is a bump pointer space, I guess we can do space-\u003eWalk?",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d2b69c2_5d57db90",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 220,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-01-08T02:00:38Z",
      "side": 1,
      "message": "Do you mean moving the live bitmap scanning code from below MarkReachableObjects() (lines 261-274) up here and combine it with the mod union table scan of the other immune spaces here?\n\nAs we\u0027d need to scan the objects on the live (allocation) stack as well, the current code scans the live bitmap after the objects on the live stack are marked in the live bitmap (the MarkAllocStackAslive() call in MarkReachableObjects().)\n\nI added another loop over the continuous space list and scan the live bitmap in MarkReachableObjects() to handle this.",
      "parentUuid": "48631fc4_860fb445",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6da395b3_d3fba65a",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 220,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-01-08T19:04:30Z",
      "side": 1,
      "message": "Forgot about the allocation stack, the current approach should be fine then.",
      "parentUuid": "8d2b69c2_5d57db90",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e871338d_684a6b41",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 265,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2013-12-20T23:52:12Z",
      "side": 1,
      "message": "This won\u0027t be correct after the background compaction CL since the non_moving_space and main alloc space are different.",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d25f1ed_bb753f5d",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 265,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-01-08T02:00:38Z",
      "side": 1,
      "message": "Right. We\u0027d need to scan the live bitmaps of both the main space and the non-moving space (if they are not the same space, for example, pre-zygote fork). I leave a TODO for now (before the background compaction CL is merged.)",
      "parentUuid": "e871338d_684a6b41",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e871338d_c8eb7fd3",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 271,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2013-12-20T23:52:12Z",
      "side": 1,
      "message": "Since classes can move, don\u0027t you need to scan large objects update their classes? Even thought the classes never get collected, they can still move.",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d2b69c2_fdb32f7b",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 271,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-01-08T02:00:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e871338d_c8eb7fd3",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c86e2fb0_42ee6c31",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 311,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2013-12-20T23:52:12Z",
      "side": 1,
      "message": "Might be worth refactoring the sweep logic to ignore immune spaces, this way you don\u0027t need this special logic assuming you immune all of the right spaces.",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d2b69c2_18e1f143",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 311,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-01-08T02:00:38Z",
      "side": 1,
      "message": "Done. I added is_large_object_space_immune_ to indicate whether we are collecting the large object space. When it\u0027s false, we won\u0027t call SweepLargeObjects() from Sweep().",
      "parentUuid": "c86e2fb0_42ee6c31",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e871338d_28db133d",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 430,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2013-12-20T23:52:12Z",
      "side": 1,
      "message": "I think you could bind the bitmaps earlier to avoid needing to mark both the live and mark bitmaps?",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d2b69c2_f86e9dd5",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 430,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-01-08T02:00:38Z",
      "side": 1,
      "message": "Here\u0027s my thinking: Here (in the else block of this if statement), the non-moving space (the destination of the promotion) is not immune (i.e., it\u0027s being collected) and its live/mark bitmaps aren\u0027t bound (or, they don\u0027t point to the same bit map). In addition, the promoted object is sort of a special-case allocation for the non-moving space, that is, it does not go through the allocation stack and is not marked in the live bitmap at this point, but it should be for it to be handled (swept) in future collections. So, I think we can\u0027t avoid marking both bitmaps.",
      "parentUuid": "e871338d_28db133d",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6da395b3_932e7ebf",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 430,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-01-08T19:04:30Z",
      "side": 1,
      "message": "Nevermind, I think you\u0027re right.",
      "parentUuid": "8d2b69c2_f86e9dd5",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c86e2fb0_42158c53",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 667,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2013-12-20T23:52:12Z",
      "side": 1,
      "message": "We probably want to copy somewhere other than the non_moving_space in the future, since these objects will never get copied again.",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d2b69c2_d8c4797c",
        "filename": "runtime/gc/collector/semi_space.cc",
        "patchSetId": 2
      },
      "lineNbr": 667,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-01-08T02:00:38Z",
      "side": 1,
      "message": "Yes, after the background compaction CL, we should copy (promote) to the main free-list space (as the objects in the bump pointer space (the from space) is by definition movable.) I left a TODO in MarkObject().",
      "parentUuid": "c86e2fb0_42158c53",
      "revId": "d748621cd66c6d88afaf498b25ebeab0acaa845c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}