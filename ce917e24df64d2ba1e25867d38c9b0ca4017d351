{
  "comments": [
    {
      "key": {
        "uuid": "24a8e18f_af807938",
        "filename": "runtime/class_linker-inl.h",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-06-23T22:05:20Z",
      "side": 1,
      "message": "This is only called a few places, it might be cleaner to delete it and add a GetDexCache which uses the read barrier and GetDexCacheCount. Also you could replace a lot of the places you modified to use GetDexCache.",
      "revId": "ce917e24df64d2ba1e25867d38c9b0ca4017d351",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44a315b3_f7bfafe6",
        "filename": "runtime/class_linker-inl.h",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-06-24T18:15:34Z",
      "side": 1,
      "message": "I thought of that way, too.\n\nAn issue would be atomicity/race between GetDexCacheCount() and GetDexCache() as they need to acquire dex_lock_. It\u0027d be possible after we call GetDexCacheCount(), the count could be changed by the time we call GetDexCache(). It might be ok if we can assume that dex_caches are never removed from the vector, or ImageWriter (the caller) won\u0027t violate the atomicity, thought that could be fragile.\n\nWe could expose the dex_lock to the caller, but it seems to make this less cleaner than the current way.\n\nAnother way is to return a copy of the vector, which would solve this issue and avoid the need to update the roots (line 225). As long as the number of dex caches is small, it might be ok.\n\nMore thoughts?",
      "parentUuid": "24a8e18f_af807938",
      "revId": "ce917e24df64d2ba1e25867d38c9b0ca4017d351",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4a7a9cf_9d9f634f",
        "filename": "runtime/class_linker-inl.h",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-06-24T18:21:47Z",
      "side": 1,
      "message": "What if you make GetDexCacheCount and GetDexCache require the dex_lock_ does that work?",
      "parentUuid": "44a315b3_f7bfafe6",
      "revId": "ce917e24df64d2ba1e25867d38c9b0ca4017d351",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e4a7a9cf_430a1a88",
        "filename": "runtime/class_linker-inl.h",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2014-06-24T20:38:15Z",
      "side": 1,
      "message": "I tried this. There\u0027s one issue in ImageWriter::CreateImageRoots(). We\u0027d need to allocate an ObjectArray of the exact size GetDexCacheCount(), but we can\u0027t do the allocation while holding dex_lock_, since that allocation could cause a thread suspension. So, we can\u0027t guarantee the atomicity between GetDexCacheCount() and GetDexCache(). The best we can do is to lock dex_lock_ twice, first to get the count, unlock it, allocate the ObjectArray, lock it again, check that the count hasn\u0027t changed, and copy the elements. Not sure if this is good.\n\nBefore:\n\n  Handle\u003cObjectArray\u003cObject\u003e\u003e dex_caches(\n      hs.NewHandle(ObjectArray\u003cObject\u003e::Alloc(self, object_array_class.Get(),\n                                             class_linker-\u003eGetDexCaches().size())));\n  int i \u003d 0;\n  for (DexCache* dex_cache : class_linker-\u003eGetDexCaches()) {\n    dex_caches-\u003eSet\u003cfalse\u003e(i++, dex_cache);\n\n(note the \u0027before\u0027 code wasn\u0027t atomic w.r.t. the dex caches.)\n\nAfter:\n\n  size_t dex_cache_count;\n  {\n    ReaderMutexLock mu(Thread::Current(), *class_linker-\u003eDexLock());\n    dex_cache_count \u003d class_linker-\u003eGetDexCacheCount();\n  }\n  Handle\u003cObjectArray\u003cObject\u003e\u003e dex_caches(\n      hs.NewHandle(ObjectArray\u003cObject\u003e::Alloc(self, object_array_class.Get(),\n                                              dex_cache_count)));\n  CHECK(dex_caches.Get() !\u003d nullptr) \u003c\u003c \"Failed to allocate a dex cache array.\";\n  {\n    ReaderMutexLock mu(Thread::Current(), *class_linker-\u003eDexLock());\n    CHECK_EQ(dex_cache_count, class_linker-\u003eGetDexCacheCount())\n        \u003c\u003c \"The number of dex caches changed.\";\n    for (size_t i \u003d 0; i \u003c dex_cache_count; ++i) {\n      dex_caches-\u003eSet\u003cfalse\u003e(i, class_linker-\u003eGetDexCache(i));\n    }\n  }\n\nCopying the dex caches in a temporary container wouldn\u0027t work as that would hold Object* without being a root.",
      "parentUuid": "e4a7a9cf_9d9f634f",
      "revId": "ce917e24df64d2ba1e25867d38c9b0ca4017d351",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "04abdd9e_720e0055",
        "filename": "runtime/class_linker-inl.h",
        "patchSetId": 1
      },
      "lineNbr": 217,
      "author": {
        "id": 1015378
      },
      "writtenOn": "2014-06-24T20:55:02Z",
      "side": 1,
      "message": "In that case, do whichever way you prefer.",
      "parentUuid": "e4a7a9cf_430a1a88",
      "revId": "ce917e24df64d2ba1e25867d38c9b0ca4017d351",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}