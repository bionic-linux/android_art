{
  "comments": [
    {
      "key": {
        "uuid": "cb69dfa3_0d7bc1ac",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 57,
      "author": {
        "id": 1030338
      },
      "writtenOn": "2015-01-27T16:57:46Z",
      "side": 1,
      "message": "Move this to code_generator_arm64.h?\nWe already define:\n48 const vixl::Register tr \u003d vixl::x18;        // Thread Register \n\nAnd we can make use of this in code_generator_arm64.cc too.\n\nSorry for this I have missed it in my previous comments. I can include this as part of one of my patches.",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "abd02b89_319bb280",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 82,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "Is it not safe to ignore\n  mov w0, w0\n?\nIf it is safe, we need to add `kDiscardForSameWReg` as the last parameter of the move.\n\nNote that executing the \u0027mov w0, w0\u0027 instruction has the side effect of clearing the top 32 bits of x0. I think it should be safe.",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bab5bf1_157db69c",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 100,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "Just a note: at some point we will want to optimise this to use LDP and STP (load pair and store pair).",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d7e7c792_97dd761f",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 100,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-01-27T16:11:10Z",
      "side": 1,
      "message": "That should be transparent and in the move resolver, not here, though.",
      "parentUuid": "2bab5bf1_157db69c",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "abd02b89_11014e78",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 100,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-01-27T16:49:11Z",
      "side": 1,
      "message": "Agreed with Andreas.",
      "parentUuid": "d7e7c792_97dd761f",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "578037c4_f6a140bd",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 100,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-28T10:47:13Z",
      "side": 1,
      "message": "And I agree also! The idea has always been to improve the code generated by the resolver without requiring any changes to the user.",
      "parentUuid": "abd02b89_11014e78",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb69dfa3_c2819865",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 230,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "Here and in other places: what about `kNoOutputOverlap`?",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d7e7c792_b7407a23",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 230,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-01-27T16:11:10Z",
      "side": 1,
      "message": "Once somebody can tell me what that would actually change, maybe. Right now I don\u0027t see any use, and can\u0027t really say whether I want to force it.",
      "parentUuid": "cb69dfa3_c2819865",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bab5bf1_757a3a26",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 230,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2015-01-27T16:49:11Z",
      "side": 1,
      "message": "Yeah, I\u0027m currently implementing it. It currently has no effect on the register allocator. Once it does, it means the output can share the same register with an input.",
      "parentUuid": "d7e7c792_b7407a23",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bab5bf1_f54e2a89",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 241,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "Was that a comment for x86? If so remove.",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bab5bf1_d5532e2f",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 280,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "Here and in other places: why \u0027size\u0027 and not \u0027type\u0027?",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bab5bf1_35b27208",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 315,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "I\u0027m fine if it stays like this, but as a note, in VIXL we generally shorten MacroAssembler to masm. Assembler refers to a parent class of the MacroAssembler. The Assembler can only generate \u0027real\u0027 instructions, while the MacroAssembler takes care of a lot of things for the user (eg. constants that don\u0027t fit in immediate fields, or optimising away mov x1, x1).",
      "range": {
        "startLine": 315,
        "startChar": 86,
        "endLine": 315,
        "endChar": 95
      },
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb69dfa3_623d2cfb",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 884,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "This function generates code for a compare exchange, isn\u0027t it?\nCan we use LDXR and STXR in the loop, and have a DMB before loop_head and after exit_loop?",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7ec137b_1644ca88",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 884,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-01-27T16:11:10Z",
      "side": 1,
      "message": "That\u0027s counter to what happened in Quick. There we started with the purely exclusive loads, but went to acquire-release. Note that a certain S. Constantinescu was the one to suggest and implement that...",
      "parentUuid": "cb69dfa3_623d2cfb",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "abd02b89_51710677",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 884,
      "author": {
        "id": 1030338
      },
      "writtenOn": "2015-01-27T16:57:46Z",
      "side": 1,
      "message": "This is what Quick does now. Since I expect the default case to be one where the exclusive store succeeds (no retry) - this variant should, at least in theory, be faster.\n\nWe can however have a !kUseAcquireRelease variant that is implemented as you suggested.",
      "parentUuid": "cb69dfa3_623d2cfb",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "abd02b89_d1d0568e",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 884,
      "author": {
        "id": 1030338
      },
      "writtenOn": "2015-01-27T17:03:06Z",
      "side": 1,
      "message": "For now it is fine like this. Please note that for the Optimizing compiler we prefer Load-Acquire Store-Release over the DMB variants, wherever the two can be replaced.\n\nFor Nicolas, Andreas - we expect newer CPUs to have a faster implementation for this semantic.",
      "parentUuid": "abd02b89_51710677",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f79dab26_1bfe5b74",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 884,
      "author": {
        "id": 1065463
      },
      "writtenOn": "2015-01-28T11:15:02Z",
      "side": 1,
      "message": "You\u0027re missing a subtlety here in that DMB; LDXR; ...; STXR; DMB has stronger ordering guarantees than the corresponding LDAXR; ...; STLXR sequence.\n\nFor example, if A() and B() consist of standard LDR/STR instructions then:\n\nA()\nDMB\nLDXR\n...\nSTXR\nDMB\nB()\n\nRequires A() to be globally observed before B(). However:\n\nA()\nLDAXR\n...\nSTLXR\nB()\n\nPermits B() to be observed before A().\n\nSo the question really is: what memory ordering semantics do you require for your cmpxchg? If you define that, then we can come up with an optimal instruction sequence.",
      "parentUuid": "abd02b89_d1d0568e",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "578037c4_96f1ec9f",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 884,
      "author": {
        "id": 1030338
      },
      "writtenOn": "2015-01-28T11:52:53Z",
      "side": 1,
      "message": "A global field must be \"volatile\" in Java (\"Volatile fields are special fields which are used for communicating state between threads.\")\n\nThus every A() and B() will have the Acquire-Release semantics (as implemented in the Optimizing compiler). Therefore in this case both variants are syntactically equivalent and in theory the faster is the one implemented here (due to the stronger semantics ordering for the DMB variant).\n\nWhat I am not sure is if we need to ensure both atomicity and ordering for Unsafe.cmpxchg(). For now we do so we should be safe. Hans probably knows whether we can downgrade this to only ensuring atomicity (no Acquire-Release semantics and no DMBs for ARM). I assume we can\u0027t.",
      "parentUuid": "f79dab26_1bfe5b74",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bab5bf1_f522aa92",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 959,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "Here and below: HeapOperand() ?\nYou could even pass thee offsets without calling the Int32Value() member.",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bab5bf1_153ad6b5",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 979,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-27T15:22:41Z",
      "side": 1,
      "message": "Should there be a \u0027LOG(FATAL)\u0027?",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "57fbd733_c48fd28c",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 979,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-01-27T16:11:10Z",
      "side": 1,
      "message": "No. Otherwise the compiler will abort every time you hit one. Which is pretty much guaranteed.",
      "parentUuid": "2bab5bf1_153ad6b5",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f79dab26_fb460f41",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 12
      },
      "lineNbr": 979,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-01-28T10:47:13Z",
      "side": 1,
      "message": "Ok. I thought they wouldn\u0027t be hit if they weren\u0027t implemented. I need to check how it works :)",
      "parentUuid": "57fbd733_c48fd28c",
      "revId": "f24525e5d9d9dccbec9ead7b0d352f77961b98e0",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}