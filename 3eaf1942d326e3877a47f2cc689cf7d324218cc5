{
  "comments": [
    {
      "key": {
        "uuid": "4144f0e8_00f8a8d9",
        "filename": "compiler/optimizing/code_generator.cc",
        "patchSetId": 2
      },
      "lineNbr": 336,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-12-19T17:29:24Z",
      "side": 1,
      "message": "we could store this in the CodeGenerator base class but until we have a real need in other sub classes I wouldn\u0027t bother.",
      "range": {
        "startLine": 336,
        "startChar": 10,
        "endLine": 336,
        "endChar": 53
      },
      "revId": "3eaf1942d326e3877a47f2cc689cf7d324218cc5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "614734ed_2120488c",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 2
      },
      "lineNbr": 2662,
      "author": {
        "id": 1030338
      },
      "writtenOn": "2014-12-19T18:48:32Z",
      "side": 1,
      "message": "I am not sure about this.\n\nThe Java spec needs both Atomic and Volatile for Loading/Storing volatiles. As I understand this you only issue a DMB if the implementation does not have HasAtomicLdrd...(). Thus, for platforms that do not have the LPAE extensions you do not generate the DMB, therefore you do not ensure memory ordering.",
      "revId": "3eaf1942d326e3877a47f2cc689cf7d324218cc5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a13dac4e_03d510ff",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 2
      },
      "lineNbr": 2662,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-12-19T22:42:22Z",
      "side": 1,
      "message": "oh yes... this is wrong (got carried away with the replacement), thanks!. We should always generate the barrier.",
      "parentUuid": "614734ed_2120488c",
      "revId": "3eaf1942d326e3877a47f2cc689cf7d324218cc5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4144f0e8_6035ecf7",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 2
      },
      "lineNbr": 2692,
      "author": {
        "id": 1030338
      },
      "writtenOn": "2014-12-19T18:48:32Z",
      "side": 1,
      "message": "Only this should depend on HasAtomicLdrdAnd...()",
      "revId": "3eaf1942d326e3877a47f2cc689cf7d324218cc5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a13dac4e_c3de4821",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 2
      },
      "lineNbr": 2692,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2014-12-19T22:42:22Z",
      "side": 1,
      "message": "I assume that you wanted to say this, and the double below?\n\nThis is one question that I forgot to address. When using LPAE, does the atomicity holds for both, ldrd/strd and vldrd/vstrd? I assumed so since this is how it is done in quick.",
      "parentUuid": "4144f0e8_6035ecf7",
      "revId": "3eaf1942d326e3877a47f2cc689cf7d324218cc5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a1b76c4b_d07cdca6",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 2
      },
      "lineNbr": 2692,
      "author": {
        "id": 1030338
      },
      "writtenOn": "2014-12-22T11:03:24Z",
      "side": 1,
      "message": "From ARM ARM - \"LDRD and STRD accesses to 64-bit aligned locations are 64-bit single-copy atomic as seen by translation table walks and accesses to translation tables.\" But no mention of VLDRD and VSTRD being atomic. \n\nThe reason for 64-bit atomic load/stores in LPAE are the page table entries that need to be updated atomicly (using the General Purpose register bank). From this point of view I see no reason  to impose this restriction on the load/stores coming from the Floating Point bank.\n\nIf Quick does it, you can use it as a reference, but I am not sure it is correct in this case. I will raise this question with the architecture team, but I do not expect an answer before the new year. I will update you on this as soon as I have an answer.",
      "parentUuid": "a13dac4e_c3de4821",
      "revId": "3eaf1942d326e3877a47f2cc689cf7d324218cc5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a185ac8b_14302489",
        "filename": "compiler/optimizing/code_generator_arm.cc",
        "patchSetId": 2
      },
      "lineNbr": 2692,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2015-01-05T16:26:56Z",
      "side": 1,
      "message": "Yea, I use Quick as a reference.",
      "parentUuid": "a1b76c4b_d07cdca6",
      "revId": "3eaf1942d326e3877a47f2cc689cf7d324218cc5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}