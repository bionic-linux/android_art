{
  "comments": [
    {
      "key": {
        "uuid": "aa50601d_36a244b1",
        "filename": "dex2oat/dex2oat_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 461,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-15T09:39:16Z",
      "side": 1,
      "message": "Unrelated?",
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ada63c1d_044abf98",
        "filename": "dex2oat/dex2oat_test.cc",
        "patchSetId": 1
      },
      "lineNbr": 461,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-15T17:33:24Z",
      "side": 1,
      "message": "It seems something about this change (probably making Thread* a bit larger) causes this test to fail. The linked bug basically says that nobody knows why it fails on x86 so I just added a skip for the rest too.",
      "parentUuid": "aa50601d_36a244b1",
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b9b755d0_f51894f1",
        "filename": "runtime/instrumentation.cc",
        "patchSetId": 1
      },
      "lineNbr": 406,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-15T09:39:16Z",
      "side": 1,
      "message": "Can you try moving this stack walker in a ScopedSuspendAll block? This will remove the need for the other changes.",
      "range": {
        "startLine": 406,
        "startChar": 0,
        "endLine": 406,
        "endChar": 98
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36d962f8_913def2d",
        "filename": "runtime/instrumentation.cc",
        "patchSetId": 1
      },
      "lineNbr": 406,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-15T17:33:24Z",
      "side": 1,
      "message": "Nope that won\u0027t work. Several of the other stack-walkers are run by suspended threads so the race is still present. Furthermore at least 2 stack-walkers can suspend during the stack walk (they both walk their own stack so this is safe enough assuming WalkStack is thread safe). This could lead to the exact type of interleaving that causes the bug.",
      "parentUuid": "b9b755d0_f51894f1",
      "range": {
        "startLine": 406,
        "startChar": 0,
        "endLine": 406,
        "endChar": 98
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "89550f6d_bce2ec54",
        "filename": "runtime/instrumentation.cc",
        "patchSetId": 1
      },
      "lineNbr": 406,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-01-16T10:21:07Z",
      "side": 1,
      "message": "Is there no other way?\n\nDo those 2 stack-walkers really need to suspend during the stack walk, or could they just collect information during stack walk and do the rest of the work afterwards? (That would be a valuable rewrite on its own.)\n\nCould we have a reader-writer mutex for the instrumentation stack that normal stack walk would acquire as a reader?",
      "parentUuid": "36d962f8_913def2d",
      "range": {
        "startLine": 406,
        "startChar": 0,
        "endLine": 406,
        "endChar": 98
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "295a3d03_f5f6ae4f",
        "filename": "runtime/instrumentation.cc",
        "patchSetId": 1
      },
      "lineNbr": 406,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-16T16:18:18Z",
      "side": 1,
      "message": "+1 to that - If you can find a way that doesn\u0027t require that many changes to the stack walking code (it\u0027s ok to make anything related to instrumentation slow by the way), that would be much better. The stack walking code is already very fragile.",
      "parentUuid": "89550f6d_bce2ec54",
      "range": {
        "startLine": 406,
        "startChar": 0,
        "endLine": 406,
        "endChar": 98
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "391a7a0c_4f9bb7be",
        "filename": "runtime/instrumentation.cc",
        "patchSetId": 1
      },
      "lineNbr": 406,
      "author": {
        "id": 1047769
      },
      "writtenOn": "2020-01-16T17:29:16Z",
      "side": 1,
      "message": "I don\u0027t believe that is really feasible at this time. \n\nThere are ~50 stack-visitors present in ART.\n\n```\n% git grep -E \u0027(public .*StackVisitor|StackVisitor::WalkStack)\u0027 | wc -l\n57\n```\n\nThe two that I found which contain potentially suspending code are the CatchBlockStackVisitor (rand the CollectFramesAndLocksStackVisitor. Neither of these are associated with Instrumentation directly (being part of exception handling and SIGQUIT logging respectively). Both of these are very large and complicated visitors that would be rather complicated to rewrite. Also these are just the 2 that our current tests happened to catch due to AssertThreadSuspensionIsAllowable being called (and yes I checked the assert is legitimate, the first needs to potentially resolve classes and the second needs to inflate locks). I am far from certain that these are the only visitors that do this, they are just the first 2 that I found when looking at test failures on go/aog/1206897. Once I determined that even fixing just those 2 would be a rather large undertaking I switched gears to making WalkStack actually thread-safe like it had been assumed to be.",
      "parentUuid": "295a3d03_f5f6ae4f",
      "range": {
        "startLine": 406,
        "startChar": 0,
        "endLine": 406,
        "endChar": 98
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d0207c8_8051a8de",
        "filename": "runtime/stack.cc",
        "patchSetId": 1
      },
      "lineNbr": 990,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-01-17T05:22:36Z",
      "side": 1,
      "message": "What exactly happens in this case? Presumably the above code read some data that changed in the meantime, and your now going to discard it? So there is still a data race between the two threads? If so, this is problematic, and we should talk.",
      "range": {
        "startLine": 990,
        "startChar": 18,
        "endLine": 990,
        "endChar": 93
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caec9c59_11c22441",
        "filename": "runtime/stack.cc",
        "patchSetId": 1
      },
      "lineNbr": 999,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-01-17T05:22:36Z",
      "side": 1,
      "message": "Is this doing more than asserting that MutexLock works correctly? If not, I\u0027d be strongly inclined to drop it.",
      "range": {
        "startLine": 999,
        "startChar": 16,
        "endLine": 999,
        "endChar": 89
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1033795_2427bb1d",
        "filename": "runtime/stack.h",
        "patchSetId": 1
      },
      "lineNbr": 367,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2020-01-16T16:18:18Z",
      "side": 1,
      "message": "initial",
      "range": {
        "startLine": 367,
        "startChar": 31,
        "endLine": 367,
        "endChar": 38
      },
      "revId": "66c60b2cc1f0a0f3b5b5b53c2c78d1c0a94faa90",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}