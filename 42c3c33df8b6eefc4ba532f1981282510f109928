{
  "comments": [
    {
      "key": {
        "uuid": "93a1f560_c26566c2",
        "filename": "runtime/gc/allocation_record.cc",
        "patchSetId": 3
      },
      "lineNbr": 110,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2015-06-26T23:53:11Z",
      "side": 1,
      "message": "I think there is an invariant that IsMarkedCallback() won\u0027t get nullptr passed to it (see MarkSweep, SemiSpace or ConcurrentCopying) . It seems that this CL breaks that if we ever collect class objects. Before this CL, it was fine as we delete the entry if the object gets collected and the GcRoot becomes nullptr. It isn\u0027t the case any more as we now keep nullptr GcRoots around.\n\nBesides, there\u0027s no point in calling callback if old_object is nullptr (for performance reason).\n\nHow about not calling \u0027callback\u0027 if old_object is null?",
      "range": {
        "startLine": 110,
        "startChar": 40,
        "endLine": 110,
        "endChar": 50
      },
      "revId": "42c3c33df8b6eefc4ba532f1981282510f109928",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "934c958c_fe6ec128",
        "filename": "runtime/gc/allocation_record.cc",
        "patchSetId": 3
      },
      "lineNbr": 110,
      "author": {
        "id": 1073545
      },
      "writtenOn": "2015-06-27T03:08:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "93a1f560_c26566c2",
      "range": {
        "startLine": 110,
        "startChar": 40,
        "endLine": 110,
        "endChar": 50
      },
      "revId": "42c3c33df8b6eefc4ba532f1981282510f109928",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "934c958c_98d9259a",
        "filename": "runtime/gc/allocation_record.cc",
        "patchSetId": 3
      },
      "lineNbr": 132,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2015-06-26T23:53:11Z",
      "side": 1,
      "message": "Same here.\n\nNot sure why it isn\u0027t already causing an error as old_object can actually be nullptr here (as we do collect those objects unlike class objects)?",
      "range": {
        "startLine": 132,
        "startChar": 33,
        "endLine": 132,
        "endChar": 41
      },
      "revId": "42c3c33df8b6eefc4ba532f1981282510f109928",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "138ee5ef_b4a098aa",
        "filename": "runtime/gc/allocation_record.cc",
        "patchSetId": 3
      },
      "lineNbr": 132,
      "author": {
        "id": 1073545
      },
      "writtenOn": "2015-06-27T03:08:47Z",
      "side": 1,
      "message": "Good find! Fixed in CL 156975. Not sure why the DCHECK() for nullptr was not fired, either.",
      "parentUuid": "934c958c_98d9259a",
      "range": {
        "startLine": 132,
        "startChar": 33,
        "endLine": 132,
        "endChar": 41
      },
      "revId": "42c3c33df8b6eefc4ba532f1981282510f109928",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "73a3a180_c3747648",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 3720,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2015-06-27T17:09:40Z",
      "side": 1,
      "message": "Can we see the value of this change in the middle of a GC and end up with mismatched allow/disallow calls? Is it safe?",
      "range": {
        "startLine": 3720,
        "startChar": 6,
        "endLine": 3720,
        "endChar": 28
      },
      "revId": "42c3c33df8b6eefc4ba532f1981282510f109928",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f390710b_0e45b3c6",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 3720,
      "author": {
        "id": 1073545
      },
      "writtenOn": "2015-06-27T22:09:41Z",
      "side": 1,
      "message": "Yes, this value can change in the middle of a GC.\n\nFor a change from Enabled to Disabled, it is safe because disabling tracking deallocates the entries, thus GC won\u0027t need to sweep entries or call AllowNewAllocationRecords().\n\nFor a change from Disabled to Enabled, the result is that AllowNewAllocationRecords() and EnsureNewAllocationRecordsDisallowed() could be called when new allocations should be disallowed but are actually allowed. This might fail the CHECK() in EnsureNewAllocationRecordsDisallowed(). But it is safe for AllowNewAllocationRecords(), which just does a redundant store of \"true\" and a redundant Broadcast().\n\nIt is also possible that new allocation records get added to the list in this period, and they will be deleted on the next sweep. But I think this is OK since it just misses the first few allocation records, which is the same result as the user not clicking the button soon enough.\n\nTherefore I think I can just remove EnsureNewAllocationRecordsDisallowed() to fix this issue.",
      "parentUuid": "73a3a180_c3747648",
      "range": {
        "startLine": 3720,
        "startChar": 6,
        "endLine": 3720,
        "endChar": 28
      },
      "revId": "42c3c33df8b6eefc4ba532f1981282510f109928",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "736d61b3_59466373",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 3720,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2015-07-06T20:52:43Z",
      "side": 1,
      "message": "\u003e It is also possible that new allocation records get added to the list in this period, and they will be deleted on the next sweep. But I think this is OK since it just misses the first few allocation records, which is the same result as the user not clicking the button soon enough.\n\nIs it safe for a new allocation record (a class strong root and a weak object root) to be added while GC is sweeping? How is this different such that the original reason that we needed to disable new allocation records during sweeping does not apply here?",
      "parentUuid": "f390710b_0e45b3c6",
      "range": {
        "startLine": 3720,
        "startChar": 6,
        "endLine": 3720,
        "endChar": 28
      },
      "revId": "42c3c33df8b6eefc4ba532f1981282510f109928",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}