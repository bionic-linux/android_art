{
  "comments": [
    {
      "key": {
        "uuid": "aa747f75_8d7f5c51",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 1
      },
      "lineNbr": 760,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-10-04T16:27:36Z",
      "side": 1,
      "message": "What do you mean? The JitCompileTask should keep the class (and therefore the method) alive.",
      "range": {
        "startLine": 760,
        "startChar": 11,
        "endLine": 760,
        "endChar": 63
      },
      "revId": "f35fe67d4f4fea573078f1090edde4948af57aff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "020ecea5_5e32b4be",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 1
      },
      "lineNbr": 760,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-10-04T16:36:24Z",
      "side": 1,
      "message": "m is in data-\u003eGetMethods() it\u0027s not necessarily the method being compiled.",
      "parentUuid": "aa747f75_8d7f5c51",
      "range": {
        "startLine": 760,
        "startChar": 11,
        "endLine": 760,
        "endChar": 63
      },
      "revId": "f35fe67d4f4fea573078f1090edde4948af57aff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0092f19_099edf61",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 1
      },
      "lineNbr": 760,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-10-04T16:51:06Z",
      "side": 1,
      "message": "I see.\n\nSo, the worst that can happen is that we erroneously keep the old entrypoint here. How do we ensure that we do not keep it indefinitely? Should we ClearMethodCounter()?",
      "parentUuid": "020ecea5_5e32b4be",
      "range": {
        "startLine": 760,
        "startChar": 11,
        "endLine": 760,
        "endChar": 63
      },
      "revId": "f35fe67d4f4fea573078f1090edde4948af57aff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1b7ba7e_4dfbf5fa",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 1
      },
      "lineNbr": 760,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2019-10-04T16:55:03Z",
      "side": 1,
      "message": "You\u0027re more familiar wot the JniStubData implementation, but isn\u0027t the reason we end up here is that the data got its entrypoint GCed?\n\n(Also do we agree my change doesn\u0027t affect what you\u0027re mentioning?)",
      "parentUuid": "b0092f19_099edf61",
      "range": {
        "startLine": 760,
        "startChar": 11,
        "endLine": 760,
        "endChar": 63
      },
      "revId": "f35fe67d4f4fea573078f1090edde4948af57aff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b76b0888_e839dbf5",
        "filename": "runtime/jit/jit_code_cache.cc",
        "patchSetId": 1
      },
      "lineNbr": 760,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-10-04T17:14:19Z",
      "side": 1,
      "message": "No, `m !\u003d method` just means we were asked to JIT native method thunks for two or more methods that have the same shorty and relevant flags (thus the same thunk), so we commit the code to all those methods.\n\nBut I agree that even before this CL, there are races that can lead to a missed entrypoint update. So we can commit this as is.",
      "parentUuid": "a1b7ba7e_4dfbf5fa",
      "range": {
        "startLine": 760,
        "startChar": 11,
        "endLine": 760,
        "endChar": 63
      },
      "revId": "f35fe67d4f4fea573078f1090edde4948af57aff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}