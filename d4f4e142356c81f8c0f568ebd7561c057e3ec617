{
  "comments": [
    {
      "key": {
        "uuid": "4c89b1d4_5575ee99",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-17T23:28:24Z",
      "side": 1,
      "message": "Compared to aog/324303, the CPU may mispredict this more because this is a forward branch rather than a fall-through to the next instruction.",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "984c4e27_5d9ed1ad",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-02-20T14:33:21Z",
      "side": 1,
      "message": "So, the implementation in this patch set is basically:\n\n    // Load and test the read barrier marking entry point.\n    ldr lr, [tr, entry_point_offset]\n    cbz lr, gc_is_not_marking\n\n    // Test the gray bit of `obj`.\n    ldr temp, [obj, monitor_offset]  // Load lock word.\n    add obj, obj, temp \u003e\u003e 32         // Fake dependency of `obj on the lock word.\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n    // Test gray bit.\n    tbz temp, LockWord::kReadBarrierStateShift, done\n    b slow_path\n  \n  gc_is_not_marking:\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n  \n  done:\n    […]\n  \n  slow_path:\n    // Call read barrier marking entry point.\n    blr lr\n    b done\n\nTo avoid the conditional forward branches for the optimistic cases (gc is not marking, gray bit is not set, we could instead do:\n\n    // Load and test the read barrier marking entry point.\n    ldr lr, [tr, entry_point_offset]\n    cbnz lr, gc_is_marking\n    b fast_path\n  \n  gc_is_marking:\n    // Test the gray bit of `obj`.\n    ldr temp, [obj, monitor_offset]  // Load lock word.\n    add obj, obj, temp \u003e\u003e 32         // Fake dependency of `obj on the lock word.\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n    // Test gray bit.\n    tbnz temp, LockWord::kReadBarrierStateShift, slow_path\n  \n  fast_path:\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n  \n    […]\n  \n  slow_path:\n    // Call read barrier marking entry point.\n    blr lr\n    b done",
      "parentUuid": "4c89b1d4_5575ee99",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d0e10183_917c2609",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5848,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-17T23:28:24Z",
      "side": 1,
      "message": "Similarly because this is a forward branch rather than a backward branch. This probably matters less than the above though.",
      "range": {
        "startLine": 5848,
        "startChar": 2,
        "endLine": 5848,
        "endChar": 56
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ddd916b_a8eb8c69",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5868,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-17T23:28:24Z",
      "side": 1,
      "message": "This version has on more instruction than aog/324303 for this branch?",
      "range": {
        "startLine": 5868,
        "startChar": 0,
        "endLine": 5868,
        "endChar": 35
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8fa8f001_950accc9",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5868,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-02-20T14:33:21Z",
      "side": 1,
      "message": "Indeed; the implementation in https://android-review.googlesource.com/#/c/324303/14/compiler/optimizing/code_generator_arm64.cc has one instruction less:\n\n    // Load and test the read barrier marking entry point.\n    ldr lr, [tr, entry_point_offset]\n    cbnz lr, slow_path\n    \n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n  exit:\n    […]\n  \n  slow_path:\n    // Test the gray bit of `obj`.\n    ldr temp, [obj, monitor_offset]  // Load lock word.\n    add obj, obj, temp \u003e\u003e 32         // Fake dependency of `obj on the lock word.\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n    // Test gray bit.\n    tbz temp, LockWord::kReadBarrierStateShift, done\n    // Call read barrier marking entry point.\n    blr lr\n  done:\n    b exit\n\nAlso, I wonder whether we would benefit from jumping directly to `exit` when the TBZ instructions succeeds (instead of jumping to `done`)?",
      "parentUuid": "0ddd916b_a8eb8c69",
      "range": {
        "startLine": 5868,
        "startChar": 0,
        "endLine": 5868,
        "endChar": 35
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}