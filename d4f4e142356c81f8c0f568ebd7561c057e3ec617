{
  "comments": [
    {
      "key": {
        "uuid": "4c89b1d4_5575ee99",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-17T23:28:24Z",
      "side": 1,
      "message": "Compared to aog/324303, the CPU may mispredict this more because this is a forward branch rather than a fall-through to the next instruction.",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "984c4e27_5d9ed1ad",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-02-20T14:33:21Z",
      "side": 1,
      "message": "So, the implementation in this patch set is basically:\n\n    // Load and test the read barrier marking entry point.\n    ldr lr, [tr, entry_point_offset]\n    cbz lr, gc_is_not_marking\n\n    // Test the gray bit of `obj`.\n    ldr temp, [obj, monitor_offset]  // Load lock word.\n    add obj, obj, temp \u003e\u003e 32         // Fake dependency of `obj on the lock word.\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n    // Test gray bit.\n    tbz temp, LockWord::kReadBarrierStateShift, done\n    b slow_path\n  \n  gc_is_not_marking:\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n  \n  done:\n    […]\n  \n  slow_path:\n    // Call read barrier marking entry point.\n    blr lr\n    b done\n\nTo avoid the conditional forward branches for the optimistic cases (gc is not marking, gray bit is not set, we could instead do:\n\n    // Load and test the read barrier marking entry point.\n    ldr lr, [tr, entry_point_offset]\n    cbnz lr, gc_is_marking\n    b fast_path\n  \n  gc_is_marking:\n    // Test the gray bit of `obj`.\n    ldr temp, [obj, monitor_offset]  // Load lock word.\n    add obj, obj, temp \u003e\u003e 32         // Fake dependency of `obj on the lock word.\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n    // Test gray bit.\n    tbnz temp, LockWord::kReadBarrierStateShift, slow_path\n  \n  fast_path:\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n  \n    […]\n  \n  slow_path:\n    // Call read barrier marking entry point.\n    blr lr\n    b done",
      "parentUuid": "4c89b1d4_5575ee99",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d1f46bf_996b9fe0",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-21T19:43:56Z",
      "side": 1,
      "message": "Agree that may be better for the branch prediction though there\u0027s one more instruction due to the additional instruction \"b fast_path\".",
      "parentUuid": "984c4e27_5d9ed1ad",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "69bea102_0cfa9577",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-02-21T23:37:43Z",
      "side": 1,
      "message": "Actually, I think the number of instructions is the same as for the code originally implemented in this CL; the second version proposed in these comments (without  the conditional forward branches) does not have the \"b slow_path\" instruction. I\u0027ll implement it.\n\nAnother thing we should try (later) is to \"inline\" the slow path when it contains only a call to the read barrier marking entry point (but that would probably be bad for branch prediction too).",
      "parentUuid": "4d1f46bf_996b9fe0",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5b16f795_3c3958e9",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-22T19:18:33Z",
      "side": 1,
      "message": "What do you mean by \"inline the slow path\"?",
      "parentUuid": "69bea102_0cfa9577",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f653827b_7b79f44f",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-02-22T19:45:39Z",
      "side": 1,
      "message": "I mean calling directly the entry point from the fast path, instead of jumping to a slow path at the end of the method:\n\n    // Load and test the read barrier marking entry point.\n    ldr lr, [tr, entry_point_offset]\n    cbz lr, gc_is_not_marking\n    // Test the gray bit of `obj`.\n    ldr temp, [obj, monitor_offset]  // Load lock word.\n    add obj, obj, temp \u003e\u003e 32         // Fake dependency of `obj on the lock word.\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n    // Test gray bit.\n    tbz temp, LockWord::kReadBarrierStateShift, done\n    // Call read barrier marking entry point.\n    blr lr\n    b done\n  \n  gc_is_not_marking:\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n  \n  done:\n    […]\n\nThis implementation has one less instruction.",
      "parentUuid": "5b16f795_3c3958e9",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "99cc2e21_23fa9456",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5817,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-22T19:55:23Z",
      "side": 1,
      "message": "I see. I agree with \"that would probably be bad for branch prediction too\".",
      "parentUuid": "f653827b_7b79f44f",
      "range": {
        "startLine": 5817,
        "startChar": 2,
        "endLine": 5817,
        "endChar": 36
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d0e10183_917c2609",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5848,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-17T23:28:24Z",
      "side": 1,
      "message": "Similarly because this is a forward branch rather than a backward branch. This probably matters less than the above though.",
      "range": {
        "startLine": 5848,
        "startChar": 2,
        "endLine": 5848,
        "endChar": 56
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ddd916b_a8eb8c69",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5868,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-17T23:28:24Z",
      "side": 1,
      "message": "This version has on more instruction than aog/324303 for this branch?",
      "range": {
        "startLine": 5868,
        "startChar": 0,
        "endLine": 5868,
        "endChar": 35
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8fa8f001_950accc9",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5868,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2017-02-20T14:33:21Z",
      "side": 1,
      "message": "Indeed; the implementation in https://android-review.googlesource.com/#/c/324303/14/compiler/optimizing/code_generator_arm64.cc has one instruction less:\n\n    // Load and test the read barrier marking entry point.\n    ldr lr, [tr, entry_point_offset]\n    cbnz lr, slow_path\n    \n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n  exit:\n    […]\n  \n  slow_path:\n    // Test the gray bit of `obj`.\n    ldr temp, [obj, monitor_offset]  // Load lock word.\n    add obj, obj, temp \u003e\u003e 32         // Fake dependency of `obj on the lock word.\n    // Actual reference load (+ potential heap unpoisoning)\n    ldr ref, [obj, offset]\n    // Test gray bit.\n    tbz temp, LockWord::kReadBarrierStateShift, done\n    // Call read barrier marking entry point.\n    blr lr\n  done:\n    b exit\n\nAlso, I wonder whether we would benefit from jumping directly to `exit` when the TBZ instructions succeeds (instead of jumping to `done`)?",
      "parentUuid": "0ddd916b_a8eb8c69",
      "range": {
        "startLine": 5868,
        "startChar": 0,
        "endLine": 5868,
        "endChar": 35
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ce100933_044db5e5",
        "filename": "compiler/optimizing/code_generator_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 5868,
      "author": {
        "id": 1022530
      },
      "writtenOn": "2017-02-21T19:43:56Z",
      "side": 1,
      "message": "Agreed jumping directly to \u0027exit\u0027 may be faster (especially since it\u0027s a backward branch.)",
      "parentUuid": "8fa8f001_950accc9",
      "range": {
        "startLine": 5868,
        "startChar": 0,
        "endLine": 5868,
        "endChar": 35
      },
      "revId": "d4f4e142356c81f8c0f568ebd7561c057e3ec617",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}