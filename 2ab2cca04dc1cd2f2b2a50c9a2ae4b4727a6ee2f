{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "085f2e6b_fe16c460",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-04T01:24:45Z",
      "side": 1,
      "message": "This is an initial pass. I suspect I misunderstood some things here ...",
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b55b5342_bc5d27c7",
        "filename": "runtime/arch/arm/fault_handler_arm.cc",
        "patchSetId": 9
      },
      "lineNbr": 83,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-04T01:24:45Z",
      "side": 1,
      "message": "Nit: \"A32 instruction encoding\" would make this clearer to many readers, I suspect.",
      "range": {
        "startLine": 83,
        "startChar": 37,
        "endLine": 83,
        "endChar": 41
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f6767f8d_e3984ead",
        "filename": "runtime/arch/arm/fault_handler_arm.cc",
        "patchSetId": 9
      },
      "lineNbr": 83,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-04T13:20:01Z",
      "side": 1,
      "message": "Rephrased. (I used A32 to refer to both the instruction set and CPU state.)",
      "parentUuid": "b55b5342_bc5d27c7",
      "range": {
        "startLine": 83,
        "startChar": 37,
        "endLine": 83,
        "endChar": 41
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32eb4e5e_c4f97f02",
        "filename": "runtime/arch/x86/fault_handler_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 297,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-04T01:24:45Z",
      "side": 1,
      "message": "Is this safe here? This runs in a signal handler, right? Is GetOatQuickMethodHeader async-signal-safe? It doesn\u0027t allocate or acquire locks? It seems rather involved. I think if it is, that should be documented. (I\u0027m willing to overlook CHECKs, which I\u0027m pretty sure are not async-signal-safe on failure, but should otherwise be.)",
      "range": {
        "startLine": 297,
        "startChar": 54,
        "endLine": 297,
        "endChar": 77
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51ad19fa_94a4c8f8",
        "filename": "runtime/arch/x86/fault_handler_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 297,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-04T13:20:01Z",
      "side": 1,
      "message": "I don\u0027t think this allocates memory or acquires any locks.\n\nThis CL is just moving the call from old `FaultManager::IsInGeneratedCode()` to NPE handlers (both the generic `NullPointerHandler::IsValidReturnPc()` and the x86-specific here).",
      "parentUuid": "32eb4e5e_c4f97f02",
      "range": {
        "startLine": 297,
        "startChar": 54,
        "endLine": 297,
        "endChar": 77
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "045152c6_18bf5e63",
        "filename": "runtime/arch/x86/fault_handler_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 297,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-08T07:25:19Z",
      "side": 1,
      "message": "Can we document that GetOatQuickMethodHeader is async-signal-safe? It seemed like a nontrivial piece of code, and this is a nontrivial assertion that needs to be maintained. Granted, it now seems orthogonal to this CL.",
      "parentUuid": "51ad19fa_94a4c8f8",
      "range": {
        "startLine": 297,
        "startChar": 54,
        "endLine": 297,
        "endChar": 77
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb25aeba_fdf9d75d",
        "filename": "runtime/arch/x86/fault_handler_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 297,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-08T17:51:37Z",
      "side": 1,
      "message": "Actually, `ArtMethod::GetOatQuickMethodHeader()` can call `JitCodeCache::LookupMethodHeader()` where we take a lock, namely `Locks::jit_lock_`.",
      "parentUuid": "045152c6_18bf5e63",
      "range": {
        "startLine": 297,
        "startChar": 54,
        "endLine": 297,
        "endChar": 77
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b00159d_23e1f34b",
        "filename": "runtime/arch/x86/fault_handler_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 297,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-11T13:09:18Z",
      "side": 1,
      "message": "Added comments here and in `NullPointerHandler::IsValidReturnPc()`. Please review.",
      "parentUuid": "cb25aeba_fdf9d75d",
      "range": {
        "startLine": 297,
        "startChar": 54,
        "endLine": 297,
        "endChar": 77
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e242c771_3827275d",
        "filename": "runtime/arch/x86/fault_handler_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 297,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-17T04:35:35Z",
      "side": 1,
      "message": "LGTM for now, though it could use commas around \"which ... handler\".",
      "parentUuid": "2b00159d_23e1f34b",
      "range": {
        "startLine": 297,
        "startChar": 54,
        "endLine": 297,
        "endChar": 77
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6346dd10_32872319",
        "filename": "runtime/arch/x86/fault_handler_x86.cc",
        "patchSetId": 9
      },
      "lineNbr": 297,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-18T10:52:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e242c771_3827275d",
      "range": {
        "startLine": 297,
        "startChar": 54,
        "endLine": 297,
        "endChar": 77
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7265c36_071aeecf",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-04T01:24:45Z",
      "side": 1,
      "message": "I don\u0027t understand what it means to be not runnable, but holding the mutator lock. Can you explain?",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86f78be2_6871c705",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-04T13:20:01Z",
      "side": 1,
      "message": "This is called from GC in some odd state when the thread is not `Runnable` but holds the mutator lock anyway. Maybe Lokesh can provide more information.",
      "parentUuid": "f7265c36_071aeecf",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43e3ecda_ec9984b6",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-11-05T01:05:58Z",
      "side": 1,
      "message": "I\u0027m also not sure. All places where we call CleanupClassLoaders seem to hold mutator lock but there is no obvious/explicit state change to non-runnable that I can find.\n\nIs this with ConcurrentCopying that you observed it?",
      "parentUuid": "86f78be2_6871c705",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d1c0dfd_a96db109",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-07T07:25:59Z",
      "side": 1,
      "message": "This was with the default config, so yes, CC GC.",
      "parentUuid": "43e3ecda_ec9984b6",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd9e584d_399baece",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-08T07:25:19Z",
      "side": 1,
      "message": "So CopyingPhase is somehow not called in Runnable state? Looking more closely, we do have a bunch of mutator_lock_-\u003eSharedLock() calls there. I previously thought that those somehow resulted in a state change. But I think they do not. Those seem like they\u0027re just a bug? I suspect we should replace them with state changes, or MutatorLock::SharedLock() should force a state change? MutatorLock conventions still don\u0027t seem quite consistent.",
      "parentUuid": "4d1c0dfd_a96db109",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "629ad924_261b9e03",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-11T13:09:18Z",
      "side": 1,
      "message": "Added a TODO to clean up state transitions. Is that enough or now?",
      "parentUuid": "bd9e584d_399baece",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af214423_a872bad5",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-17T04:35:35Z",
      "side": 1,
      "message": "Filed b/259440389 . I think this is good enough here, though you may want to cite that bug.",
      "parentUuid": "629ad924_261b9e03",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81b49059_b8dec39f",
        "filename": "runtime/class_linker.cc",
        "patchSetId": 9
      },
      "lineNbr": 10364,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-18T10:52:11Z",
      "side": 1,
      "message": "Done.\n\nAlso made the code more robust if other GC types are actually in Runnable state. This shall make the cleanup easier as we can deal with each GC on its own.",
      "parentUuid": "af214423_a872bad5",
      "range": {
        "startLine": 10363,
        "startChar": 4,
        "endLine": 10364,
        "endChar": 76
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f610755_14cb77c6",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 227,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-04T01:24:45Z",
      "side": 1,
      "message": "Why do you need a compare_exchange here? Shouldn\u0027t concurrent modifications be impossible?",
      "range": {
        "startLine": 227,
        "startChar": 37,
        "endLine": 227,
        "endChar": 60
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a96d976_a6e5e11b",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 227,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-04T13:20:01Z",
      "side": 1,
      "message": "Replaced with store. (I started without a lock and failed to correctly simplify this after adding the lock.)",
      "parentUuid": "4f610755_14cb77c6",
      "range": {
        "startLine": 227,
        "startChar": 37,
        "endLine": 227,
        "endChar": 60
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4056926b_9ea32d6f",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 262,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-04T01:24:45Z",
      "side": 1,
      "message": "I don\u0027t see why this is necessary. This presumably shouldn\u0027t race with any other modifications to the data structure, so I don\u0027t think it helps.\nThe extra acquire here seems to be nearly free, so my concern is more about my understanding than unnecessary overhead.",
      "range": {
        "startLine": 262,
        "startChar": 25,
        "endLine": 262,
        "endChar": 51
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12424d7b_34047f7b",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 262,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-04T13:20:01Z",
      "side": 1,
      "message": "Changed to relaxed. (Another case that I failed to adjust after introducing the lock.)",
      "parentUuid": "4056926b_9ea32d6f",
      "range": {
        "startLine": 262,
        "startChar": 25,
        "endLine": 262,
        "endChar": 51
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9426f089_02db6e9e",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 335,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-04T01:24:45Z",
      "side": 1,
      "message": "I\u0027m suspicious of this. I\u0027ll revisit after the other questions. My immediate take on this should be that all updates should be release stores, and this should use acquire operations. But I need to think about this more, particularly in light of the fences.",
      "range": {
        "startLine": 335,
        "startChar": 29,
        "endLine": 335,
        "endChar": 54
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "905a2184_a5816ed4",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 335,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-04T13:20:01Z",
      "side": 1,
      "message": "Anything we add to the list uses \"release\" on `generated_code_ranges_` and the \"acquire\" above should ensure memory visibility for all the range data (start, size) that the fault handler can see during the walk.\n\nIf any elements are removed while we\u0027re walking the list here, depending on whether we see the writes of the `next` links, we can either visit or not visit those removed ranges but we shall certainly visit those that were not removed and there is on problem with the visibility of their (start, size) data.\n\nAdded comments.",
      "parentUuid": "9426f089_02db6e9e",
      "range": {
        "startLine": 335,
        "startChar": 29,
        "endLine": 335,
        "endChar": 54
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "624cd210_af5996fb",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 335,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-17T04:35:35Z",
      "side": 1,
      "message": "This seems to get into tricky memory model corners. Assume a thread adds two ranges and then removes the first one. A second thread asynchronously calls IsInGenerated Range. The second thread does an acquire load on the list head and sees the formerly second added range. But that was strored with a relaxed store. So there is no synchronizes-with relationship between the writer and the reader. So at a minimum all stores to the head of the list have to be release stores.\n\nThis argument ignores the fences. (See my comment in AddGeneratedCodeRange.) But I suspect they don\u0027t actually figure in here?",
      "parentUuid": "905a2184_a5816ed4",
      "range": {
        "startLine": 335,
        "startChar": 29,
        "endLine": 335,
        "endChar": 54
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74bfefe6_4475bd03",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 335,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-18T10:52:11Z",
      "side": 1,
      "message": "No, the `std::atomic_thread_fence()`s are not relevant for this.\n\nThe second thread uses load-acquire on `generated_code_ranges_` (we never use relaxed operations on the list head), so it has memory visibility of all the ranges added before the corresponding store-release. The only operation allowed on that memory is to change the `next` link to skip some nodes where we no longer expect any faults. For the walking thread, it should not matter whether it sees the old value or the new value of the `next` node as visiting the removed node should not matter (the `start` and `size` are constant and should not match, the `next` can have its original value or skip one or more removed nodes).\n\n(There is also a question of the `next` links visibility for threads that fault after the removal but that is handled by the checkpoint.)",
      "parentUuid": "624cd210_af5996fb",
      "range": {
        "startLine": 335,
        "startChar": 29,
        "endLine": 335,
        "endChar": 54
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8b80b27_54950375",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 9
      },
      "lineNbr": 335,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-22T23:31:38Z",
      "side": 1,
      "message": "My concern here is that in order for a thread to \"see\" memory accesses of another, it needs to see a value written by the \"release sequence\" of a release store to that location. The relevant text in the current draft is:\n\n\"An atomic operation A that performs a release operation on an atomic object M synchronizes with an atomic operation B that performs an acquire operation on M and takes its value from any side effect in the release sequence headed by A.\"\n\n\"Release sequence\" is now defined as:\n\n\"A release sequence headed by a release operation A on an atomic object M is a maximal contiguous subsequence of side effects in the modification order of M, where the first operation is A, and every subsequent operation is an atomic read-modify-write operation.\" (This changed in C++20, but I think only in that it might previously have made our examples more complicated.)\n\nIn this case, there are no relevant reaad-modify-write operations, so the \"release sequence\" consists of just the release store. When I read generated_code_ranges_ immediately after the first range was deleted, the value at that location was written by a relaxed store, so there is no synchronization relationship. So I get no ordering guarantee for the acquire load.\n\nThe value was of course stored there at some point with a release store. But I don\u0027t see how that suffices for the C++ model. \n\nSo I think the minimum fix here is to have RemoveGeneratedCodeRange() use a release store, either always, or only when overwriting generateed_code_ranges_.\n\nIs there any reason to believe that this is performance-sensitive enough for this to matter?",
      "parentUuid": "74bfefe6_4475bd03",
      "range": {
        "startLine": 335,
        "startChar": 29,
        "endLine": 335,
        "endChar": 54
      },
      "revId": "2ab2cca04dc1cd2f2b2a50c9a2ae4b4727a6ee2f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}