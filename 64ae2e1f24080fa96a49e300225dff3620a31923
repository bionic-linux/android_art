{
  "comments": [
    {
      "key": {
        "uuid": "253496db_29141a1b",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-11T17:44:02Z",
      "side": 1,
      "message": "This is a no-op, not a fake dependency.  We need a fake dependency on the load of status into t5.\n\nAs it stands, this is clearly wrong.  Unless we get more clarification on the architecture, we need a SYNC_ACQUIRE here.",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6553ee27_7ccad674",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1064548
      },
      "writtenOn": "2015-12-11T22:17:37Z",
      "side": 1,
      "message": "As per the spec below - section 4.2 Execution order behavior states the following \n\"Uniprocessor Data Dependencies are always maintained. These include read-after-write, write-after-write and\nwrite-after-read hazards\". Using these dependencies for two instructions, we can build a larger dependency tree. The dependency tree is mostly derived information and is not documented for MIPS AFAIK if that is what you are asking.\n\nMIPS Coherence Protocol specification\nhttps://imagination-technologies-cloudfront-assets.s3.amazonaws.com/documentation/MD00605-2B-CMPCOHERE-AFP-01.01.pdf\n\nAlthough addu instruction below appears as a nop, it will need to be executed by any MIPS processor to maintain the following dependencies.I have simplified the instruction sequence for discussion.\n\n1. lw    $t5, STATUS($t0) \n2. addu  $t0, $t0, $zero  #WAR dependency on $t0\n3. lw    $t5, FLAGS($t0) #RAW dependency on $t0 \n\nWhile maintaining both the above dependencies, through \nregister renaming, I can see a possibility of a CPU \nreading flags before status.\n                           addu TMP1, $t0, $zero\n                           lw   TMP2, FLAGS(TMP1)\n lw $t5, STATUS($t0)\n                           move t0, TMP1\n                           move t5, TMP2\n\nHence my earlier suggestion of introducing only addu dependency instead of \"xor and addu\" may not work on CPUs where aggressive speculative loads are enabled. However\"xor and addu\" will introduces a series of RAW dependencies which would serialize the execution.\n\n1. lw    $t5, STATUS($t0) \n2. xor   $t5, $t5, $t5   # RAW on $t5\n3. addu  $t0, $t0, $t5   # RAW on $t5\n4. lw    $t5, FLAGS($t0) #RAW on $t0\n\n@Hans, If you agree that this information is sufficient, we would upload another patch with \"xor and addu\" to maintain the load dependencies.If you need more information on any specific topic, let me know.",
      "parentUuid": "253496db_29141a1b",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e5cc3e7f_6275b614",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-11T23:48:34Z",
      "side": 1,
      "message": "You identified the place where I also got stuck.  The questions is what that statement in 4.2 really means.  Does it mean that cross-processor ordering is enforced?  Or does it essentially only mean that a single core sees its own writes in the correct order, i.e. uniprocessor semantics are correctly maintained?\n\nI asked David Lau that question in a previous exchange, and his answer was:\n\n\"It just means that for the CPU executing the code, the RAW, WAR, WAW dependencies are always honored.\"\n\nI\u0027m inclined to read that as the latter, especially since, as you point out, you can\u0027t really do register renaming and maintain WAR dependencies.  Thus my best guess now is that the SYNC_ACQUIRE is needed, and dependencies do not affect visibility across cores.  Initially I read 4.2 roughly the way you did. In retrospect, the mention of write-after-read hazards should have dissuaded me from that.\n\nMy sense is that hardware architects are very unlikely to reflect anything but RAW dependencies in cross-core memory ordering, and they\u0027re unenthusiastic about that, because even that inhibits some optimizations.\n\nMy current interpretation scares me because of implications on final field accesses.  The added fence here seems comparatively minor.\n\nWe really do need a clarification.",
      "parentUuid": "6553ee27_7ccad674",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "45db4a39_c6bf7878",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1064548
      },
      "writtenOn": "2015-12-12T17:17:17Z",
      "side": 1,
      "message": "The statement in section 4.2 only means that uniprocessor semantics are correctly maintained. It does not guarantee cross-processor ordering of the resulting memory transactions. \n\nIn my opinion, the visibility of loads to other processors does not matter in this situation since we are talking about a cached access. It only matters that the first load completes before the second load is initiated on the current processor. We achieve it successfully through a series of RAWs. However if we have non-dependent loads or loads which are dependent through Write-after-Reads, then SYNC_ACQUIRE is mandatory to ensure that loading of status is complete before loading of flags and size is initiated.\n\nFor sake of completeness, I will mention how stores are expected to complete on MIPS where ever the status is being updated. On the store side of the story, visibility of the stores is mandatory. Hence a sync_wmb/sync_mb/sync is required.\n\n1. sw    $t1, FLAGS($t4)\n2. sw    $t2, SIZE($t4) \n3. sync_wmb      # Required for rest of the loads to be globally visible before status.\n4. sw    $t3, STATUS($t4)",
      "parentUuid": "e5cc3e7f_6275b614",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "25157684_4aa1d7c8",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-13T04:12:25Z",
      "side": 1,
      "message": "Can you point me at the spec that states that if two loads, such that the address of the second is dependent on the result of the first, i.e. there is a RAW dependency, then the first load must complete before the second is initiated?\n\nAlthough this sounds like a vacuous requirement, it is not.  It prevents data speculation.  DEC Alpha violated this rule for a different reason, related to cache architecture.  I would also like to see it pinned down, since it may help to answer my next question, which is how such a RAW dependency is defined, and whether it includes the kind of \"fake\" dependencies we\u0027re trying to use here.",
      "parentUuid": "45db4a39_c6bf7878",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "25157684_78de29fe",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1064548
      },
      "writtenOn": "2015-12-14T23:31:27Z",
      "side": 1,
      "message": "The second load can only be initiated after the address of the load instruction is known. But the address of the second load is dependent on the result of the previous instruction. As section 4.2 states that all RAW, WAR, WAW dependencies should be satisfied, each instruction after the first load will need to be executed until the address of the 2nd load is calculated. Only after the address gets calculated, the second load can be initiated. Data speculation is allowed as long as execution order rules (section 4.2) are satisfied. In our example there is no scope for a speculative 2nd load due to the RAW dependency on the address of the load.\n\nI had run this example by both architecture and hardware teams and both confirmed that these semantically fake dependencies are real dependencies for a MIPS processor and are sufficient to ensure that the second load gets initiated after the address dependency is satisfied.\n\nUnfortunately, there is no MIPS specific documentation about the dependencies. The Wikipedia definition matches the assumptions on MIPS.\nread after write (RAW), a true dependency\nwrite after read (WAR), an anti-dependency\nwrite after write (WAW), an output dependency\n\nhttps://en.wikipedia.org/wiki/Hazard_(computer_architecture)",
      "parentUuid": "25157684_4aa1d7c8",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "65e04ee1_e7f1d08d",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-15T00:08:51Z",
      "side": 1,
      "message": "The fact that the hardware teams believe fake dependencies are enforced is encouraging.\n\nThe fact that we\u0027re still talking about RAW, WAR, WAW dependencies at once seems very strange to me.  It seems entirely unreasonable to me to have hardware memory ordering be influenced by anything other than a RAW dependency, since WAR and WAW dependencies are removed by register renaming, as Ragu pointed out.  If the source code says:\n\nlw $t1, x\ncopy $t1 to $t2\nlw $t1, y\n\nI would be really surprised if that caused the loads to be ordered. That\u0027s certainly not true on any of the other weakly ordered architectures I\u0027ve encountered (ARM, Power, Itanium (and Alpha)).\n\nIf I have, with no unexpected aliasing\n\nlw $t1, x\nlw $t2, 0($t1)\n\nthe loads could in theory be performed by caching the previous address used by the second load (from the last time that instruction was executed), and then using that to run both loads in parallel, aborting the second one if the first one returns a different result.  In that case the data dependency would not force the first load to complete before the second.  I do not know of real architectures that do this, but I believe it has been seriously proposed in computer architecture papers (cf. http://citeseerx.ist.psu.edu/viewdoc/download?doi\u003d10.1.1.46.3036\u0026rep\u003drep1\u0026type\u003dpdf from Europar \u002797).\n\nAs I mentioned, Alpha had a different cache-related reason for not enforcing ordering here, which I can\u0027t immediately reconstruct.\n\nThus I don\u0027t believe we can implicitly assume that an address dependency orders accesses; you really need a commitment by the architects not to violate such dependencies.",
      "parentUuid": "25157684_78de29fe",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5b81ad7_08208f78",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1064548
      },
      "writtenOn": "2015-12-15T03:16:01Z",
      "side": 1,
      "message": "Agree with you that only RAW can ensure ordered loads. I only brought up other dependencies to list all the dependencies MIPS processor honors. I can confirm that your first example does not ensure ordered loads on MIPS.\n\nI now understand your concern through the second example. Thanks for sharing the paper on Memory Address Prediction(MAP). Implementation of MAP is possible on MIPS in theory and that would violate the fake dependency we are trying to put. There is no such implementation available now or is planned in the near future on MIPS. I cannot predict the future direction though. If we are protecting the code against such a case, sync_acquire will be required. Wouldn\u0027t there be a similar issue on ARM?",
      "parentUuid": "65e04ee1_e7f1d08d",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "85d9c240_d481da6c",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-15T06:22:02Z",
      "side": 1,
      "message": "ARM, Power, and Itanium have semi-careful definitions specifying what kind of dependencies enforce ordering, particularly between loads.\n\nIn my opinion, your hardware architects need to do something similar, since this will constrain future implementations.  It needs to at least cover the final field reference case.  Otherwise SYNC_ACQUIRE needs to be very  fast, because it will end up all over the place.  For example, if I write p.f() and the compiler can\u0027t statically resolve f not show that the object referenced by p was allocated by the same thread, we would need a SYNC_ACQUIRE after loading p to make sure the class pointer is visible.  I believe no Java implementation currently does this on any architecture.  (Alpha died just in time.)",
      "parentUuid": "c5b81ad7_08208f78",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}