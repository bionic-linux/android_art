{
  "comments": [
    {
      "key": {
        "uuid": "253496db_29141a1b",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-11T17:44:02Z",
      "side": 1,
      "message": "This is a no-op, not a fake dependency.  We need a fake dependency on the load of status into t5.\n\nAs it stands, this is clearly wrong.  Unless we get more clarification on the architecture, we need a SYNC_ACQUIRE here.",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6553ee27_7ccad674",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1064548
      },
      "writtenOn": "2015-12-11T22:17:37Z",
      "side": 1,
      "message": "As per the spec below - section 4.2 Execution order behavior states the following \n\"Uniprocessor Data Dependencies are always maintained. These include read-after-write, write-after-write and\nwrite-after-read hazards\". Using these dependencies for two instructions, we can build a larger dependency tree. The dependency tree is mostly derived information and is not documented for MIPS AFAIK if that is what you are asking.\n\nMIPS Coherence Protocol specification\nhttps://imagination-technologies-cloudfront-assets.s3.amazonaws.com/documentation/MD00605-2B-CMPCOHERE-AFP-01.01.pdf\n\nAlthough addu instruction below appears as a nop, it will need to be executed by any MIPS processor to maintain the following dependencies.I have simplified the instruction sequence for discussion.\n\n1. lw    $t5, STATUS($t0) \n2. addu  $t0, $t0, $zero  #WAR dependency on $t0\n3. lw    $t5, FLAGS($t0) #RAW dependency on $t0 \n\nWhile maintaining both the above dependencies, through \nregister renaming, I can see a possibility of a CPU \nreading flags before status.\n                           addu TMP1, $t0, $zero\n                           lw   TMP2, FLAGS(TMP1)\n lw $t5, STATUS($t0)\n                           move t0, TMP1\n                           move t5, TMP2\n\nHence my earlier suggestion of introducing only addu dependency instead of \"xor and addu\" may not work on CPUs where aggressive speculative loads are enabled. However\"xor and addu\" will introduces a series of RAW dependencies which would serialize the execution.\n\n1. lw    $t5, STATUS($t0) \n2. xor   $t5, $t5, $t5   # RAW on $t5\n3. addu  $t0, $t0, $t5   # RAW on $t5\n4. lw    $t5, FLAGS($t0) #RAW on $t0\n\n@Hans, If you agree that this information is sufficient, we would upload another patch with \"xor and addu\" to maintain the load dependencies.If you need more information on any specific topic, let me know.",
      "parentUuid": "253496db_29141a1b",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e5cc3e7f_6275b614",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-11T23:48:34Z",
      "side": 1,
      "message": "You identified the place where I also got stuck.  The questions is what that statement in 4.2 really means.  Does it mean that cross-processor ordering is enforced?  Or does it essentially only mean that a single core sees its own writes in the correct order, i.e. uniprocessor semantics are correctly maintained?\n\nI asked David Lau that question in a previous exchange, and his answer was:\n\n\"It just means that for the CPU executing the code, the RAW, WAR, WAW dependencies are always honored.\"\n\nI\u0027m inclined to read that as the latter, especially since, as you point out, you can\u0027t really do register renaming and maintain WAR dependencies.  Thus my best guess now is that the SYNC_ACQUIRE is needed, and dependencies do not affect visibility across cores.  Initially I read 4.2 roughly the way you did. In retrospect, the mention of write-after-read hazards should have dissuaded me from that.\n\nMy sense is that hardware architects are very unlikely to reflect anything but RAW dependencies in cross-core memory ordering, and they\u0027re unenthusiastic about that, because even that inhibits some optimizations.\n\nMy current interpretation scares me because of implications on final field accesses.  The added fence here seems comparatively minor.\n\nWe really do need a clarification.",
      "parentUuid": "6553ee27_7ccad674",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "45db4a39_c6bf7878",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1064548
      },
      "writtenOn": "2015-12-12T17:17:17Z",
      "side": 1,
      "message": "The statement in section 4.2 only means that uniprocessor semantics are correctly maintained. It does not guarantee cross-processor ordering of the resulting memory transactions. \n\nIn my opinion, the visibility of loads to other processors does not matter in this situation since we are talking about a cached access. It only matters that the first load completes before the second load is initiated on the current processor. We achieve it successfully through a series of RAWs. However if we have non-dependent loads or loads which are dependent through Write-after-Reads, then SYNC_ACQUIRE is mandatory to ensure that loading of status is complete before loading of flags and size is initiated.\n\nFor sake of completeness, I will mention how stores are expected to complete on MIPS where ever the status is being updated. On the store side of the story, visibility of the stores is mandatory. Hence a sync_wmb/sync_mb/sync is required.\n\n1. sw    $t1, FLAGS($t4)\n2. sw    $t2, SIZE($t4) \n3. sync_wmb      # Required for rest of the loads to be globally visible before status.\n4. sw    $t3, STATUS($t4)",
      "parentUuid": "e5cc3e7f_6275b614",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "25157684_4aa1d7c8",
        "filename": "runtime/arch/mips/quick_entrypoints_mips.S",
        "patchSetId": 3
      },
      "lineNbr": 1348,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-12-13T04:12:25Z",
      "side": 1,
      "message": "Can you point me at the spec that states that if two loads, such that the address of the second is dependent on the result of the first, i.e. there is a RAW dependency, then the first load must complete before the second is initiated?\n\nAlthough this sounds like a vacuous requirement, it is not.  It prevents data speculation.  DEC Alpha violated this rule for a different reason, related to cache architecture.  I would also like to see it pinned down, since it may help to answer my next question, which is how such a RAW dependency is defined, and whether it includes the kind of \"fake\" dependencies we\u0027re trying to use here.",
      "parentUuid": "45db4a39_c6bf7878",
      "range": {
        "startLine": 1348,
        "startChar": 4,
        "endLine": 1348,
        "endChar": 25
      },
      "revId": "64ae2e1f24080fa96a49e300225dff3620a31923",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}