{
  "comments": [
    {
      "key": {
        "uuid": "e96ff5a6_49ea3a5d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 16,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:53:03Z",
      "side": 1,
      "message": "Intrinsic",
      "range": {
        "startLine": 16,
        "startChar": 8,
        "endLine": 16,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8eed4564_31cd7f9f",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3442,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:51:47Z",
      "side": 1,
      "message": "... NaN or in0 \u003d\u003d -1 and in1 \u003d\u003d 1",
      "range": {
        "startLine": 3442,
        "startChar": 48,
        "endLine": 3442,
        "endChar": 51
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "641e3176_02cc09ba",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3452,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:57:30Z",
      "side": 1,
      "message": "inputs",
      "range": {
        "startLine": 3452,
        "startChar": 24,
        "endLine": 3452,
        "endChar": 29
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b529aea_2638d253",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3453,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:51:47Z",
      "side": 1,
      "message": "Therefore",
      "range": {
        "startLine": 3453,
        "startChar": 65,
        "endLine": 3453,
        "endChar": 73
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52ca97ce_82022e46",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:51:47Z",
      "side": 1,
      "message": "I found a solution with 15 instructions vs 18 instructions:\n\n    __ Fcmp(in0, in1);\n    __ Mov(out, 1);\n    __ B(gt, \u0026end);\n    __ B(vs, \u0026nan);\n    __ B(eq, \u0026equal);\n\n    // if in0 \u003c in1 or if only the 2nd input is NaN\n    __ Bind(\u0026neg_one);\n    __ Mov(out, -1);\n    __ B(\u0026end);\n\n    // if either of the input is NaN\n    // NaN is equal to itself and greater than any other number. Therefore:\n    // - if only in0 is NaN \u003d\u003e return 1\n    // - if only in1 is NaN \u003d\u003e return -1\n    // - if both in0 and in1 are NaN \u003d\u003e return 0\n    __ Bind(\u0026nan);\n    __ Fcmp(in0, 0.0);\n    // if in0 is not a NaN than only in1 was a NaN and therefore return -1\n    __ B(vc, \u0026neg_one);\n    __ Fcmp(in1, 0.0);\n    // if in1 is not a NaN than only in0 was a NaN and return +1\n    __ Cset(out, vc);\n    //  If the execution reaches this point, it means both registers are NaN and return 0\n    __ B(\u0026end);\n\n    // in0 \u003d\u003d in1 or if one of the inputs is +0 and the other is -0\n    __ Bind(\u0026equal);\n    __ Fcmp(in0.V1D(), in1.V1D());\n    __ B(hi, \u0026neg_one);  // in0 is -0, in1 is +0\n    __ Cset(out, mi);    // in0 is +0, in1 is -0\n\n    __ Bind(\u0026end);",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f40ff36_158c3e99",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T23:20:19Z",
      "side": 1,
      "message": "Restructure the code by making the NaN case fallthrough and only forward branches, also fixed typos in the comments:\n\n    __ Fcmp(in0, in1);\n    __ Mov(out, 1);\n    __ B(gt, \u0026end);\n    __ B(mi, \u0026neg_one);\n    __ B(eq, \u0026equal);\n\n    // Either of the inputs is NaN.\n    // NaN is equal to itself and greater than any other number.\n    // Therefore:\n    // - if only in0 is NaN \u003d\u003e return 1\n    // - if only in1 is NaN \u003d\u003e return -1\n    // - if both in0 and in1 are NaN \u003d\u003e return 0\n    __ Fcmp(in0, 0.0);\n    __ B(vc, \u0026neg_one); // in0 !\u003d NaN \u003d\u003e out \u003d -1\n    __ Fcmp(in1, 0.0);\n    __ Cset(out, vc); // if in1 !\u003d NaN \u003d\u003e out \u003d 1, otherwise both are NaNs \u003d\u003e out \u003d 0\n    __ B(\u0026end);\n\n    // in0 \u003d\u003d in1 or if one of the inputs is +0 and the other is -0\n    __ Bind(\u0026equal);\n    __ Fcmp(in0.V1D(), in1.V1D());\n    __ B(hi, \u0026neg_one);  // in0 is -0, in1 is +0 \u003d\u003e out \u003d -1\n    __ Cset(out, mi);    // if in0 is +0 and in1 is -0 \u003d\u003e out \u003d 1, otherwise out \u003d 0\n    __ B(\u0026end);\n\n    // if in0 \u003c in1 or if only the 2nd input is NaN or in0 \u003d\u003d -0 and in1 \u003d\u003d +0\n    __ Bind(\u0026neg_one);\n    __ Mov(out, -1);\n\n    __ Bind(\u0026end);",
      "parentUuid": "52ca97ce_82022e46",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "030c4971_1fdf634e",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-11-22T10:31:34Z",
      "side": 1,
      "message": "Can you explain the meaning of the `__ Fcmp(in0.V1D(), in1.V1D());` in the `equal` path? Do we just interpret the value as `double` with the higher bits being zero and thus comparing denormal values and/or +0 (but never NaN)? Would it work if we compared just floats with V1S?\n\nIf my understanding of the above is correct, this can be further improved by making both the \"normal\" and \"equal\" paths feed the same CSET+CSINV:\n\n    __ Fcmp(in0, in1);\n    __ B(eq, \u0026equal);\n    __ B(vc, \u0026normal);\n\n    // Either of the inputs is NaN.\n    // NaN is equal to itself and greater than any other number.\n    // Therefore:\n    // - if only in0 is NaN \u003d\u003e return 1\n    // - if only in1 is NaN \u003d\u003e return -1\n    // - if both in0 and in1 are NaN \u003d\u003e return 0\n    __ Fcmp(in0, 0.0);\n    __ B(vc, \u0026neg_one); // in0 !\u003d NaN \u003d\u003e out \u003d -1\n    __ Fcmp(in1, 0.0);\n    __ Cset(out, vc); // if in1 !\u003d NaN \u003d\u003e out \u003d 1, otherwise both are NaNs \u003d\u003e out \u003d 0\n    __ B(\u0026end);\n\n    // in0 \u003d\u003d in1 or if one of the inputs is +0 and the other is -0\n    __ Bind(\u0026equal);\n    // Reverse operand order because -0 \u003e +0 when compared as `double`.\n    __ Fcmp(in1.V1D(), in0.V1D());\n\n    __ Bind(\u0026normal);\n    __ Cset(out, gt);\n    __ Csinv(out, out, xzr, pl);\n\n    __ Bind(\u0026end);\n\n\n(The NaN path can also be rewritten with CSETM+CSINC if we want to reduce the number of branches but the number of instructions would remain the same.)",
      "parentUuid": "6f40ff36_158c3e99",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "569c255f_ac852a97",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1576111
      },
      "writtenOn": "2019-11-22T11:07:57Z",
      "side": 1,
      "message": "At the point we have  __ Fcmp(in0.V1D(), in1.V1D()); we are just trying to compare +/-0. For that we need to compare more than 16 bits. In Neon ARM, we can only modify 64 bits or 128 bits at a time, which is why i believe there is no V1S, which is 32 bits. The possibilities are as seen in src/aarch64/operands-aarch64.h:\n\n  VRegister V8B() const { return VRegister(code_, kDRegSize, 8); }\n  VRegister V16B() const { return VRegister(code_, kQRegSize, 16); }\n  VRegister V2H() const { return VRegister(code_, kSRegSize, 2); }\n  VRegister V4H() const { return VRegister(code_, kDRegSize, 4); }\n  VRegister V8H() const { return VRegister(code_, kQRegSize, 8); }\n  VRegister V2S() const { return VRegister(code_, kDRegSize, 2); }\n  VRegister V4S() const { return VRegister(code_, kQRegSize, 4); }\n  VRegister V2D() const { return VRegister(code_, kQRegSize, 2); }\n  VRegister V1D() const { return VRegister(code_, kDRegSize, 1); }\n\n\nWe could use V2S (2 32bits) but the result wont be any different from V1D (1 64 bits). I believe V1D might be slightly better to understand for anyone reading it in the future.",
      "parentUuid": "030c4971_1fdf634e",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}