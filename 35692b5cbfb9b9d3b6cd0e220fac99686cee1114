{
  "comments": [
    {
      "key": {
        "uuid": "e96ff5a6_49ea3a5d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 16,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:53:03Z",
      "side": 1,
      "message": "Intrinsic",
      "range": {
        "startLine": 16,
        "startChar": 8,
        "endLine": 16,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8eed4564_31cd7f9f",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3442,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:51:47Z",
      "side": 1,
      "message": "... NaN or in0 \u003d\u003d -1 and in1 \u003d\u003d 1",
      "range": {
        "startLine": 3442,
        "startChar": 48,
        "endLine": 3442,
        "endChar": 51
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "641e3176_02cc09ba",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3452,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:57:30Z",
      "side": 1,
      "message": "inputs",
      "range": {
        "startLine": 3452,
        "startChar": 24,
        "endLine": 3452,
        "endChar": 29
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b529aea_2638d253",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3453,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:51:47Z",
      "side": 1,
      "message": "Therefore",
      "range": {
        "startLine": 3453,
        "startChar": 65,
        "endLine": 3453,
        "endChar": 73
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52ca97ce_82022e46",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T21:51:47Z",
      "side": 1,
      "message": "I found a solution with 15 instructions vs 18 instructions:\n\n    __ Fcmp(in0, in1);\n    __ Mov(out, 1);\n    __ B(gt, \u0026end);\n    __ B(vs, \u0026nan);\n    __ B(eq, \u0026equal);\n\n    // if in0 \u003c in1 or if only the 2nd input is NaN\n    __ Bind(\u0026neg_one);\n    __ Mov(out, -1);\n    __ B(\u0026end);\n\n    // if either of the input is NaN\n    // NaN is equal to itself and greater than any other number. Therefore:\n    // - if only in0 is NaN \u003d\u003e return 1\n    // - if only in1 is NaN \u003d\u003e return -1\n    // - if both in0 and in1 are NaN \u003d\u003e return 0\n    __ Bind(\u0026nan);\n    __ Fcmp(in0, 0.0);\n    // if in0 is not a NaN than only in1 was a NaN and therefore return -1\n    __ B(vc, \u0026neg_one);\n    __ Fcmp(in1, 0.0);\n    // if in1 is not a NaN than only in0 was a NaN and return +1\n    __ Cset(out, vc);\n    //  If the execution reaches this point, it means both registers are NaN and return 0\n    __ B(\u0026end);\n\n    // in0 \u003d\u003d in1 or if one of the inputs is +0 and the other is -0\n    __ Bind(\u0026equal);\n    __ Fcmp(in0.V1D(), in1.V1D());\n    __ B(hi, \u0026neg_one);  // in0 is -0, in1 is +0\n    __ Cset(out, mi);    // in0 is +0, in1 is -0\n\n    __ Bind(\u0026end);",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f40ff36_158c3e99",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-21T23:20:19Z",
      "side": 1,
      "message": "Restructure the code by making the NaN case fallthrough and only forward branches, also fixed typos in the comments:\n\n    __ Fcmp(in0, in1);\n    __ Mov(out, 1);\n    __ B(gt, \u0026end);\n    __ B(mi, \u0026neg_one);\n    __ B(eq, \u0026equal);\n\n    // Either of the inputs is NaN.\n    // NaN is equal to itself and greater than any other number.\n    // Therefore:\n    // - if only in0 is NaN \u003d\u003e return 1\n    // - if only in1 is NaN \u003d\u003e return -1\n    // - if both in0 and in1 are NaN \u003d\u003e return 0\n    __ Fcmp(in0, 0.0);\n    __ B(vc, \u0026neg_one); // in0 !\u003d NaN \u003d\u003e out \u003d -1\n    __ Fcmp(in1, 0.0);\n    __ Cset(out, vc); // if in1 !\u003d NaN \u003d\u003e out \u003d 1, otherwise both are NaNs \u003d\u003e out \u003d 0\n    __ B(\u0026end);\n\n    // in0 \u003d\u003d in1 or if one of the inputs is +0 and the other is -0\n    __ Bind(\u0026equal);\n    __ Fcmp(in0.V1D(), in1.V1D());\n    __ B(hi, \u0026neg_one);  // in0 is -0, in1 is +0 \u003d\u003e out \u003d -1\n    __ Cset(out, mi);    // if in0 is +0 and in1 is -0 \u003d\u003e out \u003d 1, otherwise out \u003d 0\n    __ B(\u0026end);\n\n    // if in0 \u003c in1 or if only the 2nd input is NaN or in0 \u003d\u003d -0 and in1 \u003d\u003d +0\n    __ Bind(\u0026neg_one);\n    __ Mov(out, -1);\n\n    __ Bind(\u0026end);",
      "parentUuid": "52ca97ce_82022e46",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "030c4971_1fdf634e",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-11-22T10:31:34Z",
      "side": 1,
      "message": "Can you explain the meaning of the `__ Fcmp(in0.V1D(), in1.V1D());` in the `equal` path? Do we just interpret the value as `double` with the higher bits being zero and thus comparing denormal values and/or +0 (but never NaN)? Would it work if we compared just floats with V1S?\n\nIf my understanding of the above is correct, this can be further improved by making both the \"normal\" and \"equal\" paths feed the same CSET+CSINV:\n\n    __ Fcmp(in0, in1);\n    __ B(eq, \u0026equal);\n    __ B(vc, \u0026normal);\n\n    // Either of the inputs is NaN.\n    // NaN is equal to itself and greater than any other number.\n    // Therefore:\n    // - if only in0 is NaN \u003d\u003e return 1\n    // - if only in1 is NaN \u003d\u003e return -1\n    // - if both in0 and in1 are NaN \u003d\u003e return 0\n    __ Fcmp(in0, 0.0);\n    __ B(vc, \u0026neg_one); // in0 !\u003d NaN \u003d\u003e out \u003d -1\n    __ Fcmp(in1, 0.0);\n    __ Cset(out, vc); // if in1 !\u003d NaN \u003d\u003e out \u003d 1, otherwise both are NaNs \u003d\u003e out \u003d 0\n    __ B(\u0026end);\n\n    // in0 \u003d\u003d in1 or if one of the inputs is +0 and the other is -0\n    __ Bind(\u0026equal);\n    // Reverse operand order because -0 \u003e +0 when compared as `double`.\n    __ Fcmp(in1.V1D(), in0.V1D());\n\n    __ Bind(\u0026normal);\n    __ Cset(out, gt);\n    __ Csinv(out, out, xzr, pl);\n\n    __ Bind(\u0026end);\n\n\n(The NaN path can also be rewritten with CSETM+CSINC if we want to reduce the number of branches but the number of instructions would remain the same.)",
      "parentUuid": "6f40ff36_158c3e99",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "569c255f_ac852a97",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1576111
      },
      "writtenOn": "2019-11-22T11:07:57Z",
      "side": 1,
      "message": "At the point we have  __ Fcmp(in0.V1D(), in1.V1D()); we are just trying to compare +/-0. For that we need to compare more than 16 bits. In Neon ARM, we can only modify 64 bits or 128 bits at a time, which is why i believe there is no V1S, which is 32 bits. The possibilities are as seen in src/aarch64/operands-aarch64.h:\n\n  VRegister V8B() const { return VRegister(code_, kDRegSize, 8); }\n  VRegister V16B() const { return VRegister(code_, kQRegSize, 16); }\n  VRegister V2H() const { return VRegister(code_, kSRegSize, 2); }\n  VRegister V4H() const { return VRegister(code_, kDRegSize, 4); }\n  VRegister V8H() const { return VRegister(code_, kQRegSize, 8); }\n  VRegister V2S() const { return VRegister(code_, kDRegSize, 2); }\n  VRegister V4S() const { return VRegister(code_, kQRegSize, 4); }\n  VRegister V2D() const { return VRegister(code_, kQRegSize, 2); }\n  VRegister V1D() const { return VRegister(code_, kDRegSize, 1); }\n\n\nWe could use V2S (2 32bits) but the result wont be any different from V1D (1 64 bits). I believe V1D might be slightly better to understand for anyone reading it in the future.",
      "parentUuid": "030c4971_1fdf634e",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8614951_26cc6d61",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1576111
      },
      "writtenOn": "2019-11-22T11:09:20Z",
      "side": 1,
      "message": "The above code is in external/vixl/src/aarch64/operands-aarch64.h",
      "parentUuid": "569c255f_ac852a97",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac01a306_c1deccf3",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-11-22T11:24:21Z",
      "side": 1,
      "message": "Looking at that file, while there\u0027s no \"V1S()\", there is indeed \"S()\" which would be more appropriate for the scalar instruction FCMP. Even if you want to use a `double` comparison, you should use `D()` instead of `V1D()`.",
      "parentUuid": "a8614951_26cc6d61",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1fd3c44c_2d465898",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2019-11-22T11:34:26Z",
      "side": 1,
      "message": "It looks like we don\u0027t need \"Fcmp(in1.V1D(), in0.V1D())\" at all. We can compare original integer registers.",
      "parentUuid": "a8614951_26cc6d61",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e37e3d92_c73dd305",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1576111
      },
      "writtenOn": "2019-11-22T11:35:23Z",
      "side": 1,
      "message": "Evgeny pointed out that as we have access to input W register, Cmp would be faster than using Fcmp. Fcmp can take upto 3 cycles depending on the core. So will switch to using W register. This will mean i cant use the GenerateFP16Compare. I will post a new patch with the changes.",
      "parentUuid": "ac01a306_c1deccf3",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc1cef33_2132c2db",
        "filename": "compiler/optimizing/intrinsics_arm64.cc",
        "patchSetId": 1
      },
      "lineNbr": 3475,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2019-11-22T11:45:21Z",
      "side": 1,
      "message": "I have not reviewed your previous CLs but let me comment on the overall approach now. Your current approach contains a lot of unnecessary moves between W registers and S registers. You should specify all input and output locations as S registers for FP16 and let the parallel move resolver deal with moving things around if needed. If you have two chained FP16 operations and do not need to keep the intermediate result for any other calculation, you shall save 2 instructions.\n\nTherefore you should not use the W registers for the comparison in the \"equal\" path.",
      "parentUuid": "e37e3d92_c73dd305",
      "range": {
        "startLine": 3437,
        "startChar": 1,
        "endLine": 3475,
        "endChar": 18
      },
      "revId": "35692b5cbfb9b9d3b6cd0e220fac99686cee1114",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}