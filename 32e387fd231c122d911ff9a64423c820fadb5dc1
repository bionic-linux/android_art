{
  "comments": [
    {
      "key": {
        "uuid": "d529edd3_743414f1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 15,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2020-08-03T20:10:45Z",
      "side": 1,
      "message": "The benchmark part can be extracted to run on golem.\n\nI think we should keep the run-tests for correctness and if we need the benchmark we can put it to go/lem.",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 15,
        "endChar": 13
      },
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95c483da_9b97adc8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 15,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-08-03T22:25:21Z",
      "side": 1,
      "message": "I think the problem with that is that the benchmark was used to obtain the sets of 15 measurements for aosp/1331512. And I think we need all of them when evaluating BigInteger changes. I don\u0027t know of a way to generate groups of measurements like that in go/lem. Do we really want 15 BigInteger benchmarks in go/lem?\n\nThis is essentially a way of preserving the benchmarking code, getting some added test coverage, without regularly reporting a bunch of rather specialized benchmarks.\n\nIf we want something in go/lem (probably we do) I\u0027d suggest that we  limit it to the harmonic series benchmark run on something like 50 digit integers, and modPow run at 1000 digits, and leave it at those two. Two BigInteger benchmarks seems reasonable to me. (It might make sense to use BigDecimal for the first one, since that has better coverage, and the code is more natural.)",
      "parentUuid": "d529edd3_743414f1",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 15,
        "endChar": 13
      },
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d75a4fb_febf36f3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 6
      },
      "lineNbr": 15,
      "author": {
        "id": 1022077
      },
      "writtenOn": "2020-08-04T01:01:07Z",
      "side": 1,
      "message": "In go/lem you can run the benchmarks with a WIP CL which does not require submission: so it should be easy to analyze and leaves a trace (so it\u0027s easier to quote and not subject to possible error measurements). \n\nI don\u0027t have a strong opinion whether or not we want to run these specialized benchmarks all the time: are they expensive? if they are fast to run we might as well.\n\nDaulet/Pete, does libcore have any other benchmarks?",
      "parentUuid": "95c483da_9b97adc8",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 15,
        "endChar": 13
      },
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da162870_0a5ff6a3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2020-08-04T13:40:19Z",
      "side": 1,
      "message": "Hi Hans,\n\nI ran the Pi digits benchmark (https://android-git.linaro.org/linaro/art-testing.git/tree/benchmarks/benchmarksgame/pidigits.java) for aosp/1331512 on Pixel 2. \u0027aosp/1331512\u0027 is 3.5 times slower than the current implementation. BigInteger hottest methods:\n\n7.53%     java.math.BigInteger.multiplyByInt\n6.67%     java.math.BigInteger.divideAndRemainder\n2.97%     java.math.BigInteger.add\n2.88%     java.math.BigInteger.subtract\n1.52%     java.math.BigInteger.shiftLeft\n0.13%     java.math.BigInteger.multiply\n",
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "12349692_ccdbe860",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2020-08-04T16:04:15Z",
      "side": 1,
      "message": "I also found another benchmark which uses BigInteger: http://gas.dia.unisa.it/projects/jpbc/benchmark.html",
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "88986259_bd1741ea",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1308278
      },
      "writtenOn": "2020-08-05T16:49:26Z",
      "side": 1,
      "message": "To increase the running time I made the following changes to the benchmark:\n\n```\ndiff --git a/benchmarks/benchmarksgame/pidigits.java b/benchmarks/benchmarksgame/pidigits.java\nindex ce67e73..fc47289 100644\n--- a/benchmarks/benchmarksgame/pidigits.java\n+++ b/benchmarks/benchmarksgame/pidigits.java\n@@ -28,7 +28,9 @@ import java.math.BigInteger;\n public class pidigits {\n // CHECKSTYLE.ON: TypeName\n   static final int L \u003d 10;\n-  private static final int PREDEFINED_N_DIGITS \u003d 27;\n+  private static final int PREDEFINED_N_DIGITS \u003d 5000;\n+\n+  public int[] ds;\n\n   public static void old_main() {\n     int n \u003d PREDEFINED_N_DIGITS;\n@@ -36,15 +38,10 @@ public class pidigits {\n\n     PiDigitSpigot digits \u003d new PiDigitSpigot();\n\n-    while (n \u003e 0) {\n-      if (n \u003e\u003d L) {\n-        for (int i \u003d 0; i \u003c L; i++) digits.next();\n-        j +\u003d L;\n-      } else {\n-        for (int i \u003d 0; i \u003c n; i++) digits.next();\n-        j +\u003d n;\n-      }\n-      n -\u003d L;\n+    int[] ds \u003d new int[n];\n+\n+    for (int i \u003d 0; i \u003c n; ++i) {\n+      ds[i] \u003d digits.next();\n     }\n   }\n\n@@ -55,18 +52,6 @@ public class pidigits {\n   }\n\n   public boolean verifyPidigits() {\n-    PiDigitSpigot digits \u003d new PiDigitSpigot();\n-\n-    for (int i \u003d 0; i \u003c PREDEFINED_N_DIGITS; ++i) {\n-      digits.next();\n-    }\n-    int expected \u003d 3;\n-    int found \u003d digits.next();\n-\n-    if (expected !\u003d found) {\n-      System.out.println(\"ERROR: Expected \" + expected + \" but found \" + found);\n-      return false;\n-    }\n     return true;\n   }\n```",
      "parentUuid": "da162870_0a5ff6a3",
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e0a9a6ec_8fadce52",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-08-06T00:11:53Z",
      "side": 1,
      "message": "I looked a bit at what this does on host. It didn\u0027t seem to actually produce digits of pi. It seems to build up rather large numbers (on the order of the number of digits being computed, maybe a bit more) inside the transformations. So it\u0027s mostly either dividing two numbers of very similar magnitude, or performing operations on one very large and one small integer. Everything is thus linear time.\n\nWith the original 27 digit version of the benchmark, I would expect the OpenJDK code to be much faster than the current code, since OpenJDK avoids all the reference processing. With the modified version, your result is much less surprising. I would expect OpenJDK to be slower since the reference processing is much less significant, and:\n\n1) It uses 32- rather than 64-bit digits.\n2) The inner loop is Java rather than C++.\n3) We may be garbage collecting more frequently and using less space because everything is now in the Java heap\n\nBut I\u0027m also probably handling this case poorly in division. I believe I currently fall back to boringssl if both arguments are large, even if they\u0027re of similar size. That\u0027s probably a mistake. I\u0027ll revisit.",
      "parentUuid": "da162870_0a5ff6a3",
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b6cfd13_c8b4c6a7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2020-08-12T04:37:23Z",
      "side": 1,
      "message": "PS6 of the BigInteger CL should remove a large part of this regression. For linear operations (e.g. multiplication by a small integer) on very large integers, we may still lose a little. But I was also not handling divisions of roughly equal-sized operands very well.",
      "parentUuid": "e0a9a6ec_8fadce52",
      "revId": "32e387fd231c122d911ff9a64423c820fadb5dc1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}