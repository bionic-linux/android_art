{
  "comments": [
    {
      "key": {
        "uuid": "8b5ca306_87d33060",
        "filename": "compiler/optimizing/licm.cc",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-11-11T14:07:49Z",
      "side": 1,
      "message": "We should also make it clear in the comment it\u0027s in the loop header only. Since other loop blocks may not be executed. Loop header also rules out that the can-throw instruction can move in front of a try boundary within the loop, since try boundary introduces additional blocks so the can-throw instruction can\u0027t be in the loop header. So it rules out something like:\ntry {\n  int i \u003d 0;\n  do {\n    try {\n      i \u003d 1;    // even though there is no field store, following NullCheck should not be hoisted.\n    } catch(Exception e) {}\n  } while (arr.length \u003c 10)\n} catch (Exception e) {}",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b5ca306_e7130c3c",
        "filename": "compiler/optimizing/licm.cc",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-11-11T14:16:04Z",
      "side": 1,
      "message": "Actually if we have:\ni \u003d 0;\ntry {\n  do {\n      i \u003d 1;    // even though there is no field store, following NullCheck should not be hoisted.\n  } while (arr.length \u003c 10)\n} catch (Exception e) {}\n\nThat still doesn\u0027t look right. Do we guard against this case? Looks like the whole thing can\u0027t be in a try block.",
      "parentUuid": "8b5ca306_87d33060",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8be74356_20c98ab3",
        "filename": "compiler/optimizing/licm.cc",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-11-11T14:31:30Z",
      "side": 1,
      "message": "The \"i\" at the NullCheck is a constant, i.e. defined before the loop. NullCheck can be hoisted, the environment will contain that constant. (If the assignment was something more complex, say \"i \u003d (i + 3) ^ 2\", we would not hoist. Simple \"i +\u003d 1\" falls under https://android-review.googlesource.com/301687 .)",
      "parentUuid": "8b5ca306_e7130c3c",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b5ca306_f27f48ca",
        "filename": "compiler/optimizing/licm.cc",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-11T17:30:39Z",
      "side": 1,
      "message": "I played around with those cases as well while working on both cls. When we have explicit catches that can see the local i, we don\u0027t LICM anyway due to the try boundaries. If we don\u0027t have those, so only the method throws, i is not visible, except for possible an environment, which we capture correctly. So perhaps only deopts are a concern if we ever see them in licm.",
      "parentUuid": "8b5ca306_e7130c3c",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b5ca306_5f02bc71",
        "filename": "compiler/optimizing/licm.cc",
        "patchSetId": 1
      },
      "lineNbr": 123,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-11-11T20:45:33Z",
      "side": 1,
      "message": "I\u0027ve played with it more and I think we are good even with try-catch.",
      "parentUuid": "8b5ca306_f27f48ca",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4bf54bfd_fe2581c7",
        "filename": "test/625-checker-licm-regressions/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-11-11T10:37:00Z",
      "side": 1,
      "message": "This test isn\u0027t very future-proof. The StaticFieldSet could be hoisted and then the NullCheck+ArrayLength would be hoisted as well. Maybe we should add something like \"j \u003d (j+3)^2\" and change the store to \"sA \u003d j\".",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b5ca306_47c918b2",
        "filename": "test/625-checker-licm-regressions/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1043514
      },
      "writtenOn": "2016-11-11T14:07:49Z",
      "side": 1,
      "message": "StaticFieldSet can\u0027t move so it won\u0027t be hoisted.\nI tried yesterday to have other patterns and it\u0027s quite difficult to allow the NullCheck to be hoisted since it\u0027s easy to introduce loop_effects that NullCheck depends on.",
      "parentUuid": "4bf54bfd_fe2581c7",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6bba0f39_6f3d517f",
        "filename": "test/625-checker-licm-regressions/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-11-11T14:19:42Z",
      "side": 1,
      "message": "Non-volatile StaticFieldSet that always stores the same value and is executed at least once is a perfect candidate for hoisting if there are no other writes to memory observable by other threads. (Not by the current LICM though.)",
      "parentUuid": "8b5ca306_47c918b2",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2bf2d718_808a18fd",
        "filename": "test/625-checker-licm-regressions/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-11-11T14:23:33Z",
      "side": 1,
      "message": "Actually, it\u0027s not exactly LICM. It\u0027s something like LICM-enhanced LSE.",
      "parentUuid": "6bba0f39_6f3d517f",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b5ca306_b2a31055",
        "filename": "test/625-checker-licm-regressions/src/Main.java",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1074526
      },
      "writtenOn": "2016-11-11T17:30:39Z",
      "side": 1,
      "message": "Well is is a regression test. I also have some follow up tests planned in combination with the other Cl to make sure those are not messed up. Will add those when merged.",
      "parentUuid": "4bf54bfd_fe2581c7",
      "revId": "5c628bffc62b0ec718bad3ec65375a73615c628b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}