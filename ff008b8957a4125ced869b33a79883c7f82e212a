{
  "comments": [
    {
      "key": {
        "uuid": "9f448158_8f5b153f",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 411,
      "author": {
        "id": 1042649
      },
      "writtenOn": "2014-11-21T10:30:42Z",
      "side": 1,
      "message": "This generates more ldr/str for split long(ignoring arm soft-float), but it really make things easier and fits all targets.",
      "range": {
        "startLine": 410,
        "startChar": 0,
        "endLine": 411,
        "endChar": 31
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df3a79c4_11a2acb6",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 411,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-11-21T10:50:16Z",
      "side": 1,
      "message": "I agree with you. If it is an performance problem we can handle this in more optimal way, say to add a check if destination is promoted reg then run virtual function like OpRegCopy(dest_wide_reg, reg, mem location) and each architecture can implement this in its way (taking into account that dest_wide_reg can be fp).\n\nI would prefer to do this optimization (if it is required) in a separate CL if you do not mind. If this is a critical, let me know and I will update a code.",
      "parentUuid": "9f448158_8f5b153f",
      "range": {
        "startLine": 410,
        "startChar": 0,
        "endLine": 411,
        "endChar": 31
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f448158_0faf2577",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 411,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-11-21T11:06:29Z",
      "side": 1,
      "message": "By the way the similar pattern can be met in several other places (everywhere we should handle split long). They are LoadArg, LoadArgDirect and GenDalvikArgs. If we decide to fix this we should fix that places as well.",
      "parentUuid": "df3a79c4_11a2acb6",
      "range": {
        "startLine": 410,
        "startChar": 0,
        "endLine": 411,
        "endChar": 31
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f526d24_46eab288",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 411,
      "author": {
        "id": 1042649
      },
      "writtenOn": "2014-11-21T11:21:44Z",
      "side": 1,
      "message": "Yes, that\u0027s great you\u0027ve removed the assumption that 64-bit register is always 32-bit pairs in all these places, so that we can also remove the redundant source code in int_arm.cc and utility_arm.cc which has TODO comment talking about this.",
      "parentUuid": "9f448158_0faf2577",
      "range": {
        "startLine": 410,
        "startChar": 0,
        "endLine": 411,
        "endChar": 31
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f526d24_86454a10",
        "filename": "compiler/dex/quick/gen_invoke.cc",
        "patchSetId": 1
      },
      "lineNbr": 411,
      "author": {
        "id": 1042649
      },
      "writtenOn": "2014-11-21T11:21:44Z",
      "side": 1,
      "message": "It is something could do, but I don\u0027t it is critical.",
      "parentUuid": "df3a79c4_11a2acb6",
      "range": {
        "startLine": 410,
        "startChar": 0,
        "endLine": 411,
        "endChar": 31
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "df3a79c4_512394d4",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1777,
      "author": {
        "id": 1042649
      },
      "writtenOn": "2014-11-21T10:30:42Z",
      "side": 1,
      "message": "How about \"GetNextReg(char type)\"?",
      "range": {
        "startLine": 1777,
        "startChar": 25,
        "endLine": 1777,
        "endChar": 87
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f526d24_c6990252",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1777,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-11-21T10:50:16Z",
      "side": 1,
      "message": "This is an interface to implement by each arch, so in the case of \"char type\" each architecture will need to parse this char. So I prefer to do it in common code and provide only required information. That was my intent.",
      "parentUuid": "df3a79c4_512394d4",
      "range": {
        "startLine": 1777,
        "startChar": 25,
        "endLine": 1777,
        "endChar": 87
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f448158_8fbaf5ad",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1777,
      "author": {
        "id": 1042649
      },
      "writtenOn": "2014-11-21T11:21:44Z",
      "side": 1,
      "message": "I think parse the char is more clean. And we parse char or PrimitiveType directly to map in registers in all other places, such as trampoline , jni compiler, optimising compiler.",
      "parentUuid": "7f526d24_c6990252",
      "range": {
        "startLine": 1777,
        "startChar": 25,
        "endLine": 1777,
        "endChar": 87
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7f526d24_4604f2ef",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1786,
      "author": {
        "id": 1042649
      },
      "writtenOn": "2014-11-21T10:30:42Z",
      "side": 1,
      "message": "How about const char* or std::string?",
      "range": {
        "startLine": 1786,
        "startChar": 22,
        "endLine": 1786,
        "endChar": 36
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f448158_afd37910",
        "filename": "compiler/dex/quick/mir_to_lir.h",
        "patchSetId": 1
      },
      "lineNbr": 1786,
      "author": {
        "id": 1040038
      },
      "writtenOn": "2014-11-21T10:50:16Z",
      "side": 1,
      "message": "I guess shorty iterator is a more general case (you may extend it and provide any implementation you want). If we provide shorty as string we need also provide whether call is static or not. So I decided to do in this way.",
      "parentUuid": "7f526d24_4604f2ef",
      "range": {
        "startLine": 1786,
        "startChar": 22,
        "endLine": 1786,
        "endChar": 36
      },
      "revId": "ff008b8957a4125ced869b33a79883c7f82e212a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}