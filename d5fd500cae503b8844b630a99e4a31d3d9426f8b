{
  "comments": [
    {
      "key": {
        "uuid": "2d3aa6f6_c36ae8de",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-07-23T15:23:58Z",
      "side": 1,
      "message": "How do we handle Intel 80bit floating-point related issues?",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d862697_60fff29f",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2015-07-28T09:47:48Z",
      "side": 1,
      "message": "I thought all our operations in x86/x86-64 were only 32- or 64-bit; is there any place where we use 80-bit operations?",
      "parentUuid": "2d3aa6f6_c36ae8de",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d8962a8_ff0f1f6a",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-07-28T10:21:18Z",
      "side": 1,
      "message": "I meant, do we pay attention that we compile with gcc/clang flags disabling (not enabling?) 80bit float in the C++ compiled code? Otherwise the `ComputeFP` functions could operate with a higher precision than what should happen, and we could get \u0027wrong\u0027 results out of constant propagation.",
      "parentUuid": "2d862697_60fff29f",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d7fda4c_21524e35",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2015-07-28T11:08:35Z",
      "side": 1,
      "message": "Oh right, I thought you were talking about the code generated by ART/dex2oat.  Thanks for pointing that out!  I\u0027ll look at the options here (using compile flags; or maybe using special instructions, such as SSE) and I\u0027ll update the CL.",
      "parentUuid": "0d8962a8_ff0f1f6a",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd174afa_953c2481",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-07-28T16:03:39Z",
      "side": 1,
      "message": "I don\u0027t think this really matters. It seems rather unlikely that there will be code produced that doesn\u0027t use intermediates. For some reason, multiple operations would have to line up somewhere. I don\u0027t think the driver for the constant folding looks that way. (I\u0027d contend that any inliner/unroller that produces such code is a bit insane.)",
      "parentUuid": "0d8962a8_ff0f1f6a",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}