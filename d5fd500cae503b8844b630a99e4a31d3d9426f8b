{
  "comments": [
    {
      "key": {
        "uuid": "2d3aa6f6_c36ae8de",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-07-23T15:23:58Z",
      "side": 1,
      "message": "How do we handle Intel 80bit floating-point related issues?",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d862697_60fff29f",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2015-07-28T09:47:48Z",
      "side": 1,
      "message": "I thought all our operations in x86/x86-64 were only 32- or 64-bit; is there any place where we use 80-bit operations?",
      "parentUuid": "2d3aa6f6_c36ae8de",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d8962a8_ff0f1f6a",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-07-28T10:21:18Z",
      "side": 1,
      "message": "I meant, do we pay attention that we compile with gcc/clang flags disabling (not enabling?) 80bit float in the C++ compiled code? Otherwise the `ComputeFP` functions could operate with a higher precision than what should happen, and we could get \u0027wrong\u0027 results out of constant propagation.",
      "parentUuid": "2d862697_60fff29f",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d7fda4c_21524e35",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2015-07-28T11:08:35Z",
      "side": 1,
      "message": "Oh right, I thought you were talking about the code generated by ART/dex2oat.  Thanks for pointing that out!  I\u0027ll look at the options here (using compile flags; or maybe using special instructions, such as SSE) and I\u0027ll update the CL.",
      "parentUuid": "0d8962a8_ff0f1f6a",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cd174afa_953c2481",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-07-28T16:03:39Z",
      "side": 1,
      "message": "I don\u0027t think this really matters. It seems rather unlikely that there will be code produced that doesn\u0027t use intermediates. For some reason, multiple operations would have to line up somewhere. I don\u0027t think the driver for the constant folding looks that way. (I\u0027d contend that any inliner/unroller that produces such code is a bit insane.)",
      "parentUuid": "0d8962a8_ff0f1f6a",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d7fda4c_21fece2d",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-07-28T16:36:32Z",
      "side": 1,
      "message": "I think that is incorrect and that the issue can happen for a single operation.\nIf 80bit FP is enabled, the operation can happen with more precision, and when rounded back to 64bit FP the value can be different. I think we have seen this issue in real-world examples when working on the VIXL simulator.",
      "parentUuid": "cd174afa_953c2481",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d862697_a053baeb",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052644
      },
      "writtenOn": "2015-07-28T16:40:30Z",
      "side": 1,
      "message": "I\u0027ll try to come up with an example and turn it into a test.\n\nRegarding the fix, I like the idea of using SSE intrinsics, as it is the closest to what we use in the x86 \u0026 x86-64 back ends.",
      "parentUuid": "4d7fda4c_21fece2d",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d657ec3_daa8a563",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-07-28T16:42:07Z",
      "side": 1,
      "message": "This is a tricky issue when cross-compiling. The compiler must know how to evaluate the FP expression exactly as the target would evaluate it if we actually emitted the code for it.",
      "parentUuid": "2d862697_a053baeb",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ad9936fb_9c37059c",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1052304
      },
      "writtenOn": "2015-07-28T16:47:37Z",
      "side": 1,
      "message": "There should be tests and code for that in the VIXL simulator that can serve as examples. I\u0027ll try to find exacly where and send you the details.",
      "parentUuid": "6d657ec3_daa8a563",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ad1696fe_57ce0ea5",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-07-28T16:58:11Z",
      "side": 1,
      "message": "Alex: really? If things are stored into doubles, shouldn\u0027t things be correctly rounded for a *single* operation?\n\nMark: I added you to the bug to chime in on that... :-)",
      "parentUuid": "4d7fda4c_21fece2d",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed1c0e21_d9d1b7ca",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-07-28T16:58:11Z",
      "side": 1,
      "message": "vmarko: No, you don\u0027t need to know how the target would evaluate it. You just need to follow IEEE-754, as that is what Java mandates...",
      "parentUuid": "6d657ec3_daa8a563",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed1c0e21_19296f3a",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2015-07-28T17:10:09Z",
      "side": 1,
      "message": "The existing x86 compilers will use XMM instructions to compute this, which will be IEEE compliant. I can\u0027t see a modern compiler using the 80 bit FP instructions.  I am okay with it as it is.",
      "parentUuid": "ed1c0e21_d9d1b7ca",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4d68ba9e_9910fb11",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2015-07-28T17:27:55Z",
      "side": 1,
      "message": "Reading the Wiki, it seems to me that IEEE-754 compliance is not enough to guarantee the very same results. See \"Expression evaluation\" and \"Reproducibility\" at\n\n    https://en.wikipedia.org/wiki/IEEE_floating_point#Expression_evaluation\n\nAnd even if Java mandates a specific behavior, is there any guarantee for C++11 compilers? The C++ standard provides for a lot of implementation-defined behavior.",
      "parentUuid": "ed1c0e21_19296f3a",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6dae5efb_12caecc2",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1036869
      },
      "writtenOn": "2015-07-28T17:32:39Z",
      "side": 1,
      "message": "This is theoretically true, but in practice is probably irrelevant.  If you really want to do this portably, you should be using a software IEEE-754 implementation that does what Java wants.  Then it doesn\u0027t matter on what machine this is executed on.  I have seen this on other compilers I have worked on.",
      "parentUuid": "4d68ba9e_9910fb11",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6dae5efb_b5d94a6f",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-07-28T18:16:36Z",
      "side": 1,
      "message": "AFAIK the JLS provides clear guidance. Expression evaluation doesn\u0027t apply here, as long as the folding takes both precedence and order specified in the JLS into account (both of which are above the ComputeFP).\n\nI did not want to intimate that we can rely on C++11 guarantees. I just wanted to state that it doesn\u0027t matter what the target does. The target must be doing it as defined by the JLS (which is double precision, not 80b, with defined rounding mode), or we\u0027re doing things wrong...",
      "parentUuid": "4d68ba9e_9910fb11",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2db8e63c_33bd72b1",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2015-07-28T18:16:36Z",
      "side": 1,
      "message": "A library would make all this definite. But honestly we\u0027d have to change the interpreter then, too. Instead we may check for the compiler support. Googling gives, for example:\n http://stackoverflow.com/questions/5777484/how-to-check-if-c-compiler-uses-ieee-754-floating-point-standard\nhboehm, danalbert and srhines may have opinions.",
      "parentUuid": "6dae5efb_12caecc2",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4db19a56_bad9356f",
        "filename": "compiler/optimizing/nodes.h",
        "patchSetId": 3
      },
      "lineNbr": 3327,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2015-07-28T21:10:46Z",
      "side": 1,
      "message": "As far as I can tell:\n\n1) C and C++ allow 80 bit arithmetic, though everybody is probably right that this is unlikely in practice with modern compiler options.\n2) 80 bit operations can give the wrong results by Java rules, under unlikely conditions, even for a single operation.  Consider an operation that has to very slightly round up to get the nearest 80 bit result x.  Assume that x is half-way between the two closest 64 bit results, and the higher one is even.  Thus rounding to 64 bits gets us the higher value, which is not the nearest 64-bit result to the true answer.\n\nThus doing this portably and correctly, probably does require a library.  Or possibly just checking our compiler options might do.\n\nI\u0027m also not positive that C++ arithmetic will handle denormals correctly.  That presumably also depends on compiler flags.",
      "parentUuid": "6dae5efb_b5d94a6f",
      "revId": "d5fd500cae503b8844b630a99e4a31d3d9426f8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}