{
  "comments": [
    {
      "key": {
        "uuid": "ad833f54_bb047bc8",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 3
      },
      "lineNbr": 440,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-12-06T19:43:55Z",
      "side": 1,
      "message": "Is it better to use a different type? In the future, this is likely to allow accidental access through the normal standard library mechanism, which may rely on locks instead, and thus wouldn\u0027t provide atomicity with respect to these.",
      "range": {
        "startLine": 440,
        "startChar": 6,
        "endLine": 440,
        "endChar": 35
      },
      "revId": "e3c04453299813f9cd94b995ecb83cd5c7bc163b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0d5d2bd4_e5bc96a0",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 3
      },
      "lineNbr": 440,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-12-06T20:01:43Z",
      "side": 1,
      "message": "In future, when normal 16-byte atomics are supported by the standard library, this workaround should go away. There is no reason why we should have 2 different ways to performing the same operation.",
      "parentUuid": "ad833f54_bb047bc8",
      "range": {
        "startLine": 440,
        "startChar": 6,
        "endLine": 440,
        "endChar": 35
      },
      "revId": "e3c04453299813f9cd94b995ecb83cd5c7bc163b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da6aeb2c_f2b5f6ab",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 3
      },
      "lineNbr": 440,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-12-14T01:33:22Z",
      "side": 1,
      "message": "I remain nervous about relying on the fact the the compiler is broken to ensure that this doesn\u0027t get mixed with conventional atomic accesses.\n\nIf you really want to avoid locks here, then I\u0027m not sure this \"workaround\" can ever go away. I would personally not want a compiler to use this implementation implicitly, since it requires that loads have write permission. The \"fixed\" compiler may well use an underlying lock table (as it already should).",
      "parentUuid": "0d5d2bd4_e5bc96a0",
      "range": {
        "startLine": 440,
        "startChar": 6,
        "endLine": 440,
        "endChar": 35
      },
      "revId": "e3c04453299813f9cd94b995ecb83cd5c7bc163b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7aa1ffa9_102c44c8",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 3
      },
      "lineNbr": 440,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2016-12-14T11:27:52Z",
      "side": 1,
      "message": "Why is it so wrong for a compiler to assume that you have the write permission?",
      "parentUuid": "da6aeb2c_f2b5f6ab",
      "range": {
        "startLine": 440,
        "startChar": 6,
        "endLine": 440,
        "endChar": 35
      },
      "revId": "e3c04453299813f9cd94b995ecb83cd5c7bc163b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "da6aeb2c_e539ad01",
        "filename": "runtime/mirror/dex_cache.h",
        "patchSetId": 3
      },
      "lineNbr": 440,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2016-12-14T18:35:19Z",
      "side": 1,
      "message": "This is all well beyond any standard, so \"wrong\" is too strong. But it breaks code that I would expect to work, at least if is_lock_free() is true. Do you know if it does?\n\nIf I use atomics in a shared memory segment to communicate with another process, it\u0027s perfectly reasonable to map the segment read-only, and read from atomics.\n\nHaving is_lock_free return true and read-only accesses cause cache contention also seems really questionable.\n\nWith this implementation, it\u0027s also not at all clear what you can possibly do if some joker uses a load on a 16-bit volatile atomic. Generating a store really seems to be against the rules.\n\nLet me start an external email discussion on this issue. This is an ABI (and maybe API) issue, so I think it\u0027s really ARM\u0027s (and maybe WG21s) job to resolve this.",
      "parentUuid": "7aa1ffa9_102c44c8",
      "range": {
        "startLine": 440,
        "startChar": 6,
        "endLine": 440,
        "endChar": 35
      },
      "revId": "e3c04453299813f9cd94b995ecb83cd5c7bc163b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}