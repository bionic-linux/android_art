{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3b4e6940_628f5ebd",
        "filename": "runtime/jit/jit.cc",
        "patchSetId": 1
      },
      "lineNbr": 262,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-04-27T10:46:58Z",
      "side": 1,
      "message": "This is a very odd RAII class because you need to acquire the resource before construction and then we release it in destructor.\n\nCan we instead try to acquire the resource in the constructor instead of external callers? We would then have `bool IsValid()` to indicate whether we should proceed with the compilation and also whether to release the resource in destructor.\n\nWe would need to make this movable, so that we can transfer ownership to a new `JitCompileTask` after we have checked that the compilation should proceed.",
      "range": {
        "startLine": 262,
        "startChar": 6,
        "endLine": 262,
        "endChar": 23
      },
      "revId": "6621c99eb3d1a7ec40f4de1149430150f23faca3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7efe4cf7_7aa868b2",
        "filename": "runtime/jit/jit_code_cache.h",
        "patchSetId": 1
      },
      "lineNbr": 553,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-04-26T14:19:03Z",
      "side": 1,
      "message": "The ArtMethods, to which we store pointers in these sets, are the same that get allocated in ArtMethod arrays during class loading, right?\n\nIf so, then I don\u0027t think we need to visit them as roots (in Runtime::VisitConcurrentRoots()) during GC. Be it CC or the new GC, they will get visited either during graph traversal (by calling VisitNativeRoots() on classes) or via the (yet to be implemented) userfaultfd-protected space which will have all ArtMethod/ArtField arrays allocated in it.\n\nPlease let me know if I\u0027m missing something.",
      "range": {
        "startLine": 550,
        "startChar": 2,
        "endLine": 553,
        "endChar": 0
      },
      "revId": "6621c99eb3d1a7ec40f4de1149430150f23faca3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "feb78306_f19f97fd",
        "filename": "runtime/jit/jit_code_cache.h",
        "patchSetId": 1
      },
      "lineNbr": 553,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2022-04-26T14:23:58Z",
      "side": 1,
      "message": "Visiting them here prevents class unloading, in case the class loader becomes unreachable. What you mention I think works when the class loader is reachable in Java land, but when it stops being reachable, we need to visit those methods to make sure their classes stay live.",
      "parentUuid": "7efe4cf7_7aa868b2",
      "range": {
        "startLine": 550,
        "startChar": 2,
        "endLine": 553,
        "endChar": 0
      },
      "revId": "6621c99eb3d1a7ec40f4de1149430150f23faca3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a57d0bd_96b21c6f",
        "filename": "runtime/jit/jit_code_cache.h",
        "patchSetId": 1
      },
      "lineNbr": 553,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2022-04-27T06:55:06Z",
      "side": 1,
      "message": "That makes sense. Thanks for reminding ðŸ˜Š",
      "parentUuid": "feb78306_f19f97fd",
      "range": {
        "startLine": 550,
        "startChar": 2,
        "endLine": 553,
        "endChar": 0
      },
      "revId": "6621c99eb3d1a7ec40f4de1149430150f23faca3",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}