{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1c16dec4_b509cd7d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-03-25T16:11:36Z",
      "side": 1,
      "message": "I\u0027m a bit surprised that it crashes. We are simply deferring GC trigger.",
      "range": {
        "startLine": 19,
        "startChar": 7,
        "endLine": 19,
        "endChar": 48
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "446ecedf_f586dbc8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-03-25T17:48:07Z",
      "side": 1,
      "message": "It has to so with forking dex2oat from zygote and acquiring a lock that probably wasn\u0027t previously acquired there, but now is by  SetDefaultConcurrentStartBytes. Still investigating.",
      "parentUuid": "1c16dec4_b509cd7d",
      "range": {
        "startLine": 19,
        "startChar": 7,
        "endLine": 19,
        "endChar": 48
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c06524b6_c4370992",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-03-25T02:39:55Z",
      "side": 1,
      "message": "Lokesh -\n\nDo you understand why the garbage collection task itself does not simply hold a mutex during the GC, to prevent multiple concurrent GCs?\n\nWe do only allow one GC at a time. But the mechanism for doing that seems needlessly complicated, involving gc_complete_lock, and a field protected by it. We seem to be emulating a mutex with a mutex. This CL attempts to document a little better what we do, but I\u0027m not sure it\u0027s necessary.",
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9cb21136_873e068a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-03-25T16:11:36Z",
      "side": 1,
      "message": "\u003e Lokesh -\n\u003e \n\u003e Do you understand why the garbage collection task itself does not simply hold a mutex during the GC, to prevent multiple concurrent GCs?\n\u003e \n\nI\u0027m not fully sure, but I guess if were to do that then couldn\u0027t have synchronized blocking GC calls with non-blocking (via GC-task) ones. That\u0027s why it was necessary to keep that synchronization deeper in the call graph.\n\n\u003e We do only allow one GC at a time. But the mechanism for doing that seems needlessly complicated, involving gc_complete_lock, and a field protected by it. We seem to be emulating a mutex with a mutex. This CL attempts to document a little better what we do, but I\u0027m not sure it\u0027s necessary.\n\nMaybe I missed. can you point me to where have you explained that logic?",
      "parentUuid": "c06524b6_c4370992",
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6aa52a7c_130693a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-04-24T01:41:14Z",
      "side": 1,
      "message": "I\u0027ve added a few more comments in heap.h about how things are protected against concurrent access, but nothing major.\nA lot of things seem to be effectively protected by a combination of collector_type_running_ and gc_complete_lock_ . Superficially, it seems much simpler to hold a lock during the entire GC, where we now just set collector_type_running_",
      "parentUuid": "9cb21136_873e068a",
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15f30fe0_f960730f",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 2130,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-03-25T16:11:36Z",
      "side": 1,
      "message": "kMaxConcurrentRemainingBytes is too small (only 512KB). We should consider increasing it. Also, should we be using the heap_growth_multiplier_ here?\n\nWhat\u0027s the reasoning behind using reserved_bytes. Can\u0027t we directly use kMaxConcurrentRemainingBytes against target_footprint?",
      "range": {
        "startLine": 2130,
        "startChar": 4,
        "endLine": 2130,
        "endChar": 74
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d639af47_a67fad2b",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 2130,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-03-25T17:48:07Z",
      "side": 1,
      "message": "Some of the use cases previously used half the target footprint, others used the minimum. I\u0027m trying to compromise and switch to a common algorithm. I agree the maximum is too small. I may increase it, but I think that has the potential to affect performance. So it should probably be a separate CL.",
      "parentUuid": "15f30fe0_f960730f",
      "range": {
        "startLine": 2130,
        "startChar": 4,
        "endLine": 2130,
        "endChar": 74
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c4a18a1_6ba89abd",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 2130,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-04-24T01:41:14Z",
      "side": 1,
      "message": "After thinking about it, I don\u0027t think it makes sense to include HeapGrowthMultiplier here. We\u0027re basically computing a guess as to how long it will take to GC.",
      "parentUuid": "d639af47_a67fad2b",
      "range": {
        "startLine": 2130,
        "startChar": 4,
        "endLine": 2130,
        "endChar": 74
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a664b237_5d11de62",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 4457,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-03-25T16:11:36Z",
      "side": 1,
      "message": "I think you missed setting concurrent_start_bytes_ here.",
      "range": {
        "startLine": 4457,
        "startChar": 4,
        "endLine": 4457,
        "endChar": 59
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aaf9c2d7_b5927a7d",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 4457,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-03-25T17:48:07Z",
      "side": 1,
      "message": "Yes. Thanks.",
      "parentUuid": "a664b237_5d11de62",
      "range": {
        "startLine": 4457,
        "startChar": 4,
        "endLine": 4457,
        "endChar": 59
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ccaaac80_2ef5c50d",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 4457,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-04-24T01:44:30Z",
      "side": 1,
      "message": "Forgot to mark resolved.",
      "parentUuid": "aaf9c2d7_b5927a7d",
      "range": {
        "startLine": 4457,
        "startChar": 4,
        "endLine": 4457,
        "endChar": 59
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6bb56c1b_7c9d2f94",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 4466,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-03-25T16:11:36Z",
      "side": 1,
      "message": "Why so low? Shouldn\u0027t we set it to what the heap would have been if all this logic wasn\u0027t there, which I think is \u0027initial heap size\u0027?",
      "range": {
        "startLine": 4466,
        "startChar": 44,
        "endLine": 4466,
        "endChar": 57
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b20efb7_783a1ae0",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 4466,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-03-25T17:48:07Z",
      "side": 1,
      "message": "I agree. I\u0027ll fix.",
      "parentUuid": "6bb56c1b_7c9d2f94",
      "range": {
        "startLine": 4466,
        "startChar": 44,
        "endLine": 4466,
        "endChar": 57
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9c47e55d_66a36851",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 4466,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-04-24T01:44:30Z",
      "side": 1,
      "message": "Forgot to mark resolved.",
      "parentUuid": "7b20efb7_783a1ae0",
      "range": {
        "startLine": 4466,
        "startChar": 44,
        "endLine": 4466,
        "endChar": 57
      },
      "revId": "fe738e6b3a99bfc8c1913f2ea660368cc880f13f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}