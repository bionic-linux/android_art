{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d9361094_d8ca20e9",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-17T18:11:55Z",
      "side": 1,
      "message": "I think this ratio will be close to 1.0 most of the time. The GC thread hardly gets suspended and hence ThreadCpuNanoTime() readings will be hardly any different from NanoTime().\n\nMore importantly, what you are trying to measure here (as per the commit message) is definitely not happening. ProcessCpuNanoTime() would make more sense than NanoTime() but it would still only be capturing the process\u0027 CPU usage only during the GC cycle. I don\u0027t think there is any easy way to measure the device-wide CPU usage, which is required for what you are trying to achieve as per the commit message.",
      "range": {
        "startLine": 187,
        "startChar": 2,
        "endLine": 187,
        "endChar": 62
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3bfbcfce_0d2e36c0",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1896531
      },
      "writtenOn": "2021-09-23T01:41:10Z",
      "side": 1,
      "message": "The purpose of this modification is to adjust the Multiplier to delay the arrival of the next BackgroundGC when the equipment load is high, so as to reduce the increased load of heaptaskdaemon for a period of time.\n1.this ratio will be close to 1.0 most of the time?\nYES,but on some devices with low performance,when there are many applications in the background,it is often seen from anr\\skimFrame\\jank systrace that the ratio is less than 0.5 or even 0.2.\nTo some extent, this ratio can represent the load state of the system during this GC.\nOf course, the ratio during this GC cannot reflect the future situation.Therefore, the Multiplier adjustment is conservative and appropriately delay the arrival of the next BackgroundGC.\n\n2.ProcessCpuNanoTime() would make more sense than NanoTime()?\nNO,gc_cpu_time/process_cpu_time does not represent the device load during GC.\n\n3. I don\u0027t think there is any easy way to measure the device-wide CPU usage.\nI deeply agree that.It may not be reasonable to use the ratio to represent the equipment load, but the effect is obvious from the power consumption test data(Use time increased by 18 minutes).\n\nIt is hoped that google art developers can evaluate this patch and take some measures on the s version to appropriately reduce the occurrence of backgroundGC when the equipment is under high load.",
      "parentUuid": "d9361094_d8ca20e9",
      "range": {
        "startLine": 187,
        "startChar": 2,
        "endLine": 187,
        "endChar": 62
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e09f47d0_224c41b0",
        "filename": "runtime/gc/collector/garbage_collector.cc",
        "patchSetId": 1
      },
      "lineNbr": 187,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-23T21:22:45Z",
      "side": 1,
      "message": "\u003e The purpose of this modification is to adjust the Multiplier to delay the arrival of the next BackgroundGC when the equipment load is high, so as to reduce the increased load of heaptaskdaemon for a period of time.\n\u003e 1.this ratio will be close to 1.0 most of the time?\n\u003e YES,but on some devices with low performance,when there are many applications in the background,it is often seen from anr\\skimFrame\\jank systrace that the ratio is less than 0.5 or even 0.2.\n\nThis is only possible if the GC-thread was made to wait while GC was running. But this could happen even when the device is not really under high load. For instance, when waiting for a checkpoint, if those waits are longer for any reason, they would not be counted towards the gc_cpu_time.\n\nI agree that it gives some indication of CPU load, but really far from perfect.\n\n\u003e To some extent, this ratio can represent the load state of the system during this GC.\n\u003e Of course, the ratio during this GC cannot reflect the future situation.Therefore, the Multiplier adjustment is conservative and appropriately delay the arrival of the next BackgroundGC.\n\u003e \n\u003e 2.ProcessCpuNanoTime() would make more sense than NanoTime()?\n\u003e NO,gc_cpu_time/process_cpu_time does not represent the device load during GC.\n\u003e \n\u003e 3. I don\u0027t think there is any easy way to measure the device-wide CPU usage.\n\u003e I deeply agree that.It may not be reasonable to use the ratio to represent the equipment load, but the effect is obvious from the power consumption test data(Use time increased by 18 minutes).\n\u003e \n\u003e It is hoped that google art developers can evaluate this patch and take some measures on the s version to appropriately reduce the occurrence of backgroundGC when the equipment is under high load.",
      "parentUuid": "3bfbcfce_0d2e36c0",
      "range": {
        "startLine": 187,
        "startChar": 2,
        "endLine": 187,
        "endChar": 62
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "15745297_edf0c6c6",
        "filename": "runtime/gc/collector/iteration.h",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-17T18:11:55Z",
      "side": 1,
      "message": "Comments should not include email address and/or dates. Please remove them everywhere in this patch.",
      "range": {
        "startLine": 48,
        "startChar": 4,
        "endLine": 48,
        "endChar": 35
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b71b10a6_aa38aebb",
        "filename": "runtime/gc/collector/iteration.h",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1896531
      },
      "writtenOn": "2021-09-23T01:41:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "15745297_edf0c6c6",
      "range": {
        "startLine": 48,
        "startChar": 4,
        "endLine": 48,
        "endChar": 35
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af1e628c_466e127f",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 1089,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-17T18:11:55Z",
      "side": 1,
      "message": "This code seems to assume that the byte-allocated will stay in a range across multiple transitions of an app.\n\nI agree in general that it makes sense to not GC on transition if the heap usage is lower. But I would rather just skip a transition GC if we are below a certain threshold, rather than making it based on how many times state has changed. This is because there is really no harm in not performing a GC here. We will eventually GC if the app continues to allocate even when it\u0027s in the background.",
      "range": {
        "startLine": 1075,
        "startChar": 4,
        "endLine": 1089,
        "endChar": 7
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e30b96e_0699f8e0",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 1089,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2021-09-22T16:48:20Z",
      "side": 1,
      "message": "I\u0027m also very uncomfortable with this change. We\u0027re essentially randomly dropping the transition GC requests, in a way that seems to have been tuned to a particular workload. It may be that we\u0027re collecting too aggressively on transitions with CC. If so, is there a more systematic way we can fix that? Conditioning this (more deterministically) on the number of bytes allocated since the last GC would make a lot more sense to me. Lokesh?\n\nIt\u0027s also unclear to me that any of these changes make sense to me for CMS. So shouldn\u0027t this be conditioned on CC?",
      "parentUuid": "af1e628c_466e127f",
      "range": {
        "startLine": 1075,
        "startChar": 4,
        "endLine": 1089,
        "endChar": 7
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "299167b2_e1b869b9",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 1089,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-22T21:53:38Z",
      "side": 1,
      "message": "\u003e I\u0027m also very uncomfortable with this change. We\u0027re essentially randomly dropping the transition GC requests, in a way that seems to have been tuned to a particular workload. It may be that we\u0027re collecting too aggressively on transitions with CC. If so, is there a more systematic way we can fix that? Conditioning this (more deterministically) on the number of bytes allocated since the last GC would make a lot more sense to me. Lokesh?\n\u003e\nI agree. It\u0027s plausible that for some apps the transition happens frequently, and performing a GC each time is not always desirable. Also, I agree that something based on bytes-allocated since last GC makes more sense. Maybe we can also use the free-heap in the equation to make it relative. For instance, \"we will collect on transition if we have consumed more than 30% of free heap\".\n\nAnother approach we can take (maybe in conjunction with the above one) is to shrink the free-heap watermark after a certain time if no background GC has been triggered by then.\n\nSo something like: \"if we have consumed more than 30% of free heap then do a GC, otherwise, shrink the free-heap after a certain amount of time\".\n \n\u003e It\u0027s also unclear to me that any of these changes make sense to me for CMS. So shouldn\u0027t this be conditioned on CC?\n\nYes, avoiding these transitional GCs for CMS for a very long time could be really risky.",
      "parentUuid": "0e30b96e_0699f8e0",
      "range": {
        "startLine": 1075,
        "startChar": 4,
        "endLine": 1089,
        "endChar": 7
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cef3bee_d978bdac",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 1089,
      "author": {
        "id": 1896531
      },
      "writtenOn": "2021-09-23T01:41:10Z",
      "side": 1,
      "message": "Yes, I agree with your conclusion.\n\nIn version Android S, it is necessary to limit this type of CollectorTransitionGC. From the GC data of real users, it is found that the total amount of this type of CollectorTransitionGC is very large.\n\nFor processes with small memory consumption, it is not necessary to perform GC every time.\n\nThe optimization point comes from a Launcher jank bug. Five processes under the same uid perform CollectorTransitionGC in the background at the same time, resulting in high system load. The heap size of four sub processes is less than 5MB. systrace file in issue 200116730.",
      "parentUuid": "af1e628c_466e127f",
      "range": {
        "startLine": 1075,
        "startChar": 4,
        "endLine": 1089,
        "endChar": 7
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6363a9f9_03b9be75",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 1089,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-23T21:22:45Z",
      "side": 1,
      "message": "Instead of basing this on the total heap consumption of the app, it would be better to base it on allocation since last GC cycle. This way, every app will get a chance to skip the transition-GC, irrespective of how big their heap usage is.\n\nAlso, instead of skipping some transition-GCs, make it simpler like: \"if allocations since last GC are less than 3MB then we will not GC on transition\".",
      "parentUuid": "1cef3bee_d978bdac",
      "range": {
        "startLine": 1075,
        "startChar": 4,
        "endLine": 1089,
        "endChar": 7
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21b02204_c67c354c",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3607,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-17T18:11:55Z",
      "side": 1,
      "message": "Please have a more detailed description of what the function is doing",
      "range": {
        "startLine": 3607,
        "startChar": 30,
        "endLine": 3607,
        "endChar": 52
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5cb1c9a1_62fe2456",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3607,
      "author": {
        "id": 1896531
      },
      "writtenOn": "2021-09-23T01:41:10Z",
      "side": 1,
      "message": "Heapgrowthmultiplier() interface is called in many cases, resulting in inaccurate return value of getrunningratio() interface. Therefore, this HeapGrowthMultiplierExt() interface is added for only growforutilization() call.\n\nNew comments have been updated.",
      "parentUuid": "21b02204_c67c354c",
      "range": {
        "startLine": 3607,
        "startChar": 30,
        "endLine": 3607,
        "endChar": 52
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81dfc4bf_32745119",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3608,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-17T18:11:55Z",
      "side": 1,
      "message": "Move the whole logic in HeapGrowthMultiplier() rather than a separate function.",
      "range": {
        "startLine": 3608,
        "startChar": 14,
        "endLine": 3608,
        "endChar": 36
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "289c9cea_63c7f49c",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3608,
      "author": {
        "id": 1896531
      },
      "writtenOn": "2021-09-23T01:41:10Z",
      "side": 1,
      "message": "Heapgrowthmultiplier() interface is called in many cases, resulting in inaccurate return value of getrunningratio() interface. Therefore, this HeapGrowthMultiplierExt() interface is added for only growforutilization() call.\n\nNew comments have been updated.",
      "parentUuid": "81dfc4bf_32745119",
      "range": {
        "startLine": 3608,
        "startChar": 14,
        "endLine": 3608,
        "endChar": 36
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07e9e890_24e6a24b",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3609,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-17T18:11:55Z",
      "side": 1,
      "message": "The problem is that even though you are checking screen state here, but this change will be applicable to all the system processes (like system_server, systemui etc).\n\nIt seems reasonable to assume that the app in foreground can benefit out of larger multiplier when it\u0027s in foreground, but giving the same benefit to system processes seems wrong.",
      "range": {
        "startLine": 3609,
        "startChar": 2,
        "endLine": 3609,
        "endChar": 89
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9a6642d_3462457d",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3609,
      "author": {
        "id": 1896531
      },
      "writtenOn": "2021-09-23T01:41:10Z",
      "side": 1,
      "message": "I agree with you, but I\u0027m not sure how to make a distinction is more appropriate.",
      "parentUuid": "07e9e890_24e6a24b",
      "range": {
        "startLine": 3609,
        "startChar": 2,
        "endLine": 3609,
        "endChar": 89
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0df92345_c5680808",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3619,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-17T18:11:55Z",
      "side": 1,
      "message": "It\u0027s unclear on what basis have you chosen these values. As I said in the comment in garbage_collector.cc, the calculation of the ratio isn\u0027t doing what you expect it to.",
      "range": {
        "startLine": 3614,
        "startChar": 5,
        "endLine": 3619,
        "endChar": 34
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "569ff120_8c9eecf5",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3619,
      "author": {
        "id": 1896531
      },
      "writtenOn": "2021-09-23T01:41:10Z",
      "side": 1,
      "message": "The purpose of  adjust the Multiplier is shown in comment in garbage_collector.cc.\n\nThe logic of selecting these values is based on the default multiplier and system load(Expressed as gc_cpu_time/duration_ns) . The greater the load, the greater the coefficient. These parameter values are conservative.\n\nWhen the application can be perceived by the user, the adjustment coefficient is adopted only when the load is relatively high.\n\nWhen the application cannot be perceived by the user, when the load is a little high, the Multiplier can also be adjusted to delay the arrival of GC for a while to avoid the continuous increase of system load.\n\nThe whole patch provides GC problems often encountered by partners and corresponding optimization ideas.If valuable, please consider developing a GC load optimization scheme in version s.\n\nIn addition, please evaluate whether it is feasible to change explicit GC to concurrent GC in the commit message No.4. Thank you",
      "parentUuid": "0df92345_c5680808",
      "range": {
        "startLine": 3614,
        "startChar": 5,
        "endLine": 3619,
        "endChar": 34
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42643317_356e33bb",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 1
      },
      "lineNbr": 3619,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2021-09-23T21:22:45Z",
      "side": 1,
      "message": "\u003e The purpose of  adjust the Multiplier is shown in comment in garbage_collector.cc.\n\u003e \n\u003e The logic of selecting these values is based on the default multiplier and system load(Expressed as gc_cpu_time/duration_ns) . The greater the load, the greater the coefficient. These parameter values are conservative.\n\u003e \n\u003e When the application can be perceived by the user, the adjustment coefficient is adopted only when the load is relatively high.\n\u003e \n\u003e When the application cannot be perceived by the user, when the load is a little high, the Multiplier can also be adjusted to delay the arrival of GC for a while to avoid the continuous increase of system load.\n\u003e \n\u003e The whole patch provides GC problems often encountered by partners and corresponding optimization ideas.If valuable, please consider developing a GC load optimization scheme in version s.\n\nI understand the code that you added. I want to understand what made you choose these values only? For instance, why not 8.0 instead of 6.0?\n\n\u003e \n\u003e In addition, please evaluate whether it is feasible to change explicit GC to concurrent GC in the commit message No.4. Thank you\n\nI\u0027m not sure which one are you referring to. Can you please clarify?",
      "parentUuid": "569ff120_8c9eecf5",
      "range": {
        "startLine": 3614,
        "startChar": 5,
        "endLine": 3619,
        "endChar": 34
      },
      "revId": "68d7c5b6a2d5a174c483e112d6cb30cc8c81872e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}