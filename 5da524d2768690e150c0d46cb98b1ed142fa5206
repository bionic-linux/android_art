{
  "comments": [
    {
      "key": {
        "uuid": "b2a29b6b_97024c69",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-01T21:51:51Z",
      "side": 1,
      "message": "Can we somehow provide an API to do this? The memory ordering requirements to do this correctly are complicated and counter-intuitive. See http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf .\n\nI don\u0027t fully understand the context here, but this scheme generally isn\u0027t correct unless you also make all the data in the linked list atomic, and impose some draconian constraints on the reader. The practical problem is that before the final check, the reader can see arbitrarily inconsistent data, and it\u0027s not easy to ensure that this doesn\u0027t result in a crash before it does the second read to discover that it was all useless. And if the data is not atomic, this is all undefined behavior anyway, and the compiler may break it in other exciting ways.\n\nIf the debugger is reading this via something like ptrace, it can probably be defensive enough about this. But for something libunwind, this seems very tricky.\n\nIs it possible to use bionics rwlocks here instead? That seems MUCH cleaner, even if it\u0027s a bit more painful to set up and slightly slower.",
      "range": {
        "startLine": 47,
        "startChar": 0,
        "endLine": 49,
        "endChar": 71
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d64909b3_9e0b40de",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-02-28T15:26:41Z",
      "side": 1,
      "message": "Would there be any harm in dropping the std::atomic as long as I use manual memory barriers?",
      "range": {
        "startLine": 86,
        "startChar": 9,
        "endLine": 86,
        "endChar": 24
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "38c10a53_8d961531",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1038443
      },
      "writtenOn": "2018-03-01T14:23:52Z",
      "side": 1,
      "message": "Don\u0027t you need it if there\u0027s multitple writers?",
      "parentUuid": "d64909b3_9e0b40de",
      "range": {
        "startLine": 86,
        "startChar": 9,
        "endLine": 86,
        "endChar": 24
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "adc5d8f2_d0690d1e",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-01T14:37:08Z",
      "side": 1,
      "message": "The writes happen here and are under a lock, so there is no multi-writer race.\n\nI assume that normal write will still be atomic (i.e. it is not possible to observe just half of the uint32 being written).\n\nAnd I assume that normal write still respect the ordering guarantees provided by the barriers.",
      "parentUuid": "38c10a53_8d961531",
      "range": {
        "startLine": 86,
        "startChar": 9,
        "endLine": 86,
        "endChar": 24
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eed13883_82ec25a9",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 86,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-01T21:51:51Z",
      "side": 1,
      "message": "You also need it if there are concurrent readers, which is the point, right?",
      "parentUuid": "adc5d8f2_d0690d1e",
      "range": {
        "startLine": 86,
        "startChar": 9,
        "endLine": 86,
        "endChar": 24
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c6f7e25a_f590df4f",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-01T21:51:51Z",
      "side": 1,
      "message": "Surprisingly, I think this would be necessary in spite of the fact that fetch_or is already seq_cst, if the rest of this were correct. I mention this only to convince you that this is way too subtle to use here.",
      "range": {
        "startLine": 118,
        "startChar": 2,
        "endLine": 118,
        "endChar": 54
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04e6a7c1_20ffec8c",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-02T17:02:48Z",
      "side": 1,
      "message": "Yes, in fact, I believe seq_cst of the fetch has no value here at all.  Plain relaxed write would do.",
      "parentUuid": "c6f7e25a_f590df4f",
      "range": {
        "startLine": 118,
        "startChar": 2,
        "endLine": 118,
        "endChar": 54
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3118696_782a7db4",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-02T21:50:45Z",
      "side": 1,
      "message": "++ is still memory_order_seq_cst. If you really want to do this, you want\n\nuint32_t old \u003d descriptor.action_counter_.fetch_or(1u, memory_order_relaxed);  // Set LSB.\nDCHECK_EQ(old \u0026 1, 0u) \u003c\u003c \"The counter was already locked\";\nstd::atomic_thread_fence(std::memory_order_release);\n\nNote that a release fence AFTER a store is extremely odd, but appropriate in this one case.",
      "parentUuid": "04e6a7c1_20ffec8c",
      "range": {
        "startLine": 118,
        "startChar": 2,
        "endLine": 118,
        "endChar": 54
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67a88b61_5fd7b1fb",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 125,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-01T21:51:51Z",
      "side": 1,
      "message": "Unnecessary. The fetch_add defaults to memory_order_seq_cst, which suffices here.",
      "range": {
        "startLine": 125,
        "startChar": 2,
        "endLine": 125,
        "endChar": 54
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "00bc6af2_9dc942ff",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 125,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2018-03-02T17:02:48Z",
      "side": 1,
      "message": "I think I need it.  I want to be sure writes after the unlock  (anything that would use the freed memory) don\u0027t get moved before the unlock. Again, I don\u0027t think the seq_cst is very helpful here, so I need my own fence.\n\nI moved this line outside though and added a comment to make it clearer.\n\nThe main motivation for this fence is this:\n1) The reader gets the counter - which ends up being locked.\n2) It reads the data of the entry anyway (but does not use it yet).\n3) It reads the counter again.\n4) If the two counter values match, the data is safe to use, despite the fact it is in a locked state.\n\nI know that sounds a bit weird, but we are not always in position to wait and retry (e.g. the process crashed and will never unlock). So this ensures we can reason about consistency of the data even in a locked state.",
      "parentUuid": "67a88b61_5fd7b1fb",
      "range": {
        "startLine": 125,
        "startChar": 2,
        "endLine": 125,
        "endChar": 54
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad0e561e_9e6466a6",
        "filename": "runtime/jit/debugger_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 125,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2018-03-02T21:50:45Z",
      "side": 1,
      "message": "I don\u0027t understand the above response. It shouldn\u0027t matter whether later writes get moved before the unlock.\n\nThe added code comment is correct. However, if you want to optimize the fencing, you really want\n\nuint32_t old \u003d descriptor.action_counter_.fetch_add(1u, memory_order_release);\n\nwhich is weaker than memory_order_seq_cst, and provides that guarantee without the fence. Or it would if you didn\u0027t have undefined behavior anyway due to the non-atomic racing accesses.",
      "parentUuid": "00bc6af2_9dc942ff",
      "range": {
        "startLine": 125,
        "startChar": 2,
        "endLine": 125,
        "endChar": 54
      },
      "revId": "5da524d2768690e150c0d46cb98b1ed142fa5206",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}