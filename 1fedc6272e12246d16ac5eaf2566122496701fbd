{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2043378b_d803502b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-17T04:35:35Z",
      "side": 1,
      "message": "This seems to get into surprisingly tricky memory model issues. I have a couple of more questions around that. Other than that, LGTM.",
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef692c9e_e9400797",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-17T04:35:35Z",
      "side": 1,
      "message": "So the goal here is to ensure that if we have seen the class, and could thus be running the code, we can definitely also see the corresponding generated_code_ranges_ value? Is that the intent? I don\u0027t quite see how this is guaranteed by the C++ memory model, since the intermediaries execute neither fences nor acquire/release operations, right? But it\u0027s probably quite similar to our existing assumption that a constructor fence guarantees that no other threads can dereference on object pointer and see a null class, so probably it\u0027s OK.\n\nI guess it also guarantees that IsInGeneratedCode can see all writes to anywhere in the list up to the loading of the class. But it doesn\u0027t guarantee visibility of additional entries added later, which I also need for traversal, right?",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88be80cc_60497085",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-18T10:52:11Z",
      "side": 1,
      "message": "Yes, that\u0027s the intent and I\u0027m relying on the \"Fence-fence synchronization\" described at https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence to ensure the visibility of the required `generated_code_ranges_` write (or a subsequent one). I\u0027m pretty sure this works when only two threads are involved. But I\u0027m not sure if the visibility is guaranteed for three threads.\nT1: stores `generated_code_ranges_`, issues release fence, stores object reference in location1.\nT2: loads object reference from location1, stores it in location2.\nT3: loads object reference from location2, uses it to execute code from the oat file, faults and issues acquire fence.\n\nOnce the thread sees that write, the visibility of actual data is guaranteed by the release and acquire operations on `generated_code_ranges_`.",
      "parentUuid": "ef692c9e_e9400797",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd7f7367_769496c8",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-18T15:42:54Z",
      "side": 1,
      "message": "Should we use another checkpoint instead?",
      "parentUuid": "88be80cc_60497085",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2aa51fd_2f42f46a",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-22T17:22:33Z",
      "side": 1,
      "message": "I agree with our reading. I don\u0027t think it\u0027s guaranteed for the 3+ thread case. It probably is guaranteed by all currently relevant hardware specs, except maybe ARMv7. Do we still support ARMv7 hardware without the v8 memory model guarantees? I don\u0027t know.\n\nFor a more solid correctness argument, I think we could use an asymmetric fence, i.e. membarrier(MEMBARRIER_CMD_PRIVATE_EXPEDITED) when registering. That should ensure that everybody has seen the registration before they see the class. And it should be cheaper than a checkpoint, though significantly more expensive than atomic_thread_fence. I also like it better than a checkpoint because it can\u0027t possibly participate in deadlocks.",
      "parentUuid": "bd7f7367_769496c8",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0d12aaf_8a02ff68",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-23T13:30:07Z",
      "side": 1,
      "message": "After talking to Nicolas, I decided to use the \"sync-core\" version just like JIT, just to be sure. (The unlikely case of unloading an oat file and loading another one to the same memory range probably needs flushing instruction caches.)\n\nPlease review PS16.",
      "parentUuid": "a2aa51fd_2f42f46a",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44f69340_12ac0e11",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-23T23:03:16Z",
      "side": 1,
      "message": "That seems a bit like an orthogonal issue. The current loading mechanism doesn\u0027t already handle that?\nIf not, this looks fine, but I think we really need a comment as to why the SyncCore is there. Currently that part looks really mysterious. That comment probably belongs in fault_handler.h to explain that this function includes the barrier functionality.",
      "parentUuid": "b0d12aaf_8a02ff68",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7d2b3ca_d61bdafe",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-25T13:52:44Z",
      "side": 1,
      "message": "I think the underlying `memmap` should make sure that all threads correctly see the newly-mapped data.\n\nAfter thinking about this, I decided to remove the \"SyncCore\". `FaultHandler` does not need it.",
      "parentUuid": "44f69340_12ac0e11",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fda6f13d_90a24ea6",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 248,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-26T19:46:09Z",
      "side": 1,
      "message": "Agreed.",
      "parentUuid": "c7d2b3ca_d61bdafe",
      "range": {
        "startLine": 244,
        "startChar": 29,
        "endLine": 248,
        "endChar": 36
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d14614d_6f0a0f2e",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 408,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2022-11-17T04:35:35Z",
      "side": 1,
      "message": "delete",
      "range": {
        "startLine": 408,
        "startChar": 46,
        "endLine": 408,
        "endChar": 48
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "10a066fb_33083554",
        "filename": "runtime/fault_handler.cc",
        "patchSetId": 12
      },
      "lineNbr": 408,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2022-11-18T10:52:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1d14614d_6f0a0f2e",
      "range": {
        "startLine": 408,
        "startChar": 46,
        "endLine": 408,
        "endChar": 48
      },
      "revId": "1fedc6272e12246d16ac5eaf2566122496701fbd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}