{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ec9200b7_5c20f4be",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-07-16T21:29:34Z",
      "side": 1,
      "message": "I think I need a refresher on shared libraries. I thought they\u0027re (always?) in partition-global locations like \u003cpartition\u003e/framework and not really owned by any package. So:\n\n1. Isn\u0027t it possible to detect them by path prefix alone?\n\n2. If that\u0027s not a good idea, then how common is it that a package loads another package\u0027s shared library dependency? Iow, isn\u0027t it enough to do this check only for the loading package?",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f955e844_c52d4279",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-07-16T22:14:58Z",
      "side": 1,
      "message": "\u003e Isn\u0027t it possible to detect them by path prefix alone?\n\nNo. First, there are two types of shared libraries: apk and jar. The former is like a normal package, located in `/system/app`, etc. if it\u0027s preinstalled, or `/data/app/...` if it\u0027s updated. The latter can be at any location, specified by xml files at `/system/etc/permissions`.\n\n\u003e If that\u0027s not a good idea, then how common is it that a package loads another package\u0027s shared library dependency? Iow, isn\u0027t it enough to do this check only for the loading package?\n\nIf a package loads another package\u0027s primary dex file, then the owning package\u0027s shared libraries are also loaded because they are in the primary dex file\u0027s class loader.",
      "parentUuid": "ec9200b7_5c20f4be",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "37669f1a_c811d585",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-07-17T19:09:12Z",
      "side": 1,
      "message": "Ok, but when it\u0027s not a shared library this will recheck the same shared libraries used by many apps over and over again, which is a bit of a pity.\n\nIf it wasn\u0027t for the other case I\u0027ve added a comment on below, I\u0027d argue it\u0027s better to just ignore the shared libs and instead rely on the cache to speed up the non-recording of the popular ones.\n\nAs it is I can\u0027t think of a way to improve this appreciably (can\u0027t find any hint that PackageManager even maintains a data structure of all shared libs).",
      "parentUuid": "f955e844_c52d4279",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "28e1b848_d478a4d2",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-07-17T21:15:52Z",
      "side": 1,
      "message": "I feel the same unfortunate as you do that we will probably recheck the same shared libraries used by many apps over and over again, but I don\u0027t see a better way either. I think PackageManager must be maintaining a data structure of all shared libs because I\u0027ve seen it printing all shared libs in dumpsys, but I just can\u0027t find an API that returns this information.\n\nHowever, the reason I added this early return is not for the other case that you commented. Instead, it\u0027s for avoiding the penalty of cache miss. If we just ignore them and instead rely on the cache, since jar libraries don\u0027t have package names, we won\u0027t record them in the cache and we\u0027ll get a cache miss every time.",
      "parentUuid": "37669f1a_c811d585",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9614a052_78da7a74",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-07-18T15:11:09Z",
      "side": 1,
      "message": "\u003e since jar libraries don\u0027t have package names, we won\u0027t record them in the cache and we\u0027ll get a cache miss every time\n\nBut now with the cache changed to use the dex paths as keys, isn\u0027t it possible?",
      "parentUuid": "28e1b848_d478a4d2",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0435ba96_2a6dd3c0",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-07-19T10:40:45Z",
      "side": 1,
      "message": "I still don\u0027t see how it\u0027s possible. After the change, we still need a package name in order to call `checkForPackage`. If we don\u0027t call it, we may hurt correctness.",
      "parentUuid": "9614a052_78da7a74",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9cd94cdd_a0a9f800",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-07-19T15:00:30Z",
      "side": 1,
      "message": "But didn\u0027t you say we still find the shared library as a normal package sooner or later? Which libraries is it that we don\u0027t get package names for?\n\nIf they\u0027re in read-only partitions we don\u0027t need to recheck them anyway, so wouldn\u0027t we get pretty far by just matching well known system partition prefixes like /system(_ext), /product, and /vendor?\n\nNote you can provide a package in the `TYPE_DONT_RECORD` return on line 559, to recheck non-existence within existing package directories.",
      "parentUuid": "0435ba96_2a6dd3c0",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ae3e4f48_46f149d9",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-07-23T14:37:09Z",
      "side": 1,
      "message": "\u003e But didn\u0027t you say we still find the shared library as a normal package sooner or later?\n\nI said there are two types of shared libraries: apk and jar. Only the former have package names, and the latter don\u0027t belong to any packages.\n\n\u003e If they\u0027re in read-only partitions we don\u0027t need to recheck them anyway, so wouldn\u0027t we get pretty far by just matching well known system partition prefixes like /system(_ext), /product, and /vendor?\n\nOnly jar libraries are always on read-only partitions; apk libraries are on /data once they are updated.\n\nIf we didn\u0027t check for shared libraries at all, how would we get a result that we could cache? For jar libraries, we wouldn\u0027t get any result after going through all packages because they don\u0027t belong to any packages. Do you mean we cache the results being \"not found\" for dex files on read-only partitions? This adds even more complexity on top of the complexity that we already have, and it\u0027s bad for peace of mind because it\u0027s unclear to me whether results for dex files on read-only partitions can even change or not.\n\nTaking a step back, this added check won\u0027t bring much cost. Most of the shared libraries have only one dex file and has no dependencies, so checking one is as trivial as a single string comparison on the dex path (that\u0027s why I didn\u0027t even add a HashSet for checked libraries, as a key lookup by the library name, which involves hashCode() and equals() may be even more expensive than the string comparison). In practice, the cost isn\u0027t measurable. The test app has two files (file (3) and (4) in http://b/328673771#comment4) that belong to other packages. When there is no LRU cache, finding the owning package for them needs iteration over all packages, which involves this added check, and as you can see, this check doesn\u0027t introduce a noticeable regression ((1) + (2) + (3) compared to (1) + (2) in http://b/328673771#comment5).",
      "parentUuid": "9cd94cdd_a0a9f800",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86fc8e4b_48629834",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-08-07T21:40:56Z",
      "side": 1,
      "message": "My suggestion is to let the normal package check find the shared libs in APKs, and then check well-known read-only partition prefixes for jars (where it\u0027s safe to cache that they\u0027re not found). Would that leave a (significant) gap for shared libs in other places?\n\nThe recursive function can multiply with a potentially large number of packages, so its performance can be highly variable and is hard to predict. I remain unconvinced of the real-world behaviour from your limited experiments - OEMs may have shared libs with larger dependency trees, and it may change over time as well.\n\nAs for complexity, my suggestions seems simpler code-wise since the recursive function disappears. Then there\u0027s:\n\n\u003e it\u0027s bad for peace of mind because it\u0027s unclear to me whether results for dex files on read-only partitions can even change or not.\n\nTo me it\u0027s pretty clear they can\u0027t - they\u0027re read-only afterall. Am I missing something? Well, there\u0027s the exception of remounting, and that\u0027s somewhat unfortunate but it\u0027s afterall a dev-only corner case.\n\nEven so, if we want to play safe there as well it\u0027s possible to deal with by stat\u0027ing the dex path both before entering it into the cache, and when the cached entry is used. Maybe with that approach it\u0027s not even necessary to check read-only partition prefixes?",
      "parentUuid": "ae3e4f48_46f149d9",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a24906bf_dcb636e5",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-08-12T14:58:12Z",
      "side": 1,
      "message": "Note that \"not found\" here means not found as an app or a shared library from the package manager\u0027s perspective. Files on readonly partitions cannot change, but it\u0027s unclear to me whether the package manager can change its mind not. Consider the following case:\n\n1. Initially, the package manager doesn\u0027t recognize an apk on a readonly partition.\n2. The apk is somehow loaded by app A.\n3. We cannot find the apk in the snapshot provided by the package manager. Since the apk is on a readonly partition, we think it\u0027s a shared library jar (assuming we don\u0027t have assumptions on the file extension), and therefore we put `\u003capk-path, null\u003e` in the cache.\n4. At some point, the package manager starts to recognize the apk as part of a preinstalled app.\n5. The apk is loaded by app B as an app.\n6. We get `null` from the cache, and we have no way to verify the cached value because there is no package name in it, so we just return `null`. This is a wrong result.\n\nBesides, I\u0027m not a fan of keeping a hardcoded list of readonly partitions.\n\nIf your concern is that the cost can multiply with a potentially large number of packages, I just limited the check to the loading package and the cached packages. With this approach, the only gap left is that we\u0027ll have to complete the full loop when looking up a shared library of an unpopular shared app, which is acceptable to me.",
      "parentUuid": "86fc8e4b_48629834",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "838646e4_e25e8010",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1373864
      },
      "writtenOn": "2024-08-21T13:02:46Z",
      "side": 1,
      "message": "If we don\u0027t find the package in step #3, PackageManager would need to return an incomplete snapshot, wouldn\u0027t it? `UnfilteredSnapshot.getPackageStates` clearly says it returns _all_ packages on the device, so if that happens it\u0027s plain buggy.\n\nSo I\u0027m still unconvinced about that, but I reckon another variant of step #3 and #4 is if a system package gets updated, or conversely an update is uninstalled. In such cases the APK path for the package can change between the read-only partition and the update on the data partition, can\u0027t it? Then we could indeed get into the situation you described. We\u0027d need an API that returns the paths in both partitions, but I suppose the list of splits is only for the version in use.\n\nIf that argument is correct then my suggestion won\u0027t work (without more PackageManager APIs). I\u0027ll leave this unresolved to let you confirm, but if so it\u0027s fine as-is.",
      "parentUuid": "a24906bf_dcb636e5",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b8803f1_8bac5aaa",
        "filename": "libartservice/service/java/com/android/server/art/DexUseManagerLocal.java",
        "patchSetId": 1
      },
      "lineNbr": 519,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2024-08-21T13:42:26Z",
      "side": 1,
      "message": "\u003e another variant of step #3 and #4 is if a system package gets updated, or conversely an update is uninstalled. In such cases the APK path for the package can change between the read-only partition and the update on the data partition, can\u0027t it?\n\nWhat you said is exactly a concrete example of what I meant by \"we cannot find the apk in the snapshot provided by the package manager\".\n\nAnother example could be that, one day, package manager may have a new feature that allows the user to \"hide\" a pre-installed package as if there is no such package and \"unhide\" it later.\n\nThe API doc only says \"returns a map of all PackageStates on the device\", while I\u0027m not confident that \"all PackageStates\" \u003d\u003d \"all apks\".",
      "parentUuid": "838646e4_e25e8010",
      "revId": "76f1d0c6c490b6fe5a88cd9eff0b01a1142cae54",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}