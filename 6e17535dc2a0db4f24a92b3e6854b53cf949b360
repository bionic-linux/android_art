{
  "comments": [
    {
      "key": {
        "uuid": "f93914b5_6ce7eef4",
        "filename": "compiler/dex/quick/x86/utility_x86.cc",
        "patchSetId": 3
      },
      "lineNbr": 576,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2014-07-24T16:45:23Z",
      "side": 1,
      "message": "Is the bug that this is never true? Well it looks currently that it could be true, but that\u0027s a bug in that we should generating PC relative loads using RIP addressing.",
      "range": {
        "startLine": 576,
        "startChar": 0,
        "endLine": 576,
        "endChar": 44
      },
      "revId": "6e17535dc2a0db4f24a92b3e6854b53cf949b360",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9932d8d1_4d5b0d68",
        "filename": "compiler/dex/quick/x86/utility_x86.cc",
        "patchSetId": 3
      },
      "lineNbr": 576,
      "author": {
        "id": 1039893
      },
      "writtenOn": "2014-07-24T17:31:35Z",
      "side": 1,
      "message": "Seems like there is no bug here. I\u0027ve checked it on a simple test like:\n\npublic static double foo(double a) {\n   return a / 500000000000.0d;\n}\n\nCompiler generated loading through const pool in both x86 and x86_64 cases (without this patch). The problem was in my test, I made it based on my Min/Max patch which was not enabled in AnalyzeInvokeStatic, and after I checked the generated code, I found out that it used 2 core regs. So that was my mistake.\n\nSeems like this (loading through const pool) is not the optimal method for x86_64, because compiler generates an additional call/pop in a beginning of the function and use the memory access to const pool, which can be expensive.",
      "parentUuid": "f93914b5_6ce7eef4",
      "range": {
        "startLine": 576,
        "startChar": 0,
        "endLine": 576,
        "endChar": 44
      },
      "revId": "6e17535dc2a0db4f24a92b3e6854b53cf949b360",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d9461042_a7be5198",
        "filename": "compiler/dex/quick/x86/utility_x86.cc",
        "patchSetId": 3
      },
      "lineNbr": 576,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2014-07-24T17:39:58Z",
      "side": 1,
      "message": "The reason the call-pop is generated is that x86 doesn\u0027t have RIP addressing, while x86-64 does. The codegen choices are:\n\nmov rX, #value\nmovd xmmY, rX\n\nor\n\nmovd xmmY, rip:[literal pool offset to #value]\n\nmy experience has been the latter is better in that it at least uses 1 fewer register.\n\nI\u0027m happy to have the two implementation choices be available under an instruction set features flag. I\u0027d like if we could fix the non-use of RIP addressing as that also impacts the switch implementation.\n\nI\u0027m happy to take this code relatively as-is and follow up on the other issues, but I\u0027d like the structure of the float code to match that of the int code below. As I commented below.",
      "parentUuid": "9932d8d1_4d5b0d68",
      "range": {
        "startLine": 576,
        "startChar": 0,
        "endLine": 576,
        "endChar": 44
      },
      "revId": "6e17535dc2a0db4f24a92b3e6854b53cf949b360",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f93914b5_cc14621d",
        "filename": "compiler/dex/quick/x86/utility_x86.cc",
        "patchSetId": 3
      },
      "lineNbr": 612,
      "author": {
        "id": 1010118
      },
      "writtenOn": "2014-07-24T16:45:23Z",
      "side": 1,
      "message": "which means we always come in here, and this code is 32-bit specific?\nShould this code do what the code below does and do:\nif (r_dest.IsPair()) {\n  ... what we have 32-bit code\n} else {\n  ... the code you added above for 64-bit\n}",
      "range": {
        "startLine": 602,
        "startChar": 0,
        "endLine": 612,
        "endChar": 9
      },
      "revId": "6e17535dc2a0db4f24a92b3e6854b53cf949b360",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}