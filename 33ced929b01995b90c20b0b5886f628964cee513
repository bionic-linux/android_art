{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "be669864_8295c500",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2021-11-03T11:29:18Z",
      "side": 1,
      "message": "Friendly ping",
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc846d75_9fb15206",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2021-11-03T15:44:57Z",
      "side": 1,
      "message": "An environment use by `HDeoptimize` needs to be fully preserved, including the contents of the `StringBuilder` as the code may actually use the `StringBuilder` to finish appending in interpreter.\n\nI am not sure if HDeoptimize is the only environment use that would block this transformation.",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b54ca91b_a8bacb06",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2021-11-03T16:37:57Z",
      "side": 1,
      "message": "I am failing to see why the `HDeoptimize` would block the optimization. The contents of the string builder would be the same, right?\nIf we have an environment use of `HDeoptimize` (or any other instruction), then the NewInstance won\u0027t be removed and the Deoptimize should continue to work as expected.",
      "parentUuid": "cc846d75_9fb15206",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd30e4b2_65565cbc",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2021-11-03T17:03:02Z",
      "side": 1,
      "message": "Deoptimize can cause the `StringBuilder.toString()` to be executed by the interpreter, so the full contents of the `StringBuilder` need to be correctly preserved at the `HDeoptimize` instruction.",
      "parentUuid": "b54ca91b_a8bacb06",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c53e194_b6d10f84",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2021-11-03T17:30:32Z",
      "side": 1,
      "message": "Do you mean deoptimizing because of the string builder? Or deoptimizing for whatever reason in that method (before or after the string building)?",
      "parentUuid": "fd30e4b2_65565cbc",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "575f4253_f41150d7",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2021-11-03T17:34:11Z",
      "side": 1,
      "message": "There can be an arbitrary `HDeoptimize` anywhere between the `NewInstance` and `HInvoke/StringBuilder.toString()`.\n\n(If the `HDeoptimize is after the `HInvoke/StringBuilder.toString()`, you could argue that the contents of the `StringBuilder` are irrelevant.)",
      "parentUuid": "0c53e194_b6d10f84",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bc5849b_a8364ccf",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2021-11-03T17:37:26Z",
      "side": 1,
      "message": "But that could happen tip of tree as well, right? We are only blocking the environment uses of the `NewInstance` but we could have a HDeoptimize that it is not an environment use of `NewInstance` and it is between `NewInstance` and `HInvoke/StringBuilder.toString()`.",
      "parentUuid": "575f4253_f41150d7",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fadd93d_5b8e48d0",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2021-11-04T09:25:40Z",
      "side": 1,
      "message": "If the `HNewInstance` is not used by the `HDeoptimize` environment, it shall not be visible after deoptimizing. But I really doubt that such situation could come up as every `HDeoptimize` we construct has the full environment and being between the `HNewInstance` and the `HInvoke/StringBuilder.toString()` means that the `HNewInstance` is in some vreg.",
      "parentUuid": "7bc5849b_a8364ccf",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71c832c2_09ba71a4",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2021-11-04T11:18:47Z",
      "side": 1,
      "message": "Hm, I see. Also, the Deoptimize may appear as such in other phases like during BCE.\n\nWhat I am thinking is: The deoptimize can happen 1) before, 2) after, or 3)  between `HNewInstance` and `StringBuilder.toString()`.\n\n1) The `HNewInstance` will not be in the deoptimize environment list and we are fine.\n2) The string has already been built and we are fine.\n3) is the problematic one. However, if that\u0027s the case we should have the `HNewInstance` and the `StringBuilder.toString()` in different blocks and the optimization would not happen (line 2777).\n\nIf we are okay with moving forward I can make test cases for 1), 2), and 3) and add them to this CL.",
      "parentUuid": "5fadd93d_5b8e48d0",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1cd225f8_60c26819",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2021-11-04T14:09:31Z",
      "side": 1,
      "message": "For 3), think about this test:\n\n  static void $noinline$deoptTestOuter() {\n    try {\n      $noinline$deoptTestInner(new int[]{ 1, 2, 3 }, 0);\n      throw new Error(\"Unreachable!\");\n    } catch (ArrayIndexOutOfBoundsException expected) {\n      if (!\"a[o]\u003d1\".equals(stringField)) {\n        throw new Error(\"Unexpected stringField: \" + stringField);\n      }\n      if (0 !\u003d intField) {\n        throw new Error(\"Unexpected intField: \" + intField);\n      }\n    }\n  }\n\n  static void $noinline$deoptTestInner(int[] a, int o) {\n    stringField \u003d \"a[o]\u003d\" + a[o];\n    intField \u003d a[o+1] + a[o+2] + a[o+3];\n  }\n\n  static String stringField;\n  static int intField;\n\nand look at the configuration \"BCE (after)\" for the `$noinline$deoptTestInner` - it\u0027s all in one block. We take the deopt path and complete the append in interpreter, then store the string in `stringField`. Then we throw AIOOBE when evaluating `a[o+3]`.",
      "parentUuid": "71c832c2_09ba71a4",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2274fec9_969ca0b1",
        "filename": "compiler/optimizing/instruction_simplifier.cc",
        "patchSetId": 5
      },
      "lineNbr": 2773,
      "author": {
        "id": 1889741
      },
      "writtenOn": "2021-11-05T10:26:56Z",
      "side": 1,
      "message": "Okay, this is trickier than I thought...\nOne last idea: in line 2661 we can collect that instructions that are in the middle of the string building operation. Then, we bail out if there\u0027s an instruction in that set that it is also in the sb-\u003eGetEnvUses() list.\n\nThis could be having an extra if in line 2778:\n// pseudocode, `instructions_in_the_middle` contains the instructions between `HNewInstance` and `StringBuilder.toString()`.\nif (find(holder, instructions_in_the_middle) \u003d\u003d instructions_in_the_middle.end()) { continue; }\n\nUploaded a patchset to show what I mean.\n\nPS: I think that if we do that we might be able to remove the \n  if (holder-\u003eGetBlock() !\u003d block) {\n    return false;\n  }\n\ncheck (lines 2776-2778), since other environment use blocks are not important to us anymore.\nOr even better, it might be changed to \n  if (holder-\u003eGetBlock() !\u003d block) {\n    continue;\n  }\n  \nsince, as we said, later block\u0027s environment uses are not important to us.\nThis is also included in the new patchset.",
      "parentUuid": "1cd225f8_60c26819",
      "range": {
        "startLine": 2772,
        "startChar": 5,
        "endLine": 2773,
        "endChar": 83
      },
      "revId": "33ced929b01995b90c20b0b5886f628964cee513",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}