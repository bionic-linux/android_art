{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "121b14be_ae2d6943",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2023-05-16T16:24:58Z",
      "side": 1,
      "message": "Do you plan to test this on golem before submitting? Shall we wait for performance numbers to be added to the commit message?",
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2a3f775f_cdb15838",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-05-16T18:43:46Z",
      "side": 1,
      "message": "My main concern here is whether 16-bit sequence numbers are enough, or whether this will lead to another source of very rare crashes. How frequent are updates? Is it plausible that we will cycle through 32K updates within 10 seconds or so? If not, this is OK. Otherwise I\u0027m concerned, and we may want a separate sequence number.",
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "56d75a78_f7180851",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2023-05-16T18:56:04Z",
      "side": 1,
      "message": "64k should be enough for anyone.\n\nDexCache indices only use 4-bytes.  The full 4-bytes are still free.  I will enlarge the seqlock.",
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2cce5c5b_f3ad6d6c",
        "filename": "runtime/base/atomic_pair.h",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-05-16T18:43:46Z",
      "side": 1,
      "message": "Not very clear. kSeqParity?",
      "range": {
        "startLine": 41,
        "startChar": 27,
        "endLine": 41,
        "endChar": 28
      },
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea450c1c_a4c479b5",
        "filename": "runtime/base/atomic_pair.h",
        "patchSetId": 1
      },
      "lineNbr": 79,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-05-16T18:43:46Z",
      "side": 1,
      "message": "This can be changed to relaxed. Given the current acquire-load situation on RISC-V, we should do so. If I read the first field of a concurrent store in the first read, then the write of the second field happens-before that read, so I must see it, too, so I have a consistent value. If I see the second field of a write in the middle load, and I don\u0027t see the final store of first, then I must still see the results of the compare_exchange, and thus see a bad parity bit.",
      "range": {
        "startLine": 79,
        "startChar": 32,
        "endLine": 79,
        "endChar": 58
      },
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24050753_63c12273",
        "filename": "runtime/base/atomic_pair.h",
        "patchSetId": 1
      },
      "lineNbr": 93,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-05-16T20:20:12Z",
      "side": 1,
      "message": "Note that this is a bit ugly, since it\u0027s redundant if the CAS fails, but not if you see an odd sequence number. But I\u0027m not sure there\u0027s a much better way to write it.",
      "range": {
        "startLine": 93,
        "startChar": 4,
        "endLine": 93,
        "endChar": 49
      },
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4ef59f8_5ab9f61b",
        "filename": "runtime/base/atomic_pair.h",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-05-16T18:43:46Z",
      "side": 1,
      "message": "This is currently dead code, right? And that may be correct; I would guess the above load implementation is as fast as the one below. Remove the x86-specific code?\n\nThe x86-specific one has the annoying property that loads conflict in the cache.",
      "range": {
        "startLine": 101,
        "startChar": 1,
        "endLine": 101,
        "endChar": 25
      },
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d446e9ae_30ff31bc",
        "filename": "runtime/base/atomic_pair.h",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 1065473
      },
      "writtenOn": "2023-05-16T18:56:04Z",
      "side": 1,
      "message": "I didn\u0027t want to be too keen on deleting it before proving it.  We can still tweak when we use which path.\n\nI think that ARM has the same annoying property (loads fighting for the cache line).\n\nBut I think my original motivation for this CL was that x86 lock heavily showed in profiles.",
      "parentUuid": "e4ef59f8_5ab9f61b",
      "range": {
        "startLine": 101,
        "startChar": 1,
        "endLine": 101,
        "endChar": 25
      },
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ab20b8d_c474c0e7",
        "filename": "runtime/base/atomic_pair.h",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2023-05-16T20:20:12Z",
      "side": 1,
      "message": "I would delete it and resurrect it if something doesn\u0027t work out. Especially since it\u0027s ugly assembly code.\n\nARM has the same issues. I think there are 16-byte load/store exclusive instructions, but no 16 byte plain loads. I\u0027m not sure what code we were generating.",
      "parentUuid": "d446e9ae_30ff31bc",
      "range": {
        "startLine": 101,
        "startChar": 1,
        "endLine": 101,
        "endChar": 25
      },
      "revId": "9933be7373e0c8e9c83220598cc3f0b7da69bb99",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}