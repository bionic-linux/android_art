{
  "comments": [
    {
      "key": {
        "uuid": "f8875eb8_16895cda",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-12-14T01:14:29Z",
      "side": 1,
      "message": "A priori, that\u0027s surprising to me. I would not have expected other mutexes to be acuired after this, but why does it matter whether you already hold any? Or do you just need the special mutator lock behavior (which also seems a bit strange to me). A comment may help.",
      "range": {
        "startLine": 287,
        "startChar": 62,
        "endLine": 287,
        "endChar": 75
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d5752e85_10be46d9",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-12-14T01:38:26Z",
      "side": 1,
      "message": "Frankly, I wasn\u0027t sure in the beginning what level (runtime/base/locks.h line:134) should I choose. So, I chose the default level. But unfortunately that crashed ThreadStress test. And given that this lock is acquired when mutator_lock_ is not held, I thought this level was right.\n\nPlease suggest, if I should set it to something else, or introduce a new level for this mutex.",
      "parentUuid": "f8875eb8_16895cda",
      "range": {
        "startLine": 287,
        "startChar": 62,
        "endLine": 287,
        "endChar": 75
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "810773d7_185530c0",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-12-14T03:07:09Z",
      "side": 1,
      "message": "My a priori guess would have been kGenericBottomLock. But I have little confidence that works.",
      "parentUuid": "d5752e85_10be46d9",
      "range": {
        "startLine": 287,
        "startChar": 62,
        "endLine": 287,
        "endChar": 75
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5db6ea67_09f289a0",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-12-17T00:07:11Z",
      "side": 1,
      "message": "The problem is that in GrowForUtilization() there is a call to NumberOfIterations(), which eventually acquires CumulativeLogger\u0027s lock_, which is at kDefaultMutexLevel.\n\nI\u0027ve added a comment in latest patch. PTAL.",
      "parentUuid": "810773d7_185530c0",
      "range": {
        "startLine": 287,
        "startChar": 62,
        "endLine": 287,
        "endChar": 75
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b880d70f_a5e8d516",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-12-17T01:15:56Z",
      "side": 1,
      "message": "OK. I\u0027m a bit surprised that we never hold other locks while acquiring this. My pending CL will change things so that we hold a kMonitorLock mutex while inside a Java synchronized block. Any danger of that interfering here? If so, we should probably put it between kMonitorLock and kDefaultMutexLevel.",
      "parentUuid": "5db6ea67_09f289a0",
      "range": {
        "startLine": 287,
        "startChar": 62,
        "endLine": 287,
        "endChar": 75
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3895acdb_ef8a8767",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 287,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-12-17T18:38:48Z",
      "side": 1,
      "message": "Thanks for bringing this up. The call to UpdateProcessState() takes place in a Java synchronized block. Also, we can always have a scenario where a java thread is blocked on allocation within a synchronized block. In that case if that thread runs the GC, and eventually GrowForUtilization(), then also we\u0027ll be in same situation. So this will definitely be a problem.\n\nFollowing is the list of lock-levels between DefaultMutex and MonitorLock.\n\n  kDefaultMutexLevel,\n  kDexLock,\n  kMarkSweepLargeObjectLock,\n  kJdwpObjectRegistryLock,\n  kModifyLdtLock,\n  kAllocatedThreadIdsLock,\n  kMonitorPoolLock,\n  kClassLinkerClassesLock,  // TODO rename.\n  kDexToDexCompilerLock,\n  kSubtypeCheckLock,\n  kBreakpointLock,\n  kMonitorLock,\n\nPlease suggest if I can reuse any of the locks in between or if I should add a new one? I guess we should add a generic lock-level right before MonitorLock to be used in all cases like this one?",
      "parentUuid": "b880d70f_a5e8d516",
      "range": {
        "startLine": 287,
        "startChar": 62,
        "endLine": 287,
        "endChar": 75
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2070e4a_f17ad243",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 3507,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-12-14T01:14:29Z",
      "side": 1,
      "message": "Since everything is really relative to this, I would consider just making this 1.0 and losing the constant definition. I don\u0027t think it makes sense to change it to something other than 1, right?",
      "range": {
        "startLine": 3507,
        "startChar": 11,
        "endLine": 3507,
        "endChar": 50
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3bcbcb4_2a081182",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 3507,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-12-14T01:38:26Z",
      "side": 1,
      "message": "The only reason I introduced this constant was because with this CL it is now being used at more than one place. I\u0027m concerned that without it, in future, if someone decides to change it, then we\u0027ll have inconsistency in the code.",
      "parentUuid": "a2070e4a_f17ad243",
      "range": {
        "startLine": 3507,
        "startChar": 11,
        "endLine": 3507,
        "endChar": 50
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f66d222f_228d4430",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 3507,
      "author": {
        "id": 1042828
      },
      "writtenOn": "2019-12-14T03:07:09Z",
      "side": 1,
      "message": "I guess I\u0027m arguing that we don\u0027t want people to change it ever. The forground multiplier is relative to this. We\u0027re arbitraarily calling something 1, and then specifying a ratio relative to that. If you also get to change the value of 1, you just end up with a redundant knob.",
      "parentUuid": "c3bcbcb4_2a081182",
      "range": {
        "startLine": 3507,
        "startChar": 11,
        "endLine": 3507,
        "endChar": 50
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d22e93f_8b7c95b2",
        "filename": "runtime/gc/heap.cc",
        "patchSetId": 3
      },
      "lineNbr": 3507,
      "author": {
        "id": 1258954
      },
      "writtenOn": "2019-12-17T00:07:11Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f66d222f_228d4430",
      "range": {
        "startLine": 3507,
        "startChar": 11,
        "endLine": 3507,
        "endChar": 50
      },
      "revId": "83cb114832daaa67273bacab82806522f5df47d8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}