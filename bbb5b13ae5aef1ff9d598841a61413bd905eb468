{
  "comments": [
    {
      "key": {
        "uuid": "6a59925e_43375bef",
        "filename": "/COMMIT_MSG",
        "patchSetId": 19
      },
      "lineNbr": 18,
      "author": {
        "id": 1550939
      },
      "writtenOn": "2020-06-18T16:30:29Z",
      "side": 1,
      "message": "Do you think it\u0027s the extra registers backup/restore on arm64 that explains smaller performance gain compared to arm?\n\nI wonder if specializing and inlining artCriticalNativeFrameSize for different cases would help (it doesn\u0027t look very simple to me, although I assume ISA switches are compiled away).",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 18,
        "endChar": 57
      },
      "revId": "bbb5b13ae5aef1ff9d598841a61413bd905eb468",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6e0210e_8c73b26d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 19
      },
      "lineNbr": 18,
      "author": {
        "id": 1018108
      },
      "writtenOn": "2020-06-18T16:39:25Z",
      "side": 1,
      "message": "For the \"6\", I\u0027d guess the gains are better on ARM than ARM64 because the compiled stub that we\u0027re avoiding had more work to do on ARM, including moving stack args. For the non-6 (i.e. no-args case), I don\u0027t know, we would have to look at the disassembly.\n\nartCriticalNativeFrameSize is irrelevant for the benchmark as it can be called a few times but once the class is visibly initialized we\u0027re completely avoiding it.",
      "parentUuid": "6a59925e_43375bef",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 18,
        "endChar": 57
      },
      "revId": "bbb5b13ae5aef1ff9d598841a61413bd905eb468",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}