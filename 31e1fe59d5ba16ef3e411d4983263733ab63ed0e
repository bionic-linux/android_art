{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "76ba6de3_c7f930b5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-10-07T23:44:30Z",
      "side": 1,
      "message": "Just some high-level comments. I\u0027ll review the CL again once they are addressed.",
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5509f02e_f7cf3b66",
        "filename": "artd/external/include/libdexopt_context.h",
        "patchSetId": 2
      },
      "lineNbr": 36,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-10-07T23:44:30Z",
      "side": 1,
      "message": "Is Android T API level 32?",
      "range": {
        "startLine": 36,
        "startChar": 19,
        "endLine": 36,
        "endChar": 31
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0fd76e18_3e33ba2d",
        "filename": "artd/external/include/libdexopt_context.h",
        "patchSetId": 2
      },
      "lineNbr": 36,
      "author": {
        "id": 1042276
      },
      "writtenOn": "2021-10-08T00:34:21Z",
      "side": 1,
      "message": "T is 33.\n https://cs.android.com/android/platform/superproject/+/master:bionic/libc/include/android/api-level.h;l\u003d155?q\u003dbionic%2Flibc%2Finclude%2Fandroid%2Fapi-level.h",
      "parentUuid": "5509f02e_f7cf3b66",
      "range": {
        "startLine": 36,
        "startChar": 19,
        "endLine": 36,
        "endChar": 31
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d7f1f6fb_018d4533",
        "filename": "artd/external/include/libdexopt_context.h",
        "patchSetId": 2
      },
      "lineNbr": 36,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-10-08T08:44:14Z",
      "side": 1,
      "message": "Interesting. 32 is skipped for some reason.",
      "parentUuid": "0fd76e18_3e33ba2d",
      "range": {
        "startLine": 36,
        "startChar": 19,
        "endLine": 36,
        "endChar": 31
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d520d21_58a6f6d0",
        "filename": "artd/external/include/libdexopt_context.h",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-10-07T23:44:30Z",
      "side": 1,
      "message": "ADexoptContext looks like implementation details. Does it have to be exposed as part of the APIs? Alternatively, instead of having these three APIs, can we simply have:\n\nconst char* const* ADexopt_GetCmdlineArguments(const uint8_t* marshaled, size_t size)?",
      "range": {
        "startLine": 38,
        "startChar": 6,
        "endLine": 38,
        "endChar": 20
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05fb1e86_7c6a99b7",
        "filename": "artd/external/include/libdexopt_context.h",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1042276
      },
      "writtenOn": "2021-10-08T00:34:21Z",
      "side": 1,
      "message": "For now, yes.  But we need other functions to extract the FD information (I\u0027m still working on it).  Having ADexoptContext avoids re-creating from marshaled on every call.",
      "parentUuid": "7d520d21_58a6f6d0",
      "range": {
        "startLine": 38,
        "startChar": 6,
        "endLine": 38,
        "endChar": 20
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fe76ecf_0bd3c743",
        "filename": "artd/external/include/libdexopt_context.h",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-10-08T08:44:14Z",
      "side": 1,
      "message": "Exposing `ADexoptContext` means that the platform (and other modules) will be able to inspect its contents and make use of them. I know that CompOS won\u0027t do so, but you can\u0027t prevent a partner from doing this. If we expose it, we may end up having to keep this struct unchanged for years just for maintaining the compatibility. In addition, there are `std::vector` and `std::string` involved in the struct, which are C++ things and are not guaranteed to be stable. I would suggest not to expose it as part of the APIs. Alternatives are:\n\n1. Unmarshaling the request on every call, which seems fine because the number of calls won\u0027t be too many, or\n2. Returning a serialized protobuf, which is extensible that you can add other information including the FD information into it, so that everything can be done within a single call.",
      "parentUuid": "05fb1e86_7c6a99b7",
      "range": {
        "startLine": 38,
        "startChar": 6,
        "endLine": 38,
        "endChar": 20
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "213e59ae_511ad32b",
        "filename": "artd/external/include/libdexopt_context.h",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 1042276
      },
      "writtenOn": "2021-10-08T17:37:00Z",
      "side": 1,
      "message": "\u003e Exposing `ADexoptContext` means that the platform (and other modules) will be able to inspect its contents and make use of them.\n\nNo, they don\u0027t have the visibility to ADexoptContext\u0027s implementation, just the name to compile and the pointer to use.  This it NOT exposing the internal `std::vector`, which can be changed, and should be accessed via the provided stable API in this file. I think this is a very common pattern in C API (for example, https://www.openssl.org/docs/man1.0.2/man3/SHA256.html), and I believe it\u0027s recommended way per my understanding from go/android-ndk-api-guidelines#abi-stability.\n\nI\u0027m also asking the API council for their review (you\u0027re CC\u0027ed).  We need their approval anyway.  I wanted to also ask their suggestion for the upcoming changes that\u0027s probably more controversial.\n\nHope it makes sense?",
      "parentUuid": "5fe76ecf_0bd3c743",
      "range": {
        "startLine": 38,
        "startChar": 6,
        "endLine": 38,
        "endChar": 20
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c9c2259_c40606e5",
        "filename": "artd/libdexopt.cc",
        "patchSetId": 2
      },
      "lineNbr": 357,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-10-07T23:44:30Z",
      "side": 1,
      "message": "Can the binder API pass std::vector? If so, why does AComposClient_Request have to be defined in a C style?",
      "range": {
        "startLine": 356,
        "startChar": 0,
        "endLine": 357,
        "endChar": 46
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e063aeb_23772304",
        "filename": "artd/libdexopt.cc",
        "patchSetId": 2
      },
      "lineNbr": 357,
      "author": {
        "id": 1042276
      },
      "writtenOn": "2021-10-08T00:34:21Z",
      "side": 1,
      "message": "If you look at go/android-mainline-apis, our only option is C API, not Java (no Java runtime in the VM).  \"Stable Binder\" (since binder itself is unstable) is another option, but that requires us to stabilize the parameter, and I assume we\u0027re not ready for that.\n\nThe only other way I can think of to really use binder as (private) API is to create a binder service in ART to run in CompOS VM.  Which is almost equivalent to re-implement/move the better part of compsvc in ART code base.  But then there may still be concerns to maintain those complexity in ART, and also the new unstable API that the whole pKVM effort introduces.\n\nWe can provide a C++ static library on top of the C API, but I\u0027m not using it anyway since I\u0027m calling the C API from Rust.\n\nLet me know if you have other ideas. We can also chat if easier.",
      "parentUuid": "5c9c2259_c40606e5",
      "range": {
        "startLine": 356,
        "startChar": 0,
        "endLine": 357,
        "endChar": 46
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "029dd170_da5f9f01",
        "filename": "artd/libdexopt.cc",
        "patchSetId": 2
      },
      "lineNbr": 357,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-10-08T08:44:14Z",
      "side": 1,
      "message": "Please see my comment in the other file.",
      "parentUuid": "5e063aeb_23772304",
      "range": {
        "startLine": 356,
        "startChar": 0,
        "endLine": 357,
        "endChar": 46
      },
      "revId": "31e1fe59d5ba16ef3e411d4983263733ab63ed0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}